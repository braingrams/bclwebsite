webpackJsonp(
  [23],
  {
    /***/ 0: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var bind = __webpack_require__(22);

      // utils is a library of generic helper functions non-specific to axios

      var toString = Object.prototype.toString;

      // eslint-disable-next-line func-names
      var kindOf = (function (cache) {
        // eslint-disable-next-line func-names
        return function (thing) {
          var str = toString.call(thing);
          return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
        };
      })(Object.create(null));

      function kindOfTest(type) {
        type = type.toLowerCase();
        return function isKindOf(thing) {
          return kindOf(thing) === type;
        };
      }

      /**
       * Determine if a value is an Array
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an Array, otherwise false
       */
      function isArray(val) {
        return Array.isArray(val);
      }

      /**
       * Determine if a value is undefined
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if the value is undefined, otherwise false
       */
      function isUndefined(val) {
        return typeof val === "undefined";
      }

      /**
       * Determine if a value is a Buffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Buffer, otherwise false
       */
      function isBuffer(val) {
        return (
          val !== null &&
          !isUndefined(val) &&
          val.constructor !== null &&
          !isUndefined(val.constructor) &&
          typeof val.constructor.isBuffer === "function" &&
          val.constructor.isBuffer(val)
        );
      }

      /**
       * Determine if a value is an ArrayBuffer
       *
       * @function
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an ArrayBuffer, otherwise false
       */
      var isArrayBuffer = kindOfTest("ArrayBuffer");

      /**
       * Determine if a value is a view on an ArrayBuffer
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
       */
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }

      /**
       * Determine if a value is a String
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a String, otherwise false
       */
      function isString(val) {
        return typeof val === "string";
      }

      /**
       * Determine if a value is a Number
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Number, otherwise false
       */
      function isNumber(val) {
        return typeof val === "number";
      }

      /**
       * Determine if a value is an Object
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is an Object, otherwise false
       */
      function isObject(val) {
        return (
          val !== null &&
          (typeof val === "undefined" ? "undefined" : _typeof(val)) === "object"
        );
      }

      /**
       * Determine if a value is a plain Object
       *
       * @param {Object} val The value to test
       * @return {boolean} True if value is a plain Object, otherwise false
       */
      function isPlainObject(val) {
        if (kindOf(val) !== "object") {
          return false;
        }

        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }

      /**
       * Determine if a value is a Date
       *
       * @function
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Date, otherwise false
       */
      var isDate = kindOfTest("Date");

      /**
       * Determine if a value is a File
       *
       * @function
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a File, otherwise false
       */
      var isFile = kindOfTest("File");

      /**
       * Determine if a value is a Blob
       *
       * @function
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Blob, otherwise false
       */
      var isBlob = kindOfTest("Blob");

      /**
       * Determine if a value is a FileList
       *
       * @function
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a File, otherwise false
       */
      var isFileList = kindOfTest("FileList");

      /**
       * Determine if a value is a Function
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Function, otherwise false
       */
      function isFunction(val) {
        return toString.call(val) === "[object Function]";
      }

      /**
       * Determine if a value is a Stream
       *
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a Stream, otherwise false
       */
      function isStream(val) {
        return isObject(val) && isFunction(val.pipe);
      }

      /**
       * Determine if a value is a FormData
       *
       * @param {Object} thing The value to test
       * @returns {boolean} True if value is an FormData, otherwise false
       */
      function isFormData(thing) {
        var pattern = "[object FormData]";
        return (
          thing &&
          ((typeof FormData === "function" && thing instanceof FormData) ||
            toString.call(thing) === pattern ||
            (isFunction(thing.toString) && thing.toString() === pattern))
        );
      }

      /**
       * Determine if a value is a URLSearchParams object
       * @function
       * @param {Object} val The value to test
       * @returns {boolean} True if value is a URLSearchParams object, otherwise false
       */
      var isURLSearchParams = kindOfTest("URLSearchParams");

      /**
       * Trim excess whitespace off the beginning and end of a string
       *
       * @param {String} str The String to trim
       * @returns {String} The String freed of excess whitespace
       */
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }

      /**
       * Determine if we're running in a standard browser environment
       *
       * This allows axios to run in a web worker, and react-native.
       * Both environments support XMLHttpRequest, but not fully standard globals.
       *
       * web workers:
       *  typeof window -> undefined
       *  typeof document -> undefined
       *
       * react-native:
       *  navigator.product -> 'ReactNative'
       * nativescript
       *  navigator.product -> 'NativeScript' or 'NS'
       */
      function isStandardBrowserEnv() {
        if (
          typeof navigator !== "undefined" &&
          (navigator.product === "ReactNative" ||
            navigator.product === "NativeScript" ||
            navigator.product === "NS")
        ) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }

      /**
       * Iterate over an Array or an Object invoking a function for each item.
       *
       * If `obj` is an Array callback will be called passing
       * the value, index, and complete array for each item.
       *
       * If 'obj' is an Object callback will be called passing
       * the value, key, and complete object for each property.
       *
       * @param {Object|Array} obj The object to iterate
       * @param {Function} fn The callback to invoke for each item
       */
      function forEach(obj, fn) {
        // Don't bother if no value provided
        if (obj === null || typeof obj === "undefined") {
          return;
        }

        // Force an array if not already something iterable
        if (
          (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object"
        ) {
          /*eslint no-param-reassign:0*/
          obj = [obj];
        }

        if (isArray(obj)) {
          // Iterate over array values
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          // Iterate over object keys
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }

      /**
       * Accepts varargs expecting each argument to be an object, then
       * immutably merges the properties of each object and returns result.
       *
       * When multiple objects contain the same key the later object in
       * the arguments list will take precedence.
       *
       * Example:
       *
       * ```js
       * var result = merge({foo: 123}, {foo: 456});
       * console.log(result.foo); // outputs 456
       * ```
       *
       * @param {Object} obj1 Object to merge
       * @returns {Object} Result of all merge properties
       */
      function merge() /* obj1, obj2, obj3, ... */ {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject(result[key]) && isPlainObject(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }

        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }

      /**
       * Extends object a by mutably adding to it the properties of object b.
       *
       * @param {Object} a The object to be extended
       * @param {Object} b The object to copy properties from
       * @param {Object} thisArg The object to bind function to
       * @return {Object} The resulting value of object a
       */
      function extend(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }

      /**
       * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
       *
       * @param {string} content with BOM
       * @return {string} content value without BOM
       */
      function stripBOM(content) {
        if (content.charCodeAt(0) === 0xfeff) {
          content = content.slice(1);
        }
        return content;
      }

      /**
       * Inherit the prototype methods from one constructor into another
       * @param {function} constructor
       * @param {function} superConstructor
       * @param {object} [props]
       * @param {object} [descriptors]
       */

      function inherits(constructor, superConstructor, props, descriptors) {
        constructor.prototype = Object.create(
          superConstructor.prototype,
          descriptors
        );
        constructor.prototype.constructor = constructor;
        props && _extends(constructor.prototype, props);
      }

      /**
       * Resolve object with deep prototype chain to a flat object
       * @param {Object} sourceObj source object
       * @param {Object} [destObj]
       * @param {Function} [filter]
       * @returns {Object}
       */

      function toFlatObject(sourceObj, destObj, filter) {
        var props;
        var i;
        var prop;
        var merged = {};

        destObj = destObj || {};

        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i = props.length;
          while (i-- > 0) {
            prop = props[i];
            if (!merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = Object.getPrototypeOf(sourceObj);
        } while (
          sourceObj &&
          (!filter || filter(sourceObj, destObj)) &&
          sourceObj !== Object.prototype
        );

        return destObj;
      }

      /*
       * determines whether a string ends with the characters of a specified string
       * @param {String} str
       * @param {String} searchString
       * @param {Number} [position= 0]
       * @returns {boolean}
       */
      function endsWith(str, searchString, position) {
        str = String(str);
        if (position === undefined || position > str.length) {
          position = str.length;
        }
        position -= searchString.length;
        var lastIndex = str.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      }

      /**
       * Returns new array from array like object
       * @param {*} [thing]
       * @returns {Array}
       */
      function toArray(thing) {
        if (!thing) return null;
        var i = thing.length;
        if (isUndefined(i)) return null;
        var arr = new Array(i);
        while (i-- > 0) {
          arr[i] = thing[i];
        }
        return arr;
      }

      // eslint-disable-next-line func-names
      var isTypedArray = (function (TypedArray) {
        // eslint-disable-next-line func-names
        return function (thing) {
          return TypedArray && thing instanceof TypedArray;
        };
      })(
        typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array)
      );

      module.exports = {
        isArray: isArray,
        isArrayBuffer: isArrayBuffer,
        isBuffer: isBuffer,
        isFormData: isFormData,
        isArrayBufferView: isArrayBufferView,
        isString: isString,
        isNumber: isNumber,
        isObject: isObject,
        isPlainObject: isPlainObject,
        isUndefined: isUndefined,
        isDate: isDate,
        isFile: isFile,
        isBlob: isBlob,
        isFunction: isFunction,
        isStream: isStream,
        isURLSearchParams: isURLSearchParams,
        isStandardBrowserEnv: isStandardBrowserEnv,
        forEach: forEach,
        merge: merge,
        extend: extend,
        trim: trim,
        stripBOM: stripBOM,
        inherits: inherits,
        toFlatObject: toFlatObject,
        kindOf: kindOf,
        kindOfTest: kindOfTest,
        endsWith: endsWith,
        toArray: toArray,
        isTypedArray: isTypedArray,
        isFileList: isFileList,
      };

      /***/
    },

    /***/ 1: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.createElementIfNotDefined =
        exports.classesToSelector =
        exports.getComputedStyle =
        exports.bindModuleMethods =
        exports.extend =
        exports.isObject =
        exports.getTranslate =
        exports.now =
        exports.nextTick =
        exports.deleteProps =
          undefined;

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var _ssrWindow = __webpack_require__(5);

      function deleteProps(obj) {
        var object = obj;
        Object.keys(object).forEach(function (key) {
          try {
            object[key] = null;
          } catch (e) {
            // no getter for object
          }

          try {
            delete object[key];
          } catch (e) {
            // something got wrong
          }
        });
      }

      function nextTick(callback, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        return setTimeout(callback, delay);
      }

      function now() {
        return Date.now();
      }

      function getComputedStyle(el) {
        var window = (0, _ssrWindow.getWindow)();
        var style;

        if (window.getComputedStyle) {
          style = window.getComputedStyle(el, null);
        }

        if (!style && el.currentStyle) {
          style = el.currentStyle;
        }

        if (!style) {
          style = el.style;
        }

        return style;
      }

      function getTranslate(el, axis) {
        if (axis === void 0) {
          axis = "x";
        }

        var window = (0, _ssrWindow.getWindow)();
        var matrix;
        var curTransform;
        var transformMatrix;
        var curStyle = getComputedStyle(el, null);

        if (window.WebKitCSSMatrix) {
          curTransform = curStyle.transform || curStyle.webkitTransform;

          if (curTransform.split(",").length > 6) {
            curTransform = curTransform
              .split(", ")
              .map(function (a) {
                return a.replace(",", ".");
              })
              .join(", ");
          } // Some old versions of Webkit choke when 'none' is passed; pass
          // empty string instead in this case

          transformMatrix = new window.WebKitCSSMatrix(
            curTransform === "none" ? "" : curTransform
          );
        } else {
          transformMatrix =
            curStyle.MozTransform ||
            curStyle.OTransform ||
            curStyle.MsTransform ||
            curStyle.msTransform ||
            curStyle.transform ||
            curStyle
              .getPropertyValue("transform")
              .replace("translate(", "matrix(1, 0, 0, 1,");
          matrix = transformMatrix.toString().split(",");
        }

        if (axis === "x") {
          // Latest Chrome and webkits Fix
          if (window.WebKitCSSMatrix)
            curTransform = transformMatrix.m41; // Crazy IE10 Matrix
          else if (matrix.length === 16)
            curTransform = parseFloat(matrix[12]); // Normal Browsers
          else curTransform = parseFloat(matrix[4]);
        }

        if (axis === "y") {
          // Latest Chrome and webkits Fix
          if (window.WebKitCSSMatrix)
            curTransform = transformMatrix.m42; // Crazy IE10 Matrix
          else if (matrix.length === 16)
            curTransform = parseFloat(matrix[13]); // Normal Browsers
          else curTransform = parseFloat(matrix[5]);
        }

        return curTransform || 0;
      }

      function isObject(o) {
        return (
          (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" &&
          o !== null &&
          o.constructor &&
          Object.prototype.toString.call(o).slice(8, -1) === "Object"
        );
      }

      function isNode(node) {
        // eslint-disable-next-line
        if (
          typeof window !== "undefined" &&
          typeof window.HTMLElement !== "undefined"
        ) {
          return node instanceof HTMLElement;
        }

        return node && (node.nodeType === 1 || node.nodeType === 11);
      }

      function extend() {
        var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
        var noExtend = ["__proto__", "constructor", "prototype"];

        for (var i = 1; i < arguments.length; i += 1) {
          var nextSource =
            i < 0 || arguments.length <= i ? undefined : arguments[i];

          if (
            nextSource !== undefined &&
            nextSource !== null &&
            !isNode(nextSource)
          ) {
            var keysArray = Object.keys(Object(nextSource)).filter(function (
              key
            ) {
              return noExtend.indexOf(key) < 0;
            });

            for (
              var nextIndex = 0, len = keysArray.length;
              nextIndex < len;
              nextIndex += 1
            ) {
              var nextKey = keysArray[nextIndex];
              var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

              if (desc !== undefined && desc.enumerable) {
                if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                  if (nextSource[nextKey].__swiper__) {
                    to[nextKey] = nextSource[nextKey];
                  } else {
                    extend(to[nextKey], nextSource[nextKey]);
                  }
                } else if (
                  !isObject(to[nextKey]) &&
                  isObject(nextSource[nextKey])
                ) {
                  to[nextKey] = {};

                  if (nextSource[nextKey].__swiper__) {
                    to[nextKey] = nextSource[nextKey];
                  } else {
                    extend(to[nextKey], nextSource[nextKey]);
                  }
                } else {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }
        }

        return to;
      }

      function bindModuleMethods(instance, obj) {
        Object.keys(obj).forEach(function (key) {
          if (isObject(obj[key])) {
            Object.keys(obj[key]).forEach(function (subKey) {
              if (typeof obj[key][subKey] === "function") {
                obj[key][subKey] = obj[key][subKey].bind(instance);
              }
            });
          }

          instance[key] = obj[key];
        });
      }

      function classesToSelector(classes) {
        if (classes === void 0) {
          classes = "";
        }

        return (
          "." +
          classes
            .trim()
            .replace(/([\.:!\/])/g, "\\$1") // eslint-disable-line
            .replace(/ /g, ".")
        );
      }

      function createElementIfNotDefined(
        $container,
        params,
        createElements,
        checkProps
      ) {
        var document = (0, _ssrWindow.getDocument)();

        if (createElements) {
          Object.keys(checkProps).forEach(function (key) {
            if (!params[key] && params.auto === true) {
              var element = document.createElement("div");
              element.className = checkProps[key];
              $container.append(element);
              params[key] = element;
            }
          });
        }

        return params;
      }

      exports.deleteProps = deleteProps;
      exports.nextTick = nextTick;
      exports.now = now;
      exports.getTranslate = getTranslate;
      exports.isObject = isObject;
      exports.extend = extend;
      exports.bindModuleMethods = bindModuleMethods;
      exports.getComputedStyle = getComputedStyle;
      exports.classesToSelector = classesToSelector;
      exports.createElementIfNotDefined = createElementIfNotDefined;

      /***/
    },

    /***/ 10: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var bodyScrollIsOff = false;
      var lastScrollPos = 0;

      module.exports = {
        scrollOff: function scrollOff() {
          if (!bodyScrollIsOff) lastScrollPos = document.body.scrollTop;
          bodyScrollIsOff = true;

          document.documentElement.classList.add("noscroll");
          document.documentElement.style.top = "-" + lastScrollPos + "px";
        },
        scrollOn: function scrollOn() {
          bodyScrollIsOff = false;

          document.documentElement.classList.remove("noscroll");
          document.documentElement.style.top = "";
          document.body.scrollTop = lastScrollPos;
        },
        scrollToggle: function scrollToggle() {
          if (bodyScrollIsOff) {
            this.scrollOn();
          } else {
            this.scrollOff();
          }
        },
        isScrollOff: function isScrollOff() {
          return bodyScrollIsOff;
        },
      };

      /***/
    },

    /***/ 100: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.f = {}.propertyIsEnumerable;

      /***/
    },

    /***/ 101: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // most Object methods by ES6 should accept primitives
      var $export = __webpack_require__(34);
      var core = __webpack_require__(9);
      var fails = __webpack_require__(18);
      module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY];
        var exp = {};
        exp[KEY] = exec(fn);
        $export(
          $export.S +
            $export.F *
              fails(function () {
                fn(1);
              }),
          "Object",
          exp
        );
      };

      /***/
    },

    /***/ 102: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /*
       * classList.js: Cross-browser full element.classList implementation.
       * 1.1.20170427
       *
       * By Eli Grey, http://eligrey.com
       * License: Dedicated to the public domain.
       *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
       */

      /*global self, document, DOMException */

      /*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

      if ("document" in window.self) {
        // Full polyfill for browsers with no classList support
        // Including IE < Edge missing SVGElement.classList
        if (
          !("classList" in document.createElement("_")) ||
          (document.createElementNS &&
            !(
              "classList" in
              document.createElementNS("http://www.w3.org/2000/svg", "g")
            ))
        ) {
          (function (view) {
            "use strict";

            if (!("Element" in view)) return;

            var classListProp = "classList",
              protoProp = "prototype",
              elemCtrProto = view.Element[protoProp],
              objCtr = Object,
              strTrim =
                String[protoProp].trim ||
                function () {
                  return this.replace(/^\s+|\s+$/g, "");
                },
              arrIndexOf =
                Array[protoProp].indexOf ||
                function (item) {
                  var i = 0,
                    len = this.length;
                  for (; i < len; i++) {
                    if (i in this && this[i] === item) {
                      return i;
                    }
                  }
                  return -1;
                },
              // Vendors: please allow content code to instantiate DOMExceptions
              DOMEx = function DOMEx(type, message) {
                this.name = type;
                this.code = DOMException[type];
                this.message = message;
              },
              checkTokenAndGetIndex = function checkTokenAndGetIndex(
                classList,
                token
              ) {
                if (token === "") {
                  throw new DOMEx(
                    "SYNTAX_ERR",
                    "An invalid or illegal string was specified"
                  );
                }
                if (/\s/.test(token)) {
                  throw new DOMEx(
                    "INVALID_CHARACTER_ERR",
                    "String contains an invalid character"
                  );
                }
                return arrIndexOf.call(classList, token);
              },
              ClassList = function ClassList(elem) {
                var trimmedClasses = strTrim.call(
                    elem.getAttribute("class") || ""
                  ),
                  classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
                  i = 0,
                  len = classes.length;
                for (; i < len; i++) {
                  this.push(classes[i]);
                }
                this._updateClassName = function () {
                  elem.setAttribute("class", this.toString());
                };
              },
              classListProto = (ClassList[protoProp] = []),
              classListGetter = function classListGetter() {
                return new ClassList(this);
              };
            // Most DOMException implementations don't allow calling DOMException's toString()
            // on non-DOMExceptions. Error's toString() is sufficient here.
            DOMEx[protoProp] = Error[protoProp];
            classListProto.item = function (i) {
              return this[i] || null;
            };
            classListProto.contains = function (token) {
              token += "";
              return checkTokenAndGetIndex(this, token) !== -1;
            };
            classListProto.add = function () {
              var tokens = arguments,
                i = 0,
                l = tokens.length,
                token,
                updated = false;
              do {
                token = tokens[i] + "";
                if (checkTokenAndGetIndex(this, token) === -1) {
                  this.push(token);
                  updated = true;
                }
              } while (++i < l);

              if (updated) {
                this._updateClassName();
              }
            };
            classListProto.remove = function () {
              var tokens = arguments,
                i = 0,
                l = tokens.length,
                token,
                updated = false,
                index;
              do {
                token = tokens[i] + "";
                index = checkTokenAndGetIndex(this, token);
                while (index !== -1) {
                  this.splice(index, 1);
                  updated = true;
                  index = checkTokenAndGetIndex(this, token);
                }
              } while (++i < l);

              if (updated) {
                this._updateClassName();
              }
            };
            classListProto.toggle = function (token, force) {
              token += "";

              var result = this.contains(token),
                method = result
                  ? force !== true && "remove"
                  : force !== false && "add";

              if (method) {
                this[method](token);
              }

              if (force === true || force === false) {
                return force;
              } else {
                return !result;
              }
            };
            classListProto.toString = function () {
              return this.join(" ");
            };

            if (objCtr.defineProperty) {
              var classListPropDesc = {
                get: classListGetter,
                enumerable: true,
                configurable: true,
              };
              try {
                objCtr.defineProperty(
                  elemCtrProto,
                  classListProp,
                  classListPropDesc
                );
              } catch (ex) {
                // IE 8 doesn't support enumerable:true
                // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
                // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
                if (ex.number === undefined || ex.number === -0x7ff5ec54) {
                  classListPropDesc.enumerable = false;
                  objCtr.defineProperty(
                    elemCtrProto,
                    classListProp,
                    classListPropDesc
                  );
                }
              }
            } else if (objCtr[protoProp].__defineGetter__) {
              elemCtrProto.__defineGetter__(classListProp, classListGetter);
            }
          })(window.self);
        }

        // There is full or partial native classList support, so just check if we need
        // to normalize the add/remove and toggle APIs.

        (function () {
          "use strict";

          var testElement = document.createElement("_");

          testElement.classList.add("c1", "c2");

          // Polyfill for IE 10/11 and Firefox <26, where classList.add and
          // classList.remove exist but support only one argument at a time.
          if (!testElement.classList.contains("c2")) {
            var createMethod = function createMethod(method) {
              var original = DOMTokenList.prototype[method];

              DOMTokenList.prototype[method] = function (token) {
                var i,
                  len = arguments.length;

                for (i = 0; i < len; i++) {
                  token = arguments[i];
                  original.call(this, token);
                }
              };
            };
            createMethod("add");
            createMethod("remove");
          }

          testElement.classList.toggle("c3", false);

          // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
          // support the second argument.
          if (testElement.classList.contains("c3")) {
            var _toggle = DOMTokenList.prototype.toggle;

            DOMTokenList.prototype.toggle = function (token, force) {
              if (1 in arguments && !this.contains(token) === !force) {
                return force;
              } else {
                return _toggle.call(this, token);
              }
            };
          }

          testElement = null;
        })();
      }

      /***/
    },

    /***/ 103: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var Handlers = __webpack_require__(7);
      var scrollBlocker = __webpack_require__(10);

      /**
       * @private
       */
      var DOM = {};
      var handlers = new Handlers();

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: init,
        on: handlers.add.bind(handlers),
        off: handlers.remove.bind(handlers),
      };

      /**
       * @private
       */
      function init() {
        var close = document.querySelector(".js-popup_close");

        if (close) {
          close.onclick = function () {
            handlers.call("close");
            scrollBlocker.scrollOn();
            _gaq.push(["_trackEvent", "popupClose", "click"]);
          };
        }
      }

      /***/
    },

    /***/ 104: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (setImmediate) {
        var _typeof =
          typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
            ? function (obj) {
                return typeof obj;
              }
            : function (obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };

        (function (root) {
          // Store setTimeout reference so promise-polyfill will be unaffected by
          // other code modifying setTimeout (like sinon.useFakeTimers())
          var setTimeoutFunc = setTimeout;

          function noop() {}

          // Polyfill for Function.prototype.bind
          function bind(fn, thisArg) {
            return function () {
              fn.apply(thisArg, arguments);
            };
          }

          function Promise(fn) {
            if (!(this instanceof Promise))
              throw new TypeError("Promises must be constructed via new");
            if (typeof fn !== "function") throw new TypeError("not a function");
            this._state = 0;
            this._handled = false;
            this._value = undefined;
            this._deferreds = [];

            doResolve(fn, this);
          }

          function handle(self, deferred) {
            while (self._state === 3) {
              self = self._value;
            }
            if (self._state === 0) {
              self._deferreds.push(deferred);
              return;
            }
            self._handled = true;
            Promise._immediateFn(function () {
              var cb =
                self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
              if (cb === null) {
                (self._state === 1 ? resolve : reject)(
                  deferred.promise,
                  self._value
                );
                return;
              }
              var ret;
              try {
                ret = cb(self._value);
              } catch (e) {
                reject(deferred.promise, e);
                return;
              }
              resolve(deferred.promise, ret);
            });
          }

          function resolve(self, newValue) {
            try {
              // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
              if (newValue === self)
                throw new TypeError(
                  "A promise cannot be resolved with itself."
                );
              if (
                newValue &&
                ((typeof newValue === "undefined"
                  ? "undefined"
                  : _typeof(newValue)) === "object" ||
                  typeof newValue === "function")
              ) {
                var then = newValue.then;
                if (newValue instanceof Promise) {
                  self._state = 3;
                  self._value = newValue;
                  finale(self);
                  return;
                } else if (typeof then === "function") {
                  doResolve(bind(then, newValue), self);
                  return;
                }
              }
              self._state = 1;
              self._value = newValue;
              finale(self);
            } catch (e) {
              reject(self, e);
            }
          }

          function reject(self, newValue) {
            self._state = 2;
            self._value = newValue;
            finale(self);
          }

          function finale(self) {
            if (self._state === 2 && self._deferreds.length === 0) {
              Promise._immediateFn(function () {
                if (!self._handled) {
                  Promise._unhandledRejectionFn(self._value);
                }
              });
            }

            for (var i = 0, len = self._deferreds.length; i < len; i++) {
              handle(self, self._deferreds[i]);
            }
            self._deferreds = null;
          }

          function Handler(onFulfilled, onRejected, promise) {
            this.onFulfilled =
              typeof onFulfilled === "function" ? onFulfilled : null;
            this.onRejected =
              typeof onRejected === "function" ? onRejected : null;
            this.promise = promise;
          }

          /**
           * Take a potentially misbehaving resolver function and make sure
           * onFulfilled and onRejected are only called once.
           *
           * Makes no guarantees about asynchrony.
           */
          function doResolve(fn, self) {
            var done = false;
            try {
              fn(
                function (value) {
                  if (done) return;
                  done = true;
                  resolve(self, value);
                },
                function (reason) {
                  if (done) return;
                  done = true;
                  reject(self, reason);
                }
              );
            } catch (ex) {
              if (done) return;
              done = true;
              reject(self, ex);
            }
          }

          Promise.prototype["catch"] = function (onRejected) {
            return this.then(null, onRejected);
          };

          Promise.prototype.then = function (onFulfilled, onRejected) {
            var prom = new this.constructor(noop);

            handle(this, new Handler(onFulfilled, onRejected, prom));
            return prom;
          };

          Promise.all = function (arr) {
            return new Promise(function (resolve, reject) {
              if (!arr || typeof arr.length === "undefined")
                throw new TypeError("Promise.all accepts an array");
              var args = Array.prototype.slice.call(arr);
              if (args.length === 0) return resolve([]);
              var remaining = args.length;

              function res(i, val) {
                try {
                  if (
                    val &&
                    ((typeof val === "undefined"
                      ? "undefined"
                      : _typeof(val)) === "object" ||
                      typeof val === "function")
                  ) {
                    var then = val.then;
                    if (typeof then === "function") {
                      then.call(
                        val,
                        function (val) {
                          res(i, val);
                        },
                        reject
                      );
                      return;
                    }
                  }
                  args[i] = val;
                  if (--remaining === 0) {
                    resolve(args);
                  }
                } catch (ex) {
                  reject(ex);
                }
              }

              for (var i = 0; i < args.length; i++) {
                res(i, args[i]);
              }
            });
          };

          Promise.resolve = function (value) {
            if (
              value &&
              (typeof value === "undefined" ? "undefined" : _typeof(value)) ===
                "object" &&
              value.constructor === Promise
            ) {
              return value;
            }

            return new Promise(function (resolve) {
              resolve(value);
            });
          };

          Promise.reject = function (value) {
            return new Promise(function (resolve, reject) {
              reject(value);
            });
          };

          Promise.race = function (values) {
            return new Promise(function (resolve, reject) {
              for (var i = 0, len = values.length; i < len; i++) {
                values[i].then(resolve, reject);
              }
            });
          };

          // Use polyfill for setImmediate for performance gains
          Promise._immediateFn =
            (typeof setImmediate === "function" &&
              function (fn) {
                setImmediate(fn);
              }) ||
            function (fn) {
              setTimeoutFunc(fn, 0);
            };

          Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
            if (typeof console !== "undefined" && console) {
              console.warn("Possible Unhandled Promise Rejection:", err); // eslint-disable-line no-console
            }
          };

          /**
           * Set the immediate function to execute callbacks
           * @param fn {function} Function to execute
           * @deprecated
           */
          Promise._setImmediateFn = function _setImmediateFn(fn) {
            Promise._immediateFn = fn;
          };

          /**
           * Change the function to execute on unhandled rejection
           * @param {function} fn Function to execute on unhandled rejection
           * @deprecated
           */
          Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(
            fn
          ) {
            Promise._unhandledRejectionFn = fn;
          };

          if (typeof module !== "undefined" && module.exports) {
            module.exports = Promise;
          } else if (!root.Promise) {
            root.Promise = Promise;
          }
        })(undefined);
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(105).setImmediate);

      /***/
    },

    /***/ 105: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (global) {
        var scope =
          (typeof global !== "undefined" && global) ||
          (typeof self !== "undefined" && self) ||
          window;
        var apply = Function.prototype.apply;

        // DOM APIs, for completeness

        exports.setTimeout = function () {
          return new Timeout(
            apply.call(setTimeout, scope, arguments),
            clearTimeout
          );
        };
        exports.setInterval = function () {
          return new Timeout(
            apply.call(setInterval, scope, arguments),
            clearInterval
          );
        };
        exports.clearTimeout = exports.clearInterval = function (timeout) {
          if (timeout) {
            timeout.close();
          }
        };

        function Timeout(id, clearFn) {
          this._id = id;
          this._clearFn = clearFn;
        }
        Timeout.prototype.unref = Timeout.prototype.ref = function () {};
        Timeout.prototype.close = function () {
          this._clearFn.call(scope, this._id);
        };

        // Does not start the time, just sets up the members needed.
        exports.enroll = function (item, msecs) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = msecs;
        };

        exports.unenroll = function (item) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = -1;
        };

        exports._unrefActive = exports.active = function (item) {
          clearTimeout(item._idleTimeoutId);

          var msecs = item._idleTimeout;
          if (msecs >= 0) {
            item._idleTimeoutId = setTimeout(function onTimeout() {
              if (item._onTimeout) item._onTimeout();
            }, msecs);
          }
        };

        // setimmediate attaches itself to the global object
        __webpack_require__(106);
        // On some exotic environments, it's not clear which object `setimmediate` was
        // able to install onto.  Search each possibility in the same order as the
        // `setimmediate` library.
        exports.setImmediate =
          (typeof self !== "undefined" && self.setImmediate) ||
          (typeof global !== "undefined" && global.setImmediate) ||
          (undefined && undefined.setImmediate);
        exports.clearImmediate =
          (typeof self !== "undefined" && self.clearImmediate) ||
          (typeof global !== "undefined" && global.clearImmediate) ||
          (undefined && undefined.clearImmediate);
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(13));

      /***/
    },

    /***/ 106: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (global, process) {
        (function (global, undefined) {
          "use strict";

          if (global.setImmediate) {
            return;
          }

          var nextHandle = 1; // Spec says greater than zero
          var tasksByHandle = {};
          var currentlyRunningATask = false;
          var doc = global.document;
          var registerImmediate;

          function setImmediate(callback) {
            // Callback can either be a function or a string
            if (typeof callback !== "function") {
              callback = new Function("" + callback);
            }
            // Copy function arguments
            var args = new Array(arguments.length - 1);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i + 1];
            }
            // Store and register the task
            var task = { callback: callback, args: args };
            tasksByHandle[nextHandle] = task;
            registerImmediate(nextHandle);
            return nextHandle++;
          }

          function clearImmediate(handle) {
            delete tasksByHandle[handle];
          }

          function run(task) {
            var callback = task.callback;
            var args = task.args;
            switch (args.length) {
              case 0:
                callback();
                break;
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              default:
                callback.apply(undefined, args);
                break;
            }
          }

          function runIfPresent(handle) {
            // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
            // So if we're currently running a task, we'll need to delay this invocation.
            if (currentlyRunningATask) {
              // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
              // "too much recursion" error.
              setTimeout(runIfPresent, 0, handle);
            } else {
              var task = tasksByHandle[handle];
              if (task) {
                currentlyRunningATask = true;
                try {
                  run(task);
                } finally {
                  clearImmediate(handle);
                  currentlyRunningATask = false;
                }
              }
            }
          }

          function installNextTickImplementation() {
            registerImmediate = function registerImmediate(handle) {
              process.nextTick(function () {
                runIfPresent(handle);
              });
            };
          }

          function canUsePostMessage() {
            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
            // where `global.postMessage` means something completely different and can't be used for this purpose.
            if (global.postMessage && !global.importScripts) {
              var postMessageIsAsynchronous = true;
              var oldOnMessage = global.onmessage;
              global.onmessage = function () {
                postMessageIsAsynchronous = false;
              };
              global.postMessage("", "*");
              global.onmessage = oldOnMessage;
              return postMessageIsAsynchronous;
            }
          }

          function installPostMessageImplementation() {
            // Installs an event handler on `global` for the `message` event: see
            // * https://developer.mozilla.org/en/DOM/window.postMessage
            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

            var messagePrefix = "setImmediate$" + Math.random() + "$";
            var onGlobalMessage = function onGlobalMessage(event) {
              if (
                event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0
              ) {
                runIfPresent(+event.data.slice(messagePrefix.length));
              }
            };

            if (global.addEventListener) {
              global.addEventListener("message", onGlobalMessage, false);
            } else {
              global.attachEvent("onmessage", onGlobalMessage);
            }

            registerImmediate = function registerImmediate(handle) {
              global.postMessage(messagePrefix + handle, "*");
            };
          }

          function installMessageChannelImplementation() {
            var channel = new MessageChannel();
            channel.port1.onmessage = function (event) {
              var handle = event.data;
              runIfPresent(handle);
            };

            registerImmediate = function registerImmediate(handle) {
              channel.port2.postMessage(handle);
            };
          }

          function installReadyStateChangeImplementation() {
            var html = doc.documentElement;
            registerImmediate = function registerImmediate(handle) {
              // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
              // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
              var script = doc.createElement("script");
              script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
              };
              html.appendChild(script);
            };
          }

          function installSetTimeoutImplementation() {
            registerImmediate = function registerImmediate(handle) {
              setTimeout(runIfPresent, 0, handle);
            };
          }

          // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
          var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
          attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

          // Don't get fooled by e.g. browserify environments.
          if ({}.toString.call(global.process) === "[object process]") {
            // For Node.js before 0.9
            installNextTickImplementation();
          } else if (canUsePostMessage()) {
            // For non-IE10 modern browsers
            installPostMessageImplementation();
          } else if (global.MessageChannel) {
            // For web workers, where supported
            installMessageChannelImplementation();
          } else if (
            doc &&
            "onreadystatechange" in doc.createElement("script")
          ) {
            // For IE 68
            installReadyStateChangeImplementation();
          } else {
            // For older browsers
            installSetTimeoutImplementation();
          }

          attachTo.setImmediate = setImmediate;
          attachTo.clearImmediate = clearImmediate;
        })(
          typeof self === "undefined"
            ? typeof global === "undefined"
              ? undefined
              : global
            : self
        );
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(13), __webpack_require__(12));

      /***/
    },

    /***/ 107: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var inputs = document.querySelectorAll(".js-request_field");
      var activeClassName = "c-field--focused";

      var inputsFocusHandler = function inputsFocusHandler(evt) {
        var target = evt.target;

        var isFocused = evt.type === "focus";

        isFocused &&
          !target.parentNode.classList.contains(activeClassName) &&
          target.parentNode.classList.add(activeClassName);
        !isFocused &&
          target.parentNode.classList.contains(activeClassName) &&
          target.parentNode.classList.remove(activeClassName);
      };

      for (var i = 0; i < inputs.length; i++) {
        var el = inputs[i];

        el.addEventListener("focus", inputsFocusHandler);
        el.addEventListener("blur", inputsFocusHandler);
      }

      /***/
    },

    /***/ 108: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var checkboxes = document.querySelectorAll(".ui-checkbox");

      function switchDisable(checked, target) {
        var className = "b-request_submit-disabled";
        var submitBtnWrapper = target
          .closest(".b-request_form")
          .querySelector(".b-request_submit");
        var submitBtn = submitBtnWrapper.querySelector('input[type="submit"]');

        if (checked) {
          submitBtnWrapper.classList.remove(className);
          submitBtn.removeAttribute("disabled");
        } else {
          submitBtnWrapper.classList.add(className);
          submitBtn.setAttribute("disabled", "disabled");
        }
      }

      function checkboxesChangeHandler(evt) {
        var target = evt.target;
        var checked = target.checked;

        switchDisable(checked, target);
      }

      for (var i = 0; i < checkboxes.length; i++) {
        var el = checkboxes[i];

        switchDisable(el.checked, el);

        el.addEventListener("change", checkboxesChangeHandler);
      }

      /***/
    },

    /***/ 109: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      /*! modernizr 3.5.0 (Custom Build) | MIT *
       * https://modernizr.com/download/?-cssanimations-touchevents-videoautoplay-setclasses !*/
      !(function (A, e, t) {
        function n(A, e) {
          return (typeof A === "undefined" ? "undefined" : _typeof(A)) === e;
        }
        function o() {
          var A, e, t, o, i, r, l;
          for (var a in y) {
            if (y.hasOwnProperty(a)) {
              if (
                ((A = []),
                (e = y[a]),
                e.name &&
                  (A.push(e.name.toLowerCase()),
                  e.options && e.options.aliases && e.options.aliases.length))
              )
                for (t = 0; t < e.options.aliases.length; t++) {
                  A.push(e.options.aliases[t].toLowerCase());
                }
              for (
                o = n(e.fn, "function") ? e.fn() : e.fn, i = 0;
                i < A.length;
                i++
              ) {
                (r = A[i]),
                  (l = r.split(".")),
                  1 === l.length
                    ? (Modernizr[l[0]] = o)
                    : (!Modernizr[l[0]] ||
                        Modernizr[l[0]] instanceof Boolean ||
                        (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])),
                      (Modernizr[l[0]][l[1]] = o)),
                  E.push((o ? "" : "no-") + l.join("-"));
              }
            }
          }
        }
        function i(A) {
          var e = v.className,
            t = Modernizr._config.classPrefix || "";
          if ((T && (e = e.baseVal), Modernizr._config.enableJSClass)) {
            var n = new RegExp("(^|\\s)" + t + "no-js(\\s|$)");
            e = e.replace(n, "$1" + t + "js$2");
          }
          Modernizr._config.enableClasses &&
            ((e += " " + t + A.join(" " + t)),
            T ? (v.className.baseVal = e) : (v.className = e));
        }
        function r() {
          return "function" != typeof e.createElement
            ? e.createElement(arguments[0])
            : T
            ? e.createElementNS.call(
                e,
                "http://www.w3.org/2000/svg",
                arguments[0]
              )
            : e.createElement.apply(e, arguments);
        }
        function l(A, e) {
          if ("object" == (typeof A === "undefined" ? "undefined" : _typeof(A)))
            for (var t in A) {
              G(A, t) && l(t, A[t]);
            }
          else {
            A = A.toLowerCase();
            var n = A.split("."),
              o = Modernizr[n[0]];
            if ((2 == n.length && (o = o[n[1]]), "undefined" != typeof o))
              return Modernizr;
            (e = "function" == typeof e ? e() : e),
              1 == n.length
                ? (Modernizr[n[0]] = e)
                : (!Modernizr[n[0]] ||
                    Modernizr[n[0]] instanceof Boolean ||
                    (Modernizr[n[0]] = new Boolean(Modernizr[n[0]])),
                  (Modernizr[n[0]][n[1]] = e)),
              i([(e && 0 != e ? "" : "no-") + n.join("-")]),
              Modernizr._trigger(A, e);
          }
          return Modernizr;
        }
        function a() {
          var A = e.body;
          return A || ((A = r(T ? "svg" : "body")), (A.fake = !0)), A;
        }
        function s(A, t, n, o) {
          var i,
            l,
            s,
            c,
            u = "modernizr",
            d = r("div"),
            p = a();
          if (parseInt(n, 10))
            for (; n--; ) {
              (s = r("div")), (s.id = o ? o[n] : u + (n + 1)), d.appendChild(s);
            }
          return (
            (i = r("style")),
            (i.type = "text/css"),
            (i.id = "s" + u),
            (p.fake ? p : d).appendChild(i),
            p.appendChild(d),
            i.styleSheet
              ? (i.styleSheet.cssText = A)
              : i.appendChild(e.createTextNode(A)),
            (d.id = u),
            p.fake &&
              ((p.style.background = ""),
              (p.style.overflow = "hidden"),
              (c = v.style.overflow),
              (v.style.overflow = "hidden"),
              v.appendChild(p)),
            (l = t(d, A)),
            p.fake
              ? (p.parentNode.removeChild(p),
                (v.style.overflow = c),
                v.offsetHeight)
              : d.parentNode.removeChild(d),
            !!l
          );
        }
        function c(A, e) {
          return function () {
            return A.apply(e, arguments);
          };
        }
        function u(A, e, t) {
          var o;
          for (var i in A) {
            if (A[i] in e)
              return t === !1
                ? A[i]
                : ((o = e[A[i]]), n(o, "function") ? c(o, t || e) : o);
          }
          return !1;
        }
        function d(A, e) {
          return !!~("" + A).indexOf(e);
        }
        function p(A) {
          return A.replace(/([a-z])-([a-z])/g, function (A, e, t) {
            return e + t.toUpperCase();
          }).replace(/^-/, "");
        }
        function f(A) {
          return A.replace(/([A-Z])/g, function (A, e) {
            return "-" + e.toLowerCase();
          }).replace(/^ms-/, "-ms-");
        }
        function h(e, t, n) {
          var o;
          if ("getComputedStyle" in A) {
            o = getComputedStyle.call(A, e, t);
            var i = A.console;
            if (null !== o) n && (o = o.getPropertyValue(n));
            else if (i) {
              var r = i.error ? "error" : "log";
              i[r].call(
                i,
                "getComputedStyle returning null, its possible modernizr test results are inaccurate"
              );
            }
          } else o = !t && e.currentStyle && e.currentStyle[n];
          return o;
        }
        function m(e, n) {
          var o = e.length;
          if ("CSS" in A && "supports" in A.CSS) {
            for (; o--; ) {
              if (A.CSS.supports(f(e[o]), n)) return !0;
            }
            return !1;
          }
          if ("CSSSupportsRule" in A) {
            for (var i = []; o--; ) {
              i.push("(" + f(e[o]) + ":" + n + ")");
            }
            return (
              (i = i.join(" or ")),
              s(
                "@supports (" + i + ") { #modernizr { position: absolute; } }",
                function (A) {
                  return "absolute" == h(A, null, "position");
                }
              )
            );
          }
          return t;
        }
        function w(A, e, o, i) {
          function l() {
            s && (delete V.style, delete V.modElem);
          }
          if (((i = n(i, "undefined") ? !1 : i), !n(o, "undefined"))) {
            var a = m(A, o);
            if (!n(a, "undefined")) return a;
          }
          for (
            var s, c, u, f, h, w = ["modernizr", "tspan", "samp"];
            !V.style && w.length;

          ) {
            (s = !0), (V.modElem = r(w.shift())), (V.style = V.modElem.style);
          }
          for (u = A.length, c = 0; u > c; c++) {
            if (
              ((f = A[c]),
              (h = V.style[f]),
              d(f, "-") && (f = p(f)),
              V.style[f] !== t)
            ) {
              if (i || n(o, "undefined")) return l(), "pfx" == e ? f : !0;
              try {
                V.style[f] = o;
              } catch (g) {}
              if (V.style[f] != h) return l(), "pfx" == e ? f : !0;
            }
          }
          return l(), !1;
        }
        function g(A, e, t, o, i) {
          var r = A.charAt(0).toUpperCase() + A.slice(1),
            l = (A + " " + Z.join(r + " ") + r).split(" ");
          return n(e, "string") || n(e, "undefined")
            ? w(l, e, o, i)
            : ((l = (A + " " + Y.join(r + " ") + r).split(" ")), u(l, e, t));
        }
        function R(A, e, n) {
          return g(A, t, t, e, n);
        }
        var E = [],
          y = [],
          B = {
            _version: "3.5.0",
            _config: {
              classPrefix: "",
              enableClasses: !0,
              enableJSClass: !0,
              usePrefixes: !0,
            },
            _q: [],
            on: function on(A, e) {
              var t = this;
              setTimeout(function () {
                e(t[A]);
              }, 0);
            },
            addTest: function addTest(A, e, t) {
              y.push({ name: A, fn: e, options: t });
            },
            addAsyncTest: function addAsyncTest(A) {
              y.push({ name: null, fn: A });
            },
          },
          Modernizr = function Modernizr() {};
        (Modernizr.prototype = B), (Modernizr = new Modernizr());
        var v = e.documentElement,
          T = "svg" === v.nodeName.toLowerCase(),
          F = B._config.usePrefixes
            ? " -webkit- -moz- -o- -ms- ".split(" ")
            : ["", ""];
        (B._prefixes = F),
          Modernizr.addTest("video", function () {
            var A = r("video"),
              e = !1;
            try {
              (e = !!A.canPlayType),
                e &&
                  ((e = new Boolean(e)),
                  (e.ogg = A.canPlayType('video/ogg; codecs="theora"').replace(
                    /^no$/,
                    ""
                  )),
                  (e.h264 = A.canPlayType(
                    'video/mp4; codecs="avc1.42E01E"'
                  ).replace(/^no$/, "")),
                  (e.webm = A.canPlayType(
                    'video/webm; codecs="vp8, vorbis"'
                  ).replace(/^no$/, "")),
                  (e.vp9 = A.canPlayType('video/webm; codecs="vp9"').replace(
                    /^no$/,
                    ""
                  )),
                  (e.hls = A.canPlayType(
                    'application/x-mpegURL; codecs="avc1.42E01E"'
                  ).replace(/^no$/, "")));
            } catch (t) {}
            return e;
          });
        var G;
        !(function () {
          var A = {}.hasOwnProperty;
          G =
            n(A, "undefined") || n(A.call, "undefined")
              ? function (A, e) {
                  return e in A && n(A.constructor.prototype[e], "undefined");
                }
              : function (e, t) {
                  return A.call(e, t);
                };
        })(),
          (B._l = {}),
          (B.on = function (A, e) {
            this._l[A] || (this._l[A] = []),
              this._l[A].push(e),
              Modernizr.hasOwnProperty(A) &&
                setTimeout(function () {
                  Modernizr._trigger(A, Modernizr[A]);
                }, 0);
          }),
          (B._trigger = function (A, e) {
            if (this._l[A]) {
              var t = this._l[A];
              setTimeout(function () {
                var A, n;
                for (A = 0; A < t.length; A++) {
                  (n = t[A])(e);
                }
              }, 0),
                delete this._l[A];
            }
          }),
          Modernizr._q.push(function () {
            B.addTest = l;
          }),
          Modernizr.addAsyncTest(function () {
            function A(r) {
              o++, clearTimeout(e);
              var a = (r && "playing" === r.type) || 0 !== i.currentTime;
              return !a && n > o
                ? void (e = setTimeout(A, t))
                : (i.removeEventListener("playing", A, !1),
                  l("videoautoplay", a),
                  void (i.parentNode && i.parentNode.removeChild(i)));
            }
            var e,
              t = 200,
              n = 5,
              o = 0,
              i = r("video"),
              a = i.style;
            if (!(Modernizr.video && "autoplay" in i))
              return void l("videoautoplay", !1);
            (a.position = "absolute"), (a.height = 0), (a.width = 0);
            try {
              if (Modernizr.video.ogg)
                i.src =
                  "data:video/ogg;base64,T2dnUwACAAAAAAAAAABmnCATAAAAAHDEixYBKoB0aGVvcmEDAgEAAQABAAAQAAAQAAAAAAAFAAAAAQAAAAAAAAAAAGIAYE9nZ1MAAAAAAAAAAAAAZpwgEwEAAAACrA7TDlj///////////////+QgXRoZW9yYSsAAABYaXBoLk9yZyBsaWJ0aGVvcmEgMS4xIDIwMDkwODIyIChUaHVzbmVsZGEpAQAAABoAAABFTkNPREVSPWZmbXBlZzJ0aGVvcmEtMC4yOYJ0aGVvcmG+zSj3uc1rGLWpSUoQc5zmMYxSlKQhCDGMYhCEIQhAAAAAAAAAAAAAEW2uU2eSyPxWEvx4OVts5ir1aKtUKBMpJFoQ/nk5m41mUwl4slUpk4kkghkIfDwdjgajQYC8VioUCQRiIQh8PBwMhgLBQIg4FRba5TZ5LI/FYS/Hg5W2zmKvVoq1QoEykkWhD+eTmbjWZTCXiyVSmTiSSCGQh8PB2OBqNBgLxWKhQJBGIhCHw8HAyGAsFAiDgUCw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDAwPEhQUFQ0NDhESFRUUDg4PEhQVFRUOEBETFBUVFRARFBUVFRUVEhMUFRUVFRUUFRUVFRUVFRUVFRUVFRUVEAwLEBQZGxwNDQ4SFRwcGw4NEBQZHBwcDhATFhsdHRwRExkcHB4eHRQYGxwdHh4dGxwdHR4eHh4dHR0dHh4eHRALChAYKDM9DAwOExo6PDcODRAYKDlFOA4RFh0zV1A+EhYlOkRtZ00YIzdAUWhxXDFATldneXhlSFxfYnBkZ2MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEhIVGRoaGhoSFBYaGhoaGhUWGRoaGhoaGRoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhESFh8kJCQkEhQYIiQkJCQWGCEkJCQkJB8iJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQREhgvY2NjYxIVGkJjY2NjGBo4Y2NjY2MvQmNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRISEhUXGBkbEhIVFxgZGxwSFRcYGRscHRUXGBkbHB0dFxgZGxwdHR0YGRscHR0dHhkbHB0dHR4eGxwdHR0eHh4REREUFxocIBERFBcaHCAiERQXGhwgIiUUFxocICIlJRcaHCAiJSUlGhwgIiUlJSkcICIlJSUpKiAiJSUlKSoqEBAQFBgcICgQEBQYHCAoMBAUGBwgKDBAFBgcICgwQEAYHCAoMEBAQBwgKDBAQEBgICgwQEBAYIAoMEBAQGCAgAfF5cdH1e3Ow/L66wGmYnfIUbwdUTe3LMRbqON8B+5RJEvcGxkvrVUjTMrsXYhAnIwe0dTJfOYbWrDYyqUrz7dw/JO4hpmV2LsQQvkUeGq1BsZLx+cu5iV0e0eScJ91VIQYrmqfdVSK7GgjOU0oPaPOu5IcDK1mNvnD+K8LwS87f8Jx2mHtHnUkTGAurWZlNQa74ZLSFH9oF6FPGxzLsjQO5Qe0edcpttd7BXBSqMCL4k/4tFrHIPuEQ7m1/uIWkbDMWVoDdOSuRQ9286kvVUlQjzOE6VrNguN4oRXYGkgcnih7t13/9kxvLYKQezwLTrO44sVmMPgMqORo1E0sm1/9SludkcWHwfJwTSybR4LeAz6ugWVgRaY8mV/9SluQmtHrzsBtRF/wPY+X0JuYTs+ltgrXAmlk10xQHmTu9VSIAk1+vcvU4ml2oNzrNhEtQ3CysNP8UeR35wqpKUBdGdZMSjX4WVi8nJpdpHnbhzEIdx7mwf6W1FKAiucMXrWUWVjyRf23chNtR9mIzDoT/6ZLYailAjhFlZuvPtSeZ+2oREubDoWmT3TguY+JHPdRVSLKxfKH3vgNqJ/9emeEYikGXDFNzaLjvTeGAL61mogOoeG3y6oU4rW55ydoj0lUTSR/mmRhPmF86uwIfzp3FtiufQCmppaHDlGE0r2iTzXIw3zBq5hvaTldjG4CPb9wdxAme0SyedVKczJ9AtYbgPOzYKJvZZImsN7ecrxWZg5dR6ZLj/j4qpWsIA+vYwE+Tca9ounMIsrXMB4Stiib2SPQtZv+FVIpfEbzv8ncZoLBXc3YBqTG1HsskTTotZOYTG+oVUjLk6zhP8bg4RhMUNtfZdO7FdpBuXzhJ5Fh8IKlJG7wtD9ik8rWOJxy6iQ3NwzBpQ219mlyv+FLicYs2iJGSE0u2txzed++D61ZWCiHD/cZdQVCqkO2gJpdpNaObhnDfAPrT89RxdWFZ5hO3MseBSIlANppdZNIV/Rwe5eLTDvkfWKzFnH+QJ7m9QWV1KdwnuIwTNtZdJMoXBf74OhRnh2t+OTGL+AVUnIkyYY+QG7g9itHXyF3OIygG2s2kud679ZWKqSFa9n3IHD6MeLv1lZ0XyduRhiDRtrNnKoyiFVLcBm0ba5Yy3fQkDh4XsFE34isVpOzpa9nR8iCpS4HoxG2rJpnRhf3YboVa1PcRouh5LIJv/uQcPNd095ickTaiGBnWLKVWRc0OnYTSyex/n2FofEPnDG8y3PztHrzOLK1xo6RAml2k9owKajOC0Wr4D5x+3nA0UEhK2m198wuBHF3zlWWVKWLN1CHzLClUfuoYBcx4b1llpeBKmbayaR58njtE9onD66lUcsg0Spm2snsb+8HaJRn4dYcLbCuBuYwziB8/5U1C1DOOz2gZjSZtrLJk6vrLF3hwY4Io9xuT/ruUFRSBkNtUzTOWhjh26irLEPx4jPZL3Fo3QrReoGTTM21xYTT9oFdhTUIvjqTkfkvt0bzgVUjq/hOYY8j60IaO/0AzRBtqkTS6R5ellZd5uKdzzhb8BFlDdAcrwkE0rbXTOPB+7Y0FlZO96qFL4Ykg21StJs8qIW7h16H5hGiv8V2Cflau7QVDepTAHa6Lgt6feiEvJDM21StJsmOH/hynURrKxvUpQ8BH0JF7BiyG2qZpnL/7AOU66gt+reLEXY8pVOCQvSsBtqZTNM8bk9ohRcwD18o/WVkbvrceVKRb9I59IEKysjBeTMmmbA21xu/6iHadLRxuIzkLpi8wZYmmbbWi32RVAUjruxWlJ//iFxE38FI9hNKOoCdhwf5fDe4xZ81lgREhK2m1j78vW1CqkuMu/AjBNK210kzRUX/B+69cMMUG5bYrIeZxVSEZISmkzbXOi9yxwIfPgdsov7R71xuJ7rFcACjG/9PzApqFq7wEgzNJm2suWESPuwrQvejj7cbnQxMkxpm21lUYJL0fKmogPPqywn7e3FvB/FCNxPJ85iVUkCE9/tLKx31G4CgNtWTTPFhMvlu8G4/TrgaZttTChljfNJGgOT2X6EqpETy2tYd9cCBI4lIXJ1/3uVUllZEJz4baqGF64yxaZ+zPLYwde8Uqn1oKANtUrSaTOPHkhvuQP3bBlEJ/LFe4pqQOHUI8T8q7AXx3fLVBgSCVpMba55YxN3rv8U1Dv51bAPSOLlZWebkL8vSMGI21lJmmeVxPRwFlZF1CpqCN8uLwymaZyjbXHCRytogPN3o/n74CNykfT+qqRv5AQlHcRxYrC5KvGmbbUwmZY/29BvF6C1/93x4WVglXDLFpmbapmF89HKTogRwqqSlGbu+oiAkcWFbklC6Zhf+NtTLFpn8oWz+HsNRVSgIxZWON+yVyJlE5tq/+GWLTMutYX9ekTySEQPLVNQQ3OfycwJBM0zNtZcse7CvcKI0V/zh16Dr9OSA21MpmmcrHC+6pTAPHPwoit3LHHqs7jhFNRD6W8+EBGoSEoaZttTCZljfduH/fFisn+dRBGAZYtMzbVMwvul/T/crK1NQh8gN0SRRa9cOux6clC0/mDLFpmbarmF8/e6CopeOLCNW6S/IUUg3jJIYiAcDoMcGeRbOvuTPjXR/tyo79LK3kqqkbxkkMRAOB0GODPItnX3Jnxro/25Ud+llbyVVSN4ySGIgHA6DHBnkWzr7kz410f7cqO/Syt5KqpFVJwn6gBEvBM0zNtZcpGOEPiysW8vvRd2R0f7gtjhqUvXL+gWVwHm4XJDBiMpmmZtrLfPwd/IugP5+fKVSysH1EXreFAcEhelGmbbUmZY4Xdo1vQWVnK19P4RuEnbf0gQnR+lDCZlivNM22t1ESmopPIgfT0duOfQrsjgG4tPxli0zJmF5trdL1JDUIUT1ZXSqQDeR4B8mX3TrRro/2McGeUvLtwo6jIEKMkCUXWsLyZROd9P/rFYNtXPBli0z398iVUlVKAjFlY437JXImUTm2r/4ZYtMy61hf16RPJIU9nZ1MABAwAAAAAAAAAZpwgEwIAAABhp658BScAAAAAAADnUFBQXIDGXLhwtttNHDhw5OcpQRMETBEwRPduylKVB0HRdF0A";
              else {
                if (!Modernizr.video.h264) return void l("videoautoplay", !1);
                i.src =
                  "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAs1tZGF0AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMjYwMSBhMGNkN2QzIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNSAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEwIHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAD2WIhAA3//728P4FNjuZQQAAAu5tb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAAZAABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACGHRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAgAAAAIAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAGQAAAAAAAEAAAAAAZBtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAACgAAAAEAFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAE7bWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAA+3N0YmwAAACXc3RzZAAAAAAAAAABAAAAh2F2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAgACAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAxYXZjQwFkAAr/4QAYZ2QACqzZX4iIhAAAAwAEAAADAFA8SJZYAQAGaOvjyyLAAAAAGHN0dHMAAAAAAAAAAQAAAAEAAAQAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAABRzdHN6AAAAAAAAAsUAAAABAAAAFHN0Y28AAAAAAAAAAQAAADAAAABidWR0YQAAAFptZXRhAAAAAAAAACFoZGxyAAAAAAAAAABtZGlyYXBwbAAAAAAAAAAAAAAAAC1pbHN0AAAAJal0b28AAAAdZGF0YQAAAAEAAAAATGF2ZjU2LjQwLjEwMQ==";
              }
            } catch (s) {
              return void l("videoautoplay", !1);
            }
            i.setAttribute("autoplay", ""),
              (i.style.cssText = "display:none"),
              v.appendChild(i),
              setTimeout(function () {
                i.addEventListener("playing", A, !1), (e = setTimeout(A, t));
              }, 0);
          });
        var C = (B.testStyles = s);
        Modernizr.addTest("touchevents", function () {
          var t;
          if (
            "ontouchstart" in A ||
            (A.DocumentTouch && e instanceof DocumentTouch)
          )
            t = !0;
          else {
            var n = [
              "@media (",
              F.join("touch-enabled),("),
              "heartz",
              ")",
              "{#modernizr{top:9px;position:absolute}}",
            ].join("");
            C(n, function (A) {
              t = 9 === A.offsetTop;
            });
          }
          return t;
        });
        var Q = "Moz O ms Webkit",
          Z = B._config.usePrefixes ? Q.split(" ") : [];
        B._cssomPrefixes = Z;
        var Y = B._config.usePrefixes ? Q.toLowerCase().split(" ") : [];
        B._domPrefixes = Y;
        var x = { elem: r("modernizr") };
        Modernizr._q.push(function () {
          delete x.elem;
        });
        var V = { style: x.elem.style };
        Modernizr._q.unshift(function () {
          delete V.style;
        }),
          (B.testAllProps = g),
          (B.testAllProps = R),
          Modernizr.addTest("cssanimations", R("animationName", "a", !0)),
          o(),
          i(E),
          delete B.addTest,
          delete B.addAsyncTest;
        for (var M = 0; M < Modernizr._q.length; M++) {
          Modernizr._q[M]();
        }
        A.Modernizr = Modernizr;
      })(window, document);

      /***/
    },

    /***/ 11: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value === "undefined" ? "undefined" : _typeof(value);
        return value != null && (type == "object" || type == "function");
      }

      module.exports = isObject;

      /***/
    },

    /***/ 110: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      function _asyncToGenerator(fn) {
        return function () {
          var gen = fn.apply(this, arguments);
          return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(
                  function (value) {
                    step("next", value);
                  },
                  function (err) {
                    step("throw", err);
                  }
                );
              }
            }
            return step("next");
          });
        };
      }

      var $ = __webpack_require__(82);

      var _document = document,
        body = _document.body;

      var modal = body
        .querySelector("#privacy-full")
        .content.querySelector(".privacy-modal");
      var links = body.querySelectorAll(".privacy-link");
      var privacyHash = "#privacy";

      function closeBtnClickHandler(evt) {
        var parentNode = evt.target.parentNode;

        body.style.overflow = "unset";

        $(".privacy-modal").fadeOut(300);
        setTimeout(function () {
          return parentNode.remove();
        }, 300);
        history.back();
      }

      function openPopup() {
        var _this = this;

        body.style.overflow = "hidden";

        _asyncToGenerator(
          /*#__PURE__*/ regeneratorRuntime.mark(function _callee() {
            var closeBtn;
            return regeneratorRuntime.wrap(
              function _callee$(_context) {
                while (1) {
                  switch ((_context.prev = _context.next)) {
                    case 0:
                      _context.next = 2;
                      return body.append(modal);

                    case 2:
                      $(".privacy-modal").fadeIn(300);
                      history.pushState(null, null, privacyHash);

                      closeBtn = body.querySelector(".privacy-modal_close-btn");

                      closeBtn.addEventListener("click", closeBtnClickHandler);

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              },
              _callee,
              _this
            );
          })
        )();
      }

      function linkClickHandler(evt) {
        evt.preventDefault();

        openPopup();
      }

      (function privacyHashCkecker() {
        var hash = window.location.hash;

        var isPrivacy = hash === privacyHash;

        if (isPrivacy) {
          openPopup();
        }
      })();

      for (var i = 0; i < links.length; i++) {
        links[i].addEventListener("click", linkClickHandler);
      }

      exports.linkClickHandler = linkClickHandler;

      /***/
    },

    /***/ 111: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var modal = document.querySelector(".cookie-msg");
      var closeBtn = modal.querySelector(".cookie-msg__close-btn");
      var modalHiddenClassname = "cookie-msg--hidden";

      function closeBtnClickHandler(evt) {
        evt.preventDefault();

        modal.classList.add(modalHiddenClassname);
        window.localStorage.setItem("isCookieAccept", true);
      }

      window.onload = function () {
        var isCookieAccept = window.localStorage.isCookieAccept;

        !isCookieAccept &&
          setTimeout(function () {
            return modal.classList.remove(modalHiddenClassname);
          }, 5000);
      };

      closeBtn.addEventListener("click", closeBtnClickHandler);

      /***/
    },

    /***/ 113: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var googleAnalytics = __webpack_require__(3);

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: function init() {
          initCopyright();

          var link = document.querySelector(".l-footer .l-mail-link");

          link.addEventListener("click", function () {
            googleAnalytics.sendEvent({
              eventCategory: "request",
              eventAction: "email",
              eventLabel: "footer",
            });
          });
        },
      };

      function initCopyright() {
        var currentYear = new Date().getFullYear();
        var copyrightElement = document.querySelector(".c-copyright span");
        copyrightElement.innerText =
          "\xA9 1999-" + currentYear + " BEAUTIFIER CORPORATE LIMITED";
      }

      /***/
    },

    /***/ 114: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * @public
       */

      var timer;
      var isDisabled = false;

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: function init() {
          window.addEventListener("scroll", onScroll, false);
        },
      };

      /**
       * @public
       */
      function onScroll() {
        timer && clearTimeout(timer);

        !isDisabled && toggleMouseEvent(true);

        timer = setTimeout(function () {
          toggleMouseEvent(false);
        }, 300);
      }

      /**
       * @private
       */
      function toggleMouseEvent(state) {
        isDisabled = state;
        document.body.classList.toggle("disable-pointer-events", state);
      }

      /***/
    },

    /***/ 12: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // shim for using process in browser
      var process = (module.exports = {});

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function () {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if (
          (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
          setTimeout
        ) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if (
          (cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &&
          clearTimeout
        ) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ""; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error("process.binding is not supported");
      };

      process.cwd = function () {
        return "/";
      };
      process.chdir = function (dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function () {
        return 0;
      };

      /***/
    },

    /***/ 121: /***/ function (module, exports) {
      // removed by extract-text-webpack-plugin
      /***/
    },

    /***/ 122: /***/ function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */ (function (module) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*** IMPORTS FROM imports-loader ***/
        var global = window;

        ("use strict");

        var _typeof =
          typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
            ? function (obj) {
                return typeof obj;
              }
            : function (obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };

        (function webpackUniversalModuleDefinition(root, factory) {
          if (
            (false ? "undefined" : _typeof(exports)) === "object" &&
            (false ? "undefined" : _typeof(module)) === "object"
          )
            module.exports = factory();
          else if (true)
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          else {
            var a = factory();
            for (var i in a) {
              ((typeof exports === "undefined"
                ? "undefined"
                : _typeof(exports)) === "object"
                ? exports
                : root)[i] = a[i];
            }
          }
        })(typeof self !== "undefined" ? self : undefined, function () {
          return /******/ (function (modules) {
            // webpackBootstrap
            /******/ // The module cache
            /******/ var installedModules = {};
            /******/
            /******/ // The require function
            /******/ function __webpack_require__(moduleId) {
              /******/
              /******/ // Check if module is in cache
              /******/ if (installedModules[moduleId]) {
                /******/ return installedModules[moduleId].exports;
                /******/
              }
              /******/ // Create a new module (and put it into the cache)
              /******/ var module = (installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: false,
                /******/ exports: {},
                /******/
              });
              /******/
              /******/ // Execute the module function
              /******/ modules[moduleId].call(
                module.exports,
                module,
                module.exports,
                __webpack_require__
              );
              /******/
              /******/ // Flag the module as loaded
              /******/ module.l = true;
              /******/
              /******/ // Return the exports of the module
              /******/ return module.exports;
              /******/
            }
            /******/
            /******/
            /******/ // expose the modules object (__webpack_modules__)
            /******/ __webpack_require__.m = modules;
            /******/
            /******/ // expose the module cache
            /******/ __webpack_require__.c = installedModules;
            /******/
            /******/ // define getter function for harmony exports
            /******/ __webpack_require__.d = function (exports, name, getter) {
              /******/ if (!__webpack_require__.o(exports, name)) {
                /******/ Object.defineProperty(exports, name, {
                  /******/ configurable: false,
                  /******/ enumerable: true,
                  /******/ get: getter,
                  /******/
                });
                /******/
              }
              /******/
            };
            /******/
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __webpack_require__.n = function (module) {
              /******/ var getter =
                module && module.__esModule
                  ? /******/ function getDefault() {
                      return module["default"];
                    }
                  : /******/ function getModuleExports() {
                      return module;
                    };
              /******/ __webpack_require__.d(getter, "a", getter);
              /******/ return getter;
              /******/
            };
            /******/
            /******/ // Object.prototype.hasOwnProperty.call
            /******/ __webpack_require__.o = function (object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            /******/
            /******/ // __webpack_public_path__
            /******/ __webpack_require__.p = "";
            /******/
            /******/ // Load entry module and return exports
            /******/ return __webpack_require__((__webpack_require__.s = 7));
            /******/
          })(
            /************************************************************************/
            /******/ [
              /* 0 */
              /***/ function (module, exports, __webpack_require__) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                  value: true,
                });

                var _extends =
                  Object.assign ||
                  function (target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                          target[key] = source[key];
                        }
                      }
                    }
                    return target;
                  }; /* globals jQuery */

                exports.lory = lory;

                var _detectPrefixes = __webpack_require__(1);

                var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

                var _detectSupportsPassive = __webpack_require__(2);

                var _detectSupportsPassive2 = _interopRequireDefault(
                  _detectSupportsPassive
                );

                var _dispatchEvent = __webpack_require__(3);

                var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

                var _defaults = __webpack_require__(6);

                var _defaults2 = _interopRequireDefault(_defaults);

                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }

                var slice = Array.prototype.slice;

                function lory(slider, opts) {
                  var position = void 0;
                  var slidesWidth = void 0;
                  var frameWidth = void 0;
                  var slides = void 0;

                  /**
                   * slider DOM elements
                   */
                  var frame = void 0;
                  var slideContainer = void 0;
                  var prevCtrl = void 0;
                  var nextCtrl = void 0;
                  var prefixes = void 0;
                  var transitionEndCallback = void 0;

                  var index = 0;
                  var options = {};
                  var touchEventParams = (0, _detectSupportsPassive2.default)()
                    ? { passive: true }
                    : false;

                  /**
                   * if object is jQuery convert to native DOM element
                   */
                  if (
                    typeof jQuery !== "undefined" &&
                    slider instanceof jQuery
                  ) {
                    slider = slider[0];
                  }

                  /**
                   * private
                   * set active class to element which is the current slide
                   */
                  function setActiveElement(slides, currentIndex) {
                    var _options = options,
                      classNameActiveSlide = _options.classNameActiveSlide;

                    slides.forEach(function (element, index) {
                      if (element.classList.contains(classNameActiveSlide)) {
                        element.classList.remove(classNameActiveSlide);
                      }
                    });

                    slides[currentIndex].classList.add(classNameActiveSlide);
                  }

                  /**
                   * private
                   * setupInfinite: function to setup if infinite is set
                   *
                   * @param  {array} slideArray
                   * @return {array} array of updated slideContainer elements
                   */
                  function setupInfinite(slideArray) {
                    var _options2 = options,
                      infinite = _options2.infinite;

                    var front = slideArray.slice(0, infinite);
                    var back = slideArray.slice(
                      slideArray.length - infinite,
                      slideArray.length
                    );

                    front.forEach(function (element) {
                      var cloned = element.cloneNode(true);

                      slideContainer.appendChild(cloned);
                    });

                    back.reverse().forEach(function (element) {
                      var cloned = element.cloneNode(true);

                      slideContainer.insertBefore(
                        cloned,
                        slideContainer.firstChild
                      );
                    });

                    slideContainer.addEventListener(
                      prefixes.transitionEnd,
                      onTransitionEnd
                    );

                    return slice.call(slideContainer.children);
                  }

                  /**
                   * [dispatchSliderEvent description]
                   * @return {[type]} [description]
                   */
                  function dispatchSliderEvent(phase, type, detail) {
                    (0, _dispatchEvent2.default)(
                      slider,
                      phase + ".lory." + type,
                      detail
                    );
                  }

                  /**
                   * translates to a given position in a given time in milliseconds
                   *
                   * @to        {number} number in pixels where to translate to
                   * @duration  {number} time in milliseconds for the transistion
                   * @ease      {string} easing css property
                   */
                  function translate(to, duration, ease) {
                    var style = slideContainer && slideContainer.style;

                    if (style) {
                      style[prefixes.transition + "TimingFunction"] = ease;
                      style[prefixes.transition + "Duration"] = duration + "ms";
                      style[prefixes.transform] = "translateX(" + to + "px)";
                    }
                  }

                  /**
                   * returns an element's width
                   */
                  function elementWidth(element) {
                    return (
                      element.getBoundingClientRect().width ||
                      element.offsetWidth
                    );
                  }

                  /**
                   * slidefunction called by prev, next & touchend
                   *
                   * determine nextIndex and slide to next postion
                   * under restrictions of the defined options
                   *
                   * @direction  {boolean}
                   */
                  function slide(nextIndex, direction) {
                    var _options3 = options,
                      slideSpeed = _options3.slideSpeed,
                      slidesToScroll = _options3.slidesToScroll,
                      infinite = _options3.infinite,
                      rewind = _options3.rewind,
                      rewindPrev = _options3.rewindPrev,
                      rewindSpeed = _options3.rewindSpeed,
                      ease = _options3.ease,
                      classNameActiveSlide = _options3.classNameActiveSlide,
                      _options3$classNameDi =
                        _options3.classNameDisabledNextCtrl,
                      classNameDisabledNextCtrl =
                        _options3$classNameDi === undefined
                          ? "disabled"
                          : _options3$classNameDi,
                      _options3$classNameDi2 =
                        _options3.classNameDisabledPrevCtrl,
                      classNameDisabledPrevCtrl =
                        _options3$classNameDi2 === undefined
                          ? "disabled"
                          : _options3$classNameDi2;

                    var duration = slideSpeed;

                    var nextSlide = direction ? index + 1 : index - 1;
                    var maxOffset = Math.round(slidesWidth - frameWidth);

                    dispatchSliderEvent("before", "slide", {
                      index: index,
                      nextSlide: nextSlide,
                    });

                    /**
                     * Reset control classes
                     */
                    if (prevCtrl) {
                      prevCtrl.classList.remove(classNameDisabledPrevCtrl);
                    }
                    if (nextCtrl) {
                      nextCtrl.classList.remove(classNameDisabledNextCtrl);
                    }

                    if (typeof nextIndex !== "number") {
                      if (direction) {
                        if (
                          infinite &&
                          index + infinite * 2 !== slides.length
                        ) {
                          nextIndex = index + (infinite - (index % infinite));
                        } else {
                          nextIndex = index + slidesToScroll;
                        }
                      } else {
                        if (infinite && index % infinite !== 0) {
                          nextIndex = index - (index % infinite);
                        } else {
                          nextIndex = index - slidesToScroll;
                        }
                      }
                    }

                    nextIndex = Math.min(
                      Math.max(nextIndex, 0),
                      slides.length - 1
                    );

                    if (infinite && direction === undefined) {
                      nextIndex += infinite;
                    }

                    if (
                      rewindPrev &&
                      Math.abs(position.x) === 0 &&
                      direction === false
                    ) {
                      nextIndex = slides.length - 1;
                      duration = rewindSpeed;
                    }

                    var nextOffset = Math.min(
                      Math.max(
                        slides[nextIndex].offsetLeft * -1,
                        maxOffset * -1
                      ),
                      0
                    );

                    if (
                      rewind &&
                      Math.abs(position.x) === maxOffset &&
                      direction
                    ) {
                      nextOffset = 0;
                      nextIndex = 0;
                      duration = rewindSpeed;
                    }

                    /**
                     * translate to the nextOffset by a defined duration and ease function
                     */
                    translate(nextOffset, duration, ease);

                    /**
                     * update the position with the next position
                     */
                    position.x = nextOffset;

                    /**
                     * update the index with the nextIndex only if
                     * the offset of the nextIndex is in the range of the maxOffset
                     */
                    if (slides[nextIndex].offsetLeft <= maxOffset) {
                      index = nextIndex;
                    }

                    if (
                      infinite &&
                      (nextIndex === slides.length - infinite ||
                        nextIndex ===
                          slides.length - (slides.length % infinite) ||
                        nextIndex === 0)
                    ) {
                      if (direction) {
                        index = infinite;
                      }

                      if (!direction) {
                        index = slides.length - infinite * 2;
                      }

                      position.x = slides[index].offsetLeft * -1;

                      transitionEndCallback = function transitionEndCallback() {
                        translate(slides[index].offsetLeft * -1, 0, undefined);
                      };
                    }

                    if (classNameActiveSlide) {
                      setActiveElement(slice.call(slides), index);
                    }

                    /**
                     * update classes for next and prev arrows
                     * based on user settings
                     */
                    if (
                      prevCtrl &&
                      !infinite &&
                      !rewindPrev &&
                      nextIndex === 0
                    ) {
                      prevCtrl.classList.add(classNameDisabledPrevCtrl);
                    }

                    if (
                      nextCtrl &&
                      !infinite &&
                      !rewind &&
                      nextIndex + 1 === slides.length
                    ) {
                      nextCtrl.classList.add(classNameDisabledNextCtrl);
                    }

                    dispatchSliderEvent("after", "slide", {
                      currentSlide: index,
                    });
                  }

                  /**
                   * public
                   * setup function
                   */
                  function setup() {
                    dispatchSliderEvent("before", "init");

                    prefixes = (0, _detectPrefixes2.default)();
                    options = _extends({}, _defaults2.default, opts);

                    var _options4 = options,
                      classNameFrame = _options4.classNameFrame,
                      classNameSlideContainer =
                        _options4.classNameSlideContainer,
                      classNamePrevCtrl = _options4.classNamePrevCtrl,
                      classNameNextCtrl = _options4.classNameNextCtrl,
                      _options4$classNameDi =
                        _options4.classNameDisabledNextCtrl,
                      classNameDisabledNextCtrl =
                        _options4$classNameDi === undefined
                          ? "disabled"
                          : _options4$classNameDi,
                      _options4$classNameDi2 =
                        _options4.classNameDisabledPrevCtrl,
                      classNameDisabledPrevCtrl =
                        _options4$classNameDi2 === undefined
                          ? "disabled"
                          : _options4$classNameDi2,
                      enableMouseEvents = _options4.enableMouseEvents,
                      classNameActiveSlide = _options4.classNameActiveSlide,
                      initialIndex = _options4.initialIndex;

                    index = initialIndex;
                    frame = slider.getElementsByClassName(classNameFrame)[0];
                    slideContainer = frame.getElementsByClassName(
                      classNameSlideContainer
                    )[0];
                    prevCtrl =
                      slider.getElementsByClassName(classNamePrevCtrl)[0];
                    nextCtrl =
                      slider.getElementsByClassName(classNameNextCtrl)[0];

                    position = {
                      x: slideContainer.offsetLeft,
                      y: slideContainer.offsetTop,
                    };

                    if (options.infinite) {
                      slides = setupInfinite(
                        slice.call(slideContainer.children)
                      );
                    } else {
                      slides = slice.call(slideContainer.children);

                      if (prevCtrl && !options.rewindPrev) {
                        prevCtrl.classList.add(classNameDisabledPrevCtrl);
                      }

                      if (nextCtrl && slides.length === 1 && !options.rewind) {
                        nextCtrl.classList.add(classNameDisabledNextCtrl);
                      }
                    }

                    reset();

                    if (classNameActiveSlide) {
                      setActiveElement(slides, index);
                    }

                    if (prevCtrl && nextCtrl) {
                      prevCtrl.addEventListener("click", prev);
                      nextCtrl.addEventListener("click", next);
                    }

                    frame.addEventListener(
                      "touchstart",
                      onTouchstart,
                      touchEventParams
                    );

                    if (enableMouseEvents) {
                      frame.addEventListener("mousedown", onTouchstart);
                      frame.addEventListener("click", onClick);
                    }

                    options.window.addEventListener("resize", onResize);

                    dispatchSliderEvent("after", "init");
                  }

                  /**
                   * public
                   * reset function: called on resize
                   */
                  function reset() {
                    var _options5 = options,
                      infinite = _options5.infinite,
                      ease = _options5.ease,
                      rewindSpeed = _options5.rewindSpeed,
                      rewindOnResize = _options5.rewindOnResize,
                      classNameActiveSlide = _options5.classNameActiveSlide,
                      initialIndex = _options5.initialIndex;

                    slidesWidth = elementWidth(slideContainer);
                    frameWidth = elementWidth(frame);

                    if (frameWidth === slidesWidth) {
                      slidesWidth = slides.reduce(function (
                        previousValue,
                        slide
                      ) {
                        return previousValue + elementWidth(slide);
                      },
                      0);
                    }

                    if (rewindOnResize) {
                      index = initialIndex;
                    } else {
                      ease = null;
                      rewindSpeed = 0;
                    }

                    if (infinite) {
                      translate(
                        slides[index + infinite].offsetLeft * -1,
                        0,
                        null
                      );

                      index = index + infinite;
                      position.x = slides[index].offsetLeft * -1;
                    } else {
                      translate(
                        slides[index].offsetLeft * -1,
                        rewindSpeed,
                        ease
                      );
                      position.x = slides[index].offsetLeft * -1;
                    }

                    if (classNameActiveSlide) {
                      setActiveElement(slice.call(slides), index);
                    }
                  }

                  /**
                   * public
                   * slideTo: called on clickhandler
                   */
                  function slideTo(index) {
                    slide(index);
                  }

                  /**
                   * public
                   * returnIndex function: called on clickhandler
                   */
                  function returnIndex() {
                    return index - options.infinite || 0;
                  }

                  /**
                   * public
                   * prev function: called on clickhandler
                   */
                  function prev() {
                    slide(false, false);
                  }

                  /**
                   * public
                   * next function: called on clickhandler
                   */
                  function next() {
                    slide(false, true);
                  }

                  /**
                   * public
                   * destroy function: called to gracefully destroy the lory instance
                   */
                  function destroy() {
                    dispatchSliderEvent("before", "destroy");

                    // remove event listeners
                    frame.removeEventListener(
                      prefixes.transitionEnd,
                      onTransitionEnd
                    );
                    frame.removeEventListener(
                      "touchstart",
                      onTouchstart,
                      touchEventParams
                    );
                    frame.removeEventListener(
                      "touchmove",
                      onTouchmove,
                      touchEventParams
                    );
                    frame.removeEventListener("touchend", onTouchend);
                    frame.removeEventListener("mousemove", onTouchmove);
                    frame.removeEventListener("mousedown", onTouchstart);
                    frame.removeEventListener("mouseup", onTouchend);
                    frame.removeEventListener("mouseleave", onTouchend);
                    frame.removeEventListener("click", onClick);

                    options.window.removeEventListener("resize", onResize);

                    if (prevCtrl) {
                      prevCtrl.removeEventListener("click", prev);
                    }

                    if (nextCtrl) {
                      nextCtrl.removeEventListener("click", next);
                    }

                    // remove cloned slides if infinite is set
                    if (options.infinite) {
                      Array.apply(null, Array(options.infinite)).forEach(
                        function () {
                          slideContainer.removeChild(slideContainer.firstChild);
                          slideContainer.removeChild(slideContainer.lastChild);
                        }
                      );
                    }

                    dispatchSliderEvent("after", "destroy");
                  }

                  // event handling

                  var touchOffset = void 0;
                  var delta = void 0;
                  var isScrolling = void 0;

                  function onTransitionEnd() {
                    if (transitionEndCallback) {
                      transitionEndCallback();

                      transitionEndCallback = undefined;
                    }
                  }

                  function onTouchstart(event) {
                    var _options6 = options,
                      enableMouseEvents = _options6.enableMouseEvents;

                    var touches = event.touches ? event.touches[0] : event;

                    if (enableMouseEvents) {
                      frame.addEventListener("mousemove", onTouchmove);
                      frame.addEventListener("mouseup", onTouchend);
                      frame.addEventListener("mouseleave", onTouchend);
                    }

                    frame.addEventListener(
                      "touchmove",
                      onTouchmove,
                      touchEventParams
                    );
                    frame.addEventListener("touchend", onTouchend);

                    var pageX = touches.pageX,
                      pageY = touches.pageY;

                    touchOffset = {
                      x: pageX,
                      y: pageY,
                      time: Date.now(),
                    };

                    isScrolling = undefined;

                    delta = {};

                    dispatchSliderEvent("on", "touchstart", {
                      event: event,
                    });
                  }

                  function onTouchmove(event) {
                    var touches = event.touches ? event.touches[0] : event;
                    var pageX = touches.pageX,
                      pageY = touches.pageY;

                    delta = {
                      x: pageX - touchOffset.x,
                      y: pageY - touchOffset.y,
                    };

                    if (typeof isScrolling === "undefined") {
                      isScrolling = !!(
                        isScrolling || Math.abs(delta.x) < Math.abs(delta.y)
                      );
                    }

                    if (!isScrolling && touchOffset) {
                      translate(position.x + delta.x, 0, null);
                    }

                    // may be
                    dispatchSliderEvent("on", "touchmove", {
                      event: event,
                    });
                  }

                  function onTouchend(event) {
                    /**
                     * time between touchstart and touchend in milliseconds
                     * @duration {number}
                     */
                    var duration = touchOffset
                      ? Date.now() - touchOffset.time
                      : undefined;

                    /**
                     * is valid if:
                     *
                     * -> swipe attempt time is over 300 ms
                     * and
                     * -> swipe distance is greater than 25px
                     * or
                     * -> swipe distance is more then a third of the swipe area
                     *
                     * @isValidSlide {Boolean}
                     */
                    var isValid =
                      (Number(duration) < 300 && Math.abs(delta.x) > 25) ||
                      Math.abs(delta.x) > frameWidth / 3;

                    /**
                     * is out of bounds if:
                     *
                     * -> index is 0 and delta x is greater than 0
                     * or
                     * -> index is the last slide and delta is smaller than 0
                     *
                     * @isOutOfBounds {Boolean}
                     */
                    var isOutOfBounds =
                      (!index && delta.x > 0) ||
                      (index === slides.length - 1 && delta.x < 0);

                    var direction = delta.x < 0;

                    if (!isScrolling) {
                      if (isValid && !isOutOfBounds) {
                        slide(false, direction);
                      } else {
                        translate(position.x, options.snapBackSpeed);
                      }
                    }

                    touchOffset = undefined;

                    /**
                     * remove eventlisteners after swipe attempt
                     */
                    frame.removeEventListener("touchmove", onTouchmove);
                    frame.removeEventListener("touchend", onTouchend);
                    frame.removeEventListener("mousemove", onTouchmove);
                    frame.removeEventListener("mouseup", onTouchend);
                    frame.removeEventListener("mouseleave", onTouchend);

                    dispatchSliderEvent("on", "touchend", {
                      event: event,
                    });
                  }

                  function onClick(event) {
                    if (delta.x) {
                      event.preventDefault();
                    }
                  }

                  function onResize(event) {
                    if (frameWidth !== elementWidth(frame)) {
                      reset();

                      dispatchSliderEvent("on", "resize", {
                        event: event,
                      });
                    }
                  }

                  // trigger initial setup
                  setup();

                  // expose public api
                  return {
                    setup: setup,
                    reset: reset,
                    slideTo: slideTo,
                    returnIndex: returnIndex,
                    prev: prev,
                    next: next,
                    destroy: destroy,
                  };
                }

                /***/
              },
              /* 1 */
              /***/ function (module, exports, __webpack_require__) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                  value: true,
                });
                exports.default = detectPrefixes;
                /**
                 * Detecting prefixes for saving time and bytes
                 */
                function detectPrefixes() {
                  var transform = void 0;
                  var transition = void 0;
                  var transitionEnd = void 0;

                  (function () {
                    var el = document.createElement("_");
                    var style = el.style;

                    var prop = void 0;

                    if (style[(prop = "webkitTransition")] === "") {
                      transitionEnd = "webkitTransitionEnd";
                      transition = prop;
                    }

                    if (style[(prop = "transition")] === "") {
                      transitionEnd = "transitionend";
                      transition = prop;
                    }

                    if (style[(prop = "webkitTransform")] === "") {
                      transform = prop;
                    }

                    if (style[(prop = "msTransform")] === "") {
                      transform = prop;
                    }

                    if (style[(prop = "transform")] === "") {
                      transform = prop;
                    }

                    document.body.insertBefore(el, null);
                    style[transform] = "translateX(0)";
                    document.body.removeChild(el);
                  })();

                  return {
                    transform: transform,
                    transition: transition,
                    transitionEnd: transitionEnd,
                  };
                }

                /***/
              },
              /* 2 */
              /***/ function (module, exports, __webpack_require__) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                  value: true,
                });
                exports.default = detectSupportsPassive;
                function detectSupportsPassive() {
                  var supportsPassive = false;

                  try {
                    var opts = Object.defineProperty({}, "passive", {
                      get: function get() {
                        supportsPassive = true;
                      },
                    });

                    window.addEventListener("testPassive", null, opts);
                    window.removeEventListener("testPassive", null, opts);
                  } catch (e) {}

                  return supportsPassive;
                }

                /***/
              },
              /* 3 */
              /***/ function (module, exports, __webpack_require__) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                  value: true,
                });
                exports.default = dispatchEvent;

                var _customEvent = __webpack_require__(4);

                var _customEvent2 = _interopRequireDefault(_customEvent);

                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }

                /**
                 * dispatch custom events
                 *
                 * @param  {element} el         slideshow element
                 * @param  {string}  type       custom event name
                 * @param  {object}  detail     custom detail information
                 */
                function dispatchEvent(target, type, detail) {
                  var event = new _customEvent2.default(type, {
                    bubbles: true,
                    cancelable: true,
                    detail: detail,
                  });

                  target.dispatchEvent(event);
                }

                /***/
              },
              /* 4 */
              /***/ function (module, exports, __webpack_require__) {
                /* WEBPACK VAR INJECTION */ (function (global) {
                  var NativeCustomEvent = global.CustomEvent;

                  function useNative() {
                    try {
                      var p = new NativeCustomEvent("cat", {
                        detail: { foo: "bar" },
                      });
                      return "cat" === p.type && "bar" === p.detail.foo;
                    } catch (e) {}
                    return false;
                  }

                  /**
                   * Cross-browser `CustomEvent` constructor.
                   *
                   * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
                   *
                   * @public
                   */

                  module.exports = useNative()
                    ? NativeCustomEvent
                    : // IE >= 9
                    "undefined" !== typeof document &&
                      "function" === typeof document.createEvent
                    ? function CustomEvent(type, params) {
                        var e = document.createEvent("CustomEvent");
                        if (params) {
                          e.initCustomEvent(
                            type,
                            params.bubbles,
                            params.cancelable,
                            params.detail
                          );
                        } else {
                          e.initCustomEvent(type, false, false, void 0);
                        }
                        return e;
                      }
                    : // IE <= 8
                      function CustomEvent(type, params) {
                        var e = document.createEventObject();
                        e.type = type;
                        if (params) {
                          e.bubbles = Boolean(params.bubbles);
                          e.cancelable = Boolean(params.cancelable);
                          e.detail = params.detail;
                        } else {
                          e.bubbles = false;
                          e.cancelable = false;
                          e.detail = void 0;
                        }
                        return e;
                      };

                  /* WEBPACK VAR INJECTION */
                }).call(exports, __webpack_require__(5));

                /***/
              },
              /* 5 */
              /***/ function (module, exports) {
                var g;

                // This works in non-strict mode
                g = (function () {
                  return this;
                })();

                try {
                  // This works if eval is allowed (see CSP)
                  g = g || Function("return this")() || (1, eval)("this");
                } catch (e) {
                  // This works if the window reference is available
                  if (
                    (typeof window === "undefined"
                      ? "undefined"
                      : _typeof(window)) === "object"
                  )
                    g = window;
                }

                // g can still be undefined, but nothing to do about it...
                // We return undefined, instead of nothing here, so it's
                // easier to handle this case. if(!global) { ...}

                module.exports = g;

                /***/
              },
              /* 6 */
              /***/ function (module, exports, __webpack_require__) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                  value: true,
                });
                exports.default = {
                  /**
                   * slides scrolled at once
                   * @slidesToScroll {Number}
                   */
                  slidesToScroll: 1,

                  /**
                   * time in milliseconds for the animation of a valid slide attempt
                   * @slideSpeed {Number}
                   */
                  slideSpeed: 300,

                  /**
                   * time in milliseconds for the animation of the rewind after the last slide
                   * @rewindSpeed {Number}
                   */
                  rewindSpeed: 600,

                  /**
                   * time for the snapBack of the slider if the slide attempt was not valid
                   * @snapBackSpeed {Number}
                   */
                  snapBackSpeed: 200,

                  /**
                   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
                   * cubic bezier easing functions: http://easings.net/de
                   * @ease {String}
                   */
                  ease: "ease",

                  /**
                   * if slider reached the last slide, with next click the slider goes back to the startindex.
                   * use infinite or rewind, not both
                   * @rewind {Boolean}
                   */
                  rewind: false,

                  /**
                   * number of visible slides or false
                   * use infinite or rewind, not both
                   * @infinite {number}
                   */
                  infinite: false,

                  /**
                   * the slide index to show when the slider is initialized.
                   * @initialIndex {number}
                   */
                  initialIndex: 0,

                  /**
                   * class name for slider frame
                   * @classNameFrame {string}
                   */
                  classNameFrame: "js_frame",

                  /**
                   * class name for slides container
                   * @classNameSlideContainer {string}
                   */
                  classNameSlideContainer: "js_slides",

                  /**
                   * class name for slider prev control
                   * @classNamePrevCtrl {string}
                   */
                  classNamePrevCtrl: "js_prev",

                  /**
                   * class name for slider next control
                   * @classNameNextCtrl {string}
                   */
                  classNameNextCtrl: "js_next",

                  /**
                   * class name for current active slide
                   * if emptyString then no class is set
                   * @classNameActiveSlide {string}
                   */
                  classNameActiveSlide: "active",

                  /**
                   * enables mouse events for swiping on desktop devices
                   * @enableMouseEvents {boolean}
                   */
                  enableMouseEvents: false,

                  /**
                   * window instance
                   * @window {object}
                   */
                  window: typeof window !== "undefined" ? window : null,

                  /**
                   * If false, slides lory to the first slide on window resize.
                   * @rewindOnResize {boolean}
                   */
                  rewindOnResize: true,
                };

                /***/
              },
              /* 7 */
              /***/ function (module, exports, __webpack_require__) {
                module.exports = __webpack_require__(0);

                /***/
              },
            ]
            /******/
          );
        });

        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(112)(module));

      /***/
    },

    /***/ 124: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var LoryAutoplay = function LoryAutoplay() {};

      LoryAutoplay.prototype.init = function (slider, interval) {
        this.slider = slider;
        this.interval = interval;
        this.isPlaying = true;
        this.startAnimating(interval);
      };

      LoryAutoplay.prototype.destroy = function () {
        this.resetTimer.apply(this);
        this.isPlaying = false;
      };

      // begin animation (autoplay)
      LoryAutoplay.prototype.startAnimating = function () {
        this.then = Date.now();
        this.animate.apply(this);
      };

      // animate (autoplay)
      LoryAutoplay.prototype.animate = function () {
        var now = Date.now();
        var self = this;

        window.requestAnimationFrame(this.animate.bind(self));
        this.elapsed = now - this.then;

        if (this.elapsed > this.interval && this.isPlaying) {
          this.then = now - (this.elapsed % this.interval);
          this.slider.next();
        }
      };

      // reset timer
      LoryAutoplay.prototype.resetTimer = function () {
        var now = Date.now();
        this.elapsed = now - this.then;
        this.then = now - (this.elapsed % this.interval);
      };

      module.exports = LoryAutoplay;

      /***/
    },

    /***/ 125: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _VimeoVideo = __webpack_require__(126);

      var _VimeoVideo2 = _interopRequireDefault(_VimeoVideo);

      var _YoutubeVideo = __webpack_require__(127);

      var _YoutubeVideo2 = _interopRequireDefault(_YoutubeVideo);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var videoElement = null;
      var contentElement = null;
      var player = null;
      var scrollTop = 0;

      function handleCloseButtonClick(event) {
        closeVideo();
      }

      function handleLoad(event) {
        closeVideoElement();

        videoElement.classList.remove("case-study-video-opened");
        videoElement.classList.remove("case-study-video-loading");

        window.removeEventListener("load", handleLoad, false);
        window.addEventListener("scroll", handleScroll, false);
      }

      function handleOpenButtonClick(event) {
        scrollTop = document.documentElement.scrollTop;

        scrollToTop();
        openVideo();
      }

      function handleResize(event) {
        if (isMobile()) {
          closeVideoElement();
        } else if (videoElement.classList.contains("case-study-video-opened")) {
          openVideoElement();
        } else {
          closeVideoElement();
        }
      }

      function handleScroll(event) {
        if (isMobile()) {
          return;
        }

        var MIN_SCROLL = 50;

        if (
          document.documentElement.scrollTop - scrollTop > MIN_SCROLL &&
          videoElement.classList.contains("case-study-video-opened")
        ) {
          closeVideo();
          scrollTop = 0;
        }
      }

      function handleTransitionEnd(event) {
        if (
          event.target === contentElement &&
          videoElement.classList.contains("case-study-video-opened")
        ) {
          openVideoIframe();
        }
      }

      function handleVideoEnded() {
        closeVideo();
      }

      function handleVideoReady() {
        contentElement = videoElement.querySelector(
          ".case-study-video-content-foreground"
        );
        contentElement.addEventListener(
          "transitionend",
          handleTransitionEnd,
          false
        );

        var openButtonElement = document.getElementById("play-button");
        openButtonElement.addEventListener(
          "click",
          handleOpenButtonClick,
          false
        );

        var closeButtonElement = document.getElementById("close-button");
        closeButtonElement.addEventListener(
          "click",
          handleCloseButtonClick,
          false
        );
      }

      function closeVideo() {
        closeVideoElement();

        videoElement.querySelector("iframe").classList.remove("opened");
        videoElement.classList.remove("case-study-video-opened");
        player.stop();
      }

      function closeVideoElement() {
        videoElement.style.minHeight = "";
      }

      function isMobile() {
        return window.matchMedia("(max-width: 767px)").matches;
      }

      function isTablet() {
        return window.matchMedia("(min-width: 768px) and (max-width: 1024px)")
          .matches;
      }

      function openVideo() {
        openVideoElement();

        videoElement.classList.add("case-study-video-opened");
        player.play();

        if (isMobile()) {
          openVideoIframe();
        }
      }

      function openVideoIframe() {
        videoElement.querySelector("iframe").classList.add("opened");
      }

      function openVideoElement() {
        if (isMobile()) {
          videoElement.style.minHeight = "";
        } else if (isTablet()) {
          videoElement.style.minHeight = window.innerHeight - 60 + "px";
        } else {
          videoElement.style.minHeight = window.innerHeight - 90 + "px";
        }
      }

      function scrollToTop() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
      }

      function init() {
        videoElement = document.querySelector(".case-study-video");

        if (!videoElement) {
          return;
        }

        var youtubePlayerElement = videoElement.querySelector(
          ".case-study-video__player--youtube"
        );
        var vimeoPlayerElement = videoElement.querySelector(
          ".case-study-video__player--vimeo"
        );

        if (!(youtubePlayerElement || vimeoPlayerElement)) {
          return;
        }

        openVideoElement();

        var props = {
          handleVideoEnded: handleVideoEnded,
          handleVideoReady: handleVideoReady,
        };

        if (youtubePlayerElement) {
          player = new _YoutubeVideo2.default(props);
          player.init(youtubePlayerElement.id);
        } else if (vimeoPlayerElement) {
          player = new _VimeoVideo2.default(props);
          player.init(vimeoPlayerElement.id);
        }

        window.addEventListener("load", handleLoad, false);
        window.addEventListener("resize", handleResize, false);
      }

      module.exports = {
        init: init,
      };

      /***/
    },

    /***/ 126: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var VimeoVideo = (function () {
        function VimeoVideo(props) {
          _classCallCheck(this, VimeoVideo);

          this._props = props || {};
          this._player = null;
          this._videoEnded = false;
        }

        _createClass(VimeoVideo, [
          {
            key: "init",
            value: function init(playerId) {
              var _this = this;

              var iframe = document.getElementById(playerId);
              this._player = new window.Vimeo.Player(iframe);

              this._player.ready().then(function () {
                if (_this._props.handleVideoReady) {
                  _this._props.handleVideoReady();
                }
              });

              this._player.on("pause", function (event) {
                if (event.percent === 1 && !_this._videoEnded) {
                  _this._videoEnded = true;

                  if (_this._props.handleVideoEnded) {
                    _this._props.handleVideoEnded();
                  }
                }
              });
            },
          },
          {
            key: "play",
            value: function play() {
              if (this._player) {
                this._videoEnded = false;
                this._player.play();
              }
            },
          },
          {
            key: "stop",
            value: function stop() {
              if (this._player) {
                this._videoEnded = true;
                this._player.unload();
              }
            },
          },
        ]);

        return VimeoVideo;
      })();

      exports.default = VimeoVideo;

      /***/
    },

    /***/ 127: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var YoutubeVideo = (function () {
        function YoutubeVideo(props) {
          _classCallCheck(this, YoutubeVideo);

          this._onPlayerReady = this._onPlayerReady.bind(this);
          this._onPlayerStateChange = this._onPlayerStateChange.bind(this);

          this._props = props || {};
          this._player = null;
        }

        _createClass(YoutubeVideo, [
          {
            key: "_onPlayerReady",
            value: function _onPlayerReady() {
              this._player.setPlaybackQuality("highres");

              if (this._props.handleVideoReady) {
                this._props.handleVideoReady();
              }
            },
          },
          {
            key: "_onPlayerStateChange",
            value: function _onPlayerStateChange(event) {
              if (event.data === 0) {
                if (this._props.handleVideoEnded) {
                  this._props.handleVideoEnded();
                }
              }
            },
          },
          {
            key: "init",
            value: function init(playerId) {
              var _this = this;

              var tag = document.createElement("script");
              tag.src = "https://www.youtube.com/iframe_api";

              var firstScriptTag = document.getElementsByTagName("script")[0];
              firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

              window.onYouTubeIframeAPIReady = function () {
                _this._player = new YT.Player(playerId, {
                  videoId: playerId.replace("youtube-video-", ""),

                  events: {
                    onReady: _this._onPlayerReady,
                    onStateChange: _this._onPlayerStateChange,
                  },
                });
              };
            },
          },
          {
            key: "play",
            value: function play() {
              if (this._player) {
                this._player.playVideo();
              }
            },
          },
          {
            key: "stop",
            value: function stop() {
              if (this._player) {
                this._player.stopVideo();
              }
            },
          },
        ]);

        return YoutubeVideo;
      })();

      exports.default = YoutubeVideo;

      /***/
    },

    /***/ 128: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _coreClass = __webpack_require__(135);

      Object.defineProperty(exports, "Swiper", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_coreClass).default;
        },
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_coreClass).default;
        },
      });

      var _virtual = __webpack_require__(202);

      Object.defineProperty(exports, "Virtual", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_virtual).default;
        },
      });

      var _keyboard = __webpack_require__(203);

      Object.defineProperty(exports, "Keyboard", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_keyboard).default;
        },
      });

      var _mousewheel = __webpack_require__(204);

      Object.defineProperty(exports, "Mousewheel", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mousewheel).default;
        },
      });

      var _navigation = __webpack_require__(205);

      Object.defineProperty(exports, "Navigation", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_navigation).default;
        },
      });

      var _pagination = __webpack_require__(206);

      Object.defineProperty(exports, "Pagination", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_pagination).default;
        },
      });

      var _scrollbar = __webpack_require__(207);

      Object.defineProperty(exports, "Scrollbar", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_scrollbar).default;
        },
      });

      var _parallax = __webpack_require__(208);

      Object.defineProperty(exports, "Parallax", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_parallax).default;
        },
      });

      var _zoom = __webpack_require__(209);

      Object.defineProperty(exports, "Zoom", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_zoom).default;
        },
      });

      var _lazy = __webpack_require__(210);

      Object.defineProperty(exports, "Lazy", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_lazy).default;
        },
      });

      var _controller = __webpack_require__(211);

      Object.defineProperty(exports, "Controller", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_controller).default;
        },
      });

      var _a11y = __webpack_require__(212);

      Object.defineProperty(exports, "A11y", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_a11y).default;
        },
      });

      var _history = __webpack_require__(213);

      Object.defineProperty(exports, "History", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_history).default;
        },
      });

      var _hashNavigation = __webpack_require__(214);

      Object.defineProperty(exports, "HashNavigation", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_hashNavigation).default;
        },
      });

      var _autoplay = __webpack_require__(215);

      Object.defineProperty(exports, "Autoplay", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_autoplay).default;
        },
      });

      var _effectFade = __webpack_require__(216);

      Object.defineProperty(exports, "EffectFade", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_effectFade).default;
        },
      });

      var _effectCube = __webpack_require__(217);

      Object.defineProperty(exports, "EffectCube", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_effectCube).default;
        },
      });

      var _effectFlip = __webpack_require__(218);

      Object.defineProperty(exports, "EffectFlip", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_effectFlip).default;
        },
      });

      var _effectCoverflow = __webpack_require__(219);

      Object.defineProperty(exports, "EffectCoverflow", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_effectCoverflow).default;
        },
      });

      var _thumbs = __webpack_require__(220);

      Object.defineProperty(exports, "Thumbs", {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_thumbs).default;
        },
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },

    /***/ 130: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.getSupport = undefined;

      var _ssrWindow = __webpack_require__(5);

      var support;

      function calcSupport() {
        var window = (0, _ssrWindow.getWindow)();
        var document = (0, _ssrWindow.getDocument)();
        return {
          touch: !!(
            "ontouchstart" in window ||
            (window.DocumentTouch && document instanceof window.DocumentTouch)
          ),
          pointerEvents:
            !!window.PointerEvent &&
            "maxTouchPoints" in window.navigator &&
            window.navigator.maxTouchPoints >= 0,
          observer: (function checkObserver() {
            return (
              "MutationObserver" in window || "WebkitMutationObserver" in window
            );
          })(),
          passiveListener: (function checkPassiveListener() {
            var supportsPassive = false;

            try {
              var opts = Object.defineProperty({}, "passive", {
                // eslint-disable-next-line
                get: function get() {
                  supportsPassive = true;
                },
              });
              window.addEventListener("testPassiveListener", null, opts);
            } catch (e) {
              // No support
            }

            return supportsPassive;
          })(),
          gestures: (function checkGestures() {
            return "ongesturestart" in window;
          })(),
        };
      }

      function getSupport() {
        if (!support) {
          support = calcSupport();
        }

        return support;
      }

      exports.getSupport = getSupport;

      /***/
    },

    /***/ 133: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var _importsLoaderGlobalWindowLory = __webpack_require__(122);

      var toggleMouseEvent = __webpack_require__(114);
      var footer = __webpack_require__(113);
      var player, playBtn;
      var common = __webpack_require__(83);

      var LoryAutoplay = __webpack_require__(124);
      var caseStudyVideo = __webpack_require__(125);

      common.init();
      toggleMouseEvent.init();
      footer.init();
      caseStudyVideo.init();

      var slider = document.querySelector(".js_slider");

      if (slider) {
        var lorySlider = (0, _importsLoaderGlobalWindowLory.lory)(slider, {
          infinite: 1,
          enableMouseEvents: true,
        });

        var autoplay = new LoryAutoplay();
        var startAutoplay = autoplay.init.bind(autoplay, lorySlider, 3000);
        startAutoplay();

        slider.addEventListener("mouseout", function () {
          startAutoplay();
        });

        slider.addEventListener("mouseover", function () {
          autoplay.destroy();
        });
      }

      /***/
    },

    /***/ 134: /***/ function (module, exports) {
      /* WEBPACK VAR INJECTION */ (function (__webpack_amd_options__) {
        /* globals __webpack_amd_options__ */
        module.exports = __webpack_amd_options__;

        /* WEBPACK VAR INJECTION */
      }).call(exports, {});

      /***/
    },

    /***/ 135: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      var _getSupport = __webpack_require__(130);

      var _getDevice = __webpack_require__(137);

      var _getBrowser = __webpack_require__(138);

      var _resize = __webpack_require__(139);

      var _resize2 = _interopRequireDefault(_resize);

      var _observer = __webpack_require__(140);

      var _observer2 = _interopRequireDefault(_observer);

      var _modular = __webpack_require__(141);

      var _modular2 = _interopRequireDefault(_modular);

      var _eventsEmitter = __webpack_require__(142);

      var _eventsEmitter2 = _interopRequireDefault(_eventsEmitter);

      var _index = __webpack_require__(143);

      var _index2 = _interopRequireDefault(_index);

      var _index3 = __webpack_require__(153);

      var _index4 = _interopRequireDefault(_index3);

      var _index5 = __webpack_require__(159);

      var _index6 = _interopRequireDefault(_index5);

      var _index7 = __webpack_require__(163);

      var _index8 = _interopRequireDefault(_index7);

      var _index9 = __webpack_require__(171);

      var _index10 = _interopRequireDefault(_index9);

      var _index11 = __webpack_require__(175);

      var _index12 = _interopRequireDefault(_index11);

      var _index13 = __webpack_require__(178);

      var _index14 = _interopRequireDefault(_index13);

      var _index15 = __webpack_require__(184);

      var _index16 = _interopRequireDefault(_index15);

      var _index17 = __webpack_require__(191);

      var _index18 = _interopRequireDefault(_index17);

      var _index19 = __webpack_require__(194);

      var _index20 = _interopRequireDefault(_index19);

      var _index21 = __webpack_require__(197);

      var _index22 = _interopRequireDefault(_index21);

      var _index23 = __webpack_require__(200);

      var _index24 = _interopRequireDefault(_index23);

      var _defaults = __webpack_require__(201);

      var _defaults2 = _interopRequireDefault(_defaults);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      /* eslint no-param-reassign: "off" */

      var prototypes = {
        modular: _modular2.default,
        eventsEmitter: _eventsEmitter2.default,
        update: _index2.default,
        translate: _index4.default,
        transition: _index6.default,
        slide: _index8.default,
        loop: _index10.default,
        grabCursor: _index12.default,
        manipulation: _index14.default,
        events: _index16.default,
        breakpoints: _index18.default,
        checkOverflow: _index24.default,
        classes: _index20.default,
        images: _index22.default,
      };
      var extendedDefaults = {};

      var Swiper = /*#__PURE__*/ (function () {
        function Swiper() {
          var el;
          var params;

          for (
            var _len = arguments.length, args = new Array(_len), _key = 0;
            _key < _len;
            _key++
          ) {
            args[_key] = arguments[_key];
          }

          if (
            args.length === 1 &&
            args[0].constructor &&
            Object.prototype.toString.call(args[0]).slice(8, -1) === "Object"
          ) {
            params = args[0];
          } else {
            el = args[0];
            params = args[1];
          }

          if (!params) params = {};
          params = (0, _utils.extend)({}, params);
          if (el && !params.el) params.el = el;

          if (params.el && (0, _dom2.default)(params.el).length > 1) {
            var swipers = [];
            (0, _dom2.default)(params.el).each(function (containerEl) {
              var newParams = (0, _utils.extend)({}, params, {
                el: containerEl,
              });
              swipers.push(new Swiper(newParams));
            });
            return swipers;
          } // Swiper Instance

          var swiper = this;
          swiper.__swiper__ = true;
          swiper.support = (0, _getSupport.getSupport)();
          swiper.device = (0, _getDevice.getDevice)({
            userAgent: params.userAgent,
          });
          swiper.browser = (0, _getBrowser.getBrowser)();
          swiper.eventsListeners = {};
          swiper.eventsAnyListeners = [];

          if (typeof swiper.modules === "undefined") {
            swiper.modules = {};
          }

          Object.keys(swiper.modules).forEach(function (moduleName) {
            var module = swiper.modules[moduleName];

            if (module.params) {
              var moduleParamName = Object.keys(module.params)[0];
              var moduleParams = module.params[moduleParamName];
              if (
                (typeof moduleParams === "undefined"
                  ? "undefined"
                  : _typeof(moduleParams)) !== "object" ||
                moduleParams === null
              )
                return;

              if (
                ["navigation", "pagination", "scrollbar"].indexOf(
                  moduleParamName
                ) >= 0 &&
                params[moduleParamName] === true
              ) {
                params[moduleParamName] = {
                  auto: true,
                };
              }

              if (!(moduleParamName in params && "enabled" in moduleParams))
                return;

              if (params[moduleParamName] === true) {
                params[moduleParamName] = {
                  enabled: true,
                };
              }

              if (
                _typeof(params[moduleParamName]) === "object" &&
                !("enabled" in params[moduleParamName])
              ) {
                params[moduleParamName].enabled = true;
              }

              if (!params[moduleParamName])
                params[moduleParamName] = {
                  enabled: false,
                };
            }
          }); // Extend defaults with modules params

          var swiperParams = (0, _utils.extend)({}, _defaults2.default);
          swiper.useParams(swiperParams); // Extend defaults with passed params

          swiper.params = (0, _utils.extend)(
            {},
            swiperParams,
            extendedDefaults,
            params
          );
          swiper.originalParams = (0, _utils.extend)({}, swiper.params);
          swiper.passedParams = (0, _utils.extend)({}, params); // add event listeners

          if (swiper.params && swiper.params.on) {
            Object.keys(swiper.params.on).forEach(function (eventName) {
              swiper.on(eventName, swiper.params.on[eventName]);
            });
          }

          if (swiper.params && swiper.params.onAny) {
            swiper.onAny(swiper.params.onAny);
          } // Save Dom lib

          swiper.$ = _dom2.default; // Extend Swiper

          (0, _utils.extend)(swiper, {
            enabled: swiper.params.enabled,
            el: el,
            // Classes
            classNames: [],
            // Slides
            slides: (0, _dom2.default)(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            // isDirection
            isHorizontal: function isHorizontal() {
              return swiper.params.direction === "horizontal";
            },
            isVertical: function isVertical() {
              return swiper.params.direction === "vertical";
            },
            // Indexes
            activeIndex: 0,
            realIndex: 0,
            //
            isBeginning: true,
            isEnd: false,
            // Props
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            // Locks
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            // Touch Events
            touchEvents: (function touchEvents() {
              var touch = [
                "touchstart",
                "touchmove",
                "touchend",
                "touchcancel",
              ];
              var desktop = ["mousedown", "mousemove", "mouseup"];

              if (swiper.support.pointerEvents) {
                desktop = ["pointerdown", "pointermove", "pointerup"];
              }

              swiper.touchEventsTouch = {
                start: touch[0],
                move: touch[1],
                end: touch[2],
                cancel: touch[3],
              };
              swiper.touchEventsDesktop = {
                start: desktop[0],
                move: desktop[1],
                end: desktop[2],
              };
              return swiper.support.touch || !swiper.params.simulateTouch
                ? swiper.touchEventsTouch
                : swiper.touchEventsDesktop;
            })(),
            touchEventsData: {
              isTouched: undefined,
              isMoved: undefined,
              allowTouchCallbacks: undefined,
              touchStartTime: undefined,
              isScrolling: undefined,
              currentTranslate: undefined,
              startTranslate: undefined,
              allowThresholdMove: undefined,
              // Form elements to match
              focusableElements: swiper.params.focusableElements,
              // Last click time
              lastClickTime: (0, _utils.now)(),
              clickTimeout: undefined,
              // Velocities
              velocities: [],
              allowMomentumBounce: undefined,
              isTouchEvent: undefined,
              startMoving: undefined,
            },
            // Clicks
            allowClick: true,
            // Touches
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0,
            },
            // Images
            imagesToLoad: [],
            imagesLoaded: 0,
          }); // Install Modules

          swiper.useModules();
          swiper.emit("_swiper"); // Init

          if (swiper.params.init) {
            swiper.init();
          } // Return app instance

          return swiper;
        }

        var _proto = Swiper.prototype;

        _proto.enable = function enable() {
          var swiper = this;
          if (swiper.enabled) return;
          swiper.enabled = true;

          if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
          }

          swiper.emit("enable");
        };

        _proto.disable = function disable() {
          var swiper = this;
          if (!swiper.enabled) return;
          swiper.enabled = false;

          if (swiper.params.grabCursor) {
            swiper.unsetGrabCursor();
          }

          swiper.emit("disable");
        };

        _proto.setProgress = function setProgress(progress, speed) {
          var swiper = this;
          progress = Math.min(Math.max(progress, 0), 1);
          var min = swiper.minTranslate();
          var max = swiper.maxTranslate();
          var current = (max - min) * progress + min;
          swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        };

        _proto.emitContainerClasses = function emitContainerClasses() {
          var swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          var classes = swiper.el.className
            .split(" ")
            .filter(function (className) {
              return (
                className.indexOf("swiper-container") === 0 ||
                className.indexOf(swiper.params.containerModifierClass) === 0
              );
            });
          swiper.emit("_containerClasses", classes.join(" "));
        };

        _proto.getSlideClasses = function getSlideClasses(slideEl) {
          var swiper = this;
          return slideEl.className
            .split(" ")
            .filter(function (className) {
              return (
                className.indexOf("swiper-slide") === 0 ||
                className.indexOf(swiper.params.slideClass) === 0
              );
            })
            .join(" ");
        };

        _proto.emitSlidesClasses = function emitSlidesClasses() {
          var swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          var updates = [];
          swiper.slides.each(function (slideEl) {
            var classNames = swiper.getSlideClasses(slideEl);
            updates.push({
              slideEl: slideEl,
              classNames: classNames,
            });
            swiper.emit("_slideClass", slideEl, classNames);
          });
          swiper.emit("_slideClasses", updates);
        };

        _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
          var swiper = this;
          var params = swiper.params,
            slides = swiper.slides,
            slidesGrid = swiper.slidesGrid,
            swiperSize = swiper.size,
            activeIndex = swiper.activeIndex;
          var spv = 1;

          if (params.centeredSlides) {
            var slideSize = slides[activeIndex].swiperSlideSize;
            var breakLoop;

            for (var i = activeIndex + 1; i < slides.length; i += 1) {
              if (slides[i] && !breakLoop) {
                slideSize += slides[i].swiperSlideSize;
                spv += 1;
                if (slideSize > swiperSize) breakLoop = true;
              }
            }

            for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
              if (slides[_i] && !breakLoop) {
                slideSize += slides[_i].swiperSlideSize;
                spv += 1;
                if (slideSize > swiperSize) breakLoop = true;
              }
            }
          } else {
            for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
              if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
                spv += 1;
              }
            }
          }

          return spv;
        };

        _proto.update = function update() {
          var swiper = this;
          if (!swiper || swiper.destroyed) return;
          var snapGrid = swiper.snapGrid,
            params = swiper.params; // Breakpoints

          if (params.breakpoints) {
            swiper.setBreakpoint();
          }

          swiper.updateSize();
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();

          function setTranslate() {
            var translateValue = swiper.rtlTranslate
              ? swiper.translate * -1
              : swiper.translate;
            var newTranslate = Math.min(
              Math.max(translateValue, swiper.maxTranslate()),
              swiper.minTranslate()
            );
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }

          var translated;

          if (swiper.params.freeMode) {
            setTranslate();

            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          } else {
            if (
              (swiper.params.slidesPerView === "auto" ||
                swiper.params.slidesPerView > 1) &&
              swiper.isEnd &&
              !swiper.params.centeredSlides
            ) {
              translated = swiper.slideTo(
                swiper.slides.length - 1,
                0,
                false,
                true
              );
            } else {
              translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }

            if (!translated) {
              setTranslate();
            }
          }

          if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
          }

          swiper.emit("update");
        };

        _proto.changeDirection = function changeDirection(
          newDirection,
          needUpdate
        ) {
          if (needUpdate === void 0) {
            needUpdate = true;
          }

          var swiper = this;
          var currentDirection = swiper.params.direction;

          if (!newDirection) {
            // eslint-disable-next-line
            newDirection =
              currentDirection === "horizontal" ? "vertical" : "horizontal";
          }

          if (
            newDirection === currentDirection ||
            (newDirection !== "horizontal" && newDirection !== "vertical")
          ) {
            return swiper;
          }

          swiper.$el
            .removeClass(
              "" + swiper.params.containerModifierClass + currentDirection
            )
            .addClass("" + swiper.params.containerModifierClass + newDirection);
          swiper.emitContainerClasses();
          swiper.params.direction = newDirection;
          swiper.slides.each(function (slideEl) {
            if (newDirection === "vertical") {
              slideEl.style.width = "";
            } else {
              slideEl.style.height = "";
            }
          });
          swiper.emit("changeDirection");
          if (needUpdate) swiper.update();
          return swiper;
        };

        _proto.mount = function mount(el) {
          var swiper = this;
          if (swiper.mounted) return true; // Find el

          var $el = (0, _dom2.default)(el || swiper.params.el);
          el = $el[0];

          if (!el) {
            return false;
          }

          el.swiper = swiper;

          var getWrapperSelector = function getWrapperSelector() {
            return (
              "." +
              (swiper.params.wrapperClass || "").trim().split(" ").join(".")
            );
          };

          var getWrapper = function getWrapper() {
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
              var res = (0, _dom2.default)(
                el.shadowRoot.querySelector(getWrapperSelector())
              ); // Children needs to return slot items

              res.children = function (options) {
                return $el.children(options);
              };

              return res;
            }

            return $el.children(getWrapperSelector());
          }; // Find Wrapper

          var $wrapperEl = getWrapper();

          if ($wrapperEl.length === 0 && swiper.params.createElements) {
            var document = (0, _ssrWindow.getDocument)();
            var wrapper = document.createElement("div");
            $wrapperEl = (0, _dom2.default)(wrapper);
            wrapper.className = swiper.params.wrapperClass;
            $el.append(wrapper);
            $el
              .children("." + swiper.params.slideClass)
              .each(function (slideEl) {
                $wrapperEl.append(slideEl);
              });
          }

          (0, _utils.extend)(swiper, {
            $el: $el,
            el: el,
            $wrapperEl: $wrapperEl,
            wrapperEl: $wrapperEl[0],
            mounted: true,
            // RTL
            rtl:
              el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
            rtlTranslate:
              swiper.params.direction === "horizontal" &&
              (el.dir.toLowerCase() === "rtl" ||
                $el.css("direction") === "rtl"),
            wrongRTL: $wrapperEl.css("display") === "-webkit-box",
          });
          return true;
        };

        _proto.init = function init(el) {
          var swiper = this;
          if (swiper.initialized) return swiper;
          var mounted = swiper.mount(el);
          if (mounted === false) return swiper;
          swiper.emit("beforeInit"); // Set breakpoint

          if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
          } // Add Classes

          swiper.addClasses(); // Create loop

          if (swiper.params.loop) {
            swiper.loopCreate();
          } // Update size

          swiper.updateSize(); // Update slides

          swiper.updateSlides();

          if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
          } // Set Grab Cursor

          if (swiper.params.grabCursor && swiper.enabled) {
            swiper.setGrabCursor();
          }

          if (swiper.params.preloadImages) {
            swiper.preloadImages();
          } // Slide To Initial Slide

          if (swiper.params.loop) {
            swiper.slideTo(
              swiper.params.initialSlide + swiper.loopedSlides,
              0,
              swiper.params.runCallbacksOnInit,
              false,
              true
            );
          } else {
            swiper.slideTo(
              swiper.params.initialSlide,
              0,
              swiper.params.runCallbacksOnInit,
              false,
              true
            );
          } // Attach events

          swiper.attachEvents(); // Init Flag

          swiper.initialized = true; // Emit

          swiper.emit("init");
          swiper.emit("afterInit");
          return swiper;
        };

        _proto.destroy = function destroy(deleteInstance, cleanStyles) {
          if (deleteInstance === void 0) {
            deleteInstance = true;
          }

          if (cleanStyles === void 0) {
            cleanStyles = true;
          }

          var swiper = this;
          var params = swiper.params,
            $el = swiper.$el,
            $wrapperEl = swiper.$wrapperEl,
            slides = swiper.slides;

          if (typeof swiper.params === "undefined" || swiper.destroyed) {
            return null;
          }

          swiper.emit("beforeDestroy"); // Init Flag

          swiper.initialized = false; // Detach events

          swiper.detachEvents(); // Destroy loop

          if (params.loop) {
            swiper.loopDestroy();
          } // Cleanup styles

          if (cleanStyles) {
            swiper.removeClasses();
            $el.removeAttr("style");
            $wrapperEl.removeAttr("style");

            if (slides && slides.length) {
              slides
                .removeClass(
                  [
                    params.slideVisibleClass,
                    params.slideActiveClass,
                    params.slideNextClass,
                    params.slidePrevClass,
                  ].join(" ")
                )
                .removeAttr("style")
                .removeAttr("data-swiper-slide-index");
            }
          }

          swiper.emit("destroy"); // Detach emitter events

          Object.keys(swiper.eventsListeners).forEach(function (eventName) {
            swiper.off(eventName);
          });

          if (deleteInstance !== false) {
            swiper.$el[0].swiper = null;
            (0, _utils.deleteProps)(swiper);
          }

          swiper.destroyed = true;
          return null;
        };

        Swiper.extendDefaults = function extendDefaults(newDefaults) {
          (0, _utils.extend)(extendedDefaults, newDefaults);
        };

        Swiper.installModule = function installModule(module) {
          if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
          var name =
            module.name ||
            Object.keys(Swiper.prototype.modules).length +
              "_" +
              (0, _utils.now)();
          Swiper.prototype.modules[name] = module;
        };

        Swiper.use = function use(module) {
          if (Array.isArray(module)) {
            module.forEach(function (m) {
              return Swiper.installModule(m);
            });
            return Swiper;
          }

          Swiper.installModule(module);
          return Swiper;
        };

        _createClass(Swiper, null, [
          {
            key: "extendedDefaults",
            get: function get() {
              return extendedDefaults;
            },
          },
          {
            key: "defaults",
            get: function get() {
              return _defaults2.default;
            },
          },
        ]);

        return Swiper;
      })();

      Object.keys(prototypes).forEach(function (prototypeGroup) {
        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
          Swiper.prototype[protoMethod] =
            prototypes[prototypeGroup][protoMethod];
        });
      });
      Swiper.use([_resize2.default, _observer2.default]);
      exports.default = Swiper;

      /***/
    },

    /***/ 136: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.width =
        exports.value =
        exports.val =
        exports.trigger =
        exports.transitionEnd =
        exports.transition =
        exports.transform =
        exports.touchstart =
        exports.touchmove =
        exports.touchend =
        exports.toggleClass =
        exports.text =
        exports.submit =
        exports.styles =
        exports.stop =
        exports.siblings =
        exports.show =
        exports.scrollTop =
        exports.scrollTo =
        exports.scrollLeft =
        exports.scroll =
        exports.resize =
        exports.removeData =
        exports.removeClass =
        exports.removeAttr =
        exports.remove =
        exports.prop =
        exports.prevAll =
        exports.prev =
        exports.prependTo =
        exports.prepend =
        exports.parents =
        exports.parent =
        exports.outerWidth =
        exports.outerHeight =
        exports.once =
        exports.on =
        exports.offset =
        exports.off =
        exports.nextAll =
        exports.next =
        exports.mouseup =
        exports.mouseover =
        exports.mouseout =
        exports.mousemove =
        exports.mouseleave =
        exports.mouseenter =
        exports.mousedown =
        exports.keyup =
        exports.keypress =
        exports.keydown =
        exports.is =
        exports.insertBefore =
        exports.insertAfter =
        exports.index =
        exports.html =
        exports.hide =
        exports.height =
        exports.hasClass =
        exports.focusout =
        exports.focusin =
        exports.focus =
        exports.find =
        exports.filter =
        exports.eq =
        exports.empty =
        exports.each =
        exports.detach =
        exports.dataset =
        exports.data =
        exports.css =
        exports.closest =
        exports.click =
        exports.children =
        exports.change =
        exports.blur =
        exports.attr =
        exports.appendTo =
        exports.append =
        exports.animationEnd =
        exports.animate =
        exports.addClass =
        exports.add =
        exports.$ =
          undefined;

      var _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
      /**
       * Dom7 3.0.0
       * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
       * https://framework7.io/docs/dom7.html
       *
       * Copyright 2020, Vladimir Kharlampidi
       *
       * Licensed under MIT
       *
       * Released on: November 9, 2020
       */

      var _ssrWindow = __webpack_require__(5);

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };
        return _getPrototypeOf(o);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf =
          Object.setPrototypeOf ||
          function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };

        return _setPrototypeOf(o, p);
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(
            Reflect.construct(Date, [], function () {})
          );
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }

        return _construct.apply(null, arguments);
      }

      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }

      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map() : undefined;

        _wrapNativeSuper = function _wrapNativeSuper(Class) {
          if (Class === null || !_isNativeFunction(Class)) return Class;

          if (typeof Class !== "function") {
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          }

          if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);

            _cache.set(Class, Wrapper);
          }

          function Wrapper() {
            return _construct(
              Class,
              arguments,
              _getPrototypeOf(this).constructor
            );
          }

          Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true,
            },
          });
          return _setPrototypeOf(Wrapper, Class);
        };

        return _wrapNativeSuper(Class);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        }

        return self;
      }

      /* eslint-disable no-proto */
      function makeReactive(obj) {
        var proto = obj.__proto__;
        Object.defineProperty(obj, "__proto__", {
          get: function get() {
            return proto;
          },
          set: function set(value) {
            proto.__proto__ = value;
          },
        });
      }

      var Dom7 = /*#__PURE__*/ (function (_Array) {
        _inheritsLoose(Dom7, _Array);

        function Dom7(items) {
          var _this;

          _this = _Array.call.apply(_Array, [this].concat(items)) || this;
          makeReactive(_assertThisInitialized(_this));
          return _this;
        }

        return Dom7;
      })(/*#__PURE__*/ _wrapNativeSuper(Array));

      function arrayFlat(arr) {
        if (arr === void 0) {
          arr = [];
        }

        var res = [];
        arr.forEach(function (el) {
          if (Array.isArray(el)) {
            res.push.apply(res, arrayFlat(el));
          } else {
            res.push(el);
          }
        });
        return res;
      }
      function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback);
      }
      function arrayUnique(arr) {
        var uniqueArray = [];

        for (var i = 0; i < arr.length; i += 1) {
          if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
        }

        return uniqueArray;
      }
      function toCamelCase(string) {
        return string.toLowerCase().replace(/-(.)/g, function (match, group) {
          return group.toUpperCase();
        });
      }

      function qsa(selector, context) {
        if (typeof selector !== "string") {
          return [selector];
        }

        var a = [];
        var res = context.querySelectorAll(selector);

        for (var i = 0; i < res.length; i += 1) {
          a.push(res[i]);
        }

        return a;
      }

      function $(selector, context) {
        var window = (0, _ssrWindow.getWindow)();
        var document = (0, _ssrWindow.getDocument)();
        var arr = [];

        if (!context && selector instanceof Dom7) {
          return selector;
        }

        if (!selector) {
          return new Dom7(arr);
        }

        if (typeof selector === "string") {
          var html = selector.trim();

          if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
            var toCreate = "div";
            if (html.indexOf("<li") === 0) toCreate = "ul";
            if (html.indexOf("<tr") === 0) toCreate = "tbody";
            if (html.indexOf("<td") === 0 || html.indexOf("<th") === 0)
              toCreate = "tr";
            if (html.indexOf("<tbody") === 0) toCreate = "table";
            if (html.indexOf("<option") === 0) toCreate = "select";
            var tempParent = document.createElement(toCreate);
            tempParent.innerHTML = html;

            for (var i = 0; i < tempParent.childNodes.length; i += 1) {
              arr.push(tempParent.childNodes[i]);
            }
          } else {
            arr = qsa(selector.trim(), context || document);
          } // arr = qsa(selector, document);
        } else if (
          selector.nodeType ||
          selector === window ||
          selector === document
        ) {
          arr.push(selector);
        } else if (Array.isArray(selector)) {
          if (selector instanceof Dom7) return selector;
          arr = selector;
        }

        return new Dom7(arrayUnique(arr));
      }

      $.fn = Dom7.prototype;

      function addClass() {
        for (
          var _len = arguments.length, classes = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          classes[_key] = arguments[_key];
        }

        var classNames = arrayFlat(
          classes.map(function (c) {
            return c.split(" ");
          })
        );
        this.forEach(function (el) {
          var _el$classList;

          (_el$classList = el.classList).add.apply(_el$classList, classNames);
        });
        return this;
      }

      function removeClass() {
        for (
          var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0;
          _key2 < _len2;
          _key2++
        ) {
          classes[_key2] = arguments[_key2];
        }

        var classNames = arrayFlat(
          classes.map(function (c) {
            return c.split(" ");
          })
        );
        this.forEach(function (el) {
          var _el$classList2;

          (_el$classList2 = el.classList).remove.apply(
            _el$classList2,
            classNames
          );
        });
        return this;
      }

      function toggleClass() {
        for (
          var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0;
          _key3 < _len3;
          _key3++
        ) {
          classes[_key3] = arguments[_key3];
        }

        var classNames = arrayFlat(
          classes.map(function (c) {
            return c.split(" ");
          })
        );
        this.forEach(function (el) {
          classNames.forEach(function (className) {
            el.classList.toggle(className);
          });
        });
      }

      function hasClass() {
        for (
          var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0;
          _key4 < _len4;
          _key4++
        ) {
          classes[_key4] = arguments[_key4];
        }

        var classNames = arrayFlat(
          classes.map(function (c) {
            return c.split(" ");
          })
        );
        return (
          arrayFilter(this, function (el) {
            return (
              classNames.filter(function (className) {
                return el.classList.contains(className);
              }).length > 0
            );
          }).length > 0
        );
      }

      function attr(attrs, value) {
        if (arguments.length === 1 && typeof attrs === "string") {
          // Get attr
          if (this[0]) return this[0].getAttribute(attrs);
          return undefined;
        } // Set attrs

        for (var i = 0; i < this.length; i += 1) {
          if (arguments.length === 2) {
            // String
            this[i].setAttribute(attrs, value);
          } else {
            // Object
            for (var attrName in attrs) {
              this[i][attrName] = attrs[attrName];
              this[i].setAttribute(attrName, attrs[attrName]);
            }
          }
        }

        return this;
      }

      function removeAttr(attr) {
        for (var i = 0; i < this.length; i += 1) {
          this[i].removeAttribute(attr);
        }

        return this;
      }

      function prop(props, value) {
        if (arguments.length === 1 && typeof props === "string") {
          // Get prop
          if (this[0]) return this[0][props];
        } else {
          // Set props
          for (var i = 0; i < this.length; i += 1) {
            if (arguments.length === 2) {
              // String
              this[i][props] = value;
            } else {
              // Object
              for (var propName in props) {
                this[i][propName] = props[propName];
              }
            }
          }

          return this;
        }

        return this;
      }

      function data(key, value) {
        var el;

        if (typeof value === "undefined") {
          el = this[0];
          if (!el) return undefined; // Get value

          if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
            return el.dom7ElementDataStorage[key];
          }

          var dataKey = el.getAttribute("data-" + key);

          if (dataKey) {
            return dataKey;
          }

          return undefined;
        } // Set value

        for (var i = 0; i < this.length; i += 1) {
          el = this[i];
          if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
          el.dom7ElementDataStorage[key] = value;
        }

        return this;
      }

      function removeData(key) {
        for (var i = 0; i < this.length; i += 1) {
          var el = this[i];

          if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
            el.dom7ElementDataStorage[key] = null;
            delete el.dom7ElementDataStorage[key];
          }
        }
      }

      function dataset() {
        var el = this[0];
        if (!el) return undefined;
        var dataset = {}; // eslint-disable-line

        if (el.dataset) {
          for (var dataKey in el.dataset) {
            dataset[dataKey] = el.dataset[dataKey];
          }
        } else {
          for (var i = 0; i < el.attributes.length; i += 1) {
            var _attr = el.attributes[i];

            if (_attr.name.indexOf("data-") >= 0) {
              dataset[toCamelCase(_attr.name.split("data-")[1])] = _attr.value;
            }
          }
        }

        for (var key in dataset) {
          if (dataset[key] === "false") dataset[key] = false;
          else if (dataset[key] === "true") dataset[key] = true;
          else if (parseFloat(dataset[key]) === dataset[key] * 1)
            dataset[key] *= 1;
        }

        return dataset;
      }

      function val(value) {
        if (typeof value === "undefined") {
          // get value
          var el = this[0];
          if (!el) return undefined;

          if (el.multiple && el.nodeName.toLowerCase() === "select") {
            var values = [];

            for (var i = 0; i < el.selectedOptions.length; i += 1) {
              values.push(el.selectedOptions[i].value);
            }

            return values;
          }

          return el.value;
        } // set value

        for (var _i = 0; _i < this.length; _i += 1) {
          var _el = this[_i];

          if (
            Array.isArray(value) &&
            _el.multiple &&
            _el.nodeName.toLowerCase() === "select"
          ) {
            for (var j = 0; j < _el.options.length; j += 1) {
              _el.options[j].selected =
                value.indexOf(_el.options[j].value) >= 0;
            }
          } else {
            _el.value = value;
          }
        }

        return this;
      }

      function value(value) {
        return this.val(value);
      }

      function transform(transform) {
        for (var i = 0; i < this.length; i += 1) {
          this[i].style.transform = transform;
        }

        return this;
      }

      function transition(duration) {
        for (var i = 0; i < this.length; i += 1) {
          this[i].style.transitionDuration =
            typeof duration !== "string" ? duration + "ms" : duration;
        }

        return this;
      }

      function on() {
        for (
          var _len5 = arguments.length, args = new Array(_len5), _key5 = 0;
          _key5 < _len5;
          _key5++
        ) {
          args[_key5] = arguments[_key5];
        }

        var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

        if (typeof args[1] === "function") {
          eventType = args[0];
          listener = args[1];
          capture = args[2];
          targetSelector = undefined;
        }

        if (!capture) capture = false;

        function handleLiveEvent(e) {
          var target = e.target;
          if (!target) return;
          var eventData = e.target.dom7EventData || [];

          if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
          }

          if ($(target).is(targetSelector)) listener.apply(target, eventData);
          else {
            var _parents = $(target).parents(); // eslint-disable-line

            for (var k = 0; k < _parents.length; k += 1) {
              if ($(_parents[k]).is(targetSelector))
                listener.apply(_parents[k], eventData);
            }
          }
        }

        function handleEvent(e) {
          var eventData = e && e.target ? e.target.dom7EventData || [] : [];

          if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
          }

          listener.apply(this, eventData);
        }

        var events = eventType.split(" ");
        var j;

        for (var i = 0; i < this.length; i += 1) {
          var el = this[i];

          if (!targetSelector) {
            for (j = 0; j < events.length; j += 1) {
              var event = events[j];
              if (!el.dom7Listeners) el.dom7Listeners = {};
              if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
              el.dom7Listeners[event].push({
                listener: listener,
                proxyListener: handleEvent,
              });
              el.addEventListener(event, handleEvent, capture);
            }
          } else {
            // Live events
            for (j = 0; j < events.length; j += 1) {
              var _event = events[j];
              if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
              if (!el.dom7LiveListeners[_event])
                el.dom7LiveListeners[_event] = [];

              el.dom7LiveListeners[_event].push({
                listener: listener,
                proxyListener: handleLiveEvent,
              });

              el.addEventListener(_event, handleLiveEvent, capture);
            }
          }
        }

        return this;
      }

      function off() {
        for (
          var _len6 = arguments.length, args = new Array(_len6), _key6 = 0;
          _key6 < _len6;
          _key6++
        ) {
          args[_key6] = arguments[_key6];
        }

        var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

        if (typeof args[1] === "function") {
          eventType = args[0];
          listener = args[1];
          capture = args[2];
          targetSelector = undefined;
        }

        if (!capture) capture = false;
        var events = eventType.split(" ");

        for (var i = 0; i < events.length; i += 1) {
          var event = events[i];

          for (var j = 0; j < this.length; j += 1) {
            var el = this[j];
            var handlers = void 0;

            if (!targetSelector && el.dom7Listeners) {
              handlers = el.dom7Listeners[event];
            } else if (targetSelector && el.dom7LiveListeners) {
              handlers = el.dom7LiveListeners[event];
            }

            if (handlers && handlers.length) {
              for (var k = handlers.length - 1; k >= 0; k -= 1) {
                var handler = handlers[k];

                if (listener && handler.listener === listener) {
                  el.removeEventListener(event, handler.proxyListener, capture);
                  handlers.splice(k, 1);
                } else if (
                  listener &&
                  handler.listener &&
                  handler.listener.dom7proxy &&
                  handler.listener.dom7proxy === listener
                ) {
                  el.removeEventListener(event, handler.proxyListener, capture);
                  handlers.splice(k, 1);
                } else if (!listener) {
                  el.removeEventListener(event, handler.proxyListener, capture);
                  handlers.splice(k, 1);
                }
              }
            }
          }
        }

        return this;
      }

      function once() {
        var dom = this;

        for (
          var _len7 = arguments.length, args = new Array(_len7), _key7 = 0;
          _key7 < _len7;
          _key7++
        ) {
          args[_key7] = arguments[_key7];
        }

        var eventName = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

        if (typeof args[1] === "function") {
          eventName = args[0];
          listener = args[1];
          capture = args[2];
          targetSelector = undefined;
        }

        function onceHandler() {
          for (
            var _len8 = arguments.length,
              eventArgs = new Array(_len8),
              _key8 = 0;
            _key8 < _len8;
            _key8++
          ) {
            eventArgs[_key8] = arguments[_key8];
          }

          listener.apply(this, eventArgs);
          dom.off(eventName, targetSelector, onceHandler, capture);

          if (onceHandler.dom7proxy) {
            delete onceHandler.dom7proxy;
          }
        }

        onceHandler.dom7proxy = listener;
        return dom.on(eventName, targetSelector, onceHandler, capture);
      }

      function trigger() {
        var window = (0, _ssrWindow.getWindow)();

        for (
          var _len9 = arguments.length, args = new Array(_len9), _key9 = 0;
          _key9 < _len9;
          _key9++
        ) {
          args[_key9] = arguments[_key9];
        }

        var events = args[0].split(" ");
        var eventData = args[1];

        for (var i = 0; i < events.length; i += 1) {
          var event = events[i];

          for (var j = 0; j < this.length; j += 1) {
            var el = this[j];

            if (window.CustomEvent) {
              var evt = new window.CustomEvent(event, {
                detail: eventData,
                bubbles: true,
                cancelable: true,
              });
              el.dom7EventData = args.filter(function (data, dataIndex) {
                return dataIndex > 0;
              });
              el.dispatchEvent(evt);
              el.dom7EventData = [];
              delete el.dom7EventData;
            }
          }
        }

        return this;
      }

      function transitionEnd(callback) {
        var dom = this;

        function fireCallBack(e) {
          if (e.target !== this) return;
          callback.call(this, e);
          dom.off("transitionend", fireCallBack);
        }

        if (callback) {
          dom.on("transitionend", fireCallBack);
        }

        return this;
      }

      function animationEnd(callback) {
        var dom = this;

        function fireCallBack(e) {
          if (e.target !== this) return;
          callback.call(this, e);
          dom.off("animationend", fireCallBack);
        }

        if (callback) {
          dom.on("animationend", fireCallBack);
        }

        return this;
      }

      function width() {
        var window = (0, _ssrWindow.getWindow)();

        if (this[0] === window) {
          return window.innerWidth;
        }

        if (this.length > 0) {
          return parseFloat(this.css("width"));
        }

        return null;
      }

      function outerWidth(includeMargins) {
        if (this.length > 0) {
          if (includeMargins) {
            var _styles = this.styles();

            return (
              this[0].offsetWidth +
              parseFloat(_styles.getPropertyValue("margin-right")) +
              parseFloat(_styles.getPropertyValue("margin-left"))
            );
          }

          return this[0].offsetWidth;
        }

        return null;
      }

      function height() {
        var window = (0, _ssrWindow.getWindow)();

        if (this[0] === window) {
          return window.innerHeight;
        }

        if (this.length > 0) {
          return parseFloat(this.css("height"));
        }

        return null;
      }

      function outerHeight(includeMargins) {
        if (this.length > 0) {
          if (includeMargins) {
            var _styles2 = this.styles();

            return (
              this[0].offsetHeight +
              parseFloat(_styles2.getPropertyValue("margin-top")) +
              parseFloat(_styles2.getPropertyValue("margin-bottom"))
            );
          }

          return this[0].offsetHeight;
        }

        return null;
      }

      function offset() {
        if (this.length > 0) {
          var window = (0, _ssrWindow.getWindow)();
          var document = (0, _ssrWindow.getDocument)();
          var el = this[0];
          var box = el.getBoundingClientRect();
          var body = document.body;
          var clientTop = el.clientTop || body.clientTop || 0;
          var clientLeft = el.clientLeft || body.clientLeft || 0;
          var scrollTop = el === window ? window.scrollY : el.scrollTop;
          var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
          return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft,
          };
        }

        return null;
      }

      function hide() {
        for (var i = 0; i < this.length; i += 1) {
          this[i].style.display = "none";
        }

        return this;
      }

      function show() {
        var window = (0, _ssrWindow.getWindow)();

        for (var i = 0; i < this.length; i += 1) {
          var el = this[i];

          if (el.style.display === "none") {
            el.style.display = "";
          }

          if (
            window.getComputedStyle(el, null).getPropertyValue("display") ===
            "none"
          ) {
            // Still not visible
            el.style.display = "block";
          }
        }

        return this;
      }

      function styles() {
        var window = (0, _ssrWindow.getWindow)();
        if (this[0]) return window.getComputedStyle(this[0], null);
        return {};
      }

      function css(props, value) {
        var window = (0, _ssrWindow.getWindow)();
        var i;

        if (arguments.length === 1) {
          if (typeof props === "string") {
            // .css('width')
            if (this[0])
              return window
                .getComputedStyle(this[0], null)
                .getPropertyValue(props);
          } else {
            // .css({ width: '100px' })
            for (i = 0; i < this.length; i += 1) {
              for (var _prop in props) {
                this[i].style[_prop] = props[_prop];
              }
            }

            return this;
          }
        }

        if (arguments.length === 2 && typeof props === "string") {
          // .css('width', '100px')
          for (i = 0; i < this.length; i += 1) {
            this[i].style[props] = value;
          }

          return this;
        }

        return this;
      }

      function each(callback) {
        if (!callback) return this;
        this.forEach(function (el, index) {
          callback.apply(el, [el, index]);
        });
        return this;
      }

      function filter(callback) {
        var result = arrayFilter(this, callback);
        return $(result);
      }

      function html(html) {
        if (typeof html === "undefined") {
          return this[0] ? this[0].innerHTML : null;
        }

        for (var i = 0; i < this.length; i += 1) {
          this[i].innerHTML = html;
        }

        return this;
      }

      function text(text) {
        if (typeof text === "undefined") {
          return this[0] ? this[0].textContent.trim() : null;
        }

        for (var i = 0; i < this.length; i += 1) {
          this[i].textContent = text;
        }

        return this;
      }

      function is(selector) {
        var window = (0, _ssrWindow.getWindow)();
        var document = (0, _ssrWindow.getDocument)();
        var el = this[0];
        var compareWith;
        var i;
        if (!el || typeof selector === "undefined") return false;

        if (typeof selector === "string") {
          if (el.matches) return el.matches(selector);
          if (el.webkitMatchesSelector)
            return el.webkitMatchesSelector(selector);
          if (el.msMatchesSelector) return el.msMatchesSelector(selector);
          compareWith = $(selector);

          for (i = 0; i < compareWith.length; i += 1) {
            if (compareWith[i] === el) return true;
          }

          return false;
        }

        if (selector === document) {
          return el === document;
        }

        if (selector === window) {
          return el === window;
        }

        if (selector.nodeType || selector instanceof Dom7) {
          compareWith = selector.nodeType ? [selector] : selector;

          for (i = 0; i < compareWith.length; i += 1) {
            if (compareWith[i] === el) return true;
          }

          return false;
        }

        return false;
      }

      function index() {
        var child = this[0];
        var i;

        if (child) {
          i = 0; // eslint-disable-next-line

          while ((child = child.previousSibling) !== null) {
            if (child.nodeType === 1) i += 1;
          }

          return i;
        }

        return undefined;
      }

      function eq(index) {
        if (typeof index === "undefined") return this;
        var length = this.length;

        if (index > length - 1) {
          return $([]);
        }

        if (index < 0) {
          var returnIndex = length + index;
          if (returnIndex < 0) return $([]);
          return $([this[returnIndex]]);
        }

        return $([this[index]]);
      }

      function append() {
        var newChild;
        var document = (0, _ssrWindow.getDocument)();

        for (var k = 0; k < arguments.length; k += 1) {
          newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

          for (var i = 0; i < this.length; i += 1) {
            if (typeof newChild === "string") {
              var tempDiv = document.createElement("div");
              tempDiv.innerHTML = newChild;

              while (tempDiv.firstChild) {
                this[i].appendChild(tempDiv.firstChild);
              }
            } else if (newChild instanceof Dom7) {
              for (var j = 0; j < newChild.length; j += 1) {
                this[i].appendChild(newChild[j]);
              }
            } else {
              this[i].appendChild(newChild);
            }
          }
        }

        return this;
      }

      function appendTo(parent) {
        $(parent).append(this);
        return this;
      }

      function prepend(newChild) {
        var document = (0, _ssrWindow.getDocument)();
        var i;
        var j;

        for (i = 0; i < this.length; i += 1) {
          if (typeof newChild === "string") {
            var tempDiv = document.createElement("div");
            tempDiv.innerHTML = newChild;

            for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
              this[i].insertBefore(
                tempDiv.childNodes[j],
                this[i].childNodes[0]
              );
            }
          } else if (newChild instanceof Dom7) {
            for (j = 0; j < newChild.length; j += 1) {
              this[i].insertBefore(newChild[j], this[i].childNodes[0]);
            }
          } else {
            this[i].insertBefore(newChild, this[i].childNodes[0]);
          }
        }

        return this;
      }

      function prependTo(parent) {
        $(parent).prepend(this);
        return this;
      }

      function insertBefore(selector) {
        var before = $(selector);

        for (var i = 0; i < this.length; i += 1) {
          if (before.length === 1) {
            before[0].parentNode.insertBefore(this[i], before[0]);
          } else if (before.length > 1) {
            for (var j = 0; j < before.length; j += 1) {
              before[j].parentNode.insertBefore(
                this[i].cloneNode(true),
                before[j]
              );
            }
          }
        }
      }

      function insertAfter(selector) {
        var after = $(selector);

        for (var i = 0; i < this.length; i += 1) {
          if (after.length === 1) {
            after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
          } else if (after.length > 1) {
            for (var j = 0; j < after.length; j += 1) {
              after[j].parentNode.insertBefore(
                this[i].cloneNode(true),
                after[j].nextSibling
              );
            }
          }
        }
      }

      function next(selector) {
        if (this.length > 0) {
          if (selector) {
            if (
              this[0].nextElementSibling &&
              $(this[0].nextElementSibling).is(selector)
            ) {
              return $([this[0].nextElementSibling]);
            }

            return $([]);
          }

          if (this[0].nextElementSibling)
            return $([this[0].nextElementSibling]);
          return $([]);
        }

        return $([]);
      }

      function nextAll(selector) {
        var nextEls = [];
        var el = this[0];
        if (!el) return $([]);

        while (el.nextElementSibling) {
          var _next = el.nextElementSibling; // eslint-disable-line

          if (selector) {
            if ($(_next).is(selector)) nextEls.push(_next);
          } else nextEls.push(_next);

          el = _next;
        }

        return $(nextEls);
      }

      function prev(selector) {
        if (this.length > 0) {
          var el = this[0];

          if (selector) {
            if (
              el.previousElementSibling &&
              $(el.previousElementSibling).is(selector)
            ) {
              return $([el.previousElementSibling]);
            }

            return $([]);
          }

          if (el.previousElementSibling) return $([el.previousElementSibling]);
          return $([]);
        }

        return $([]);
      }

      function prevAll(selector) {
        var prevEls = [];
        var el = this[0];
        if (!el) return $([]);

        while (el.previousElementSibling) {
          var _prev = el.previousElementSibling; // eslint-disable-line

          if (selector) {
            if ($(_prev).is(selector)) prevEls.push(_prev);
          } else prevEls.push(_prev);

          el = _prev;
        }

        return $(prevEls);
      }

      function siblings(selector) {
        return this.nextAll(selector).add(this.prevAll(selector));
      }

      function parent(selector) {
        var parents = []; // eslint-disable-line

        for (var i = 0; i < this.length; i += 1) {
          if (this[i].parentNode !== null) {
            if (selector) {
              if ($(this[i].parentNode).is(selector))
                parents.push(this[i].parentNode);
            } else {
              parents.push(this[i].parentNode);
            }
          }
        }

        return $(parents);
      }

      function parents(selector) {
        var parents = []; // eslint-disable-line

        for (var i = 0; i < this.length; i += 1) {
          var _parent = this[i].parentNode; // eslint-disable-line

          while (_parent) {
            if (selector) {
              if ($(_parent).is(selector)) parents.push(_parent);
            } else {
              parents.push(_parent);
            }

            _parent = _parent.parentNode;
          }
        }

        return $(parents);
      }

      function closest(selector) {
        var closest = this; // eslint-disable-line

        if (typeof selector === "undefined") {
          return $([]);
        }

        if (!closest.is(selector)) {
          closest = closest.parents(selector).eq(0);
        }

        return closest;
      }

      function find(selector) {
        var foundElements = [];

        for (var i = 0; i < this.length; i += 1) {
          var found = this[i].querySelectorAll(selector);

          for (var j = 0; j < found.length; j += 1) {
            foundElements.push(found[j]);
          }
        }

        return $(foundElements);
      }

      function children(selector) {
        var children = []; // eslint-disable-line

        for (var i = 0; i < this.length; i += 1) {
          var childNodes = this[i].children;

          for (var j = 0; j < childNodes.length; j += 1) {
            if (!selector || $(childNodes[j]).is(selector)) {
              children.push(childNodes[j]);
            }
          }
        }

        return $(children);
      }

      function remove() {
        for (var i = 0; i < this.length; i += 1) {
          if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
        }

        return this;
      }

      function detach() {
        return this.remove();
      }

      function add() {
        var dom = this;
        var i;
        var j;

        for (
          var _len10 = arguments.length, els = new Array(_len10), _key10 = 0;
          _key10 < _len10;
          _key10++
        ) {
          els[_key10] = arguments[_key10];
        }

        for (i = 0; i < els.length; i += 1) {
          var toAdd = $(els[i]);

          for (j = 0; j < toAdd.length; j += 1) {
            dom.push(toAdd[j]);
          }
        }

        return dom;
      }

      function empty() {
        for (var i = 0; i < this.length; i += 1) {
          var el = this[i];

          if (el.nodeType === 1) {
            for (var j = 0; j < el.childNodes.length; j += 1) {
              if (el.childNodes[j].parentNode) {
                el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
              }
            }

            el.textContent = "";
          }
        }

        return this;
      }

      function scrollTo() {
        var window = (0, _ssrWindow.getWindow)();

        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }

        var left = args[0],
          top = args[1],
          duration = args[2],
          easing = args[3],
          callback = args[4];

        if (args.length === 4 && typeof easing === "function") {
          callback = easing;
          left = args[0];
          top = args[1];
          duration = args[2];
          callback = args[3];
          easing = args[4];
        }

        if (typeof easing === "undefined") easing = "swing";
        return this.each(function animate() {
          var el = this;
          var currentTop;
          var currentLeft;
          var maxTop;
          var maxLeft;
          var newTop;
          var newLeft;
          var scrollTop; // eslint-disable-line

          var scrollLeft; // eslint-disable-line

          var animateTop = top > 0 || top === 0;
          var animateLeft = left > 0 || left === 0;

          if (typeof easing === "undefined") {
            easing = "swing";
          }

          if (animateTop) {
            currentTop = el.scrollTop;

            if (!duration) {
              el.scrollTop = top;
            }
          }

          if (animateLeft) {
            currentLeft = el.scrollLeft;

            if (!duration) {
              el.scrollLeft = left;
            }
          }

          if (!duration) return;

          if (animateTop) {
            maxTop = el.scrollHeight - el.offsetHeight;
            newTop = Math.max(Math.min(top, maxTop), 0);
          }

          if (animateLeft) {
            maxLeft = el.scrollWidth - el.offsetWidth;
            newLeft = Math.max(Math.min(left, maxLeft), 0);
          }

          var startTime = null;
          if (animateTop && newTop === currentTop) animateTop = false;
          if (animateLeft && newLeft === currentLeft) animateLeft = false;

          function render(time) {
            if (time === void 0) {
              time = new Date().getTime();
            }

            if (startTime === null) {
              startTime = time;
            }

            var progress = Math.max(
              Math.min((time - startTime) / duration, 1),
              0
            );
            var easeProgress =
              easing === "linear"
                ? progress
                : 0.5 - Math.cos(progress * Math.PI) / 2;
            var done;
            if (animateTop)
              scrollTop = currentTop + easeProgress * (newTop - currentTop);
            if (animateLeft)
              scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

            if (animateTop && newTop > currentTop && scrollTop >= newTop) {
              el.scrollTop = newTop;
              done = true;
            }

            if (animateTop && newTop < currentTop && scrollTop <= newTop) {
              el.scrollTop = newTop;
              done = true;
            }

            if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
              el.scrollLeft = newLeft;
              done = true;
            }

            if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
              el.scrollLeft = newLeft;
              done = true;
            }

            if (done) {
              if (callback) callback();
              return;
            }

            if (animateTop) el.scrollTop = scrollTop;
            if (animateLeft) el.scrollLeft = scrollLeft;
            window.requestAnimationFrame(render);
          }

          window.requestAnimationFrame(render);
        });
      } // scrollTop(top, duration, easing, callback) {

      function scrollTop() {
        for (
          var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
          _key2 < _len2;
          _key2++
        ) {
          args[_key2] = arguments[_key2];
        }

        var top = args[0],
          duration = args[1],
          easing = args[2],
          callback = args[3];

        if (args.length === 3 && typeof easing === "function") {
          top = args[0];
          duration = args[1];
          callback = args[2];
          easing = args[3];
        }

        var dom = this;

        if (typeof top === "undefined") {
          if (dom.length > 0) return dom[0].scrollTop;
          return null;
        }

        return dom.scrollTo(undefined, top, duration, easing, callback);
      }

      function scrollLeft() {
        for (
          var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;
          _key3 < _len3;
          _key3++
        ) {
          args[_key3] = arguments[_key3];
        }

        var left = args[0],
          duration = args[1],
          easing = args[2],
          callback = args[3];

        if (args.length === 3 && typeof easing === "function") {
          left = args[0];
          duration = args[1];
          callback = args[2];
          easing = args[3];
        }

        var dom = this;

        if (typeof left === "undefined") {
          if (dom.length > 0) return dom[0].scrollLeft;
          return null;
        }

        return dom.scrollTo(left, undefined, duration, easing, callback);
      }

      function animate(initialProps, initialParams) {
        var window = (0, _ssrWindow.getWindow)();
        var els = this;
        var a = {
          props: _extends({}, initialProps),
          params: _extends(
            {
              duration: 300,
              easing: "swing", // or 'linear'

              /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
            },
            initialParams
          ),
          elements: els,
          animating: false,
          que: [],
          easingProgress: function easingProgress(easing, progress) {
            if (easing === "swing") {
              return 0.5 - Math.cos(progress * Math.PI) / 2;
            }

            if (typeof easing === "function") {
              return easing(progress);
            }

            return progress;
          },
          stop: function stop() {
            if (a.frameId) {
              window.cancelAnimationFrame(a.frameId);
            }

            a.animating = false;
            a.elements.each(function (el) {
              var element = el;
              delete element.dom7AnimateInstance;
            });
            a.que = [];
          },
          done: function done(complete) {
            a.animating = false;
            a.elements.each(function (el) {
              var element = el;
              delete element.dom7AnimateInstance;
            });
            if (complete) complete(els);

            if (a.que.length > 0) {
              var que = a.que.shift();
              a.animate(que[0], que[1]);
            }
          },
          animate: function animate(props, params) {
            if (a.animating) {
              a.que.push([props, params]);
              return a;
            }

            var elements = []; // Define & Cache Initials & Units

            a.elements.each(function (el, index) {
              var initialFullValue;
              var initialValue;
              var unit;
              var finalValue;
              var finalFullValue;
              if (!el.dom7AnimateInstance)
                a.elements[index].dom7AnimateInstance = a;
              elements[index] = {
                container: el,
              };
              Object.keys(props).forEach(function (prop) {
                initialFullValue = window
                  .getComputedStyle(el, null)
                  .getPropertyValue(prop)
                  .replace(",", ".");
                initialValue = parseFloat(initialFullValue);
                unit = initialFullValue.replace(initialValue, "");
                finalValue = parseFloat(props[prop]);
                finalFullValue = props[prop] + unit;
                elements[index][prop] = {
                  initialFullValue: initialFullValue,
                  initialValue: initialValue,
                  unit: unit,
                  finalValue: finalValue,
                  finalFullValue: finalFullValue,
                  currentValue: initialValue,
                };
              });
            });
            var startTime = null;
            var time;
            var elementsDone = 0;
            var propsDone = 0;
            var done;
            var began = false;
            a.animating = true;

            function render() {
              time = new Date().getTime();
              var progress;
              var easeProgress; // let el;

              if (!began) {
                began = true;
                if (params.begin) params.begin(els);
              }

              if (startTime === null) {
                startTime = time;
              }

              if (params.progress) {
                // eslint-disable-next-line
                params.progress(
                  els,
                  Math.max(
                    Math.min((time - startTime) / params.duration, 1),
                    0
                  ),
                  startTime + params.duration - time < 0
                    ? 0
                    : startTime + params.duration - time,
                  startTime
                );
              }

              elements.forEach(function (element) {
                var el = element;
                if (done || el.done) return;
                Object.keys(props).forEach(function (prop) {
                  if (done || el.done) return;
                  progress = Math.max(
                    Math.min((time - startTime) / params.duration, 1),
                    0
                  );
                  easeProgress = a.easingProgress(params.easing, progress);
                  var _el$prop = el[prop],
                    initialValue = _el$prop.initialValue,
                    finalValue = _el$prop.finalValue,
                    unit = _el$prop.unit;
                  el[prop].currentValue =
                    initialValue + easeProgress * (finalValue - initialValue);
                  var currentValue = el[prop].currentValue;

                  if (
                    (finalValue > initialValue && currentValue >= finalValue) ||
                    (finalValue < initialValue && currentValue <= finalValue)
                  ) {
                    el.container.style[prop] = finalValue + unit;
                    propsDone += 1;

                    if (propsDone === Object.keys(props).length) {
                      el.done = true;
                      elementsDone += 1;
                    }

                    if (elementsDone === elements.length) {
                      done = true;
                    }
                  }

                  if (done) {
                    a.done(params.complete);
                    return;
                  }

                  el.container.style[prop] = currentValue + unit;
                });
              });
              if (done) return; // Then call

              a.frameId = window.requestAnimationFrame(render);
            }

            a.frameId = window.requestAnimationFrame(render);
            return a;
          },
        };

        if (a.elements.length === 0) {
          return els;
        }

        var animateInstance;

        for (var i = 0; i < a.elements.length; i += 1) {
          if (a.elements[i].dom7AnimateInstance) {
            animateInstance = a.elements[i].dom7AnimateInstance;
          } else a.elements[i].dom7AnimateInstance = a;
        }

        if (!animateInstance) {
          animateInstance = a;
        }

        if (initialProps === "stop") {
          animateInstance.stop();
        } else {
          animateInstance.animate(a.props, a.params);
        }

        return els;
      }

      function stop() {
        var els = this;

        for (var i = 0; i < els.length; i += 1) {
          if (els[i].dom7AnimateInstance) {
            els[i].dom7AnimateInstance.stop();
          }
        }
      }

      var noTrigger = "resize scroll".split(" ");

      function shortcut(name) {
        function eventHandler() {
          for (
            var _len = arguments.length, args = new Array(_len), _key = 0;
            _key < _len;
            _key++
          ) {
            args[_key] = arguments[_key];
          }

          if (typeof args[0] === "undefined") {
            for (var i = 0; i < this.length; i += 1) {
              if (noTrigger.indexOf(name) < 0) {
                if (name in this[i]) this[i][name]();
                else {
                  $(this[i]).trigger(name);
                }
              }
            }

            return this;
          }

          return this.on.apply(this, [name].concat(args));
        }

        return eventHandler;
      }

      var click = shortcut("click");
      var blur = shortcut("blur");
      var focus = shortcut("focus");
      var focusin = shortcut("focusin");
      var focusout = shortcut("focusout");
      var keyup = shortcut("keyup");
      var keydown = shortcut("keydown");
      var keypress = shortcut("keypress");
      var submit = shortcut("submit");
      var change = shortcut("change");
      var mousedown = shortcut("mousedown");
      var mousemove = shortcut("mousemove");
      var mouseup = shortcut("mouseup");
      var mouseenter = shortcut("mouseenter");
      var mouseleave = shortcut("mouseleave");
      var mouseout = shortcut("mouseout");
      var mouseover = shortcut("mouseover");
      var touchstart = shortcut("touchstart");
      var touchend = shortcut("touchend");
      var touchmove = shortcut("touchmove");
      var resize = shortcut("resize");
      var scroll = shortcut("scroll");

      exports.default = $;
      exports.$ = $;
      exports.add = add;
      exports.addClass = addClass;
      exports.animate = animate;
      exports.animationEnd = animationEnd;
      exports.append = append;
      exports.appendTo = appendTo;
      exports.attr = attr;
      exports.blur = blur;
      exports.change = change;
      exports.children = children;
      exports.click = click;
      exports.closest = closest;
      exports.css = css;
      exports.data = data;
      exports.dataset = dataset;
      exports.detach = detach;
      exports.each = each;
      exports.empty = empty;
      exports.eq = eq;
      exports.filter = filter;
      exports.find = find;
      exports.focus = focus;
      exports.focusin = focusin;
      exports.focusout = focusout;
      exports.hasClass = hasClass;
      exports.height = height;
      exports.hide = hide;
      exports.html = html;
      exports.index = index;
      exports.insertAfter = insertAfter;
      exports.insertBefore = insertBefore;
      exports.is = is;
      exports.keydown = keydown;
      exports.keypress = keypress;
      exports.keyup = keyup;
      exports.mousedown = mousedown;
      exports.mouseenter = mouseenter;
      exports.mouseleave = mouseleave;
      exports.mousemove = mousemove;
      exports.mouseout = mouseout;
      exports.mouseover = mouseover;
      exports.mouseup = mouseup;
      exports.next = next;
      exports.nextAll = nextAll;
      exports.off = off;
      exports.offset = offset;
      exports.on = on;
      exports.once = once;
      exports.outerHeight = outerHeight;
      exports.outerWidth = outerWidth;
      exports.parent = parent;
      exports.parents = parents;
      exports.prepend = prepend;
      exports.prependTo = prependTo;
      exports.prev = prev;
      exports.prevAll = prevAll;
      exports.prop = prop;
      exports.remove = remove;
      exports.removeAttr = removeAttr;
      exports.removeClass = removeClass;
      exports.removeData = removeData;
      exports.resize = resize;
      exports.scroll = scroll;
      exports.scrollLeft = scrollLeft;
      exports.scrollTo = scrollTo;
      exports.scrollTop = scrollTop;
      exports.show = show;
      exports.siblings = siblings;
      exports.stop = stop;
      exports.styles = styles;
      exports.submit = submit;
      exports.text = text;
      exports.toggleClass = toggleClass;
      exports.touchend = touchend;
      exports.touchmove = touchmove;
      exports.touchstart = touchstart;
      exports.transform = transform;
      exports.transition = transition;
      exports.transitionEnd = transitionEnd;
      exports.trigger = trigger;
      exports.val = val;
      exports.value = value;
      exports.width = width;

      /***/
    },

    /***/ 137: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.getDevice = undefined;

      var _ssrWindow = __webpack_require__(5);

      var _getSupport = __webpack_require__(130);

      var device;

      function calcDevice(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
          userAgent = _ref.userAgent;

        var support = (0, _getSupport.getSupport)();
        var window = (0, _ssrWindow.getWindow)();
        var platform = window.navigator.platform;
        var ua = userAgent || window.navigator.userAgent;
        var device = {
          ios: false,
          android: false,
        };
        var screenWidth = window.screen.width;
        var screenHeight = window.screen.height;
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        var windows = platform === "Win32";
        var macos = platform === "MacIntel"; // iPadOs 13 fix

        var iPadScreens = [
          "1024x1366",
          "1366x1024",
          "834x1194",
          "1194x834",
          "834x1112",
          "1112x834",
          "768x1024",
          "1024x768",
          "820x1180",
          "1180x820",
          "810x1080",
          "1080x810",
        ];

        if (
          !ipad &&
          macos &&
          support.touch &&
          iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0
        ) {
          ipad = ua.match(/(Version)\/([\d.]+)/);
          if (!ipad) ipad = [0, 1, "13_0_0"];
          macos = false;
        } // Android

        if (android && !windows) {
          device.os = "android";
          device.android = true;
        }

        if (ipad || iphone || ipod) {
          device.os = "ios";
          device.ios = true;
        } // Export object

        return device;
      }

      function getDevice(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }

        if (!device) {
          device = calcDevice(overrides);
        }

        return device;
      }

      exports.getDevice = getDevice;

      /***/
    },

    /***/ 138: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.getBrowser = undefined;

      var _ssrWindow = __webpack_require__(5);

      var browser;

      function calcBrowser() {
        var window = (0, _ssrWindow.getWindow)();

        function isSafari() {
          var ua = window.navigator.userAgent.toLowerCase();
          return (
            ua.indexOf("safari") >= 0 &&
            ua.indexOf("chrome") < 0 &&
            ua.indexOf("android") < 0
          );
        }

        return {
          isEdge: !!window.navigator.userAgent.match(/Edge/g),
          isSafari: isSafari(),
          isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
            window.navigator.userAgent
          ),
        };
      }

      function getBrowser() {
        if (!browser) {
          browser = calcBrowser();
        }

        return browser;
      }

      exports.getBrowser = getBrowser;

      /***/
    },

    /***/ 139: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _utils = __webpack_require__(1);

      var supportsResizeObserver = function supportsResizeObserver() {
        var window = (0, _ssrWindow.getWindow)();
        return typeof window.ResizeObserver !== "undefined";
      };

      exports.default = {
        name: "resize",
        create: function create() {
          var swiper = this;
          (0, _utils.extend)(swiper, {
            resize: {
              observer: null,
              createObserver: function createObserver() {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                swiper.resize.observer = new ResizeObserver(function (entries) {
                  var width = swiper.width,
                    height = swiper.height;
                  var newWidth = width;
                  var newHeight = height;
                  entries.forEach(function (_ref) {
                    var contentBoxSize = _ref.contentBoxSize,
                      contentRect = _ref.contentRect,
                      target = _ref.target;
                    if (target && target !== swiper.el) return;
                    newWidth = contentRect
                      ? contentRect.width
                      : (contentBoxSize[0] || contentBoxSize).inlineSize;
                    newHeight = contentRect
                      ? contentRect.height
                      : (contentBoxSize[0] || contentBoxSize).blockSize;
                  });

                  if (newWidth !== width || newHeight !== height) {
                    swiper.resize.resizeHandler();
                  }
                });
                swiper.resize.observer.observe(swiper.el);
              },
              removeObserver: function removeObserver() {
                if (
                  swiper.resize.observer &&
                  swiper.resize.observer.unobserve &&
                  swiper.el
                ) {
                  swiper.resize.observer.unobserve(swiper.el);
                  swiper.resize.observer = null;
                }
              },
              resizeHandler: function resizeHandler() {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                swiper.emit("beforeResize");
                swiper.emit("resize");
              },
              orientationChangeHandler: function orientationChangeHandler() {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                swiper.emit("orientationchange");
              },
            },
          });
        },
        on: {
          init: function init(swiper) {
            var window = (0, _ssrWindow.getWindow)();

            if (swiper.params.resizeObserver && supportsResizeObserver()) {
              swiper.resize.createObserver();
              return;
            } // Emit resize

            window.addEventListener("resize", swiper.resize.resizeHandler); // Emit orientationchange

            window.addEventListener(
              "orientationchange",
              swiper.resize.orientationChangeHandler
            );
          },
          destroy: function destroy(swiper) {
            var window = (0, _ssrWindow.getWindow)();
            swiper.resize.removeObserver();
            window.removeEventListener("resize", swiper.resize.resizeHandler);
            window.removeEventListener(
              "orientationchange",
              swiper.resize.orientationChangeHandler
            );
          },
        },
      };

      /***/
    },

    /***/ 14: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * @public
       * @type {Object}
       */

      module.exports = {
        isBlendMode: function isBlendMode() {
          if ("CSS" in window && "supports" in window.CSS) {
            return window.CSS.supports("mix-blend-mode", "overlay");
          }
          return false;
        },

        isMac: function isMac() {
          return navigator.platform.toUpperCase().indexOf("MAC") > -1;
        },

        isSafari: function isSafari() {
          var ua = navigator.userAgent.toLowerCase();
          return ua.indexOf("safari") != -1 && ua.indexOf("chrome") < 0;
        },

        isAndroid: function isAndroid() {
          return navigator.userAgent.match(/Android/i);
        },

        isBlackBerry: function isBlackBerry() {
          return navigator.userAgent.match(/BlackBerry/i);
        },

        isiOS: function isiOS() {
          return (
            navigator.userAgent.match(/iPhone|iPad|iPod/i) && !window.MSStream
          );
        },

        isOpera: function isOpera() {
          return navigator.userAgent.match(/Opera Mini/i);
        },

        isWindows: function isWindows() {
          return navigator.userAgent.match(/IEMobile/i);
        },

        isTouch: function isTouch() {
          return (
            this.isAndroid() ||
            this.isBlackBerry() ||
            this.isiOS() ||
            this.isOpera() ||
            this.isWindows()
          );
        },
      };

      /***/
    },

    /***/ 140: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _utils = __webpack_require__(1);

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Observer = {
        attach: function attach(target, options) {
          if (options === void 0) {
            options = {};
          }

          var window = (0, _ssrWindow.getWindow)();
          var swiper = this;
          var ObserverFunc =
            window.MutationObserver || window.WebkitMutationObserver;
          var observer = new ObserverFunc(function (mutations) {
            // The observerUpdate event should only be triggered
            // once despite the number of mutations.  Additional
            // triggers are redundant and are very costly
            if (mutations.length === 1) {
              swiper.emit("observerUpdate", mutations[0]);
              return;
            }

            var observerUpdate = function observerUpdate() {
              swiper.emit("observerUpdate", mutations[0]);
            };

            if (window.requestAnimationFrame) {
              window.requestAnimationFrame(observerUpdate);
            } else {
              window.setTimeout(observerUpdate, 0);
            }
          });
          observer.observe(target, {
            attributes:
              typeof options.attributes === "undefined"
                ? true
                : options.attributes,
            childList:
              typeof options.childList === "undefined"
                ? true
                : options.childList,
            characterData:
              typeof options.characterData === "undefined"
                ? true
                : options.characterData,
          });
          swiper.observer.observers.push(observer);
        },
        init: function init() {
          var swiper = this;
          if (!swiper.support.observer || !swiper.params.observer) return;

          if (swiper.params.observeParents) {
            var containerParents = swiper.$el.parents();

            for (var i = 0; i < containerParents.length; i += 1) {
              swiper.observer.attach(containerParents[i]);
            }
          } // Observe container

          swiper.observer.attach(swiper.$el[0], {
            childList: swiper.params.observeSlideChildren,
          }); // Observe wrapper

          swiper.observer.attach(swiper.$wrapperEl[0], {
            attributes: false,
          });
        },
        destroy: function destroy() {
          var swiper = this;
          swiper.observer.observers.forEach(function (observer) {
            observer.disconnect();
          });
          swiper.observer.observers = [];
        },
      };
      exports.default = {
        name: "observer",
        params: {
          observer: false,
          observeParents: false,
          observeSlideChildren: false,
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            observer: _extends({}, Observer, {
              observers: [],
            }),
          });
        },
        on: {
          init: function init(swiper) {
            swiper.observer.init();
          },
          destroy: function destroy(swiper) {
            swiper.observer.destroy();
          },
        },
      };

      /***/
    },

    /***/ 141: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _utils = __webpack_require__(1);

      exports.default = {
        useParams: function useParams(instanceParams) {
          var instance = this;
          if (!instance.modules) return;
          Object.keys(instance.modules).forEach(function (moduleName) {
            var module = instance.modules[moduleName]; // Extend params

            if (module.params) {
              (0, _utils.extend)(instanceParams, module.params);
            }
          });
        },
        useModules: function useModules(modulesParams) {
          if (modulesParams === void 0) {
            modulesParams = {};
          }

          var instance = this;
          if (!instance.modules) return;
          Object.keys(instance.modules).forEach(function (moduleName) {
            var module = instance.modules[moduleName];
            var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

            if (module.on && instance.on) {
              Object.keys(module.on).forEach(function (moduleEventName) {
                instance.on(moduleEventName, module.on[moduleEventName]);
              });
            } // Module create callback

            if (module.create) {
              module.create.bind(instance)(moduleParams);
            }
          });
        },
      };

      /***/
    },

    /***/ 142: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      /* eslint-disable no-underscore-dangle */
      exports.default = {
        on: function on(events, handler, priority) {
          var self = this;
          if (typeof handler !== "function") return self;
          var method = priority ? "unshift" : "push";
          events.split(" ").forEach(function (event) {
            if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
            self.eventsListeners[event][method](handler);
          });
          return self;
        },
        once: function once(events, handler, priority) {
          var self = this;
          if (typeof handler !== "function") return self;

          function onceHandler() {
            self.off(events, onceHandler);

            if (onceHandler.__emitterProxy) {
              delete onceHandler.__emitterProxy;
            }

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            handler.apply(self, args);
          }

          onceHandler.__emitterProxy = handler;
          return self.on(events, onceHandler, priority);
        },
        onAny: function onAny(handler, priority) {
          var self = this;
          if (typeof handler !== "function") return self;
          var method = priority ? "unshift" : "push";

          if (self.eventsAnyListeners.indexOf(handler) < 0) {
            self.eventsAnyListeners[method](handler);
          }

          return self;
        },
        offAny: function offAny(handler) {
          var self = this;
          if (!self.eventsAnyListeners) return self;
          var index = self.eventsAnyListeners.indexOf(handler);

          if (index >= 0) {
            self.eventsAnyListeners.splice(index, 1);
          }

          return self;
        },
        off: function off(events, handler) {
          var self = this;
          if (!self.eventsListeners) return self;
          events.split(" ").forEach(function (event) {
            if (typeof handler === "undefined") {
              self.eventsListeners[event] = [];
            } else if (self.eventsListeners[event]) {
              self.eventsListeners[event].forEach(function (
                eventHandler,
                index
              ) {
                if (
                  eventHandler === handler ||
                  (eventHandler.__emitterProxy &&
                    eventHandler.__emitterProxy === handler)
                ) {
                  self.eventsListeners[event].splice(index, 1);
                }
              });
            }
          });
          return self;
        },
        emit: function emit() {
          var self = this;
          if (!self.eventsListeners) return self;
          var events;
          var data;
          var context;

          for (
            var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
            _key2 < _len2;
            _key2++
          ) {
            args[_key2] = arguments[_key2];
          }

          if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events = args[0];
            data = args.slice(1, args.length);
            context = self;
          } else {
            events = args[0].events;
            data = args[0].data;
            context = args[0].context || self;
          }

          data.unshift(context);
          var eventsArray = Array.isArray(events) ? events : events.split(" ");
          eventsArray.forEach(function (event) {
            if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
              self.eventsAnyListeners.forEach(function (eventHandler) {
                eventHandler.apply(context, [event].concat(data));
              });
            }

            if (self.eventsListeners && self.eventsListeners[event]) {
              self.eventsListeners[event].forEach(function (eventHandler) {
                eventHandler.apply(context, data);
              });
            }
          });
          return self;
        },
      };

      /***/
    },

    /***/ 143: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _updateSize = __webpack_require__(144);

      var _updateSize2 = _interopRequireDefault(_updateSize);

      var _updateSlides = __webpack_require__(145);

      var _updateSlides2 = _interopRequireDefault(_updateSlides);

      var _updateAutoHeight = __webpack_require__(146);

      var _updateAutoHeight2 = _interopRequireDefault(_updateAutoHeight);

      var _updateSlidesOffset = __webpack_require__(147);

      var _updateSlidesOffset2 = _interopRequireDefault(_updateSlidesOffset);

      var _updateSlidesProgress = __webpack_require__(148);

      var _updateSlidesProgress2 = _interopRequireDefault(
        _updateSlidesProgress
      );

      var _updateProgress = __webpack_require__(149);

      var _updateProgress2 = _interopRequireDefault(_updateProgress);

      var _updateSlidesClasses = __webpack_require__(150);

      var _updateSlidesClasses2 = _interopRequireDefault(_updateSlidesClasses);

      var _updateActiveIndex = __webpack_require__(151);

      var _updateActiveIndex2 = _interopRequireDefault(_updateActiveIndex);

      var _updateClickedSlide = __webpack_require__(152);

      var _updateClickedSlide2 = _interopRequireDefault(_updateClickedSlide);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        updateSize: _updateSize2.default,
        updateSlides: _updateSlides2.default,
        updateAutoHeight: _updateAutoHeight2.default,
        updateSlidesOffset: _updateSlidesOffset2.default,
        updateSlidesProgress: _updateSlidesProgress2.default,
        updateProgress: _updateProgress2.default,
        updateSlidesClasses: _updateSlidesClasses2.default,
        updateActiveIndex: _updateActiveIndex2.default,
        updateClickedSlide: _updateClickedSlide2.default,
      };

      /***/
    },

    /***/ 144: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateSize;

      var _utils = __webpack_require__(1);

      function updateSize() {
        var swiper = this;
        var width;
        var height;
        var $el = swiper.$el;

        if (
          typeof swiper.params.width !== "undefined" &&
          swiper.params.width !== null
        ) {
          width = swiper.params.width;
        } else {
          width = $el[0].clientWidth;
        }

        if (
          typeof swiper.params.height !== "undefined" &&
          swiper.params.height !== null
        ) {
          height = swiper.params.height;
        } else {
          height = $el[0].clientHeight;
        }

        if (
          (width === 0 && swiper.isHorizontal()) ||
          (height === 0 && swiper.isVertical())
        ) {
          return;
        } // Subtract paddings

        width =
          width -
          parseInt($el.css("padding-left") || 0, 10) -
          parseInt($el.css("padding-right") || 0, 10);
        height =
          height -
          parseInt($el.css("padding-top") || 0, 10) -
          parseInt($el.css("padding-bottom") || 0, 10);
        if (Number.isNaN(width)) width = 0;
        if (Number.isNaN(height)) height = 0;
        (0, _utils.extend)(swiper, {
          width: width,
          height: height,
          size: swiper.isHorizontal() ? width : height,
        });
      }

      /***/
    },

    /***/ 145: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateSlides;

      var _utils = __webpack_require__(1);

      function updateSlides() {
        var swiper = this;

        function getDirectionLabel(property) {
          if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore

          return {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom",
          }[property];
        }

        function getDirectionPropertyValue(node, label) {
          return parseFloat(
            node.getPropertyValue(getDirectionLabel(label)) || 0
          );
        }

        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl,
          swiperSize = swiper.size,
          rtl = swiper.rtlTranslate,
          wrongRTL = swiper.wrongRTL;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        var previousSlidesLength = isVirtual
          ? swiper.virtual.slides.length
          : swiper.slides.length;
        var slides = $wrapperEl.children("." + swiper.params.slideClass);
        var slidesLength = isVirtual
          ? swiper.virtual.slides.length
          : slides.length;
        var snapGrid = [];
        var slidesGrid = [];
        var slidesSizesGrid = [];
        var offsetBefore = params.slidesOffsetBefore;

        if (typeof offsetBefore === "function") {
          offsetBefore = params.slidesOffsetBefore.call(swiper);
        }

        var offsetAfter = params.slidesOffsetAfter;

        if (typeof offsetAfter === "function") {
          offsetAfter = params.slidesOffsetAfter.call(swiper);
        }

        var previousSnapGridLength = swiper.snapGrid.length;
        var previousSlidesGridLength = swiper.slidesGrid.length;
        var spaceBetween = params.spaceBetween;
        var slidePosition = -offsetBefore;
        var prevSlideSize = 0;
        var index = 0;

        if (typeof swiperSize === "undefined") {
          return;
        }

        if (
          typeof spaceBetween === "string" &&
          spaceBetween.indexOf("%") >= 0
        ) {
          spaceBetween =
            (parseFloat(spaceBetween.replace("%", "")) / 100) * swiperSize;
        }

        swiper.virtualSize = -spaceBetween; // reset margins

        if (rtl)
          slides.css({
            marginLeft: "",
            marginBottom: "",
            marginTop: "",
          });
        else
          slides.css({
            marginRight: "",
            marginBottom: "",
            marginTop: "",
          });
        var slidesNumberEvenToRows;

        if (params.slidesPerColumn > 1) {
          if (
            Math.floor(slidesLength / params.slidesPerColumn) ===
            slidesLength / swiper.params.slidesPerColumn
          ) {
            slidesNumberEvenToRows = slidesLength;
          } else {
            slidesNumberEvenToRows =
              Math.ceil(slidesLength / params.slidesPerColumn) *
              params.slidesPerColumn;
          }

          if (
            params.slidesPerView !== "auto" &&
            params.slidesPerColumnFill === "row"
          ) {
            slidesNumberEvenToRows = Math.max(
              slidesNumberEvenToRows,
              params.slidesPerView * params.slidesPerColumn
            );
          }
        } // Calc slides

        var slideSize;
        var slidesPerColumn = params.slidesPerColumn;
        var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
        var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

        for (var i = 0; i < slidesLength; i += 1) {
          slideSize = 0;
          var slide = slides.eq(i);

          if (params.slidesPerColumn > 1) {
            // Set slides order
            var newSlideOrderIndex = void 0;
            var column = void 0;
            var row = void 0;

            if (
              params.slidesPerColumnFill === "row" &&
              params.slidesPerGroup > 1
            ) {
              var groupIndex = Math.floor(
                i / (params.slidesPerGroup * params.slidesPerColumn)
              );
              var slideIndexInGroup =
                i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
              var columnsInGroup =
                groupIndex === 0
                  ? params.slidesPerGroup
                  : Math.min(
                      Math.ceil(
                        (slidesLength -
                          groupIndex *
                            slidesPerColumn *
                            params.slidesPerGroup) /
                          slidesPerColumn
                      ),
                      params.slidesPerGroup
                    );
              row = Math.floor(slideIndexInGroup / columnsInGroup);
              column =
                slideIndexInGroup -
                row * columnsInGroup +
                groupIndex * params.slidesPerGroup;
              newSlideOrderIndex =
                column + (row * slidesNumberEvenToRows) / slidesPerColumn;
              slide.css({
                "-webkit-box-ordinal-group": newSlideOrderIndex,
                "-moz-box-ordinal-group": newSlideOrderIndex,
                "-ms-flex-order": newSlideOrderIndex,
                "-webkit-order": newSlideOrderIndex,
                order: newSlideOrderIndex,
              });
            } else if (params.slidesPerColumnFill === "column") {
              column = Math.floor(i / slidesPerColumn);
              row = i - column * slidesPerColumn;

              if (
                column > numFullColumns ||
                (column === numFullColumns && row === slidesPerColumn - 1)
              ) {
                row += 1;

                if (row >= slidesPerColumn) {
                  row = 0;
                  column += 1;
                }
              }
            } else {
              row = Math.floor(i / slidesPerRow);
              column = i - row * slidesPerRow;
            }

            slide.css(
              getDirectionLabel("margin-top"),
              row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : ""
            );
          }

          if (slide.css("display") === "none") continue; // eslint-disable-line

          if (params.slidesPerView === "auto") {
            var slideStyles = getComputedStyle(slide[0]);
            var currentTransform = slide[0].style.transform;
            var currentWebKitTransform = slide[0].style.webkitTransform;

            if (currentTransform) {
              slide[0].style.transform = "none";
            }

            if (currentWebKitTransform) {
              slide[0].style.webkitTransform = "none";
            }

            if (params.roundLengths) {
              slideSize = swiper.isHorizontal()
                ? slide.outerWidth(true)
                : slide.outerHeight(true);
            } else {
              // eslint-disable-next-line
              var width = getDirectionPropertyValue(slideStyles, "width");
              var paddingLeft = getDirectionPropertyValue(
                slideStyles,
                "padding-left"
              );
              var paddingRight = getDirectionPropertyValue(
                slideStyles,
                "padding-right"
              );
              var marginLeft = getDirectionPropertyValue(
                slideStyles,
                "margin-left"
              );
              var marginRight = getDirectionPropertyValue(
                slideStyles,
                "margin-right"
              );
              var boxSizing = slideStyles.getPropertyValue("box-sizing");

              if (boxSizing && boxSizing === "border-box") {
                slideSize = width + marginLeft + marginRight;
              } else {
                var _slide$ = slide[0],
                  clientWidth = _slide$.clientWidth,
                  offsetWidth = _slide$.offsetWidth;
                slideSize =
                  width +
                  paddingLeft +
                  paddingRight +
                  marginLeft +
                  marginRight +
                  (offsetWidth - clientWidth);
              }
            }

            if (currentTransform) {
              slide[0].style.transform = currentTransform;
            }

            if (currentWebKitTransform) {
              slide[0].style.webkitTransform = currentWebKitTransform;
            }

            if (params.roundLengths) slideSize = Math.floor(slideSize);
          } else {
            slideSize =
              (swiperSize - (params.slidesPerView - 1) * spaceBetween) /
              params.slidesPerView;
            if (params.roundLengths) slideSize = Math.floor(slideSize);

            if (slides[i]) {
              slides[i].style[getDirectionLabel("width")] = slideSize + "px";
            }
          }

          if (slides[i]) {
            slides[i].swiperSlideSize = slideSize;
          }

          slidesSizesGrid.push(slideSize);

          if (params.centeredSlides) {
            slidePosition =
              slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (prevSlideSize === 0 && i !== 0)
              slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (i === 0)
              slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (index % params.slidesPerGroup === 0)
              snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
          } else {
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (
              (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %
                swiper.params.slidesPerGroup ===
              0
            )
              snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
          }

          swiper.virtualSize += slideSize + spaceBetween;
          prevSlideSize = slideSize;
          index += 1;
        }

        swiper.virtualSize =
          Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        var newSlidesGrid;

        if (
          rtl &&
          wrongRTL &&
          (params.effect === "slide" || params.effect === "coverflow")
        ) {
          $wrapperEl.css({
            width: swiper.virtualSize + params.spaceBetween + "px",
          });
        }

        if (params.setWrapperSize) {
          var _$wrapperEl$css;

          $wrapperEl.css(
            ((_$wrapperEl$css = {}),
            (_$wrapperEl$css[getDirectionLabel("width")] =
              swiper.virtualSize + params.spaceBetween + "px"),
            _$wrapperEl$css)
          );
        }

        if (params.slidesPerColumn > 1) {
          var _$wrapperEl$css2;

          swiper.virtualSize =
            (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
          swiper.virtualSize =
            Math.ceil(swiper.virtualSize / params.slidesPerColumn) -
            params.spaceBetween;
          $wrapperEl.css(
            ((_$wrapperEl$css2 = {}),
            (_$wrapperEl$css2[getDirectionLabel("width")] =
              swiper.virtualSize + params.spaceBetween + "px"),
            _$wrapperEl$css2)
          );

          if (params.centeredSlides) {
            newSlidesGrid = [];

            for (var _i = 0; _i < snapGrid.length; _i += 1) {
              var slidesGridItem = snapGrid[_i];
              if (params.roundLengths)
                slidesGridItem = Math.floor(slidesGridItem);
              if (snapGrid[_i] < swiper.virtualSize + snapGrid[0])
                newSlidesGrid.push(slidesGridItem);
            }

            snapGrid = newSlidesGrid;
          }
        } // Remove last grid elements depending on width

        if (!params.centeredSlides) {
          newSlidesGrid = [];

          for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
            var _slidesGridItem = snapGrid[_i2];
            if (params.roundLengths)
              _slidesGridItem = Math.floor(_slidesGridItem);

            if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
              newSlidesGrid.push(_slidesGridItem);
            }
          }

          snapGrid = newSlidesGrid;

          if (
            Math.floor(swiper.virtualSize - swiperSize) -
              Math.floor(snapGrid[snapGrid.length - 1]) >
            1
          ) {
            snapGrid.push(swiper.virtualSize - swiperSize);
          }
        }

        if (snapGrid.length === 0) snapGrid = [0];

        if (params.spaceBetween !== 0) {
          var _slides$filter$css;

          var key =
            swiper.isHorizontal() && rtl
              ? "marginLeft"
              : getDirectionLabel("marginRight");
          slides
            .filter(function (_, slideIndex) {
              if (!params.cssMode) return true;

              if (slideIndex === slides.length - 1) {
                return false;
              }

              return true;
            })
            .css(
              ((_slides$filter$css = {}),
              (_slides$filter$css[key] = spaceBetween + "px"),
              _slides$filter$css)
            );
        }

        if (params.centeredSlides && params.centeredSlidesBounds) {
          var allSlidesSize = 0;
          slidesSizesGrid.forEach(function (slideSizeValue) {
            allSlidesSize +=
              slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
          });
          allSlidesSize -= params.spaceBetween;
          var maxSnap = allSlidesSize - swiperSize;
          snapGrid = snapGrid.map(function (snap) {
            if (snap < 0) return -offsetBefore;
            if (snap > maxSnap) return maxSnap + offsetAfter;
            return snap;
          });
        }

        if (params.centerInsufficientSlides) {
          var _allSlidesSize = 0;
          slidesSizesGrid.forEach(function (slideSizeValue) {
            _allSlidesSize +=
              slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
          });
          _allSlidesSize -= params.spaceBetween;

          if (_allSlidesSize < swiperSize) {
            var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
            snapGrid.forEach(function (snap, snapIndex) {
              snapGrid[snapIndex] = snap - allSlidesOffset;
            });
            slidesGrid.forEach(function (snap, snapIndex) {
              slidesGrid[snapIndex] = snap + allSlidesOffset;
            });
          }
        }

        (0, _utils.extend)(swiper, {
          slides: slides,
          snapGrid: snapGrid,
          slidesGrid: slidesGrid,
          slidesSizesGrid: slidesSizesGrid,
        });

        if (slidesLength !== previousSlidesLength) {
          swiper.emit("slidesLengthChange");
        }

        if (snapGrid.length !== previousSnapGridLength) {
          if (swiper.params.watchOverflow) swiper.checkOverflow();
          swiper.emit("snapGridLengthChange");
        }

        if (slidesGrid.length !== previousSlidesGridLength) {
          swiper.emit("slidesGridLengthChange");
        }

        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
          swiper.updateSlidesOffset();
        }
      }

      /***/
    },

    /***/ 146: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateAutoHeight;
      function updateAutoHeight(speed) {
        var swiper = this;
        var activeSlides = [];
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var newHeight = 0;
        var i;

        if (typeof speed === "number") {
          swiper.setTransition(speed);
        } else if (speed === true) {
          swiper.setTransition(swiper.params.speed);
        }

        var getSlideByIndex = function getSlideByIndex(index) {
          if (isVirtual) {
            return swiper.slides.filter(function (el) {
              return (
                parseInt(el.getAttribute("data-swiper-slide-index"), 10) ===
                index
              );
            })[0];
          }

          return swiper.slides.eq(index)[0];
        }; // Find slides currently in view

        if (
          swiper.params.slidesPerView !== "auto" &&
          swiper.params.slidesPerView > 1
        ) {
          if (swiper.params.centeredSlides) {
            swiper.visibleSlides.each(function (slide) {
              activeSlides.push(slide);
            });
          } else {
            for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
              var index = swiper.activeIndex + i;
              if (index > swiper.slides.length && !isVirtual) break;
              activeSlides.push(getSlideByIndex(index));
            }
          }
        } else {
          activeSlides.push(getSlideByIndex(swiper.activeIndex));
        } // Find new height from highest slide in view

        for (i = 0; i < activeSlides.length; i += 1) {
          if (typeof activeSlides[i] !== "undefined") {
            var height = activeSlides[i].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
          }
        } // Update Height

        if (newHeight) swiper.$wrapperEl.css("height", newHeight + "px");
      }

      /***/
    },

    /***/ 147: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateSlidesOffset;
      function updateSlidesOffset() {
        var swiper = this;
        var slides = swiper.slides;

        for (var i = 0; i < slides.length; i += 1) {
          slides[i].swiperSlideOffset = swiper.isHorizontal()
            ? slides[i].offsetLeft
            : slides[i].offsetTop;
        }
      }

      /***/
    },

    /***/ 148: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateSlidesProgress;

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function updateSlidesProgress(translate) {
        if (translate === void 0) {
          translate = (this && this.translate) || 0;
        }

        var swiper = this;
        var params = swiper.params;
        var slides = swiper.slides,
          rtl = swiper.rtlTranslate;
        if (slides.length === 0) return;
        if (typeof slides[0].swiperSlideOffset === "undefined")
          swiper.updateSlidesOffset();
        var offsetCenter = -translate;
        if (rtl) offsetCenter = translate; // Visible Slides

        slides.removeClass(params.slideVisibleClass);
        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];

        for (var i = 0; i < slides.length; i += 1) {
          var slide = slides[i];
          var slideProgress =
            (offsetCenter +
              (params.centeredSlides ? swiper.minTranslate() : 0) -
              slide.swiperSlideOffset) /
            (slide.swiperSlideSize + params.spaceBetween);

          if (
            params.watchSlidesVisibility ||
            (params.centeredSlides && params.autoHeight)
          ) {
            var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
            var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
            var isVisible =
              (slideBefore >= 0 && slideBefore < swiper.size - 1) ||
              (slideAfter > 1 && slideAfter <= swiper.size) ||
              (slideBefore <= 0 && slideAfter >= swiper.size);

            if (isVisible) {
              swiper.visibleSlides.push(slide);
              swiper.visibleSlidesIndexes.push(i);
              slides.eq(i).addClass(params.slideVisibleClass);
            }
          }

          slide.progress = rtl ? -slideProgress : slideProgress;
        }

        swiper.visibleSlides = (0, _dom2.default)(swiper.visibleSlides);
      }

      /***/
    },

    /***/ 149: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateProgress;

      var _utils = __webpack_require__(1);

      function updateProgress(translate) {
        var swiper = this;

        if (typeof translate === "undefined") {
          var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

          translate =
            (swiper && swiper.translate && swiper.translate * multiplier) || 0;
        }

        var params = swiper.params;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        var progress = swiper.progress,
          isBeginning = swiper.isBeginning,
          isEnd = swiper.isEnd;
        var wasBeginning = isBeginning;
        var wasEnd = isEnd;

        if (translatesDiff === 0) {
          progress = 0;
          isBeginning = true;
          isEnd = true;
        } else {
          progress = (translate - swiper.minTranslate()) / translatesDiff;
          isBeginning = progress <= 0;
          isEnd = progress >= 1;
        }

        (0, _utils.extend)(swiper, {
          progress: progress,
          isBeginning: isBeginning,
          isEnd: isEnd,
        });
        if (
          params.watchSlidesProgress ||
          params.watchSlidesVisibility ||
          (params.centeredSlides && params.autoHeight)
        )
          swiper.updateSlidesProgress(translate);

        if (isBeginning && !wasBeginning) {
          swiper.emit("reachBeginning toEdge");
        }

        if (isEnd && !wasEnd) {
          swiper.emit("reachEnd toEdge");
        }

        if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
          swiper.emit("fromEdge");
        }

        swiper.emit("progress", progress);
      }

      /***/
    },

    /***/ 15: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (process) {
        var utils = __webpack_require__(0);
        var normalizeHeaderName = __webpack_require__(56);
        var AxiosError = __webpack_require__(2);
        var transitionalDefaults = __webpack_require__(24);
        var toFormData = __webpack_require__(25);

        var DEFAULT_CONTENT_TYPE = {
          "Content-Type": "application/x-www-form-urlencoded",
        };

        function setContentTypeIfUnset(headers, value) {
          if (
            !utils.isUndefined(headers) &&
            utils.isUndefined(headers["Content-Type"])
          ) {
            headers["Content-Type"] = value;
          }
        }

        function getDefaultAdapter() {
          var adapter;
          if (typeof XMLHttpRequest !== "undefined") {
            // For browsers use XHR adapter
            adapter = __webpack_require__(26);
          } else if (
            typeof process !== "undefined" &&
            Object.prototype.toString.call(process) === "[object process]"
          ) {
            // For node use HTTP adapter
            adapter = __webpack_require__(26);
          }
          return adapter;
        }

        function stringifySafely(rawValue, parser, encoder) {
          if (utils.isString(rawValue)) {
            try {
              (parser || JSON.parse)(rawValue);
              return utils.trim(rawValue);
            } catch (e) {
              if (e.name !== "SyntaxError") {
                throw e;
              }
            }
          }

          return (encoder || JSON.stringify)(rawValue);
        }

        var defaults = {
          transitional: transitionalDefaults,

          adapter: getDefaultAdapter(),

          transformRequest: [
            function transformRequest(data, headers) {
              normalizeHeaderName(headers, "Accept");
              normalizeHeaderName(headers, "Content-Type");

              if (
                utils.isFormData(data) ||
                utils.isArrayBuffer(data) ||
                utils.isBuffer(data) ||
                utils.isStream(data) ||
                utils.isFile(data) ||
                utils.isBlob(data)
              ) {
                return data;
              }
              if (utils.isArrayBufferView(data)) {
                return data.buffer;
              }
              if (utils.isURLSearchParams(data)) {
                setContentTypeIfUnset(
                  headers,
                  "application/x-www-form-urlencoded;charset=utf-8"
                );
                return data.toString();
              }

              var isObjectPayload = utils.isObject(data);
              var contentType = headers && headers["Content-Type"];

              var isFileList;

              if (
                (isFileList = utils.isFileList(data)) ||
                (isObjectPayload && contentType === "multipart/form-data")
              ) {
                var _FormData = this.env && this.env.FormData;
                return toFormData(
                  isFileList ? { "files[]": data } : data,
                  _FormData && new _FormData()
                );
              } else if (
                isObjectPayload ||
                contentType === "application/json"
              ) {
                setContentTypeIfUnset(headers, "application/json");
                return stringifySafely(data);
              }

              return data;
            },
          ],

          transformResponse: [
            function transformResponse(data) {
              var transitional = this.transitional || defaults.transitional;
              var silentJSONParsing =
                transitional && transitional.silentJSONParsing;
              var forcedJSONParsing =
                transitional && transitional.forcedJSONParsing;
              var strictJSONParsing =
                !silentJSONParsing && this.responseType === "json";

              if (
                strictJSONParsing ||
                (forcedJSONParsing && utils.isString(data) && data.length)
              ) {
                try {
                  return JSON.parse(data);
                } catch (e) {
                  if (strictJSONParsing) {
                    if (e.name === "SyntaxError") {
                      throw AxiosError.from(
                        e,
                        AxiosError.ERR_BAD_RESPONSE,
                        this,
                        null,
                        this.response
                      );
                    }
                    throw e;
                  }
                }
              }

              return data;
            },
          ],

          /**
           * A timeout in milliseconds to abort a request. If set to 0 (default) a
           * timeout is not created.
           */
          timeout: 0,

          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",

          maxContentLength: -1,
          maxBodyLength: -1,

          env: {
            FormData: __webpack_require__(68),
          },

          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          },

          headers: {
            common: {
              Accept: "application/json, text/plain, */*",
            },
          },
        };

        utils.forEach(
          ["delete", "get", "head"],
          function forEachMethodNoData(method) {
            defaults.headers[method] = {};
          }
        );

        utils.forEach(
          ["post", "put", "patch"],
          function forEachMethodWithData(method) {
            defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
          }
        );

        module.exports = defaults;
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(12));

      /***/
    },

    /***/ 150: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateSlidesClasses;
      function updateSlidesClasses() {
        var swiper = this;
        var slides = swiper.slides,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex,
          realIndex = swiper.realIndex;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(
          params.slideActiveClass +
            " " +
            params.slideNextClass +
            " " +
            params.slidePrevClass +
            " " +
            params.slideDuplicateActiveClass +
            " " +
            params.slideDuplicateNextClass +
            " " +
            params.slideDuplicatePrevClass
        );
        var activeSlide;

        if (isVirtual) {
          activeSlide = swiper.$wrapperEl.find(
            "." +
              params.slideClass +
              '[data-swiper-slide-index="' +
              activeIndex +
              '"]'
          );
        } else {
          activeSlide = slides.eq(activeIndex);
        } // Active classes

        activeSlide.addClass(params.slideActiveClass);

        if (params.loop) {
          // Duplicate to all looped slides
          if (activeSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  ":not(." +
                  params.slideDuplicateClass +
                  ')[data-swiper-slide-index="' +
                  realIndex +
                  '"]'
              )
              .addClass(params.slideDuplicateActiveClass);
          } else {
            $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  "." +
                  params.slideDuplicateClass +
                  '[data-swiper-slide-index="' +
                  realIndex +
                  '"]'
              )
              .addClass(params.slideDuplicateActiveClass);
          }
        } // Next Slide

        var nextSlide = activeSlide
          .nextAll("." + params.slideClass)
          .eq(0)
          .addClass(params.slideNextClass);

        if (params.loop && nextSlide.length === 0) {
          nextSlide = slides.eq(0);
          nextSlide.addClass(params.slideNextClass);
        } // Prev Slide

        var prevSlide = activeSlide
          .prevAll("." + params.slideClass)
          .eq(0)
          .addClass(params.slidePrevClass);

        if (params.loop && prevSlide.length === 0) {
          prevSlide = slides.eq(-1);
          prevSlide.addClass(params.slidePrevClass);
        }

        if (params.loop) {
          // Duplicate to all looped slides
          if (nextSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  ":not(." +
                  params.slideDuplicateClass +
                  ')[data-swiper-slide-index="' +
                  nextSlide.attr("data-swiper-slide-index") +
                  '"]'
              )
              .addClass(params.slideDuplicateNextClass);
          } else {
            $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  "." +
                  params.slideDuplicateClass +
                  '[data-swiper-slide-index="' +
                  nextSlide.attr("data-swiper-slide-index") +
                  '"]'
              )
              .addClass(params.slideDuplicateNextClass);
          }

          if (prevSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  ":not(." +
                  params.slideDuplicateClass +
                  ')[data-swiper-slide-index="' +
                  prevSlide.attr("data-swiper-slide-index") +
                  '"]'
              )
              .addClass(params.slideDuplicatePrevClass);
          } else {
            $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  "." +
                  params.slideDuplicateClass +
                  '[data-swiper-slide-index="' +
                  prevSlide.attr("data-swiper-slide-index") +
                  '"]'
              )
              .addClass(params.slideDuplicatePrevClass);
          }
        }

        swiper.emitSlidesClasses();
      }

      /***/
    },

    /***/ 151: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateActiveIndex;

      var _utils = __webpack_require__(1);

      function updateActiveIndex(newActiveIndex) {
        var swiper = this;
        var translate = swiper.rtlTranslate
          ? swiper.translate
          : -swiper.translate;
        var slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          params = swiper.params,
          previousIndex = swiper.activeIndex,
          previousRealIndex = swiper.realIndex,
          previousSnapIndex = swiper.snapIndex;
        var activeIndex = newActiveIndex;
        var snapIndex;

        if (typeof activeIndex === "undefined") {
          for (var i = 0; i < slidesGrid.length; i += 1) {
            if (typeof slidesGrid[i + 1] !== "undefined") {
              if (
                translate >= slidesGrid[i] &&
                translate <
                  slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2
              ) {
                activeIndex = i;
              } else if (
                translate >= slidesGrid[i] &&
                translate < slidesGrid[i + 1]
              ) {
                activeIndex = i + 1;
              }
            } else if (translate >= slidesGrid[i]) {
              activeIndex = i;
            }
          } // Normalize slideIndex

          if (params.normalizeSlideIndex) {
            if (activeIndex < 0 || typeof activeIndex === "undefined")
              activeIndex = 0;
          }
        }

        if (snapGrid.indexOf(translate) >= 0) {
          snapIndex = snapGrid.indexOf(translate);
        } else {
          var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
          snapIndex =
            skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
        }

        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

        if (activeIndex === previousIndex) {
          if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit("snapIndexChange");
          }

          return;
        } // Get real index

        var realIndex = parseInt(
          swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") ||
            activeIndex,
          10
        );
        (0, _utils.extend)(swiper, {
          snapIndex: snapIndex,
          realIndex: realIndex,
          previousIndex: previousIndex,
          activeIndex: activeIndex,
        });
        swiper.emit("activeIndexChange");
        swiper.emit("snapIndexChange");

        if (previousRealIndex !== realIndex) {
          swiper.emit("realIndexChange");
        }

        if (swiper.initialized || swiper.params.runCallbacksOnInit) {
          swiper.emit("slideChange");
        }
      }

      /***/
    },

    /***/ 152: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = updateClickedSlide;

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function updateClickedSlide(e) {
        var swiper = this;
        var params = swiper.params;
        var slide = (0, _dom2.default)(e.target).closest(
          "." + params.slideClass
        )[0];
        var slideFound = false;
        var slideIndex;

        if (slide) {
          for (var i = 0; i < swiper.slides.length; i += 1) {
            if (swiper.slides[i] === slide) {
              slideFound = true;
              slideIndex = i;
              break;
            }
          }
        }

        if (slide && slideFound) {
          swiper.clickedSlide = slide;

          if (swiper.virtual && swiper.params.virtual.enabled) {
            swiper.clickedIndex = parseInt(
              (0, _dom2.default)(slide).attr("data-swiper-slide-index"),
              10
            );
          } else {
            swiper.clickedIndex = slideIndex;
          }
        } else {
          swiper.clickedSlide = undefined;
          swiper.clickedIndex = undefined;
          return;
        }

        if (
          params.slideToClickedSlide &&
          swiper.clickedIndex !== undefined &&
          swiper.clickedIndex !== swiper.activeIndex
        ) {
          swiper.slideToClickedSlide();
        }
      }

      /***/
    },

    /***/ 153: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _getTranslate = __webpack_require__(154);

      var _getTranslate2 = _interopRequireDefault(_getTranslate);

      var _setTranslate = __webpack_require__(155);

      var _setTranslate2 = _interopRequireDefault(_setTranslate);

      var _minTranslate = __webpack_require__(156);

      var _minTranslate2 = _interopRequireDefault(_minTranslate);

      var _maxTranslate = __webpack_require__(157);

      var _maxTranslate2 = _interopRequireDefault(_maxTranslate);

      var _translateTo = __webpack_require__(158);

      var _translateTo2 = _interopRequireDefault(_translateTo);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        getTranslate: _getTranslate2.default,
        setTranslate: _setTranslate2.default,
        minTranslate: _minTranslate2.default,
        maxTranslate: _maxTranslate2.default,
        translateTo: _translateTo2.default,
      };

      /***/
    },

    /***/ 154: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = getSwiperTranslate;

      var _utils = __webpack_require__(1);

      function getSwiperTranslate(axis) {
        if (axis === void 0) {
          axis = this.isHorizontal() ? "x" : "y";
        }

        var swiper = this;
        var params = swiper.params,
          rtl = swiper.rtlTranslate,
          translate = swiper.translate,
          $wrapperEl = swiper.$wrapperEl;

        if (params.virtualTranslate) {
          return rtl ? -translate : translate;
        }

        if (params.cssMode) {
          return translate;
        }

        var currentTranslate = (0, _utils.getTranslate)($wrapperEl[0], axis);
        if (rtl) currentTranslate = -currentTranslate;
        return currentTranslate || 0;
      }

      /***/
    },

    /***/ 155: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = setTranslate;
      function setTranslate(translate, byController) {
        var swiper = this;
        var rtl = swiper.rtlTranslate,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          wrapperEl = swiper.wrapperEl,
          progress = swiper.progress;
        var x = 0;
        var y = 0;
        var z = 0;

        if (swiper.isHorizontal()) {
          x = rtl ? -translate : translate;
        } else {
          y = translate;
        }

        if (params.roundLengths) {
          x = Math.floor(x);
          y = Math.floor(y);
        }

        if (params.cssMode) {
          wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] =
            swiper.isHorizontal() ? -x : -y;
        } else if (!params.virtualTranslate) {
          $wrapperEl.transform(
            "translate3d(" + x + "px, " + y + "px, " + z + "px)"
          );
        }

        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

        var newProgress;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

        if (translatesDiff === 0) {
          newProgress = 0;
        } else {
          newProgress = (translate - swiper.minTranslate()) / translatesDiff;
        }

        if (newProgress !== progress) {
          swiper.updateProgress(translate);
        }

        swiper.emit("setTranslate", swiper.translate, byController);
      }

      /***/
    },

    /***/ 156: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = minTranslate;
      function minTranslate() {
        return -this.snapGrid[0];
      }

      /***/
    },

    /***/ 157: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = maxTranslate;
      function maxTranslate() {
        return -this.snapGrid[this.snapGrid.length - 1];
      }

      /***/
    },

    /***/ 158: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = translateTo;
      function translateTo(
        translate,
        speed,
        runCallbacks,
        translateBounds,
        internal
      ) {
        if (translate === void 0) {
          translate = 0;
        }

        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        if (translateBounds === void 0) {
          translateBounds = true;
        }

        var swiper = this;
        var params = swiper.params,
          wrapperEl = swiper.wrapperEl;

        if (swiper.animating && params.preventInteractionOnTransition) {
          return false;
        }

        var minTranslate = swiper.minTranslate();
        var maxTranslate = swiper.maxTranslate();
        var newTranslate;
        if (translateBounds && translate > minTranslate)
          newTranslate = minTranslate;
        else if (translateBounds && translate < maxTranslate)
          newTranslate = maxTranslate;
        else newTranslate = translate; // Update progress

        swiper.updateProgress(newTranslate);

        if (params.cssMode) {
          var isH = swiper.isHorizontal();

          if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
          } else {
            // eslint-disable-next-line
            if (wrapperEl.scrollTo) {
              var _wrapperEl$scrollTo;

              wrapperEl.scrollTo(
                ((_wrapperEl$scrollTo = {}),
                (_wrapperEl$scrollTo[isH ? "left" : "top"] = -newTranslate),
                (_wrapperEl$scrollTo.behavior = "smooth"),
                _wrapperEl$scrollTo)
              );
            } else {
              wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
            }
          }

          return true;
        }

        if (speed === 0) {
          swiper.setTransition(0);
          swiper.setTranslate(newTranslate);

          if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionEnd");
          }
        } else {
          swiper.setTransition(speed);
          swiper.setTranslate(newTranslate);

          if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionStart");
          }

          if (!swiper.animating) {
            swiper.animating = true;

            if (!swiper.onTranslateToWrapperTransitionEnd) {
              swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(
                e
              ) {
                if (!swiper || swiper.destroyed) return;
                if (e.target !== this) return;
                swiper.$wrapperEl[0].removeEventListener(
                  "transitionend",
                  swiper.onTranslateToWrapperTransitionEnd
                );
                swiper.$wrapperEl[0].removeEventListener(
                  "webkitTransitionEnd",
                  swiper.onTranslateToWrapperTransitionEnd
                );
                swiper.onTranslateToWrapperTransitionEnd = null;
                delete swiper.onTranslateToWrapperTransitionEnd;

                if (runCallbacks) {
                  swiper.emit("transitionEnd");
                }
              };
            }

            swiper.$wrapperEl[0].addEventListener(
              "transitionend",
              swiper.onTranslateToWrapperTransitionEnd
            );
            swiper.$wrapperEl[0].addEventListener(
              "webkitTransitionEnd",
              swiper.onTranslateToWrapperTransitionEnd
            );
          }
        }

        return true;
      }

      /***/
    },

    /***/ 159: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _setTransition = __webpack_require__(160);

      var _setTransition2 = _interopRequireDefault(_setTransition);

      var _transitionStart = __webpack_require__(161);

      var _transitionStart2 = _interopRequireDefault(_transitionStart);

      var _transitionEnd = __webpack_require__(162);

      var _transitionEnd2 = _interopRequireDefault(_transitionEnd);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        setTransition: _setTransition2.default,
        transitionStart: _transitionStart2.default,
        transitionEnd: _transitionEnd2.default,
      };

      /***/
    },

    /***/ 16: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var Handlers = __webpack_require__(7);
      var viewport = __webpack_require__(20);
      var googleAnalytics = __webpack_require__(3);
      var popup = __webpack_require__(103);
      var RequestEstimateForm = __webpack_require__(44);
      var RequestAdviserForm = __webpack_require__(45);
      var scrollBlocker = __webpack_require__(10);

      /**
       * @private
       */
      var isInit = false;
      var DOM = {};
      var handlers = new Handlers();
      var _isShow = false;
      var delay = 0;
      var requestEstimateForm = new RequestEstimateForm();
      var requestAdviserForm = new RequestAdviserForm();
      var selectorHide = "";

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: function init() {
          !isInit && _init();
        },
        show: show,
        hide: hide,
        getDOM: getDOM,
        on: handlers.add.bind(handlers),
        off: handlers.remove.bind(handlers),
        isShow: function isShow() {
          return _isShow;
        },
      };

      /**
       * @private
       * @type {Function}
       */
      function _init() {
        isInit = true;
        popup.init();
        setDOM();
        setSelectorHide();
        setDelay();
        requestEstimateForm.init(DOM.requestEstimate);
        requestAdviserForm.init(DOM.requestAdviser);
        initHandlers();
      }

      /**
       * @private
       * @type {Function}
       */
      function setDOM() {
        DOM.requestEstimate = document.querySelector(".js-request_estimate");
        DOM.requestAdviser = document.querySelector(
          ".js-request_estimate .js-request_success-adviser"
        );
        DOM.requestEstimateContainer = DOM.requestEstimate.querySelector(
          ".js-request_estimate_container"
        );
      }

      /**
       * @private
       */
      function setSelectorHide() {
        if (!_isShow) {
          if (viewport.isDesktop()) {
            selectorHide = "g-hidden";
            DOM.requestEstimate.classList.remove("g-hide");
          } else {
            selectorHide = "g-hide";
            DOM.requestEstimate.classList.remove("g-hidden");
          }

          DOM.requestEstimate.classList.add(selectorHide);
        }
      }

      /**
       * @private
       */
      function setDelay() {
        delay = viewport.isMobile() ? 0 : 300;
      }

      /**
       * @private
       * @type {Function}
       */
      function getDOM() {
        return DOM.requestEstimate;
      }

      /**
       * @private
       */
      function initHandlers() {
        window.addEventListener("resize", onWinResize);

        popup.on("close", hide);

        if (DOM.requestEstimateContainer) {
          DOM.requestEstimateContainer.addEventListener("click", function (e) {
            if (e.target.classList.contains("js-request_estimate_container")) {
              hide();
            }
          });
        }

        requestAdviserForm.on("done", hide);

        var emailLink = document.querySelectorAll(
          ".l-mail-link.b-request_estimate_mail_link"
        );

        if (emailLink) {
          for (var i = 0; i < emailLink.length; i++) {
            var link = emailLink[i];
            link.addEventListener("click", sendGoogleAnalyticsEvent);
          }
        }
      }

      /**
       * @private
       */
      function onWinResize() {
        setSelectorHide();
        setDelay();
      }

      /**
       * @private
       */
      function sendGoogleAnalyticsEvent() {
        googleAnalytics.sendEvent({
          eventCategory: "request",
          eventAction: "email",
          eventLabel: "form",
        });
      }

      /**
       * @private
       */
      function changeFormText(element) {
        var defaultTitle = "Request a Project Estimation";
        var defaultButton = "Send Request";

        if (
          (typeof element === "undefined" ? "undefined" : _typeof(element)) ===
          "object"
        ) {
          _setFormTitle(
            element.dataset.estimateTitle
              ? element.dataset.estimateTitle
              : defaultTitle
          );
          _setFormButton(
            element.dataset.estimateButton
              ? element.dataset.estimateButton
              : defaultButton
          );
        } else {
          _setFormTitle(defaultTitle);
          _setFormButton(defaultButton);
        }
      }

      /**
       * @private
       */
      function show(element) {
        if (!_isShow) {
          _isShow = true;
          DOM.requestEstimate.classList.remove(selectorHide);
          changeFormText(element);
          scrollBlocker.scrollOff();
          setTimeout(function () {
            handlers.call("beforeShow");
            DOM.requestEstimate.classList.add("active");
            requestEstimateForm.onShow();

            handlers.call("show");
          }, delay);
        }
      }

      /**
       * @private
       */
      function hide() {
        if (_isShow) {
          _isShow = false;
          DOM.requestEstimate.classList.remove("active");
          requestAdviserForm.clearForm();
          setTimeout(function () {
            handlers.call("beforeHide");
            DOM.requestEstimate.classList.add(selectorHide);
            requestEstimateForm.onHide();
            handlers.call("hide");

            if (requestEstimateForm.isFormStepFirst()) {
              requestEstimateForm.setTitle("Request a Project Estimation");
              requestEstimateForm.hideResult();
            }
          }, delay);

          _gaq.push(["_trackEvent", "popupClose", "click"]);
        }
      }

      /**
       * @private
       */
      function _setFormTitle(title) {
        DOM.requestEstimate.querySelector(".b-request_title span").innerHTML =
          title;
      }

      /**
       * @private
       */
      function _setFormButton(value) {
        DOM.requestEstimate.querySelector(".js-request_submit input").value =
          value;
      }

      /***/
    },

    /***/ 160: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = setTransition;
      function setTransition(duration, byController) {
        var swiper = this;

        if (!swiper.params.cssMode) {
          swiper.$wrapperEl.transition(duration);
        }

        swiper.emit("setTransition", duration, byController);
      }

      /***/
    },

    /***/ 161: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = transitionStart;
      function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        var swiper = this;
        var activeIndex = swiper.activeIndex,
          params = swiper.params,
          previousIndex = swiper.previousIndex;
        if (params.cssMode) return;

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        var dir = direction;

        if (!dir) {
          if (activeIndex > previousIndex) dir = "next";
          else if (activeIndex < previousIndex) dir = "prev";
          else dir = "reset";
        }

        swiper.emit("transitionStart");

        if (runCallbacks && activeIndex !== previousIndex) {
          if (dir === "reset") {
            swiper.emit("slideResetTransitionStart");
            return;
          }

          swiper.emit("slideChangeTransitionStart");

          if (dir === "next") {
            swiper.emit("slideNextTransitionStart");
          } else {
            swiper.emit("slidePrevTransitionStart");
          }
        }
      }

      /***/
    },

    /***/ 162: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = transitionEnd;
      function transitionEnd(runCallbacks, direction) {
        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        var swiper = this;
        var activeIndex = swiper.activeIndex,
          previousIndex = swiper.previousIndex,
          params = swiper.params;
        swiper.animating = false;
        if (params.cssMode) return;
        swiper.setTransition(0);
        var dir = direction;

        if (!dir) {
          if (activeIndex > previousIndex) dir = "next";
          else if (activeIndex < previousIndex) dir = "prev";
          else dir = "reset";
        }

        swiper.emit("transitionEnd");

        if (runCallbacks && activeIndex !== previousIndex) {
          if (dir === "reset") {
            swiper.emit("slideResetTransitionEnd");
            return;
          }

          swiper.emit("slideChangeTransitionEnd");

          if (dir === "next") {
            swiper.emit("slideNextTransitionEnd");
          } else {
            swiper.emit("slidePrevTransitionEnd");
          }
        }
      }

      /***/
    },

    /***/ 163: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _slideTo = __webpack_require__(164);

      var _slideTo2 = _interopRequireDefault(_slideTo);

      var _slideToLoop = __webpack_require__(165);

      var _slideToLoop2 = _interopRequireDefault(_slideToLoop);

      var _slideNext = __webpack_require__(166);

      var _slideNext2 = _interopRequireDefault(_slideNext);

      var _slidePrev = __webpack_require__(167);

      var _slidePrev2 = _interopRequireDefault(_slidePrev);

      var _slideReset = __webpack_require__(168);

      var _slideReset2 = _interopRequireDefault(_slideReset);

      var _slideToClosest = __webpack_require__(169);

      var _slideToClosest2 = _interopRequireDefault(_slideToClosest);

      var _slideToClickedSlide = __webpack_require__(170);

      var _slideToClickedSlide2 = _interopRequireDefault(_slideToClickedSlide);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        slideTo: _slideTo2.default,
        slideToLoop: _slideToLoop2.default,
        slideNext: _slideNext2.default,
        slidePrev: _slidePrev2.default,
        slideReset: _slideReset2.default,
        slideToClosest: _slideToClosest2.default,
        slideToClickedSlide: _slideToClickedSlide2.default,
      };

      /***/
    },

    /***/ 164: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      exports.default = slideTo;
      function slideTo(index, speed, runCallbacks, internal, initial) {
        if (index === void 0) {
          index = 0;
        }

        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        if (typeof index !== "number" && typeof index !== "string") {
          throw new Error(
            "The 'index' argument cannot have type other than 'number' or 'string'. [" +
              (typeof index === "undefined" ? "undefined" : _typeof(index)) +
              "] given."
          );
        }

        if (typeof index === "string") {
          /**
           * The `index` argument converted from `string` to `number`.
           * @type {number}
           */
          var indexAsNumber = parseInt(index, 10);
          /**
           * Determines whether the `index` argument is a valid `number`
           * after being converted from the `string` type.
           * @type {boolean}
           */

          var isValidNumber = isFinite(indexAsNumber);

          if (!isValidNumber) {
            throw new Error(
              "The passed-in 'index' (string) couldn't be converted to 'number'. [" +
                index +
                "] given."
            );
          } // Knowing that the converted `index` is a valid number,
          // we can update the original argument's value.

          index = indexAsNumber;
        }

        var swiper = this;
        var slideIndex = index;
        if (slideIndex < 0) slideIndex = 0;
        var params = swiper.params,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          previousIndex = swiper.previousIndex,
          activeIndex = swiper.activeIndex,
          rtl = swiper.rtlTranslate,
          wrapperEl = swiper.wrapperEl,
          enabled = swiper.enabled;

        if (
          (swiper.animating && params.preventInteractionOnTransition) ||
          (!enabled && !internal && !initial)
        ) {
          return false;
        }

        var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
        var snapIndex =
          skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

        if (
          (activeIndex || params.initialSlide || 0) === (previousIndex || 0) &&
          runCallbacks
        ) {
          swiper.emit("beforeSlideChangeStart");
        }

        var translate = -snapGrid[snapIndex]; // Update progress

        swiper.updateProgress(translate); // Normalize slideIndex

        if (params.normalizeSlideIndex) {
          for (var i = 0; i < slidesGrid.length; i += 1) {
            var normalizedTranslate = -Math.floor(translate * 100);
            var normalizedGird = Math.floor(slidesGrid[i] * 100);
            var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

            if (typeof slidesGrid[i + 1] !== "undefined") {
              if (
                normalizedTranslate >= normalizedGird &&
                normalizedTranslate <
                  normalizedGridNext - (normalizedGridNext - normalizedGird) / 2
              ) {
                slideIndex = i;
              } else if (
                normalizedTranslate >= normalizedGird &&
                normalizedTranslate < normalizedGridNext
              ) {
                slideIndex = i + 1;
              }
            } else if (normalizedTranslate >= normalizedGird) {
              slideIndex = i;
            }
          }
        } // Directions locks

        if (swiper.initialized && slideIndex !== activeIndex) {
          if (
            !swiper.allowSlideNext &&
            translate < swiper.translate &&
            translate < swiper.minTranslate()
          ) {
            return false;
          }

          if (
            !swiper.allowSlidePrev &&
            translate > swiper.translate &&
            translate > swiper.maxTranslate()
          ) {
            if ((activeIndex || 0) !== slideIndex) return false;
          }
        }

        var direction;
        if (slideIndex > activeIndex) direction = "next";
        else if (slideIndex < activeIndex) direction = "prev";
        else direction = "reset"; // Update Index

        if (
          (rtl && -translate === swiper.translate) ||
          (!rtl && translate === swiper.translate)
        ) {
          swiper.updateActiveIndex(slideIndex); // Update Height

          if (params.autoHeight) {
            swiper.updateAutoHeight();
          }

          swiper.updateSlidesClasses();

          if (params.effect !== "slide") {
            swiper.setTranslate(translate);
          }

          if (direction !== "reset") {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
          }

          return false;
        }

        if (params.cssMode) {
          var isH = swiper.isHorizontal();
          var t = -translate;

          if (rtl) {
            t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
          }

          if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
          } else {
            // eslint-disable-next-line
            if (wrapperEl.scrollTo) {
              var _wrapperEl$scrollTo;

              wrapperEl.scrollTo(
                ((_wrapperEl$scrollTo = {}),
                (_wrapperEl$scrollTo[isH ? "left" : "top"] = t),
                (_wrapperEl$scrollTo.behavior = "smooth"),
                _wrapperEl$scrollTo)
              );
            } else {
              wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
            }
          }

          return true;
        }

        if (speed === 0) {
          swiper.setTransition(0);
          swiper.setTranslate(translate);
          swiper.updateActiveIndex(slideIndex);
          swiper.updateSlidesClasses();
          swiper.emit("beforeTransitionStart", speed, internal);
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        } else {
          swiper.setTransition(speed);
          swiper.setTranslate(translate);
          swiper.updateActiveIndex(slideIndex);
          swiper.updateSlidesClasses();
          swiper.emit("beforeTransitionStart", speed, internal);
          swiper.transitionStart(runCallbacks, direction);

          if (!swiper.animating) {
            swiper.animating = true;

            if (!swiper.onSlideToWrapperTransitionEnd) {
              swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                if (!swiper || swiper.destroyed) return;
                if (e.target !== this) return;
                swiper.$wrapperEl[0].removeEventListener(
                  "transitionend",
                  swiper.onSlideToWrapperTransitionEnd
                );
                swiper.$wrapperEl[0].removeEventListener(
                  "webkitTransitionEnd",
                  swiper.onSlideToWrapperTransitionEnd
                );
                swiper.onSlideToWrapperTransitionEnd = null;
                delete swiper.onSlideToWrapperTransitionEnd;
                swiper.transitionEnd(runCallbacks, direction);
              };
            }

            swiper.$wrapperEl[0].addEventListener(
              "transitionend",
              swiper.onSlideToWrapperTransitionEnd
            );
            swiper.$wrapperEl[0].addEventListener(
              "webkitTransitionEnd",
              swiper.onSlideToWrapperTransitionEnd
            );
          }
        }

        return true;
      }

      /***/
    },

    /***/ 165: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = slideToLoop;
      function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) {
          index = 0;
        }

        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        var swiper = this;
        var newIndex = index;

        if (swiper.params.loop) {
          newIndex += swiper.loopedSlides;
        }

        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
      }

      /***/
    },

    /***/ 166: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = slideNext;
      /* eslint no-unused-vars: "off" */
      function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        var swiper = this;
        var params = swiper.params,
          animating = swiper.animating,
          enabled = swiper.enabled;
        if (!enabled) return swiper;
        var increment =
          swiper.activeIndex < params.slidesPerGroupSkip
            ? 1
            : params.slidesPerGroup;

        if (params.loop) {
          if (animating && params.loopPreventsSlide) return false;
          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }

        return swiper.slideTo(
          swiper.activeIndex + increment,
          speed,
          runCallbacks,
          internal
        );
      }

      /***/
    },

    /***/ 167: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = slidePrev;
      /* eslint no-unused-vars: "off" */
      function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        var swiper = this;
        var params = swiper.params,
          animating = swiper.animating,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
        if (!enabled) return swiper;

        if (params.loop) {
          if (animating && params.loopPreventsSlide) return false;
          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }

        var translate = rtlTranslate ? swiper.translate : -swiper.translate;

        function normalize(val) {
          if (val < 0) return -Math.floor(Math.abs(val));
          return Math.floor(val);
        }

        var normalizedTranslate = normalize(translate);
        var normalizedSnapGrid = snapGrid.map(function (val) {
          return normalize(val);
        });
        var prevSnap =
          snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

        if (typeof prevSnap === "undefined" && params.cssMode) {
          snapGrid.forEach(function (snap) {
            if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
          });
        }

        var prevIndex;

        if (typeof prevSnap !== "undefined") {
          prevIndex = slidesGrid.indexOf(prevSnap);
          if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        }

        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
      }

      /***/
    },

    /***/ 168: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = slideReset;
      /* eslint no-unused-vars: "off" */
      function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        var swiper = this;
        return swiper.slideTo(
          swiper.activeIndex,
          speed,
          runCallbacks,
          internal
        );
      }

      /***/
    },

    /***/ 1683: /***/ function (module, exports, __webpack_require__) {
      __webpack_require__(123);
      module.exports = __webpack_require__(1684);

      /***/
    },

    /***/ 1684: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      __webpack_require__(121);

      __webpack_require__(1685);

      __webpack_require__(222);

      __webpack_require__(133);

      __webpack_require__(1686);

      /***/
    },

    /***/ 1685: /***/ function (module, exports) {
      // removed by extract-text-webpack-plugin
      /***/
    },

    /***/ 1686: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      __webpack_require__(230);
      __webpack_require__(1687);
      __webpack_require__(1698);

      /***/
    },

    /***/ 1687: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _lottieLoad = __webpack_require__(264);

      var _lottieLoad2 = _interopRequireDefault(_lottieLoad);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var container_ovals = document.querySelectorAll(".brandsource__ovals");
      var img_ovals = __webpack_require__(1688);

      var CircleLoad_ovals = new _lottieLoad2.default();

      for (var i = 0; i < container_ovals.length; i++) {
        var container_oval = container_ovals[i];

        CircleLoad_ovals.container = container_oval;
        CircleLoad_ovals.animationData = img_ovals;

        CircleLoad_ovals.load();
      }

      var container_tri_headers = document.querySelectorAll(
        ".brandsource__header-triangles"
      );
      var img_tri_headers = __webpack_require__(1689);

      var CircleLoad_tri_headers = new _lottieLoad2.default();

      for (var _i = 0; _i < container_tri_headers.length; _i++) {
        var container_tri_header = container_tri_headers[_i];

        CircleLoad_tri_headers.container = container_tri_header;
        CircleLoad_tri_headers.animationData = img_tri_headers;

        CircleLoad_tri_headers.load();
      }

      var container_triangles = document.querySelector(
        ".brandsource__triangles"
      );
      var img_triangles = __webpack_require__(1690);

      var CircleLoad_triangles = new _lottieLoad2.default();

      CircleLoad_triangles.container = container_triangles;
      CircleLoad_triangles.animationData = img_triangles;

      CircleLoad_triangles.load();

      var container_tri_footer = document.querySelector(
        ".brandsource__footer-triangle"
      );
      var img_tri_footer = __webpack_require__(1691);

      var CircleLoad_tri_footer = new _lottieLoad2.default();

      CircleLoad_tri_footer.container = container_tri_footer;
      CircleLoad_tri_footer.animationData = img_tri_footer;

      CircleLoad_tri_footer.load();

      var container_dots = document.querySelectorAll(".brandsource__dots");
      var img_dots = __webpack_require__(1692);

      var CircleLoad_dots = new _lottieLoad2.default();

      for (var _i2 = 0; _i2 < container_dots.length; _i2++) {
        var container_dot = container_dots[_i2];

        CircleLoad_dots.container = container_dot;
        CircleLoad_dots.animationData = img_dots;

        CircleLoad_dots.load();
      }

      var container_arrows = document.querySelectorAll(".brandsource__arrows");
      var img_arrows = __webpack_require__(1693);

      var CircleLoad_arrows = new _lottieLoad2.default();

      for (var _i3 = 0; _i3 < container_arrows.length; _i3++) {
        var container_arrow = container_arrows[_i3];

        CircleLoad_arrows.container = container_arrow;
        CircleLoad_arrows.animationData = img_arrows;

        CircleLoad_arrows.load();
      }

      var container_screensaver = document.querySelector(
        ".brandsource__challenge__content__item__screensaver"
      );
      var img_screensaver = __webpack_require__(1694);

      var CircleLoad_screensaver = new _lottieLoad2.default();

      CircleLoad_screensaver.container = container_screensaver;
      CircleLoad_screensaver.animationData = img_screensaver;

      CircleLoad_screensaver.load();

      var container_algorithm = document.querySelector(
        ".brandsource__challenge__content__item__algorithm"
      );
      var img_algorithm = __webpack_require__(1695);

      var CircleLoad_algorithm = new _lottieLoad2.default();

      CircleLoad_algorithm.container = container_algorithm;
      CircleLoad_algorithm.animationData = img_algorithm;

      CircleLoad_algorithm.load();

      var container_video = document.querySelector(
        ".brandsource__challenge__content__item__video"
      );
      var img_video = __webpack_require__(1696);

      var CircleLoad_video = new _lottieLoad2.default();

      CircleLoad_video.container = container_video;
      CircleLoad_video.animationData = img_video;

      CircleLoad_video.load();

      var container_letters = document.querySelector(
        ".brandsource__colors_fonts__content__fonts__top"
      );
      var img_letters = __webpack_require__(1697);

      var CircleLoad_letters = new _lottieLoad2.default();

      CircleLoad_letters.container = container_letters;
      CircleLoad_letters.animationData = img_letters;

      CircleLoad_letters.load();

      function jsonResize() {
        CircleLoad_ovals.destroy();
        CircleLoad_tri_headers.destroy();
        CircleLoad_triangles.destroy();
        CircleLoad_tri_footer.destroy();
        CircleLoad_dots.destroy();
        CircleLoad_arrows.destroy();
        CircleLoad_screensaver.destroy();
        CircleLoad_algorithm.destroy();
        CircleLoad_video.destroy();
        CircleLoad_letters.destroy();

        for (var _i4 = 0; _i4 < container_ovals.length; _i4++) {
          var _container_oval = container_ovals[_i4];

          CircleLoad_ovals.container = _container_oval;
          CircleLoad_ovals.animationData = img_ovals;

          CircleLoad_ovals.load();
        }

        for (var _i5 = 0; _i5 < container_tri_headers.length; _i5++) {
          var _container_tri_header = container_tri_headers[_i5];

          CircleLoad_tri_headers.container = _container_tri_header;
          CircleLoad_tri_headers.animationData = img_tri_headers;

          CircleLoad_tri_headers.load();
        }

        CircleLoad_triangles.container = container_triangles;
        CircleLoad_triangles.animationData = img_triangles;

        CircleLoad_triangles.load();

        CircleLoad_tri_footer.container = container_tri_footer;
        CircleLoad_tri_footer.animationData = img_tri_footer;

        CircleLoad_tri_footer.load();

        for (var _i6 = 0; _i6 < container_dots.length; _i6++) {
          var _container_dot = container_dots[_i6];

          CircleLoad_dots.container = _container_dot;
          CircleLoad_dots.animationData = img_dots;

          CircleLoad_dots.load();
        }

        for (var _i7 = 0; _i7 < container_arrows.length; _i7++) {
          var _container_arrow = container_arrows[_i7];

          CircleLoad_arrows.container = _container_arrow;
          CircleLoad_arrows.animationData = img_arrows;

          CircleLoad_arrows.load();
        }

        CircleLoad_screensaver.container = container_screensaver;
        CircleLoad_screensaver.animationData = img_screensaver;

        CircleLoad_screensaver.load();

        CircleLoad_algorithm.container = container_algorithm;
        CircleLoad_algorithm.animationData = img_algorithm;

        CircleLoad_algorithm.load();

        CircleLoad_video.container = container_video;
        CircleLoad_video.animationData = img_video;

        CircleLoad_video.load();

        CircleLoad_letters.container = container_letters;
        CircleLoad_letters.animationData = img_letters;

        CircleLoad_letters.load();
      }

      window.addEventListener("resize", jsonResize);

      /***/
    },

    /***/ 1688: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 240,
        w: 56,
        h: 80,
        assets: [],
        layers: [
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [32, 24, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [28, 40, 0],
                  },
                  {
                    t: 30,
                    s: [28, 40, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [28, 40, 0],
                  },
                  {
                    t: 46,
                    s: [28, 40, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [28, 40, 0],
                  },
                  {
                    t: 90,
                    s: [28, 40, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [32, 24, 0],
                  },
                  {
                    t: 120,
                    s: [32, 24, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [32, 24, 0],
                  },
                  {
                    t: 150,
                    s: [32, 24, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [32, 24, 0],
                  },
                  { t: 240, s: [32, 24, 0] },
                ],
              },
              a: { a: 0, k: [0, 0, 0] },
              s: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [120, 120, 100],
                  },
                  {
                    t: 35,
                    s: [120, 120, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  {
                    t: 42,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  {
                    t: 120,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [110, 110, 100],
                  },
                  {
                    t: 125,
                    s: [110, 110, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  { t: 132, s: [100, 100, 100] },
                ],
              },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 240,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [10.493, 0],
                          [0, 10.493],
                          [-10.493, 0],
                          [0, -10.493],
                        ],
                        o: [
                          [0, 10.493],
                          [-10.493, 0],
                          [0, -10.493],
                          [10.493, 0],
                          [0, 0],
                        ],
                        v: [
                          [19, 0],
                          [0, 19],
                          [-19, 0],
                          [0, -19],
                          [19, 0],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [4.971, 0],
                          [0, 4.971],
                          [-4.971, 0],
                          [0, -4.971],
                        ],
                        o: [
                          [0, 4.971],
                          [-4.971, 0],
                          [0, -4.971],
                          [4.971, 0],
                          [0, 0],
                        ],
                        v: [
                          [9, 0],
                          [0, 9],
                          [-9, 0],
                          [0, -9],
                          [9, 0],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "st",
                    c: { a: 0, k: [0, 0.318, 0.957, 1] },
                    o: { a: 0, k: 100 },
                    w: { a: 0, k: 2 },
                    lc: 1,
                    lj: 1,
                    ml: 4,
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [1, 1, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [10, 70, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [28, 40, 0],
                  },
                  {
                    t: 30,
                    s: [28, 40, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [28, 40, 0],
                  },
                  {
                    t: 46,
                    s: [28, 40, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [28, 40, 0],
                  },
                  {
                    t: 90,
                    s: [28, 40, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [10, 70, 0],
                  },
                  {
                    t: 120,
                    s: [10, 70, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [10, 70, 0],
                  },
                  {
                    t: 150,
                    s: [10, 70, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [10, 70, 0],
                  },
                  { t: 240, s: [10, 70, 0] },
                ],
              },
              a: { a: 0, k: [0, 0, 0] },
              s: {
                a: 1,
                k: [
                  {
                    t: 34,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [120, 120, 100],
                  },
                  {
                    t: 39,
                    s: [120, 120, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  {
                    t: 46,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  {
                    t: 123,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [120, 120, 100],
                  },
                  {
                    t: 128,
                    s: [120, 120, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  { t: 135, s: [100, 100, 100] },
                ],
              },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 240,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [12, 12] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [1, 1, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1689: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 300,
        w: 120,
        h: 160,
        assets: [],
        layers: [
          {
            ind: 4,
            nm: "Triangle",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [99.501, 48.505, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [99.501, 35.302, 0],
                  },
                  {
                    t: 162,
                    s: [99.501, 35.302, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [99.501, 48.505, 0],
                  },
                  { t: 300, s: [99.501, 48.505, 0] },
                ],
              },
              a: { a: 0, k: [99.501, 41.888, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [2.852, -1.688],
                          [1.076, 0],
                          [0, 0],
                          [0, 3.314],
                          [-0.548, 0.926],
                          [0, 0],
                          [-2.851, -1.688],
                          [-0.514, -0.868],
                        ],
                        o: [
                          [0, 0],
                          [1.689, 2.851],
                          [-0.925, 0.548],
                          [0, 0],
                          [-3.314, 0],
                          [-0.001, -1.076],
                          [0, 0],
                          [1.688, -2.852],
                          [0.868, 0.513],
                          [0, 0],
                        ],
                        v: [
                          [104.663, 28.72],
                          [116.637, 48.943],
                          [114.531, 57.163],
                          [111.474, 58],
                          [87.526, 58],
                          [81.526, 52],
                          [82.363, 48.943],
                          [94.337, 28.72],
                          [102.557, 26.614],
                          [104.663, 28.72],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.51, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
            ln: "Triangle",
          },
          {
            ind: 3,
            nm: "Triangle",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [41.001, 114.733, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.642], y: [1] },
                    o: { x: [0.31], y: [0.637] },
                    e: [41.001, 115.117, 0],
                  },
                  {
                    t: 13,
                    s: [41.001, 115.117, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [41.001, 105.976, 0],
                  },
                  {
                    t: 180,
                    s: [41.001, 105.976, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.627], y: [0.802] },
                    o: { x: [0.42], y: [0] },
                    e: [41.001, 114.733, 0],
                  },
                  { t: 300, s: [41.001, 114.733, 0] },
                ],
              },
              a: { a: 0, k: [41.001, 100.774, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [4.267, -2.549],
                          [1.625, 0],
                          [0, 0],
                          [0, 4.971],
                          [-0.834, 1.396],
                          [0, 0],
                          [-4.267, -2.549],
                          [-0.764, -1.278],
                        ],
                        o: [
                          [0, 0],
                          [2.549, 4.267],
                          [-1.395, 0.834],
                          [0, 0],
                          [-4.97, 0],
                          [0, -1.625],
                          [0, 0],
                          [2.549, -4.267],
                          [1.278, 0.764],
                          [0, 0],
                        ],
                        v: [
                          [48.726, 70.933],
                          [78.866, 121.384],
                          [75.755, 133.726],
                          [71.14, 135],
                          [10.86, 135],
                          [1.86, 126],
                          [3.134, 121.384],
                          [33.274, 70.933],
                          [45.616, 67.822],
                          [48.726, 70.933],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.51, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
            ln: "Triangle",
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [],
          },
        ],
      };

      /***/
    },

    /***/ 169: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = slideToClosest;
      /* eslint no-unused-vars: "off" */
      function slideToClosest(speed, runCallbacks, internal, threshold) {
        if (speed === void 0) {
          speed = this.params.speed;
        }

        if (runCallbacks === void 0) {
          runCallbacks = true;
        }

        if (threshold === void 0) {
          threshold = 0.5;
        }

        var swiper = this;
        var index = swiper.activeIndex;
        var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
        var snapIndex =
          skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
        var translate = swiper.rtlTranslate
          ? swiper.translate
          : -swiper.translate;

        if (translate >= swiper.snapGrid[snapIndex]) {
          // The current translate is on or after the current snap index, so the choice
          // is between the current index and the one after it.
          var currentSnap = swiper.snapGrid[snapIndex];
          var nextSnap = swiper.snapGrid[snapIndex + 1];

          if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
            index += swiper.params.slidesPerGroup;
          }
        } else {
          // The current translate is before the current snap index, so the choice
          // is between the current index and the one before it.
          var prevSnap = swiper.snapGrid[snapIndex - 1];
          var _currentSnap = swiper.snapGrid[snapIndex];

          if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
            index -= swiper.params.slidesPerGroup;
          }
        }

        index = Math.max(index, 0);
        index = Math.min(index, swiper.slidesGrid.length - 1);
        return swiper.slideTo(index, speed, runCallbacks, internal);
      }

      /***/
    },

    /***/ 1690: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 300,
        w: 120,
        h: 160,
        assets: [],
        layers: [
          {
            ind: 4,
            nm: "Triangle",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [99.501, 114.733, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [99.501, 101.53, 0],
                  },
                  {
                    t: 162,
                    s: [99.501, 101.53, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [99.501, 114.733, 0],
                  },
                  { t: 300, s: [99.501, 114.733, 0] },
                ],
              },
              a: { a: 0, k: [99.501, 41.888, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [2.852, -1.688],
                          [1.076, 0],
                          [0, 0],
                          [0, 3.314],
                          [-0.548, 0.926],
                          [0, 0],
                          [-2.851, -1.688],
                          [-0.514, -0.868],
                        ],
                        o: [
                          [0, 0],
                          [1.689, 2.851],
                          [-0.925, 0.548],
                          [0, 0],
                          [-3.314, 0],
                          [-0.001, -1.076],
                          [0, 0],
                          [1.688, -2.852],
                          [0.868, 0.513],
                          [0, 0],
                        ],
                        v: [
                          [104.663, 28.72],
                          [116.637, 48.943],
                          [114.531, 57.163],
                          [111.474, 58],
                          [87.526, 58],
                          [81.526, 52],
                          [82.363, 48.943],
                          [94.337, 28.72],
                          [102.557, 26.614],
                          [104.663, 28.72],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [1, 1, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
            ln: "Triangle",
          },
          {
            ind: 3,
            nm: "Triangle",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [41.001, 49.493, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.642], y: [1] },
                    o: { x: [0.31], y: [0.637] },
                    e: [41.001, 49.877, 0],
                  },
                  {
                    t: 13,
                    s: [41.001, 49.877, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [41.001, 40.736, 0],
                  },
                  {
                    t: 180,
                    s: [41.001, 40.736, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.627], y: [0.802] },
                    o: { x: [0.42], y: [0] },
                    e: [41.001, 49.493, 0],
                  },
                  { t: 300, s: [41.001, 49.493, 0] },
                ],
              },
              a: { a: 0, k: [41.001, 100.774, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [4.267, -2.549],
                          [1.625, 0],
                          [0, 0],
                          [0, 4.971],
                          [-0.834, 1.396],
                          [0, 0],
                          [-4.267, -2.549],
                          [-0.764, -1.278],
                        ],
                        o: [
                          [0, 0],
                          [2.549, 4.267],
                          [-1.395, 0.834],
                          [0, 0],
                          [-4.97, 0],
                          [0, -1.625],
                          [0, 0],
                          [2.549, -4.267],
                          [1.278, 0.764],
                          [0, 0],
                        ],
                        v: [
                          [48.726, 70.933],
                          [78.866, 121.384],
                          [75.755, 133.726],
                          [71.14, 135],
                          [10.86, 135],
                          [1.86, 126],
                          [3.134, 121.384],
                          [33.274, 70.933],
                          [45.616, 67.822],
                          [48.726, 70.933],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.51, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
            ln: "Triangle",
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 300,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [],
          },
        ],
      };

      /***/
    },

    /***/ 1691: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 253.02,
        w: 82,
        h: 100,
        assets: [],
        layers: [
          {
            ind: 3,
            nm: "Triangle",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [41.001, 49.493, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.642], y: [1] },
                    o: { x: [0.31], y: [0.637] },
                    e: [41.001, 49.877, 0],
                  },
                  {
                    t: 13,
                    s: [41.001, 49.877, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [41.001, 40.736, 0],
                  },
                  {
                    t: 133,
                    s: [41.001, 40.736, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.627], y: [0.802] },
                    o: { x: [0.42], y: [0] },
                    e: [41.001, 49.493, 0],
                  },
                  { t: 253, s: [41.001, 49.493, 0] },
                ],
              },
              a: { a: 0, k: [41.001, 100.774, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 253.02,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [4.267, -2.549],
                          [1.625, 0],
                          [0, 0],
                          [0, 4.971],
                          [-0.834, 1.396],
                          [0, 0],
                          [-4.267, -2.549],
                          [-0.764, -1.278],
                        ],
                        o: [
                          [0, 0],
                          [2.549, 4.267],
                          [-1.395, 0.834],
                          [0, 0],
                          [-4.97, 0],
                          [0, -1.625],
                          [0, 0],
                          [2.549, -4.267],
                          [1.278, 0.764],
                          [0, 0],
                        ],
                        v: [
                          [48.726, 70.933],
                          [78.866, 121.384],
                          [75.755, 133.726],
                          [71.14, 135],
                          [10.86, 135],
                          [1.86, 126],
                          [3.134, 121.384],
                          [33.274, 70.933],
                          [45.616, 67.822],
                          [48.726, 70.933],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.51, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
            ln: "Triangle",
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 253.02,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 253.02,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [],
          },
        ],
      };

      /***/
    },

    /***/ 1692: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 90,
        w: 96,
        h: 96,
        assets: [],
        layers: [
          {
            ind: 16,
            nm: "Layer 16",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-93, -93, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 60,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 75,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 90, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 15,
            nm: "Layer 15",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-63, -93, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 50,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 65,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 80, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 14,
            nm: "Layer 14",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-33, -93, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 40,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 55,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 70, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 13,
            nm: "Layer 13",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-3, -93, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 45,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 60, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 12,
            nm: "Layer 12",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-93, -63, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 50,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 65,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 80, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 11,
            nm: "Layer 11",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-63, -63, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 40,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 55,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 70, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 10,
            nm: "Layer 10",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-33, -63, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 45,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 60, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 9,
            nm: "Layer 9",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-3, -63, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 20,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 35,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 50, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 8,
            nm: "Layer 8",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-93, -33, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 40,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 55,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 70, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 7,
            nm: "Layer 7",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-63, -33, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 45,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 60, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 6,
            nm: "Layer 6",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-33, -33, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 20,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 35,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 50, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 5,
            nm: "Layer 5",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-3, -33, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 10,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 25,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 40, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 4,
            nm: "Layer 4",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-93, -3, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 45,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 60, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 3,
            nm: "Layer 3",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-63, -3, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 20,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 35,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 50, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-33, -3, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 10,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 25,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 40, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [0, 0] },
              a: { a: 0, k: [-3, -3, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [50],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 15,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [50],
                  },
                  { t: 30, s: [50] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 90,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [6, 6] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.267, 0.506, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1693: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 88,
        w: 20,
        h: 90,
        assets: [],
        layers: [
          {
            ind: 7,
            nm: "Layer 7",
            ks: {
              p: { a: 0, k: [10, 82] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 36,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 62,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 88, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 6,
            nm: "Layer 6",
            ks: {
              p: { a: 0, k: [10, 70] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 56,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 82, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 5,
            nm: "Layer 5",
            ks: {
              p: { a: 0, k: [10, 58] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 24,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 50,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 76, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 4,
            nm: "Layer 4",
            ks: {
              p: { a: 0, k: [10, 46] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 18,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 44,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 70, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 3,
            nm: "Layer 3",
            ks: {
              p: { a: 0, k: [10, 34] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 12,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 38,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 64, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [10, 22] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 6,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 32,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 58, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [10, 10] },
              a: { a: 0, k: [10, 10, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 26,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 52, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 88,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [15.056, 5],
                          [18, 7.409],
                          [10, 15],
                          [2, 7.409],
                          [4.944, 5],
                          [10, 9.798],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1694: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 10,
        ip: 0,
        op: 100,
        w: 100,
        h: 100,
        assets: [],
        layers: [
          {
            ind: 6,
            nm: "Layer 6",
            ks: {
              p: { a: 0, k: [49, 100] },
              a: { a: 0, k: [-4.255, 67, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: {
                a: 1,
                k: [
                  {
                    t: 50,
                    s: [-39],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [38],
                  },
                  { t: 100, s: [38] },
                ],
              },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 100,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, -2.359],
                          [-2.081, -0.792],
                          [0.692, 0],
                          [0, 3.051],
                          [-3.051, 0],
                          [-0.611, -0.232],
                        ],
                        o: [
                          [-2.081, 0.792],
                          [0, 2.359],
                          [-0.611, 0.232],
                          [-3.051, 0],
                          [0, -3.051],
                          [0.692, 0],
                          [0, 0],
                        ],
                        v: [
                          [0.49, -6.64],
                          [-3.069, -1.475],
                          [0.49, 3.69],
                          [-1.475, 4.05],
                          [-7, -1.475],
                          [-1.475, -7],
                          [0.49, -6.64],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [1, 1, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 5,
            nm: "Layer 5",
            ks: {
              p: { a: 0, k: [49.5, 100] },
              a: { a: 0, k: [19, 64.5, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [-22],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [56],
                  },
                  { t: 50, s: [56] },
                ],
              },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 100,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [11, 11] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [1, 1, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 4,
            nm: "Layer 4",
            ks: {
              p: { a: 0, k: [56.713, 66] },
              a: { a: 0, k: [43.113, 52, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 100,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [5.769, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [-1.152, 5.426],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [43.4, 32],
                          [72.139, 62.503],
                          [60.4, 72],
                          [14.087, 72],
                          [43.4, 32],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.004, 0.318, 0.957, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 3,
            nm: "Layer 3",
            ks: {
              p: { a: 0, k: [77, 68.108] },
              a: { a: 0, k: [63.4, 54.108, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 100,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0.284, -1.023],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 1.114],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [54.4, 45],
                          [72.4, 51.653],
                          [72.4, 60],
                          [71.964, 63.215],
                          [54.4, 45],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.961, 0.545, 0.518, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [35.5, 66] },
              a: { a: 0, k: [21.9, 52, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 100,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 6.627],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [-6.627, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [43.4, 32],
                          [14.434, 72],
                          [12.4, 72],
                          [0.4, 60],
                          [0.4, 57.449],
                          [43.4, 32],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.694, 0.808, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [50, 43.5] },
              a: { a: 0, k: [36.4, 29.5, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 100,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, -6.627],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-6.627, 0],
                        ],
                        o: [
                          [0, 0],
                          [6.627, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, -6.627],
                          [0, 0],
                        ],
                        v: [
                          [12.4, 0],
                          [60.4, 0],
                          [72.4, 12],
                          [72.4, 59],
                          [0.4, 59],
                          [0.4, 12],
                          [12.4, 0],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1695: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 10,
        ip: 0,
        op: 20,
        w: 100,
        h: 100,
        assets: [],
        layers: [
          {
            ind: 6,
            nm: "Layer 6",
            ks: {
              p: { a: 0, k: [78, 65] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [0],
                  },
                  {
                    t: 10,
                    s: [0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100],
                  },
                  { t: 20, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 20,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [4, 4] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.694, 0.808, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 5,
            nm: "Layer 5",
            ks: {
              p: { a: 0, k: [50, 65.5] },
              a: { a: 0, k: [38.4, 49.5, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 20,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [4.418, 0],
                          [0, 0],
                          [0, 4.418],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 4.418],
                          [0, 0],
                          [-4.418, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [0.4, 43],
                          [76.4, 43],
                          [76.4, 48],
                          [68.4, 56],
                          [8.4, 56],
                          [0.4, 48],
                          [0.4, 43],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.004, 0.318, 0.957, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 4,
            nm: "Layer 4",
            ks: {
              p: { a: 0, k: [50, 42.5] },
              a: { a: 0, k: [38.4, 26.5, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [20],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [0],
                  },
                  {
                    t: 2,
                    s: [0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 4,
                    s: [20],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  {
                    t: 6,
                    s: [0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 8,
                    s: [20],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  {
                    t: 10,
                    s: [0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 12,
                    s: [20],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  {
                    t: 14,
                    s: [0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  {
                    t: 16,
                    s: [20],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  {
                    t: 18,
                    s: [0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [20],
                  },
                  { t: 20, s: [20] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 20,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [8.4, 8],
                          [68.4, 8],
                          [68.4, 43],
                          [8.4, 43],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [1, 1, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 3,
            nm: "Layer 3",
            ks: {
              p: { a: 0, k: [50, 42.5] },
              a: { a: 0, k: [38.4, 26.5, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 20,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [8.4, 8],
                          [68.4, 8],
                          [68.4, 43],
                          [8.4, 43],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.694, 0.808, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [50, 38] },
              a: { a: 0, k: [38.4, 22, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 20,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, -4.418],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-4.418, 0],
                        ],
                        o: [
                          [0, 0],
                          [4.418, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, -4.418],
                          [0, 0],
                        ],
                        v: [
                          [8.4, 0],
                          [68.4, 0],
                          [76.4, 8],
                          [76.4, 43],
                          [0.4, 43],
                          [0.4, 8],
                          [8.4, 0],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [50, 80] },
              a: { a: 0, k: [20, 4, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 20,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "rc",
                    s: { a: 0, k: [40, 8] },
                    p: { a: 0, k: [20, 4] },
                    r: { a: 0, k: 4 },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.004, 0.318, 0.957, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1696: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 10,
        ip: 0,
        op: 40,
        w: 100,
        h: 100,
        assets: [],
        layers: [
          {
            ind: 4,
            nm: "Layer 4",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [9, 54, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [9, 46, 0],
                  },
                  {
                    t: 20,
                    s: [9, 46, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [9, 54, 0],
                  },
                  { t: 40, s: [9, 54, 0] },
                ],
              },
              a: { a: 0, k: [8, 8, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 40,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 4.418],
                          [-4.418, 0],
                        ],
                        o: [
                          [0, 0],
                          [-4.418, 0],
                          [0, -4.418],
                          [0, 0],
                        ],
                        v: [
                          [8, 24],
                          [8, 40],
                          [0, 32],
                          [8, 24],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.004, 0.318, 0.957, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [4, 8] },
                    a: { a: 0, k: [4, 32] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "el",
                    s: { a: 0, k: [16, 16] },
                    p: { a: 0, k: [0, 0] },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.694, 0.808, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [8, 8] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 3,
            nm: "Layer 3",
            ks: {
              p: { a: 0, k: [83, 50] },
              a: { a: 0, k: [82, 32, 0] },
              s: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [100, 100, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [128, 128, 100],
                  },
                  {
                    t: 20,
                    s: [128, 128, 100],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [100, 100, 100],
                  },
                  { t: 40, s: [100, 100, 100] },
                ],
              },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 40,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [68, 32],
                          [82, 24],
                          [82, 40],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.694, 0.808, 1, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [46, 50] },
              a: { a: 0, k: [37, 32, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 40,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    d: 1,
                    ty: "rc",
                    s: { a: 0, k: [74, 64] },
                    p: { a: 0, k: [37, 32] },
                    r: { a: 0, k: 8 },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.937, 0.243, 0.2, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [99, 50, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [95, 50, 0],
                  },
                  {
                    t: 20,
                    s: [95, 50, 0],
                    to: [0, 0, 0],
                    ti: [0, 0, 0],
                    i: { x: [0.58], y: [1] },
                    o: { x: [0.42], y: [0] },
                    e: [99, 50, 0],
                  },
                  { t: 40, s: [99, 50, 0] },
                ],
              },
              a: { a: 0, k: [98, 32, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: { a: 0, k: 100 },
            },
            ao: 0,
            ip: 0,
            op: 40,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [82, 24],
                          [98, 14.857],
                          [98, 49.143],
                          [82, 40],
                          [82, 24],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.004, 0.318, 0.957, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 2,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1697: /***/ function (module, exports) {
      module.exports = {
        v: "5.0.1",
        fr: 60,
        ip: 0,
        op: 150,
        w: 260,
        h: 160,
        assets: [],
        layers: [
          {
            ind: 10,
            nm: "Layer 10",
            ks: {
              p: { a: 0, k: [132.194, 120.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  {
                    t: 2,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  {
                    t: 135,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 137,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  { t: 150, s: [100] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-11.467, -6.027],
                          [-6.4, -10.56],
                          [0, -13.333],
                          [2.72, -6.773],
                          [4.907, -3.52],
                          [6.613, 0],
                          [3.733, 2.347],
                          [1.707, 4.587],
                          [12.48, 0],
                          [5.653, 3.413],
                          [3.253, 6.133],
                          [0, 7.893],
                          [-3.253, 6.133],
                          [-5.6, 3.413],
                          [-6.933, 0],
                          [-5.867, -7.04],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-5.12, 0],
                          [-2.08, 4.48],
                          [0, 9.067],
                          [4.96, 8.267],
                          [9.013, 4.64],
                          [11.733, 0],
                          [9.013, -4.96],
                          [4.96, -8.747],
                          [0, -11.093],
                          [-4.907, -8.8],
                          [-8.907, -4.96],
                          [-11.627, 0],
                          [-9.493, 4.693],
                          [0, 0],
                          [6.56, -1.333],
                          [6.507, 0],
                          [11.627, 6.347],
                          [6.4, 11.2],
                          [0, 13.973],
                          [-6.453, 11.093],
                          [-11.733, 6.293],
                          [-15.253, 0],
                        ],
                        o: [
                          [14.72, 0],
                          [11.467, 6.027],
                          [6.4, 10.56],
                          [0, 9.387],
                          [-2.72, 6.773],
                          [-4.906, 3.52],
                          [-5.44, 0],
                          [-3.733, -2.347],
                          [-5.76, 9.28],
                          [-6.826, 0],
                          [-5.653, -3.413],
                          [-3.253, -6.133],
                          [0, -7.787],
                          [3.254, -6.133],
                          [5.6, -3.413],
                          [10.56, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 6.827],
                          [3.734, 0],
                          [2.08, -4.48],
                          [0, -10.773],
                          [-4.96, -8.267],
                          [-9.013, -4.64],
                          [-11.733, 0],
                          [-9.013, 4.96],
                          [-4.96, 8.747],
                          [0, 11.307],
                          [4.907, 8.8],
                          [8.907, 4.96],
                          [11.52, 0],
                          [0, 0],
                          [-4.8, 2.453],
                          [-6.56, 1.333],
                          [-15.147, 0],
                          [-11.626, -6.347],
                          [-6.4, -11.2],
                          [0, -13.867],
                          [6.453, -11.093],
                          [11.734, -6.293],
                          [0, 0],
                        ],
                        v: [
                          [0.883, -113.6],
                          [40.163, -104.56],
                          [66.963, -79.68],
                          [76.563, -43.84],
                          [72.483, -19.6],
                          [61.043, -4.16],
                          [43.763, 1.12],
                          [30.003, -2.4],
                          [21.843, -12.8],
                          [-5.517, 1.12],
                          [-24.237, -4],
                          [-37.597, -18.32],
                          [-42.477, -39.36],
                          [-37.597, -60.24],
                          [-24.317, -74.56],
                          [-5.517, -79.68],
                          [19.123, -69.12],
                          [19.123, -78.56],
                          [40.883, -78.56],
                          [40.883, -26.72],
                          [48.563, -16.48],
                          [57.283, -23.2],
                          [60.403, -43.52],
                          [52.963, -72.08],
                          [32.003, -91.44],
                          [0.883, -98.4],
                          [-30.237, -90.96],
                          [-51.197, -70.4],
                          [-58.637, -40.64],
                          [-51.277, -10.48],
                          [-30.557, 10.16],
                          [0.243, 17.6],
                          [31.763, 10.56],
                          [36.883, 25.28],
                          [19.843, 30.96],
                          [0.243, 32.96],
                          [-39.917, 23.44],
                          [-66.957, -2.88],
                          [-76.557, -40.64],
                          [-66.877, -78.08],
                          [-39.597, -104.16],
                          [0.883, -113.6],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-3.733, 3.893],
                          [0, 6.933],
                          [3.733, 3.84],
                          [5.867, 0],
                          [3.627, -3.893],
                          [0, -6.72],
                          [-3.627, -3.947],
                          [-5.973, 0],
                        ],
                        o: [
                          [5.867, 0],
                          [3.733, -3.893],
                          [0, -6.827],
                          [-3.733, -3.84],
                          [-5.973, 0],
                          [-3.626, 3.893],
                          [0, 6.827],
                          [3.627, 3.947],
                          [0, 0],
                        ],
                        v: [
                          [-0.557, -17.28],
                          [13.843, -23.12],
                          [19.443, -39.36],
                          [13.843, -55.36],
                          [-0.557, -61.12],
                          [-14.957, -55.28],
                          [-20.397, -39.36],
                          [-14.957, -23.2],
                          [-0.557, -17.28],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 9,
            nm: "Layer 9",
            ks: {
              p: { a: 0, k: [132.194, 123.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 120,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 122,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 135,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 137, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [2.987, 2.987],
                          [0, 4.48],
                          [-2.987, 2.827],
                          [-4.373, 0],
                          [-2.987, -2.827],
                          [0, -4.587],
                          [2.987, -2.987],
                          [4.373, 0],
                        ],
                        o: [
                          [-4.373, 0],
                          [-2.986, -2.987],
                          [0, -4.587],
                          [2.987, -2.827],
                          [4.374, 0],
                          [2.987, 2.827],
                          [0, 4.48],
                          [-2.986, 2.987],
                          [0, 0],
                        ],
                        v: [
                          [-64.806, -56.16],
                          [-75.846, -60.64],
                          [-80.326, -71.84],
                          [-75.846, -82.96],
                          [-64.806, -87.2],
                          [-53.766, -82.96],
                          [-49.286, -71.84],
                          [-53.766, -60.64],
                          [-64.806, -56.16],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-2.88, -2.827],
                          [0, -4.587],
                          [0.533, -2.133],
                          [1.813, -4.267],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [1.547, 2.4],
                          [0, 3.2],
                          [-2.933, 2.827],
                          [-4.48, 0],
                        ],
                        o: [
                          [4.48, 0],
                          [2.88, 2.827],
                          [0, 2.133],
                          [-0.533, 2.133],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-2.666, -1.067],
                          [-1.546, -2.4],
                          [0, -4.587],
                          [2.934, -2.827],
                          [0, 0],
                        ],
                        v: [
                          [-64.646, -29.76],
                          [-53.606, -25.52],
                          [-49.286, -14.4],
                          [-50.086, -8],
                          [-53.606, 1.6],
                          [-62.726, 24.64],
                          [-78.566, 24.64],
                          [-71.526, -0.8],
                          [-77.846, -6],
                          [-80.166, -14.4],
                          [-75.766, -25.52],
                          [-64.646, -29.76],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [-35.524, -55.04],
                          [9.756, -55.04],
                          [9.756, -35.04],
                          [-35.524, -35.04],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [66.248, -87.04],
                          [83.688, -77.6],
                          [75.848, -64.48],
                          [58.248, -74.88],
                          [58.568, -55.52],
                          [43.528, -55.52],
                          [43.688, -75.04],
                          [26.088, -64.48],
                          [18.408, -77.6],
                          [35.848, -87.04],
                          [18.408, -96.64],
                          [26.088, -109.76],
                          [43.688, -99.2],
                          [43.528, -118.72],
                          [58.568, -118.72],
                          [58.248, -99.2],
                          [75.848, -109.76],
                          [83.688, -96.64],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 8,
            nm: "Layer 8",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 105,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 107,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 120,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 122, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [-41.123, -75.52],
                          [-94.403, -56],
                          [-41.123, -36.64],
                          [-41.123, -16.64],
                          [-117.283, -45.6],
                          [-117.283, -66.4],
                          [-41.123, -95.36],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [16.161, -134.72],
                          [38.401, -134.72],
                          [-14.399, 16],
                          [-36.639, 16],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [117.439, -66.4],
                          [117.439, -45.6],
                          [41.279, -16.64],
                          [41.279, -36.64],
                          [94.559, -56],
                          [41.279, -75.52],
                          [41.279, -95.36],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 7,
            nm: "Layer 7",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 90,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 92,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 105,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 107, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [6.4, -6.24],
                          [12.053, -1.493],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [7.147, 2.347],
                          [4.373, 3.413],
                          [0, 0],
                          [-5.44, -2.027],
                          [-5.76, -0.533],
                          [0, 0],
                          [5.227, 2.24],
                          [3.52, 4.32],
                          [0, 7.147],
                          [-6.453, 6.347],
                          [-12.16, 1.387],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-8.533, -5.44],
                          [0, 0],
                          [8.32, 0.96],
                          [0, 0],
                          [-5.173, -2.187],
                          [-3.52, -4.32],
                          [0, -7.04],
                        ],
                        o: [
                          [0, 8.747],
                          [-6.4, 6.24],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-7.893, -0.427],
                          [-7.147, -2.347],
                          [0, 0],
                          [4.053, 2.987],
                          [5.44, 2.027],
                          [0, 0],
                          [-7.573, -1.813],
                          [-5.227, -2.24],
                          [-3.52, -4.32],
                          [0, -8.853],
                          [6.453, -6.347],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [13.12, 1.067],
                          [0, 0],
                          [-8, -4.587],
                          [0, 0],
                          [7.467, 1.707],
                          [5.173, 2.187],
                          [3.52, 4.32],
                          [0, 0],
                        ],
                        v: [
                          [46.561, -32.8],
                          [36.961, -10.32],
                          [9.281, 1.28],
                          [9.281, 19.2],
                          [-6.719, 19.2],
                          [-6.719, 1.76],
                          [-29.279, -2.4],
                          [-46.559, -11.04],
                          [-37.759, -30.56],
                          [-23.519, -23.04],
                          [-6.719, -19.2],
                          [-6.719, -45.92],
                          [-25.919, -52],
                          [-39.039, -61.84],
                          [-44.319, -79.04],
                          [-34.639, -101.84],
                          [-6.719, -113.44],
                          [-6.719, -131.2],
                          [9.281, -131.2],
                          [9.281, -113.76],
                          [41.761, -104],
                          [33.761, -84.32],
                          [9.281, -92.64],
                          [9.281, -65.44],
                          [28.241, -59.6],
                          [41.281, -49.84],
                          [46.561, -32.8],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-2.027, -1.707],
                          [-3.84, -1.173],
                          [0, 0],
                          [1.92, -2.08],
                          [0, -2.773],
                        ],
                        o: [
                          [0, 2.667],
                          [2.027, 1.707],
                          [0, 0],
                          [-4.053, 0.96],
                          [-1.92, 2.08],
                          [0, 0],
                        ],
                        v: [
                          [-18.559, -80.32],
                          [-15.519, -73.76],
                          [-6.719, -69.44],
                          [-6.719, -92.16],
                          [-15.679, -87.6],
                          [-18.559, -80.32],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-1.92, 1.92],
                          [0, 2.667],
                          [1.973, 1.707],
                          [3.733, 1.28],
                        ],
                        o: [
                          [3.84, -0.853],
                          [1.92, -1.92],
                          [0, -2.667],
                          [-1.973, -1.707],
                          [0, 0],
                        ],
                        v: [
                          [9.281, -19.84],
                          [17.921, -24],
                          [20.801, -30.88],
                          [17.841, -37.44],
                          [9.281, -41.92],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 6,
            nm: "Layer 6",
            ks: {
              p: { a: 0, k: [132.194, 123.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 75,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 77,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 90,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 92, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [2.987, 2.987],
                          [0, 4.48],
                          [-2.987, 2.827],
                          [-4.373, 0],
                          [-2.987, -2.827],
                          [0, -4.587],
                          [2.987, -2.987],
                          [4.373, 0],
                        ],
                        o: [
                          [-4.374, 0],
                          [-2.987, -2.987],
                          [0, -4.587],
                          [2.986, -2.827],
                          [4.373, 0],
                          [2.986, 2.827],
                          [0, 4.48],
                          [-2.987, 2.987],
                          [0, 0],
                        ],
                        v: [
                          [-59.524, -56.16],
                          [-70.564, -60.64],
                          [-75.044, -71.84],
                          [-70.564, -82.96],
                          [-59.524, -87.2],
                          [-48.484, -82.96],
                          [-44.004, -71.84],
                          [-48.484, -60.64],
                          [-59.524, -56.16],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [2.987, 2.987],
                          [0, 4.48],
                          [-2.987, 2.827],
                          [-4.373, 0],
                          [-2.987, -2.827],
                          [0, -4.587],
                          [2.987, -2.987],
                          [4.373, 0],
                        ],
                        o: [
                          [-4.374, 0],
                          [-2.987, -2.987],
                          [0, -4.587],
                          [2.986, -2.827],
                          [4.373, 0],
                          [2.986, 2.827],
                          [0, 4.48],
                          [-2.987, 2.987],
                          [0, 0],
                        ],
                        v: [
                          [-59.524, 1.28],
                          [-70.564, -3.2],
                          [-75.044, -14.4],
                          [-70.564, -25.52],
                          [-59.524, -29.76],
                          [-48.484, -25.52],
                          [-44.004, -14.4],
                          [-48.484, -3.2],
                          [-59.524, 1.28],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [-30.242, -55.04],
                          [15.038, -55.04],
                          [15.038, -35.04],
                          [-30.242, -35.04],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-3.147, 12.213],
                          [0, 13.653],
                          [3.147, 12.213],
                          [6.72, 11.84],
                          [0, 0],
                          [-3.467, -12.853],
                          [0, -14.72],
                          [3.413, -12.747],
                          [6.613, -9.707],
                        ],
                        o: [
                          [6.72, -11.84],
                          [3.147, -12.213],
                          [0, -13.653],
                          [-3.147, -12.213],
                          [0, 0],
                          [6.507, 9.493],
                          [3.467, 12.853],
                          [0, 14.72],
                          [-3.413, 12.747],
                          [0, 0],
                        ],
                        v: [
                          [24.803, 31.04],
                          [39.603, -5.04],
                          [44.323, -43.84],
                          [39.603, -82.64],
                          [24.803, -118.72],
                          [48.643, -118.72],
                          [63.603, -85.2],
                          [68.803, -43.84],
                          [63.683, -2.64],
                          [48.643, 31.04],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 5,
            nm: "Layer 5",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 60,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 62,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 75,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 77, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [-42.878, -91.2],
                          [-42.878, -61.6],
                          [8.962, -61.6],
                          [8.962, -40.8],
                          [-42.878, -40.8],
                          [-42.878, 0],
                          [-68.798, 0],
                          [-68.798, -112],
                          [15.842, -112],
                          [15.842, -91.2],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-5.813, 5.76],
                          [-10.56, 0],
                          [-3.36, -0.8],
                          [-2.24, -1.493],
                          [0, 0],
                          [3.84, 0],
                          [0, -8.32],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, -9.813],
                          [5.814, -5.76],
                          [3.734, 0],
                          [3.36, 0.8],
                          [0, 0],
                          [-2.88, -2.027],
                          [-7.573, 0],
                          [0, 0],
                        ],
                        v: [
                          [59.036, -84.16],
                          [81.116, -84.16],
                          [81.116, -64.96],
                          [59.676, -64.96],
                          [59.676, 0],
                          [34.716, 0],
                          [34.716, -64.96],
                          [21.436, -64.96],
                          [21.436, -84.16],
                          [34.716, -84.16],
                          [34.716, -88],
                          [43.436, -111.36],
                          [67.996, -120],
                          [78.636, -118.8],
                          [87.036, -115.36],
                          [80.476, -97.28],
                          [70.396, -100.32],
                          [59.036, -87.84],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 4,
            nm: "Layer 4",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 45,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 47,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 60,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 62, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [28.158, -43.04],
                          [48.958, -43.04],
                          [48.958, -25.6],
                          [26.078, -25.6],
                          [22.878, 0],
                          [4.798, 0],
                          [7.998, -25.6],
                          [-15.522, -25.6],
                          [-18.722, 0],
                          [-36.642, 0],
                          [-33.442, -25.6],
                          [-54.402, -25.6],
                          [-54.402, -43.04],
                          [-31.362, -43.04],
                          [-28.002, -68.96],
                          [-48.962, -68.96],
                          [-48.962, -86.4],
                          [-25.922, -86.4],
                          [-22.722, -112],
                          [-4.802, -112],
                          [-8.002, -86.4],
                          [15.518, -86.4],
                          [18.718, -112],
                          [36.638, -112],
                          [33.438, -86.4],
                          [54.238, -86.4],
                          [54.398, -68.96],
                          [31.358, -68.96],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [10.078, -43.04],
                          [13.438, -68.96],
                          [-10.082, -68.96],
                          [-13.442, -43.04],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 3,
            nm: "Layer 3",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 30,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 32,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 45,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 47, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [14.293, 0],
                          [6.507, 2.613],
                          [3.68, 4.693],
                          [0, 5.867],
                          [-3.893, 5.28],
                          [-8.64, 4.8],
                          [1.813, 3.787],
                          [0, 4.053],
                          [-2.88, 4.16],
                          [-5.28, 2.293],
                          [-6.933, 0],
                          [-5.867, -4.64],
                          [0, -7.893],
                          [3.467, -4.48],
                          [7.68, -4.16],
                          [0, 0],
                          [-1.28, 6.507],
                          [0, 0],
                          [4.693, -7.04],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [-10.667, 8.32],
                          [-8.107, 0],
                          [-6.507, -2.613],
                          [-3.68, -4.693],
                          [0, -6.933],
                          [3.893, -5.28],
                          [-4.053, -4.16],
                          [-1.813, -3.787],
                          [0, -5.44],
                          [2.88, -4.16],
                          [5.28, -2.293],
                          [9.706, 0],
                          [5.866, 4.64],
                          [0, 5.76],
                          [-3.467, 4.48],
                          [0, 0],
                          [2.453, -5.12],
                          [0, 0],
                          [-2.133, 9.92],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [41.118, 1.92],
                          [27.678, -10.56],
                          [-9.762, 1.92],
                          [-31.682, -2],
                          [-46.962, -12.96],
                          [-52.482, -28.8],
                          [-46.642, -47.12],
                          [-27.842, -62.24],
                          [-36.642, -74.16],
                          [-39.362, -85.92],
                          [-35.042, -100.32],
                          [-22.802, -110],
                          [-4.482, -113.44],
                          [18.878, -106.48],
                          [27.678, -87.68],
                          [22.478, -72.32],
                          [5.758, -59.36],
                          [26.238, -40.32],
                          [31.838, -57.76],
                          [51.838, -51.52],
                          [41.598, -26.08],
                          [54.718, -13.92],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [2.187, -1.92],
                          [0, -2.987],
                          [-1.173, -1.973],
                          [-3.413, -3.307],
                          [-2.133, 2.293],
                          [0, 2.667],
                          [1.92, 1.707],
                          [3.52, 0],
                        ],
                        o: [
                          [-3.734, 0],
                          [-2.187, 1.92],
                          [0, 2.24],
                          [1.173, 1.973],
                          [5.44, -2.88],
                          [2.133, -2.293],
                          [0, -2.773],
                          [-1.92, -1.707],
                          [0, 0],
                        ],
                        v: [
                          [-4.482, -96.48],
                          [-13.362, -93.6],
                          [-16.642, -86.24],
                          [-14.882, -79.92],
                          [-8.002, -72],
                          [3.358, -79.76],
                          [6.558, -87.2],
                          [3.678, -93.92],
                          [-4.482, -96.48],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-6.187, 4.373],
                          [0, 0],
                          [2.133, -2.773],
                          [0, -3.52],
                          [-3.627, -2.56],
                          [-6.08, 0],
                        ],
                        o: [
                          [7.786, 0],
                          [0, 0],
                          [-5.013, 2.88],
                          [-2.133, 2.773],
                          [0, 4.16],
                          [3.627, 2.56],
                          [0, 0],
                        ],
                        v: [
                          [-8.002, -17.6],
                          [12.958, -24.16],
                          [-14.082, -49.44],
                          [-24.802, -40.96],
                          [-28.002, -31.52],
                          [-22.562, -21.44],
                          [-8.002, -17.6],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 2,
            nm: "Layer 2",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 15,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 17,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 30,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 32, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [5.173, 5.6],
                          [0, 9.387],
                          [-5.173, 5.6],
                          [-8.213, 0],
                          [-5.12, -5.6],
                          [0, -9.387],
                          [5.12, -5.6],
                          [8.213, 0],
                        ],
                        o: [
                          [-8.214, 0],
                          [-5.174, -5.6],
                          [0, -9.387],
                          [5.173, -5.6],
                          [8.213, 0],
                          [5.12, 5.6],
                          [0, 9.387],
                          [-5.12, 5.6],
                          [0, 0],
                        ],
                        v: [
                          [-37.996, -51.52],
                          [-58.076, -59.92],
                          [-65.836, -82.4],
                          [-58.076, -104.88],
                          [-37.996, -113.28],
                          [-17.996, -104.88],
                          [-10.316, -82.4],
                          [-17.996, -59.92],
                          [-37.996, -51.52],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [28.724, -112],
                          [47.764, -112],
                          [-28.716, 0],
                          [-47.756, 0],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-2.08, 2.987],
                          [0, 5.867],
                          [2.08, 2.987],
                          [3.627, 0],
                          [2.133, -3.04],
                          [0, -5.76],
                          [-2.133, -3.04],
                          [-3.52, 0],
                        ],
                        o: [
                          [3.626, 0],
                          [2.08, -2.987],
                          [0, -5.867],
                          [-2.08, -2.987],
                          [-3.52, 0],
                          [-2.134, 3.04],
                          [0, 5.76],
                          [2.133, 3.04],
                          [0, 0],
                        ],
                        v: [
                          [-37.996, -64.64],
                          [-29.436, -69.12],
                          [-26.316, -82.4],
                          [-29.436, -95.68],
                          [-37.996, -100.16],
                          [-46.476, -95.6],
                          [-49.676, -82.4],
                          [-46.476, -69.2],
                          [-37.996, -64.64],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [4.213, 2.507],
                          [2.347, 4.693],
                          [0, 6.187],
                          [-2.347, 4.693],
                          [-4.213, 2.507],
                          [-5.333, 0],
                          [-5.173, -5.6],
                          [0, -9.387],
                          [5.173, -5.6],
                          [8.213, 0],
                        ],
                        o: [
                          [-5.334, 0],
                          [-4.214, -2.507],
                          [-2.347, -4.693],
                          [0, -6.187],
                          [2.346, -4.693],
                          [4.213, -2.507],
                          [8.213, 0],
                          [5.173, 5.6],
                          [0, 9.387],
                          [-5.174, 5.6],
                          [0, 0],
                        ],
                        v: [
                          [38.004, 1.28],
                          [23.684, -2.48],
                          [13.844, -13.28],
                          [10.324, -29.6],
                          [13.844, -45.92],
                          [23.684, -56.72],
                          [38.004, -60.48],
                          [58.084, -52.08],
                          [65.844, -29.6],
                          [58.084, -7.12],
                          [38.004, 1.28],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-2.08, 3.04],
                          [0, 5.76],
                          [2.08, 3.04],
                          [3.627, 0],
                          [2.133, -2.987],
                          [0, -5.867],
                          [-2.133, -2.987],
                          [-3.52, 0],
                        ],
                        o: [
                          [3.626, 0],
                          [2.08, -3.04],
                          [0, -5.76],
                          [-2.08, -3.04],
                          [-3.52, 0],
                          [-2.134, 2.987],
                          [0, 5.867],
                          [2.133, 2.987],
                          [0, 0],
                        ],
                        v: [
                          [38.004, -11.84],
                          [46.564, -16.4],
                          [49.684, -29.6],
                          [46.564, -42.8],
                          [38.004, -47.36],
                          [29.524, -42.88],
                          [26.324, -29.6],
                          [29.524, -16.32],
                          [38.004, -11.84],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
          {
            ind: 1,
            nm: "Layer 1",
            ks: {
              p: { a: 0, k: [132.194, 137.6] },
              a: { a: 0, k: [0, 0, 0] },
              s: { a: 0, k: [100, 100, 100] },
              r: { a: 0, k: 0 },
              o: {
                a: 1,
                k: [
                  {
                    t: 0,
                    s: [0],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 2,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [100],
                  },
                  {
                    t: 15,
                    s: [100],
                    i: { x: [0.833], y: [0.833] },
                    o: { x: [0.167], y: [0.167] },
                    e: [0],
                  },
                  { t: 17, s: [0] },
                ],
              },
            },
            ao: 0,
            ip: 0,
            op: 150,
            st: 0,
            bm: 0,
            sr: 1,
            ty: 4,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [-23.601, -24],
                          [-75.601, -24],
                          [-85.521, 0],
                          [-112.081, 0],
                          [-62.161, -112],
                          [-36.561, -112],
                          [13.519, 0],
                          [-13.681, 0],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [-31.761, -43.68],
                          [-49.521, -86.56],
                          [-67.281, -43.68],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-7.147, -6.347],
                          [0, -12.8],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [12.8, 0],
                          [4.853, 2.24],
                          [2.56, 3.947],
                          [0, 5.013],
                          [-6.027, 4.587],
                          [-12.587, 0],
                          [0, 0],
                          [3.307, 2.933],
                          [6.613, 0],
                          [4.427, -1.44],
                          [3.093, -2.453],
                          [0, 0],
                          [-6.56, 1.813],
                          [-6.933, 0],
                        ],
                        o: [
                          [13.333, 0],
                          [7.146, 6.347],
                          [0, 0],
                          [0, 0],
                          [0, 0],
                          [-4.693, 8],
                          [-6.614, 0],
                          [-4.854, -2.24],
                          [-2.56, -3.947],
                          [0, -8],
                          [6.027, -4.587],
                          [0, 0],
                          [0, -5.44],
                          [-3.307, -2.933],
                          [-4.587, 0],
                          [-4.427, 1.44],
                          [0, 0],
                          [4.693, -3.307],
                          [6.56, -1.813],
                          [0, 0],
                        ],
                        v: [
                          [58.162, -87.36],
                          [88.882, -77.84],
                          [99.602, -49.12],
                          [99.602, 0],
                          [76.242, 0],
                          [76.242, -10.72],
                          [50.002, 1.28],
                          [32.802, -2.08],
                          [21.682, -11.36],
                          [17.842, -24.8],
                          [26.882, -43.68],
                          [54.802, -50.56],
                          [74.642, -50.56],
                          [69.682, -63.12],
                          [54.802, -67.52],
                          [41.282, -65.36],
                          [30.002, -59.52],
                          [21.042, -76.96],
                          [37.922, -84.64],
                          [58.162, -87.36],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "sh",
                    d: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [0, 0],
                          [-3.307, 1.973],
                          [-1.387, 3.84],
                          [0, 0],
                          [0, 0],
                          [0, -6.72],
                          [-2.507, -1.867],
                          [-4.373, 0],
                        ],
                        o: [
                          [4.267, 0],
                          [3.307, -1.973],
                          [0, 0],
                          [0, 0],
                          [-10.24, 0],
                          [0, 3.2],
                          [2.507, 1.867],
                          [0, 0],
                        ],
                        v: [
                          [56.242, -15.52],
                          [67.602, -18.48],
                          [74.642, -27.2],
                          [74.642, -36],
                          [57.522, -36],
                          [42.162, -25.92],
                          [45.922, -18.32],
                          [56.242, -15.52],
                        ],
                        c: true,
                      },
                      hd: false,
                    },
                  },
                  {
                    ty: "fl",
                    c: { a: 0, k: [0.114, 0.118, 0.149, 1] },
                    hd: false,
                    o: { a: 0, k: 100 },
                    r: 1,
                  },
                  {
                    ty: "tr",
                    p: { a: 0, k: [0, 0] },
                    a: { a: 0, k: [0, 0] },
                    s: { a: 0, k: [100, 100] },
                    r: { a: 0, k: 0 },
                    o: { a: 0, k: 100 },
                    sk: { a: 0, k: 0 },
                    sa: { a: 0, k: 0 },
                  },
                ],
                nm: "Object",
                hd: false,
              },
            ],
          },
        ],
      };

      /***/
    },

    /***/ 1698: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _swiper = __webpack_require__(128);

      var _swiper2 = _interopRequireDefault(_swiper);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var mainSlider = new _swiper2.default(
        ".brandsource__result__content__blocks",
        {
          slidesPerView: "auto",
          initialSlide: 1,
          centeredSlides: true,
        }
      );

      /***/
    },

    /***/ 17: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      module.exports = function (it) {
        return (typeof it === "undefined" ? "undefined" : _typeof(it)) ===
          "object"
          ? it !== null
          : typeof it === "function";
      };

      /***/
    },

    /***/ 170: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = slideToClickedSlide;

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function slideToClickedSlide() {
        var swiper = this;
        var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl;
        var slidesPerView =
          params.slidesPerView === "auto"
            ? swiper.slidesPerViewDynamic()
            : params.slidesPerView;
        var slideToIndex = swiper.clickedIndex;
        var realIndex;

        if (params.loop) {
          if (swiper.animating) return;
          realIndex = parseInt(
            (0, _dom2.default)(swiper.clickedSlide).attr(
              "data-swiper-slide-index"
            ),
            10
          );

          if (params.centeredSlides) {
            if (
              slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||
              slideToIndex >
                swiper.slides.length - swiper.loopedSlides + slidesPerView / 2
            ) {
              swiper.loopFix();
              slideToIndex = $wrapperEl
                .children(
                  "." +
                    params.slideClass +
                    '[data-swiper-slide-index="' +
                    realIndex +
                    '"]:not(.' +
                    params.slideDuplicateClass +
                    ")"
                )
                .eq(0)
                .index();
              (0, _utils.nextTick)(function () {
                swiper.slideTo(slideToIndex);
              });
            } else {
              swiper.slideTo(slideToIndex);
            }
          } else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = $wrapperEl
              .children(
                "." +
                  params.slideClass +
                  '[data-swiper-slide-index="' +
                  realIndex +
                  '"]:not(.' +
                  params.slideDuplicateClass +
                  ")"
              )
              .eq(0)
              .index();
            (0, _utils.nextTick)(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else {
          swiper.slideTo(slideToIndex);
        }
      }

      /***/
    },

    /***/ 171: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _loopCreate = __webpack_require__(172);

      var _loopCreate2 = _interopRequireDefault(_loopCreate);

      var _loopFix = __webpack_require__(173);

      var _loopFix2 = _interopRequireDefault(_loopFix);

      var _loopDestroy = __webpack_require__(174);

      var _loopDestroy2 = _interopRequireDefault(_loopDestroy);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        loopCreate: _loopCreate2.default,
        loopFix: _loopFix2.default,
        loopDestroy: _loopDestroy2.default,
      };

      /***/
    },

    /***/ 172: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = loopCreate;

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function loopCreate() {
        var swiper = this;
        var document = (0, _ssrWindow.getDocument)();
        var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

        $wrapperEl
          .children("." + params.slideClass + "." + params.slideDuplicateClass)
          .remove();
        var slides = $wrapperEl.children("." + params.slideClass);

        if (params.loopFillGroupWithBlank) {
          var blankSlidesNum =
            params.slidesPerGroup - (slides.length % params.slidesPerGroup);

          if (blankSlidesNum !== params.slidesPerGroup) {
            for (var i = 0; i < blankSlidesNum; i += 1) {
              var blankNode = (0, _dom2.default)(
                document.createElement("div")
              ).addClass(params.slideClass + " " + params.slideBlankClass);
              $wrapperEl.append(blankNode);
            }

            slides = $wrapperEl.children("." + params.slideClass);
          }
        }

        if (params.slidesPerView === "auto" && !params.loopedSlides)
          params.loopedSlides = slides.length;
        swiper.loopedSlides = Math.ceil(
          parseFloat(params.loopedSlides || params.slidesPerView, 10)
        );
        swiper.loopedSlides += params.loopAdditionalSlides;

        if (swiper.loopedSlides > slides.length) {
          swiper.loopedSlides = slides.length;
        }

        var prependSlides = [];
        var appendSlides = [];
        slides.each(function (el, index) {
          var slide = (0, _dom2.default)(el);

          if (index < swiper.loopedSlides) {
            appendSlides.push(el);
          }

          if (
            index < slides.length &&
            index >= slides.length - swiper.loopedSlides
          ) {
            prependSlides.push(el);
          }

          slide.attr("data-swiper-slide-index", index);
        });

        for (var _i = 0; _i < appendSlides.length; _i += 1) {
          $wrapperEl.append(
            (0, _dom2.default)(appendSlides[_i].cloneNode(true)).addClass(
              params.slideDuplicateClass
            )
          );
        }

        for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
          $wrapperEl.prepend(
            (0, _dom2.default)(prependSlides[_i2].cloneNode(true)).addClass(
              params.slideDuplicateClass
            )
          );
        }
      }

      /***/
    },

    /***/ 173: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = loopFix;
      function loopFix() {
        var swiper = this;
        swiper.emit("beforeLoopFix");
        var activeIndex = swiper.activeIndex,
          slides = swiper.slides,
          loopedSlides = swiper.loopedSlides,
          allowSlidePrev = swiper.allowSlidePrev,
          allowSlideNext = swiper.allowSlideNext,
          snapGrid = swiper.snapGrid,
          rtl = swiper.rtlTranslate;
        var newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        var snapTranslate = -snapGrid[activeIndex];
        var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

        if (activeIndex < loopedSlides) {
          newIndex = slides.length - loopedSlides * 3 + activeIndex;
          newIndex += loopedSlides;
          var slideChanged = swiper.slideTo(newIndex, 0, false, true);

          if (slideChanged && diff !== 0) {
            swiper.setTranslate(
              (rtl ? -swiper.translate : swiper.translate) - diff
            );
          }
        } else if (activeIndex >= slides.length - loopedSlides) {
          // Fix For Positive Oversliding
          newIndex = -slides.length + activeIndex + loopedSlides;
          newIndex += loopedSlides;

          var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

          if (_slideChanged && diff !== 0) {
            swiper.setTranslate(
              (rtl ? -swiper.translate : swiper.translate) - diff
            );
          }
        }

        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit("loopFix");
      }

      /***/
    },

    /***/ 174: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = loopDestroy;
      function loopDestroy() {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          slides = swiper.slides;
        $wrapperEl
          .children(
            "." +
              params.slideClass +
              "." +
              params.slideDuplicateClass +
              ",." +
              params.slideClass +
              "." +
              params.slideBlankClass
          )
          .remove();
        slides.removeAttr("data-swiper-slide-index");
      }

      /***/
    },

    /***/ 175: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _setGrabCursor = __webpack_require__(176);

      var _setGrabCursor2 = _interopRequireDefault(_setGrabCursor);

      var _unsetGrabCursor = __webpack_require__(177);

      var _unsetGrabCursor2 = _interopRequireDefault(_unsetGrabCursor);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        setGrabCursor: _setGrabCursor2.default,
        unsetGrabCursor: _unsetGrabCursor2.default,
      };

      /***/
    },

    /***/ 176: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = setGrabCursor;
      function setGrabCursor(moving) {
        var swiper = this;
        if (
          swiper.support.touch ||
          !swiper.params.simulateTouch ||
          (swiper.params.watchOverflow && swiper.isLocked) ||
          swiper.params.cssMode
        )
          return;
        var el = swiper.el;
        el.style.cursor = "move";
        el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
        el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
        el.style.cursor = moving ? "grabbing" : "grab";
      }

      /***/
    },

    /***/ 177: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = unsetGrabCursor;
      function unsetGrabCursor() {
        var swiper = this;

        if (
          swiper.support.touch ||
          (swiper.params.watchOverflow && swiper.isLocked) ||
          swiper.params.cssMode
        ) {
          return;
        }

        swiper.el.style.cursor = "";
      }

      /***/
    },

    /***/ 178: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _appendSlide = __webpack_require__(179);

      var _appendSlide2 = _interopRequireDefault(_appendSlide);

      var _prependSlide = __webpack_require__(180);

      var _prependSlide2 = _interopRequireDefault(_prependSlide);

      var _addSlide = __webpack_require__(181);

      var _addSlide2 = _interopRequireDefault(_addSlide);

      var _removeSlide = __webpack_require__(182);

      var _removeSlide2 = _interopRequireDefault(_removeSlide);

      var _removeAllSlides = __webpack_require__(183);

      var _removeAllSlides2 = _interopRequireDefault(_removeAllSlides);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        appendSlide: _appendSlide2.default,
        prependSlide: _prependSlide2.default,
        addSlide: _addSlide2.default,
        removeSlide: _removeSlide2.default,
        removeAllSlides: _removeAllSlides2.default,
      };

      /***/
    },

    /***/ 179: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      exports.default = appendSlide;
      function appendSlide(slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params;

        if (params.loop) {
          swiper.loopDestroy();
        }

        if (
          (typeof slides === "undefined" ? "undefined" : _typeof(slides)) ===
            "object" &&
          "length" in slides
        ) {
          for (var i = 0; i < slides.length; i += 1) {
            if (slides[i]) $wrapperEl.append(slides[i]);
          }
        } else {
          $wrapperEl.append(slides);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && swiper.support.observer)) {
          swiper.update();
        }
      }

      /***/
    },

    /***/ 18: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };

      /***/
    },

    /***/ 180: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      exports.default = prependSlide;
      function prependSlide(slides) {
        var swiper = this;
        var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;

        if (params.loop) {
          swiper.loopDestroy();
        }

        var newActiveIndex = activeIndex + 1;

        if (
          (typeof slides === "undefined" ? "undefined" : _typeof(slides)) ===
            "object" &&
          "length" in slides
        ) {
          for (var i = 0; i < slides.length; i += 1) {
            if (slides[i]) $wrapperEl.prepend(slides[i]);
          }

          newActiveIndex = activeIndex + slides.length;
        } else {
          $wrapperEl.prepend(slides);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && swiper.support.observer)) {
          swiper.update();
        }

        swiper.slideTo(newActiveIndex, 0, false);
      }

      /***/
    },

    /***/ 181: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      exports.default = addSlide;
      function addSlide(index, slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;

        if (params.loop) {
          activeIndexBuffer -= swiper.loopedSlides;
          swiper.loopDestroy();
          swiper.slides = $wrapperEl.children("." + params.slideClass);
        }

        var baseLength = swiper.slides.length;

        if (index <= 0) {
          swiper.prependSlide(slides);
          return;
        }

        if (index >= baseLength) {
          swiper.appendSlide(slides);
          return;
        }

        var newActiveIndex =
          activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
        var slidesBuffer = [];

        for (var i = baseLength - 1; i >= index; i -= 1) {
          var currentSlide = swiper.slides.eq(i);
          currentSlide.remove();
          slidesBuffer.unshift(currentSlide);
        }

        if (
          (typeof slides === "undefined" ? "undefined" : _typeof(slides)) ===
            "object" &&
          "length" in slides
        ) {
          for (var _i = 0; _i < slides.length; _i += 1) {
            if (slides[_i]) $wrapperEl.append(slides[_i]);
          }

          newActiveIndex =
            activeIndexBuffer > index
              ? activeIndexBuffer + slides.length
              : activeIndexBuffer;
        } else {
          $wrapperEl.append(slides);
        }

        for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
          $wrapperEl.append(slidesBuffer[_i2]);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && swiper.support.observer)) {
          swiper.update();
        }

        if (params.loop) {
          swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
          swiper.slideTo(newActiveIndex, 0, false);
        }
      }

      /***/
    },

    /***/ 182: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      exports.default = removeSlide;
      function removeSlide(slidesIndexes) {
        var swiper = this;
        var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;

        if (params.loop) {
          activeIndexBuffer -= swiper.loopedSlides;
          swiper.loopDestroy();
          swiper.slides = $wrapperEl.children("." + params.slideClass);
        }

        var newActiveIndex = activeIndexBuffer;
        var indexToRemove;

        if (
          (typeof slidesIndexes === "undefined"
            ? "undefined"
            : _typeof(slidesIndexes)) === "object" &&
          "length" in slidesIndexes
        ) {
          for (var i = 0; i < slidesIndexes.length; i += 1) {
            indexToRemove = slidesIndexes[i];
            if (swiper.slides[indexToRemove])
              swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
          }

          newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
          indexToRemove = slidesIndexes;
          if (swiper.slides[indexToRemove])
            swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
          newActiveIndex = Math.max(newActiveIndex, 0);
        }

        if (params.loop) {
          swiper.loopCreate();
        }

        if (!(params.observer && swiper.support.observer)) {
          swiper.update();
        }

        if (params.loop) {
          swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
          swiper.slideTo(newActiveIndex, 0, false);
        }
      }

      /***/
    },

    /***/ 183: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = removeAllSlides;
      function removeAllSlides() {
        var swiper = this;
        var slidesIndexes = [];

        for (var i = 0; i < swiper.slides.length; i += 1) {
          slidesIndexes.push(i);
        }

        swiper.removeSlide(slidesIndexes);
      }

      /***/
    },

    /***/ 184: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _onTouchStart = __webpack_require__(185);

      var _onTouchStart2 = _interopRequireDefault(_onTouchStart);

      var _onTouchMove = __webpack_require__(186);

      var _onTouchMove2 = _interopRequireDefault(_onTouchMove);

      var _onTouchEnd = __webpack_require__(187);

      var _onTouchEnd2 = _interopRequireDefault(_onTouchEnd);

      var _onResize = __webpack_require__(188);

      var _onResize2 = _interopRequireDefault(_onResize);

      var _onClick = __webpack_require__(189);

      var _onClick2 = _interopRequireDefault(_onClick);

      var _onScroll = __webpack_require__(190);

      var _onScroll2 = _interopRequireDefault(_onScroll);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var dummyEventAttached = false;

      function dummyEventListener() {}

      function attachEvents() {
        var swiper = this;
        var document = (0, _ssrWindow.getDocument)();
        var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
        swiper.onTouchStart = _onTouchStart2.default.bind(swiper);
        swiper.onTouchMove = _onTouchMove2.default.bind(swiper);
        swiper.onTouchEnd = _onTouchEnd2.default.bind(swiper);

        if (params.cssMode) {
          swiper.onScroll = _onScroll2.default.bind(swiper);
        }

        swiper.onClick = _onClick2.default.bind(swiper);
        var capture = !!params.nested; // Touch Events

        if (!support.touch && support.pointerEvents) {
          el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
          document.addEventListener(
            touchEvents.move,
            swiper.onTouchMove,
            capture
          );
          document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
        } else {
          if (support.touch) {
            var passiveListener =
              touchEvents.start === "touchstart" &&
              support.passiveListener &&
              params.passiveListeners
                ? {
                    passive: true,
                    capture: false,
                  }
                : false;
            el.addEventListener(
              touchEvents.start,
              swiper.onTouchStart,
              passiveListener
            );
            el.addEventListener(
              touchEvents.move,
              swiper.onTouchMove,
              support.passiveListener
                ? {
                    passive: false,
                    capture: capture,
                  }
                : capture
            );
            el.addEventListener(
              touchEvents.end,
              swiper.onTouchEnd,
              passiveListener
            );

            if (touchEvents.cancel) {
              el.addEventListener(
                touchEvents.cancel,
                swiper.onTouchEnd,
                passiveListener
              );
            }

            if (!dummyEventAttached) {
              document.addEventListener("touchstart", dummyEventListener);
              dummyEventAttached = true;
            }
          }

          if (
            (params.simulateTouch && !device.ios && !device.android) ||
            (params.simulateTouch && !support.touch && device.ios)
          ) {
            el.addEventListener("mousedown", swiper.onTouchStart, false);
            document.addEventListener("mousemove", swiper.onTouchMove, capture);
            document.addEventListener("mouseup", swiper.onTouchEnd, false);
          }
        } // Prevent Links Clicks

        if (params.preventClicks || params.preventClicksPropagation) {
          el.addEventListener("click", swiper.onClick, true);
        }

        if (params.cssMode) {
          wrapperEl.addEventListener("scroll", swiper.onScroll);
        } // Resize handler

        if (params.updateOnWindowResize) {
          swiper.on(
            device.ios || device.android
              ? "resize orientationchange observerUpdate"
              : "resize observerUpdate",
            _onResize2.default,
            true
          );
        } else {
          swiper.on("observerUpdate", _onResize2.default, true);
        }
      }

      function detachEvents() {
        var swiper = this;
        var document = (0, _ssrWindow.getDocument)();
        var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
        var capture = !!params.nested; // Touch Events

        if (!support.touch && support.pointerEvents) {
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
          document.removeEventListener(
            touchEvents.move,
            swiper.onTouchMove,
            capture
          );
          document.removeEventListener(
            touchEvents.end,
            swiper.onTouchEnd,
            false
          );
        } else {
          if (support.touch) {
            var passiveListener =
              touchEvents.start === "onTouchStart" &&
              support.passiveListener &&
              params.passiveListeners
                ? {
                    passive: true,
                    capture: false,
                  }
                : false;
            el.removeEventListener(
              touchEvents.start,
              swiper.onTouchStart,
              passiveListener
            );
            el.removeEventListener(
              touchEvents.move,
              swiper.onTouchMove,
              capture
            );
            el.removeEventListener(
              touchEvents.end,
              swiper.onTouchEnd,
              passiveListener
            );

            if (touchEvents.cancel) {
              el.removeEventListener(
                touchEvents.cancel,
                swiper.onTouchEnd,
                passiveListener
              );
            }
          }

          if (
            (params.simulateTouch && !device.ios && !device.android) ||
            (params.simulateTouch && !support.touch && device.ios)
          ) {
            el.removeEventListener("mousedown", swiper.onTouchStart, false);
            document.removeEventListener(
              "mousemove",
              swiper.onTouchMove,
              capture
            );
            document.removeEventListener("mouseup", swiper.onTouchEnd, false);
          }
        } // Prevent Links Clicks

        if (params.preventClicks || params.preventClicksPropagation) {
          el.removeEventListener("click", swiper.onClick, true);
        }

        if (params.cssMode) {
          wrapperEl.removeEventListener("scroll", swiper.onScroll);
        } // Resize handler

        swiper.off(
          device.ios || device.android
            ? "resize orientationchange observerUpdate"
            : "resize observerUpdate",
          _onResize2.default
        );
      }

      exports.default = {
        attachEvents: attachEvents,
        detachEvents: detachEvents,
      };

      /***/
    },

    /***/ 185: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = onTouchStart;

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd

      function closestElement(selector, base) {
        if (base === void 0) {
          base = this;
        }

        function __closestFrom(el) {
          if (
            !el ||
            el === (0, _ssrWindow.getDocument)() ||
            el === (0, _ssrWindow.getWindow)()
          )
            return null;
          if (el.assignedSlot) el = el.assignedSlot;
          var found = el.closest(selector);
          return found || __closestFrom(el.getRootNode().host);
        }

        return __closestFrom(base);
      }

      function onTouchStart(event) {
        var swiper = this;
        var document = (0, _ssrWindow.getDocument)();
        var window = (0, _ssrWindow.getWindow)();
        var data = swiper.touchEventsData;
        var params = swiper.params,
          touches = swiper.touches,
          enabled = swiper.enabled;
        if (!enabled) return;

        if (swiper.animating && params.preventInteractionOnTransition) {
          return;
        }

        var e = event;
        if (e.originalEvent) e = e.originalEvent;
        var $targetEl = (0, _dom2.default)(e.target);

        if (params.touchEventsTarget === "wrapper") {
          if (!$targetEl.closest(swiper.wrapperEl).length) return;
        }

        data.isTouchEvent = e.type === "touchstart";
        if (!data.isTouchEvent && "which" in e && e.which === 3) return;
        if (!data.isTouchEvent && "button" in e && e.button > 0) return;
        if (data.isTouched && data.isMoved) return; // change target el for shadow root component

        var swipingClassHasValue =
          !!params.noSwipingClass && params.noSwipingClass !== "";

        if (
          swipingClassHasValue &&
          e.target &&
          e.target.shadowRoot &&
          event.path &&
          event.path[0]
        ) {
          $targetEl = (0, _dom2.default)(event.path[0]);
        }

        var noSwipingSelector = params.noSwipingSelector
          ? params.noSwipingSelector
          : "." + params.noSwipingClass;
        var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

        if (
          params.noSwiping &&
          (isTargetShadow
            ? closestElement(noSwipingSelector, e.target)
            : $targetEl.closest(noSwipingSelector)[0])
        ) {
          swiper.allowClick = true;
          return;
        }

        if (params.swipeHandler) {
          if (!$targetEl.closest(params.swipeHandler)[0]) return;
        }

        touches.currentX =
          e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY =
          e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        var startX = touches.currentX;
        var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

        var edgeSwipeDetection =
          params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        var edgeSwipeThreshold =
          params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

        if (
          edgeSwipeDetection &&
          (startX <= edgeSwipeThreshold ||
            startX >= window.innerWidth - edgeSwipeThreshold)
        ) {
          if (edgeSwipeDetection === "prevent") {
            event.preventDefault();
          } else {
            return;
          }
        }

        (0, _utils.extend)(data, {
          isTouched: true,
          isMoved: false,
          allowTouchCallbacks: true,
          isScrolling: undefined,
          startMoving: undefined,
        });
        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = (0, _utils.now)();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) data.allowThresholdMove = false;

        if (e.type !== "touchstart") {
          var preventDefault = true;
          if ($targetEl.is(data.focusableElements)) preventDefault = false;

          if (
            document.activeElement &&
            (0, _dom2.default)(document.activeElement).is(
              data.focusableElements
            ) &&
            document.activeElement !== $targetEl[0]
          ) {
            document.activeElement.blur();
          }

          var shouldPreventDefault =
            preventDefault &&
            swiper.allowTouchMove &&
            params.touchStartPreventDefault;

          if (
            (params.touchStartForcePreventDefault || shouldPreventDefault) &&
            !$targetEl[0].isContentEditable
          ) {
            e.preventDefault();
          }
        }

        swiper.emit("touchStart", e);
      }

      /***/
    },

    /***/ 186: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = onTouchMove;

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function onTouchMove(event) {
        var document = (0, _ssrWindow.getDocument)();
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          enabled = swiper.enabled;
        if (!enabled) return;
        var e = event;
        if (e.originalEvent) e = e.originalEvent;

        if (!data.isTouched) {
          if (data.startMoving && data.isScrolling) {
            swiper.emit("touchMoveOpposite", e);
          }

          return;
        }

        if (data.isTouchEvent && e.type !== "touchmove") return;
        var targetTouch =
          e.type === "touchmove" &&
          e.targetTouches &&
          (e.targetTouches[0] || e.changedTouches[0]);
        var pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
        var pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;

        if (e.preventedByNestedSwiper) {
          touches.startX = pageX;
          touches.startY = pageY;
          return;
        }

        if (!swiper.allowTouchMove) {
          // isMoved = true;
          swiper.allowClick = false;

          if (data.isTouched) {
            (0, _utils.extend)(touches, {
              startX: pageX,
              startY: pageY,
              currentX: pageX,
              currentY: pageY,
            });
            data.touchStartTime = (0, _utils.now)();
          }

          return;
        }

        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
          if (swiper.isVertical()) {
            // Vertical
            if (
              (pageY < touches.startY &&
                swiper.translate <= swiper.maxTranslate()) ||
              (pageY > touches.startY &&
                swiper.translate >= swiper.minTranslate())
            ) {
              data.isTouched = false;
              data.isMoved = false;
              return;
            }
          } else if (
            (pageX < touches.startX &&
              swiper.translate <= swiper.maxTranslate()) ||
            (pageX > touches.startX &&
              swiper.translate >= swiper.minTranslate())
          ) {
            return;
          }
        }

        if (data.isTouchEvent && document.activeElement) {
          if (
            e.target === document.activeElement &&
            (0, _dom2.default)(e.target).is(data.focusableElements)
          ) {
            data.isMoved = true;
            swiper.allowClick = false;
            return;
          }
        }

        if (data.allowTouchCallbacks) {
          swiper.emit("touchMove", e);
        }

        if (e.targetTouches && e.targetTouches.length > 1) return;
        touches.currentX = pageX;
        touches.currentY = pageY;
        var diffX = touches.currentX - touches.startX;
        var diffY = touches.currentY - touches.startY;
        if (
          swiper.params.threshold &&
          Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) <
            swiper.params.threshold
        )
          return;

        if (typeof data.isScrolling === "undefined") {
          var touchAngle;

          if (
            (swiper.isHorizontal() && touches.currentY === touches.startY) ||
            (swiper.isVertical() && touches.currentX === touches.startX)
          ) {
            data.isScrolling = false;
          } else {
            // eslint-disable-next-line
            if (diffX * diffX + diffY * diffY >= 25) {
              touchAngle =
                (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
              data.isScrolling = swiper.isHorizontal()
                ? touchAngle > params.touchAngle
                : 90 - touchAngle > params.touchAngle;
            }
          }
        }

        if (data.isScrolling) {
          swiper.emit("touchMoveOpposite", e);
        }

        if (typeof data.startMoving === "undefined") {
          if (
            touches.currentX !== touches.startX ||
            touches.currentY !== touches.startY
          ) {
            data.startMoving = true;
          }
        }

        if (data.isScrolling) {
          data.isTouched = false;
          return;
        }

        if (!data.startMoving) {
          return;
        }

        swiper.allowClick = false;

        if (!params.cssMode && e.cancelable) {
          e.preventDefault();
        }

        if (params.touchMoveStopPropagation && !params.nested) {
          e.stopPropagation();
        }

        if (!data.isMoved) {
          if (params.loop) {
            swiper.loopFix();
          }

          data.startTranslate = swiper.getTranslate();
          swiper.setTransition(0);

          if (swiper.animating) {
            swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
          }

          data.allowMomentumBounce = false; // Grab Cursor

          if (
            params.grabCursor &&
            (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)
          ) {
            swiper.setGrabCursor(true);
          }

          swiper.emit("sliderFirstMove", e);
        }

        swiper.emit("sliderMove", e);
        data.isMoved = true;
        var diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;
        if (rtl) diff = -diff;
        swiper.swipeDirection = diff > 0 ? "prev" : "next";
        data.currentTranslate = diff + data.startTranslate;
        var disableParentSwiper = true;
        var resistanceRatio = params.resistanceRatio;

        if (params.touchReleaseOnEdges) {
          resistanceRatio = 0;
        }

        if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
          disableParentSwiper = false;
          if (params.resistance)
            data.currentTranslate =
              swiper.minTranslate() -
              1 +
              Math.pow(
                -swiper.minTranslate() + data.startTranslate + diff,
                resistanceRatio
              );
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
          disableParentSwiper = false;
          if (params.resistance)
            data.currentTranslate =
              swiper.maxTranslate() +
              1 -
              Math.pow(
                swiper.maxTranslate() - data.startTranslate - diff,
                resistanceRatio
              );
        }

        if (disableParentSwiper) {
          e.preventedByNestedSwiper = true;
        } // Directions locks

        if (
          !swiper.allowSlideNext &&
          swiper.swipeDirection === "next" &&
          data.currentTranslate < data.startTranslate
        ) {
          data.currentTranslate = data.startTranslate;
        }

        if (
          !swiper.allowSlidePrev &&
          swiper.swipeDirection === "prev" &&
          data.currentTranslate > data.startTranslate
        ) {
          data.currentTranslate = data.startTranslate;
        }

        if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
          data.currentTranslate = data.startTranslate;
        } // Threshold

        if (params.threshold > 0) {
          if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
            if (!data.allowThresholdMove) {
              data.allowThresholdMove = true;
              touches.startX = touches.currentX;
              touches.startY = touches.currentY;
              data.currentTranslate = data.startTranslate;
              touches.diff = swiper.isHorizontal()
                ? touches.currentX - touches.startX
                : touches.currentY - touches.startY;
              return;
            }
          } else {
            data.currentTranslate = data.startTranslate;
            return;
          }
        }

        if (!params.followFinger || params.cssMode) return; // Update active index in free mode

        if (
          params.freeMode ||
          params.watchSlidesProgress ||
          params.watchSlidesVisibility
        ) {
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        if (params.freeMode) {
          // Velocity
          if (data.velocities.length === 0) {
            data.velocities.push({
              position: touches[swiper.isHorizontal() ? "startX" : "startY"],
              time: data.touchStartTime,
            });
          }

          data.velocities.push({
            position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
            time: (0, _utils.now)(),
          });
        } // Update progress

        swiper.updateProgress(data.currentTranslate); // Update translate

        swiper.setTranslate(data.currentTranslate);
      }

      /***/
    },

    /***/ 187: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = onTouchEnd;

      var _utils = __webpack_require__(1);

      function onTouchEnd(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          $wrapperEl = swiper.$wrapperEl,
          slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          enabled = swiper.enabled;
        if (!enabled) return;
        var e = event;
        if (e.originalEvent) e = e.originalEvent;

        if (data.allowTouchCallbacks) {
          swiper.emit("touchEnd", e);
        }

        data.allowTouchCallbacks = false;

        if (!data.isTouched) {
          if (data.isMoved && params.grabCursor) {
            swiper.setGrabCursor(false);
          }

          data.isMoved = false;
          data.startMoving = false;
          return;
        } // Return Grab Cursor

        if (
          params.grabCursor &&
          data.isMoved &&
          data.isTouched &&
          (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)
        ) {
          swiper.setGrabCursor(false);
        } // Time diff

        var touchEndTime = (0, _utils.now)();
        var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

        if (swiper.allowClick) {
          swiper.updateClickedSlide(e);
          swiper.emit("tap click", e);

          if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
            swiper.emit("doubleTap doubleClick", e);
          }
        }

        data.lastClickTime = (0, _utils.now)();
        (0, _utils.nextTick)(function () {
          if (!swiper.destroyed) swiper.allowClick = true;
        });

        if (
          !data.isTouched ||
          !data.isMoved ||
          !swiper.swipeDirection ||
          touches.diff === 0 ||
          data.currentTranslate === data.startTranslate
        ) {
          data.isTouched = false;
          data.isMoved = false;
          data.startMoving = false;
          return;
        }

        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        var currentPos;

        if (params.followFinger) {
          currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
          currentPos = -data.currentTranslate;
        }

        if (params.cssMode) {
          return;
        }

        if (params.freeMode) {
          if (currentPos < -swiper.minTranslate()) {
            swiper.slideTo(swiper.activeIndex);
            return;
          }

          if (currentPos > -swiper.maxTranslate()) {
            if (swiper.slides.length < snapGrid.length) {
              swiper.slideTo(snapGrid.length - 1);
            } else {
              swiper.slideTo(swiper.slides.length - 1);
            }

            return;
          }

          if (params.freeModeMomentum) {
            if (data.velocities.length > 1) {
              var lastMoveEvent = data.velocities.pop();
              var velocityEvent = data.velocities.pop();
              var distance = lastMoveEvent.position - velocityEvent.position;
              var time = lastMoveEvent.time - velocityEvent.time;
              swiper.velocity = distance / time;
              swiper.velocity /= 2;

              if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                swiper.velocity = 0;
              } // this implies that the user stopped moving a finger then released.
              // There would be no events with distance zero, so the last event is stale.

              if (time > 150 || (0, _utils.now)() - lastMoveEvent.time > 300) {
                swiper.velocity = 0;
              }
            } else {
              swiper.velocity = 0;
            }

            swiper.velocity *= params.freeModeMomentumVelocityRatio;
            data.velocities.length = 0;
            var momentumDuration = 1000 * params.freeModeMomentumRatio;
            var momentumDistance = swiper.velocity * momentumDuration;
            var newPosition = swiper.translate + momentumDistance;
            if (rtl) newPosition = -newPosition;
            var doBounce = false;
            var afterBouncePosition;
            var bounceAmount =
              Math.abs(swiper.velocity) *
              20 *
              params.freeModeMomentumBounceRatio;
            var needsLoopFix;

            if (newPosition < swiper.maxTranslate()) {
              if (params.freeModeMomentumBounce) {
                if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                  newPosition = swiper.maxTranslate() - bounceAmount;
                }

                afterBouncePosition = swiper.maxTranslate();
                doBounce = true;
                data.allowMomentumBounce = true;
              } else {
                newPosition = swiper.maxTranslate();
              }

              if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (newPosition > swiper.minTranslate()) {
              if (params.freeModeMomentumBounce) {
                if (newPosition - swiper.minTranslate() > bounceAmount) {
                  newPosition = swiper.minTranslate() + bounceAmount;
                }

                afterBouncePosition = swiper.minTranslate();
                doBounce = true;
                data.allowMomentumBounce = true;
              } else {
                newPosition = swiper.minTranslate();
              }

              if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (params.freeModeSticky) {
              var nextSlide;

              for (var j = 0; j < snapGrid.length; j += 1) {
                if (snapGrid[j] > -newPosition) {
                  nextSlide = j;
                  break;
                }
              }

              if (
                Math.abs(snapGrid[nextSlide] - newPosition) <
                  Math.abs(snapGrid[nextSlide - 1] - newPosition) ||
                swiper.swipeDirection === "next"
              ) {
                newPosition = snapGrid[nextSlide];
              } else {
                newPosition = snapGrid[nextSlide - 1];
              }

              newPosition = -newPosition;
            }

            if (needsLoopFix) {
              swiper.once("transitionEnd", function () {
                swiper.loopFix();
              });
            } // Fix duration

            if (swiper.velocity !== 0) {
              if (rtl) {
                momentumDuration = Math.abs(
                  (-newPosition - swiper.translate) / swiper.velocity
                );
              } else {
                momentumDuration = Math.abs(
                  (newPosition - swiper.translate) / swiper.velocity
                );
              }

              if (params.freeModeSticky) {
                // If freeModeSticky is active and the user ends a swipe with a slow-velocity
                // event, then durations can be 20+ seconds to slide one (or zero!) slides.
                // It's easy to see this when simulating touch with mouse events. To fix this,
                // limit single-slide swipes to the default slide duration. This also has the
                // nice side effect of matching slide speed if the user stopped moving before
                // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
                // For faster swipes, also apply limits (albeit higher ones).
                var moveDistance = Math.abs(
                  (rtl ? -newPosition : newPosition) - swiper.translate
                );
                var currentSlideSize =
                  swiper.slidesSizesGrid[swiper.activeIndex];

                if (moveDistance < currentSlideSize) {
                  momentumDuration = params.speed;
                } else if (moveDistance < 2 * currentSlideSize) {
                  momentumDuration = params.speed * 1.5;
                } else {
                  momentumDuration = params.speed * 2.5;
                }
              }
            } else if (params.freeModeSticky) {
              swiper.slideToClosest();
              return;
            }

            if (params.freeModeMomentumBounce && doBounce) {
              swiper.updateProgress(afterBouncePosition);
              swiper.setTransition(momentumDuration);
              swiper.setTranslate(newPosition);
              swiper.transitionStart(true, swiper.swipeDirection);
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed || !data.allowMomentumBounce)
                  return;
                swiper.emit("momentumBounce");
                swiper.setTransition(params.speed);
                setTimeout(function () {
                  swiper.setTranslate(afterBouncePosition);
                  $wrapperEl.transitionEnd(function () {
                    if (!swiper || swiper.destroyed) return;
                    swiper.transitionEnd();
                  });
                }, 0);
              });
            } else if (swiper.velocity) {
              swiper.updateProgress(newPosition);
              swiper.setTransition(momentumDuration);
              swiper.setTranslate(newPosition);
              swiper.transitionStart(true, swiper.swipeDirection);

              if (!swiper.animating) {
                swiper.animating = true;
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }
            } else {
              swiper.emit("_freeModeNoMomentumRelease");
              swiper.updateProgress(newPosition);
            }

            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          } else if (params.freeMode) {
            swiper.emit("_freeModeNoMomentumRelease");
          }

          if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
          }

          return;
        } // Find current slide

        var stopIndex = 0;
        var groupSize = swiper.slidesSizesGrid[0];

        for (
          var i = 0;
          i < slidesGrid.length;
          i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup
        ) {
          var _increment =
            i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

          if (typeof slidesGrid[i + _increment] !== "undefined") {
            if (
              currentPos >= slidesGrid[i] &&
              currentPos < slidesGrid[i + _increment]
            ) {
              stopIndex = i;
              groupSize = slidesGrid[i + _increment] - slidesGrid[i];
            }
          } else if (currentPos >= slidesGrid[i]) {
            stopIndex = i;
            groupSize =
              slidesGrid[slidesGrid.length - 1] -
              slidesGrid[slidesGrid.length - 2];
          }
        } // Find current slide size

        var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
        var increment =
          stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (timeDiff > params.longSwipesMs) {
          // Long touches
          if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
          }

          if (swiper.swipeDirection === "next") {
            if (ratio >= params.longSwipesRatio)
              swiper.slideTo(stopIndex + increment);
            else swiper.slideTo(stopIndex);
          }

          if (swiper.swipeDirection === "prev") {
            if (ratio > 1 - params.longSwipesRatio)
              swiper.slideTo(stopIndex + increment);
            else swiper.slideTo(stopIndex);
          }
        } else {
          // Short swipes
          if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
          }

          var isNavButtonTarget =
            swiper.navigation &&
            (e.target === swiper.navigation.nextEl ||
              e.target === swiper.navigation.prevEl);

          if (!isNavButtonTarget) {
            if (swiper.swipeDirection === "next") {
              swiper.slideTo(stopIndex + increment);
            }

            if (swiper.swipeDirection === "prev") {
              swiper.slideTo(stopIndex);
            }
          } else if (e.target === swiper.navigation.nextEl) {
            swiper.slideTo(stopIndex + increment);
          } else {
            swiper.slideTo(stopIndex);
          }
        }
      }

      /***/
    },

    /***/ 188: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = onResize;
      function onResize() {
        var swiper = this;
        var params = swiper.params,
          el = swiper.el;
        if (el && el.offsetWidth === 0) return; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        } // Save locks

        var allowSlideNext = swiper.allowSlideNext,
          allowSlidePrev = swiper.allowSlidePrev,
          snapGrid = swiper.snapGrid; // Disable locks on resize

        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateSlidesClasses();

        if (
          (params.slidesPerView === "auto" || params.slidesPerView > 1) &&
          swiper.isEnd &&
          !swiper.isBeginning &&
          !swiper.params.centeredSlides
        ) {
          swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (
          swiper.autoplay &&
          swiper.autoplay.running &&
          swiper.autoplay.paused
        ) {
          swiper.autoplay.run();
        } // Return locks after resize

        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;

        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }
      }

      /***/
    },

    /***/ 189: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = onClick;
      function onClick(e) {
        var swiper = this;
        if (!swiper.enabled) return;

        if (!swiper.allowClick) {
          if (swiper.params.preventClicks) e.preventDefault();

          if (swiper.params.preventClicksPropagation && swiper.animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        }
      }

      /***/
    },

    /***/ 190: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = onScroll;
      function onScroll() {
        var swiper = this;
        var wrapperEl = swiper.wrapperEl,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
        if (!enabled) return;
        swiper.previousTranslate = swiper.translate;

        if (swiper.isHorizontal()) {
          if (rtlTranslate) {
            swiper.translate =
              wrapperEl.scrollWidth -
              wrapperEl.offsetWidth -
              wrapperEl.scrollLeft;
          } else {
            swiper.translate = -wrapperEl.scrollLeft;
          }
        } else {
          swiper.translate = -wrapperEl.scrollTop;
        } // eslint-disable-next-line

        if (swiper.translate === -0) swiper.translate = 0;
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        var newProgress;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

        if (translatesDiff === 0) {
          newProgress = 0;
        } else {
          newProgress =
            (swiper.translate - swiper.minTranslate()) / translatesDiff;
        }

        if (newProgress !== swiper.progress) {
          swiper.updateProgress(
            rtlTranslate ? -swiper.translate : swiper.translate
          );
        }

        swiper.emit("setTranslate", swiper.translate, false);
      }

      /***/
    },

    /***/ 191: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _setBreakpoint = __webpack_require__(192);

      var _setBreakpoint2 = _interopRequireDefault(_setBreakpoint);

      var _getBreakpoint = __webpack_require__(193);

      var _getBreakpoint2 = _interopRequireDefault(_getBreakpoint);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        setBreakpoint: _setBreakpoint2.default,
        getBreakpoint: _getBreakpoint2.default,
      };

      /***/
    },

    /***/ 192: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = setBreakpoint;

      var _utils = __webpack_require__(1);

      function setBreakpoint() {
        var swiper = this;
        var activeIndex = swiper.activeIndex,
          initialized = swiper.initialized,
          _swiper$loopedSlides = swiper.loopedSlides,
          loopedSlides =
            _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
          params = swiper.params,
          $el = swiper.$el;
        var breakpoints = params.breakpoints;
        if (
          !breakpoints ||
          (breakpoints && Object.keys(breakpoints).length === 0)
        )
          return; // Get breakpoint for window width and update parameters

        var breakpoint = swiper.getBreakpoint(
          breakpoints,
          swiper.params.breakpointsBase,
          swiper.el
        );
        if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
        var breakpointOnlyParams =
          breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

        if (breakpointOnlyParams) {
          [
            "slidesPerView",
            "spaceBetween",
            "slidesPerGroup",
            "slidesPerGroupSkip",
            "slidesPerColumn",
          ].forEach(function (param) {
            var paramValue = breakpointOnlyParams[param];
            if (typeof paramValue === "undefined") return;

            if (
              param === "slidesPerView" &&
              (paramValue === "AUTO" || paramValue === "auto")
            ) {
              breakpointOnlyParams[param] = "auto";
            } else if (param === "slidesPerView") {
              breakpointOnlyParams[param] = parseFloat(paramValue);
            } else {
              breakpointOnlyParams[param] = parseInt(paramValue, 10);
            }
          });
        }

        var breakpointParams = breakpointOnlyParams || swiper.originalParams;
        var wasMultiRow = params.slidesPerColumn > 1;
        var isMultiRow = breakpointParams.slidesPerColumn > 1;
        var wasEnabled = params.enabled;

        if (wasMultiRow && !isMultiRow) {
          $el.removeClass(
            params.containerModifierClass +
              "multirow " +
              params.containerModifierClass +
              "multirow-column"
          );
          swiper.emitContainerClasses();
        } else if (!wasMultiRow && isMultiRow) {
          $el.addClass(params.containerModifierClass + "multirow");

          if (
            (breakpointParams.slidesPerColumnFill &&
              breakpointParams.slidesPerColumnFill === "column") ||
            (!breakpointParams.slidesPerColumnFill &&
              params.slidesPerColumnFill === "column")
          ) {
            $el.addClass(params.containerModifierClass + "multirow-column");
          }

          swiper.emitContainerClasses();
        }

        var directionChanged =
          breakpointParams.direction &&
          breakpointParams.direction !== params.direction;
        var needsReLoop =
          params.loop &&
          (breakpointParams.slidesPerView !== params.slidesPerView ||
            directionChanged);

        if (directionChanged && initialized) {
          swiper.changeDirection();
        }

        (0, _utils.extend)(swiper.params, breakpointParams);
        var isEnabled = swiper.params.enabled;
        (0, _utils.extend)(swiper, {
          allowTouchMove: swiper.params.allowTouchMove,
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
        });

        if (wasEnabled && !isEnabled) {
          swiper.disable();
        } else if (!wasEnabled && isEnabled) {
          swiper.enable();
        }

        swiper.currentBreakpoint = breakpoint;
        swiper.emit("_beforeBreakpoint", breakpointParams);

        if (needsReLoop && initialized) {
          swiper.loopDestroy();
          swiper.loopCreate();
          swiper.updateSlides();
          swiper.slideTo(
            activeIndex - loopedSlides + swiper.loopedSlides,
            0,
            false
          );
        }

        swiper.emit("breakpoint", breakpointParams);
      }

      /***/
    },

    /***/ 193: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = getBreakpoint;

      var _ssrWindow = __webpack_require__(5);

      function getBreakpoint(breakpoints, base, containerEl) {
        if (base === void 0) {
          base = "window";
        }

        if (!breakpoints || (base === "container" && !containerEl))
          return undefined;
        var breakpoint = false;
        var window = (0, _ssrWindow.getWindow)();
        var currentHeight =
          base === "window" ? window.innerHeight : containerEl.clientHeight;
        var points = Object.keys(breakpoints).map(function (point) {
          if (typeof point === "string" && point.indexOf("@") === 0) {
            var minRatio = parseFloat(point.substr(1));
            var value = currentHeight * minRatio;
            return {
              value: value,
              point: point,
            };
          }

          return {
            value: point,
            point: point,
          };
        });
        points.sort(function (a, b) {
          return parseInt(a.value, 10) - parseInt(b.value, 10);
        });

        for (var i = 0; i < points.length; i += 1) {
          var _points$i = points[i],
            point = _points$i.point,
            value = _points$i.value;

          if (base === "window") {
            if (window.matchMedia("(min-width: " + value + "px)").matches) {
              breakpoint = point;
            }
          } else if (value <= containerEl.clientWidth) {
            breakpoint = point;
          }
        }

        return breakpoint || "max";
      }

      /***/
    },

    /***/ 194: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _addClasses = __webpack_require__(195);

      var _addClasses2 = _interopRequireDefault(_addClasses);

      var _removeClasses = __webpack_require__(196);

      var _removeClasses2 = _interopRequireDefault(_removeClasses);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        addClasses: _addClasses2.default,
        removeClasses: _removeClasses2.default,
      };

      /***/
    },

    /***/ 195: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      exports.default = addClasses;
      function prepareClasses(entries, prefix) {
        var resultClasses = [];
        entries.forEach(function (item) {
          if (
            (typeof item === "undefined" ? "undefined" : _typeof(item)) ===
            "object"
          ) {
            Object.keys(item).forEach(function (classNames) {
              if (item[classNames]) {
                resultClasses.push(prefix + classNames);
              }
            });
          } else if (typeof item === "string") {
            resultClasses.push(prefix + item);
          }
        });
        return resultClasses;
      }

      function addClasses() {
        var swiper = this;
        var classNames = swiper.classNames,
      params = swiper.params,
      rtl = swiper.rtl,
      $el = swiper.$el,
      device = swiper.device,
      support = swiper.support; // prettier-ignore

        var suffixes = prepareClasses(
          [
            "initialized",
            params.direction,
            {
              "pointer-events": support.pointerEvents && !support.touch,
            },
            {
              "free-mode": params.freeMode,
            },
            {
              autoheight: params.autoHeight,
            },
            {
              rtl: rtl,
            },
            {
              multirow: params.slidesPerColumn > 1,
            },
            {
              "multirow-column":
                params.slidesPerColumn > 1 &&
                params.slidesPerColumnFill === "column",
            },
            {
              android: device.android,
            },
            {
              ios: device.ios,
            },
            {
              "css-mode": params.cssMode,
            },
          ],
          params.containerModifierClass
        );
        classNames.push.apply(classNames, suffixes);
        $el.addClass([].concat(classNames).join(" "));
        swiper.emitContainerClasses();
      }

      /***/
    },

    /***/ 196: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = removeClasses;
      function removeClasses() {
        var swiper = this;
        var $el = swiper.$el,
          classNames = swiper.classNames;
        $el.removeClass(classNames.join(" "));
        swiper.emitContainerClasses();
      }

      /***/
    },

    /***/ 197: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _loadImage = __webpack_require__(198);

      var _loadImage2 = _interopRequireDefault(_loadImage);

      var _preloadImages = __webpack_require__(199);

      var _preloadImages2 = _interopRequireDefault(_preloadImages);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      exports.default = {
        loadImage: _loadImage2.default,
        preloadImages: _preloadImages2.default,
      };

      /***/
    },

    /***/ 198: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = loadImage;

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function loadImage(
        imageEl,
        src,
        srcset,
        sizes,
        checkForComplete,
        callback
      ) {
        var window = (0, _ssrWindow.getWindow)();
        var image;

        function onReady() {
          if (callback) callback();
        }

        var isPicture = (0, _dom2.default)(imageEl).parent("picture")[0];

        if (!isPicture && (!imageEl.complete || !checkForComplete)) {
          if (src) {
            image = new window.Image();
            image.onload = onReady;
            image.onerror = onReady;

            if (sizes) {
              image.sizes = sizes;
            }

            if (srcset) {
              image.srcset = srcset;
            }

            if (src) {
              image.src = src;
            }
          } else {
            onReady();
          }
        } else {
          // image already loaded...
          onReady();
        }
      }

      /***/
    },

    /***/ 199: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = preloadImages;
      function preloadImages() {
        var swiper = this;
        swiper.imagesToLoad = swiper.$el.find("img");

        function onReady() {
          if (
            typeof swiper === "undefined" ||
            swiper === null ||
            !swiper ||
            swiper.destroyed
          )
            return;
          if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

          if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
            if (swiper.params.updateOnImagesReady) swiper.update();
            swiper.emit("imagesReady");
          }
        }

        for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
          var imageEl = swiper.imagesToLoad[i];
          swiper.loadImage(
            imageEl,
            imageEl.currentSrc || imageEl.getAttribute("src"),
            imageEl.srcset || imageEl.getAttribute("srcset"),
            imageEl.sizes || imageEl.getAttribute("sizes"),
            true,
            onReady
          );
        }
      }

      /***/
    },

    /***/ 2: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };

      var utils = __webpack_require__(0);

      /**
       * Create an Error with the specified message, config, error code, request and response.
       *
       * @param {string} message The error message.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [config] The config.
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       * @returns {Error} The created error.
       */
      function AxiosError(message, code, config, request, response) {
        Error.call(this);
        this.message = message;
        this.name = "AxiosError";
        code && (this.code = code);
        config && (this.config = config);
        request && (this.request = request);
        response && (this.response = response);
      }

      utils.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code,
            status:
              this.response && this.response.status
                ? this.response.status
                : null,
          };
        },
      });

      var prototype = AxiosError.prototype;
      var descriptors = {};

      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        // eslint-disable-next-line func-names
      ].forEach(function (code) {
        descriptors[code] = { value: code };
      });

      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype, "isAxiosError", { value: true });

      // eslint-disable-next-line func-names
      AxiosError.from = function (
        error,
        code,
        config,
        request,
        response,
        customProps
      ) {
        var axiosError = Object.create(prototype);

        utils.toFlatObject(error, axiosError, function filter(obj) {
          return obj !== Error.prototype;
        });

        AxiosError.call(
          axiosError,
          error.message,
          code,
          config,
          request,
          response
        );

        axiosError.name = error.name;

        customProps && _extends(axiosError, customProps);

        return axiosError;
      };

      module.exports = AxiosError;

      /***/
    },

    /***/ 20: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * @public
       * @type {Object}
       */

      module.exports = {
        width: function width() {
          return document.documentElement.clientWidth < window.innerWidth
            ? window.innerWidth
            : document.documentElement.clientWidth;
        },
        height: function height() {
          return document.documentElement.clientHeight < window.innerHeight
            ? window.innerHeight
            : document.documentElement.clientHeight;
        },
        orientation: function orientation() {
          var width = this.width();
          var height = this.height();

          if (width < height) {
            return "portrait";
          } else if (width > height) {
            return "landscape";
          } else {
            return "";
          }
        },
        isPortrait: function isPortrait() {
          return this.orientation() === "portrait" ? true : false;
        },
        isLandscape: function isLandscape() {
          return this.orientation() === "landscape" ? true : false;
        },
        isMobile: function isMobile() {
          return this.width() < 1025 ? true : false;
        },
        isPhone: function isPhone() {
          return this.width() < 768 ? true : false;
        },
        isTablet: function isTablet() {
          return this.isMobile() && !this.isPhone();
        },
        isDesktop: function isDesktop() {
          return !this.isMobile();
        },
      };

      /***/
    },

    /***/ 200: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      function checkOverflow() {
        var swiper = this;
        var params = swiper.params;
        var wasLocked = swiper.isLocked;
        var lastSlidePosition =
          swiper.slides.length > 0 &&
          params.slidesOffsetBefore +
            params.spaceBetween * (swiper.slides.length - 1) +
            swiper.slides[0].offsetWidth * swiper.slides.length;

        if (
          params.slidesOffsetBefore &&
          params.slidesOffsetAfter &&
          lastSlidePosition
        ) {
          swiper.isLocked = lastSlidePosition <= swiper.size;
        } else {
          swiper.isLocked = swiper.snapGrid.length === 1;
        }

        swiper.allowSlideNext = !swiper.isLocked;
        swiper.allowSlidePrev = !swiper.isLocked; // events

        if (wasLocked !== swiper.isLocked)
          swiper.emit(swiper.isLocked ? "lock" : "unlock");

        if (wasLocked && wasLocked !== swiper.isLocked) {
          swiper.isEnd = false;
          if (swiper.navigation) swiper.navigation.update();
        }
      }

      exports.default = {
        checkOverflow: checkOverflow,
      };

      /***/
    },

    /***/ 201: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      exports.default = {
        init: true,
        direction: "horizontal",
        touchEventsTarget: "container",
        initialSlide: 0,
        speed: 300,
        cssMode: false,
        updateOnWindowResize: true,
        resizeObserver: false,
        nested: false,
        createElements: false,
        enabled: true,
        focusableElements:
          "input, select, option, textarea, button, video, label",
        // Overrides
        width: null,
        height: null,
        //
        preventInteractionOnTransition: false,
        // ssr
        userAgent: null,
        url: null,
        // To support iOS's swipe-to-go-back gesture (when being used in-app).
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        // Free mode
        freeMode: false,
        freeModeMomentum: true,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: true,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: false,
        freeModeMinimumVelocity: 0.02,
        // Autoheight
        autoHeight: false,
        // Set wrapper width
        setWrapperSize: false,
        // Virtual Translate
        virtualTranslate: false,
        // Effects
        effect: "slide",
        // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
        // Breakpoints
        breakpoints: undefined,
        breakpointsBase: "window",
        // Slides grid
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: "column",
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        centeredSlides: false,
        centeredSlidesBounds: false,
        slidesOffsetBefore: 0,
        // in px
        slidesOffsetAfter: 0,
        // in px
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,
        // Disable swiper and hide navigation when container not overflow
        watchOverflow: false,
        // Round length
        roundLengths: false,
        // Touches
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: false,
        touchStartPreventDefault: true,
        touchStartForcePreventDefault: false,
        touchReleaseOnEdges: false,
        // Unique Navigation Elements
        uniqueNavElements: true,
        // Resistance
        resistance: true,
        resistanceRatio: 0.85,
        // Progress
        watchSlidesProgress: false,
        watchSlidesVisibility: false,
        // Cursor
        grabCursor: false,
        // Clicks
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        // Images
        preloadImages: true,
        updateOnImagesReady: true,
        // loop
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        loopPreventsSlide: true,
        // Swiping/no swiping
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        // '.swipe-handler',
        noSwiping: true,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        // Passive Listeners
        passiveListeners: true,
        // NS
        containerModifierClass: "swiper-container-",
        // NEW
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        // Callbacks
        runCallbacksOnInit: true,
        // Internals
        _emitClasses: false,
      };

      /***/
    },

    /***/ 202: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Virtual = {
        update: function update(force) {
          var swiper = this;
          var _swiper$params = swiper.params,
            slidesPerView = _swiper$params.slidesPerView,
            slidesPerGroup = _swiper$params.slidesPerGroup,
            centeredSlides = _swiper$params.centeredSlides;
          var _swiper$params$virtua = swiper.params.virtual,
            addSlidesBefore = _swiper$params$virtua.addSlidesBefore,
            addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
          var _swiper$virtual = swiper.virtual,
            previousFrom = _swiper$virtual.from,
            previousTo = _swiper$virtual.to,
            slides = _swiper$virtual.slides,
            previousSlidesGrid = _swiper$virtual.slidesGrid,
            renderSlide = _swiper$virtual.renderSlide,
            previousOffset = _swiper$virtual.offset;
          swiper.updateActiveIndex();
          var activeIndex = swiper.activeIndex || 0;
          var offsetProp;
          if (swiper.rtlTranslate) offsetProp = "right";
          else offsetProp = swiper.isHorizontal() ? "left" : "top";
          var slidesAfter;
          var slidesBefore;

          if (centeredSlides) {
            slidesAfter =
              Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            slidesBefore =
              Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
          } else {
            slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
            slidesBefore = slidesPerGroup + addSlidesBefore;
          }

          var from = Math.max((activeIndex || 0) - slidesBefore, 0);
          var to = Math.min(
            (activeIndex || 0) + slidesAfter,
            slides.length - 1
          );
          var offset =
            (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
          (0, _utils.extend)(swiper.virtual, {
            from: from,
            to: to,
            offset: offset,
            slidesGrid: swiper.slidesGrid,
          });

          function onRendered() {
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();

            if (swiper.lazy && swiper.params.lazy.enabled) {
              swiper.lazy.load();
            }
          }

          if (previousFrom === from && previousTo === to && !force) {
            if (
              swiper.slidesGrid !== previousSlidesGrid &&
              offset !== previousOffset
            ) {
              swiper.slides.css(offsetProp, offset + "px");
            }

            swiper.updateProgress();
            return;
          }

          if (swiper.params.virtual.renderExternal) {
            swiper.params.virtual.renderExternal.call(swiper, {
              offset: offset,
              from: from,
              to: to,
              slides: (function getSlides() {
                var slidesToRender = [];

                for (var i = from; i <= to; i += 1) {
                  slidesToRender.push(slides[i]);
                }

                return slidesToRender;
              })(),
            });

            if (swiper.params.virtual.renderExternalUpdate) {
              onRendered();
            }

            return;
          }

          var prependIndexes = [];
          var appendIndexes = [];

          if (force) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
          } else {
            for (var i = previousFrom; i <= previousTo; i += 1) {
              if (i < from || i > to) {
                swiper.$wrapperEl
                  .find(
                    "." +
                      swiper.params.slideClass +
                      '[data-swiper-slide-index="' +
                      i +
                      '"]'
                  )
                  .remove();
              }
            }
          }

          for (var _i = 0; _i < slides.length; _i += 1) {
            if (_i >= from && _i <= to) {
              if (typeof previousTo === "undefined" || force) {
                appendIndexes.push(_i);
              } else {
                if (_i > previousTo) appendIndexes.push(_i);
                if (_i < previousFrom) prependIndexes.push(_i);
              }
            }
          }

          appendIndexes.forEach(function (index) {
            swiper.$wrapperEl.append(renderSlide(slides[index], index));
          });
          prependIndexes
            .sort(function (a, b) {
              return b - a;
            })
            .forEach(function (index) {
              swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
          swiper.$wrapperEl
            .children(".swiper-slide")
            .css(offsetProp, offset + "px");
          onRendered();
        },
        renderSlide: function renderSlide(slide, index) {
          var swiper = this;
          var params = swiper.params.virtual;

          if (params.cache && swiper.virtual.cache[index]) {
            return swiper.virtual.cache[index];
          }

          var $slideEl = params.renderSlide
            ? (0, _dom2.default)(params.renderSlide.call(swiper, slide, index))
            : (0, _dom2.default)(
                '<div class="' +
                  swiper.params.slideClass +
                  '" data-swiper-slide-index="' +
                  index +
                  '">' +
                  slide +
                  "</div>"
              );
          if (!$slideEl.attr("data-swiper-slide-index"))
            $slideEl.attr("data-swiper-slide-index", index);
          if (params.cache) swiper.virtual.cache[index] = $slideEl;
          return $slideEl;
        },
        appendSlide: function appendSlide(slides) {
          var swiper = this;

          if (
            (typeof slides === "undefined" ? "undefined" : _typeof(slides)) ===
              "object" &&
            "length" in slides
          ) {
            for (var i = 0; i < slides.length; i += 1) {
              if (slides[i]) swiper.virtual.slides.push(slides[i]);
            }
          } else {
            swiper.virtual.slides.push(slides);
          }

          swiper.virtual.update(true);
        },
        prependSlide: function prependSlide(slides) {
          var swiper = this;
          var activeIndex = swiper.activeIndex;
          var newActiveIndex = activeIndex + 1;
          var numberOfNewSlides = 1;

          if (Array.isArray(slides)) {
            for (var i = 0; i < slides.length; i += 1) {
              if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
            }

            newActiveIndex = activeIndex + slides.length;
            numberOfNewSlides = slides.length;
          } else {
            swiper.virtual.slides.unshift(slides);
          }

          if (swiper.params.virtual.cache) {
            var cache = swiper.virtual.cache;
            var newCache = {};
            Object.keys(cache).forEach(function (cachedIndex) {
              var $cachedEl = cache[cachedIndex];
              var cachedElIndex = $cachedEl.attr("data-swiper-slide-index");

              if (cachedElIndex) {
                $cachedEl.attr(
                  "data-swiper-slide-index",
                  parseInt(cachedElIndex, 10) + 1
                );
              }

              newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] =
                $cachedEl;
            });
            swiper.virtual.cache = newCache;
          }

          swiper.virtual.update(true);
          swiper.slideTo(newActiveIndex, 0);
        },
        removeSlide: function removeSlide(slidesIndexes) {
          var swiper = this;
          if (typeof slidesIndexes === "undefined" || slidesIndexes === null)
            return;
          var activeIndex = swiper.activeIndex;

          if (Array.isArray(slidesIndexes)) {
            for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
              swiper.virtual.slides.splice(slidesIndexes[i], 1);

              if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes[i]];
              }

              if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
              activeIndex = Math.max(activeIndex, 0);
            }
          } else {
            swiper.virtual.slides.splice(slidesIndexes, 1);

            if (swiper.params.virtual.cache) {
              delete swiper.virtual.cache[slidesIndexes];
            }

            if (slidesIndexes < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
          }

          swiper.virtual.update(true);
          swiper.slideTo(activeIndex, 0);
        },
        removeAllSlides: function removeAllSlides() {
          var swiper = this;
          swiper.virtual.slides = [];

          if (swiper.params.virtual.cache) {
            swiper.virtual.cache = {};
          }

          swiper.virtual.update(true);
          swiper.slideTo(0, 0);
        },
      };
      exports.default = {
        name: "virtual",
        params: {
          virtual: {
            enabled: false,
            slides: [],
            cache: true,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: true,
            addSlidesBefore: 0,
            addSlidesAfter: 0,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            virtual: _extends({}, Virtual, {
              slides: swiper.params.virtual.slides,
              cache: {},
            }),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (!swiper.params.virtual.enabled) return;
            swiper.classNames.push(
              swiper.params.containerModifierClass + "virtual"
            );
            var overwriteParams = {
              watchSlidesProgress: true,
            };
            (0, _utils.extend)(swiper.params, overwriteParams);
            (0, _utils.extend)(swiper.originalParams, overwriteParams);

            if (!swiper.params.initialSlide) {
              swiper.virtual.update();
            }
          },
          setTranslate: function setTranslate(swiper) {
            if (!swiper.params.virtual.enabled) return;
            swiper.virtual.update();
          },
        },
      };

      /***/
    },

    /***/ 203: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      /* eslint-disable consistent-return */

      var Keyboard = {
        handle: function handle(event) {
          var swiper = this;
          if (!swiper.enabled) return;
          var window = (0, _ssrWindow.getWindow)();
          var document = (0, _ssrWindow.getDocument)();
          var rtl = swiper.rtlTranslate;
          var e = event;
          if (e.originalEvent) e = e.originalEvent; // jquery fix

          var kc = e.keyCode || e.charCode;
          var pageUpDown = swiper.params.keyboard.pageUpDown;
          var isPageUp = pageUpDown && kc === 33;
          var isPageDown = pageUpDown && kc === 34;
          var isArrowLeft = kc === 37;
          var isArrowRight = kc === 39;
          var isArrowUp = kc === 38;
          var isArrowDown = kc === 40; // Directions locks

          if (
            !swiper.allowSlideNext &&
            ((swiper.isHorizontal() && isArrowRight) ||
              (swiper.isVertical() && isArrowDown) ||
              isPageDown)
          ) {
            return false;
          }

          if (
            !swiper.allowSlidePrev &&
            ((swiper.isHorizontal() && isArrowLeft) ||
              (swiper.isVertical() && isArrowUp) ||
              isPageUp)
          ) {
            return false;
          }

          if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return undefined;
          }

          if (
            document.activeElement &&
            document.activeElement.nodeName &&
            (document.activeElement.nodeName.toLowerCase() === "input" ||
              document.activeElement.nodeName.toLowerCase() === "textarea")
          ) {
            return undefined;
          }

          if (
            swiper.params.keyboard.onlyInViewport &&
            (isPageUp ||
              isPageDown ||
              isArrowLeft ||
              isArrowRight ||
              isArrowUp ||
              isArrowDown)
          ) {
            var inView = false; // Check that swiper should be inside of visible area of window

            if (
              swiper.$el.parents("." + swiper.params.slideClass).length > 0 &&
              swiper.$el.parents("." + swiper.params.slideActiveClass)
                .length === 0
            ) {
              return undefined;
            }

            var $el = swiper.$el;
            var swiperWidth = $el[0].clientWidth;
            var swiperHeight = $el[0].clientHeight;
            var windowWidth = window.innerWidth;
            var windowHeight = window.innerHeight;
            var swiperOffset = swiper.$el.offset();
            if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
            var swiperCoord = [
              [swiperOffset.left, swiperOffset.top],
              [swiperOffset.left + swiperWidth, swiperOffset.top],
              [swiperOffset.left, swiperOffset.top + swiperHeight],
              [
                swiperOffset.left + swiperWidth,
                swiperOffset.top + swiperHeight,
              ],
            ];

            for (var i = 0; i < swiperCoord.length; i += 1) {
              var point = swiperCoord[i];

              if (
                point[0] >= 0 &&
                point[0] <= windowWidth &&
                point[1] >= 0 &&
                point[1] <= windowHeight
              ) {
                if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

                inView = true;
              }
            }

            if (!inView) return undefined;
          }

          if (swiper.isHorizontal()) {
            if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
              if (e.preventDefault) e.preventDefault();
              else e.returnValue = false;
            }

            if (
              ((isPageDown || isArrowRight) && !rtl) ||
              ((isPageUp || isArrowLeft) && rtl)
            )
              swiper.slideNext();
            if (
              ((isPageUp || isArrowLeft) && !rtl) ||
              ((isPageDown || isArrowRight) && rtl)
            )
              swiper.slidePrev();
          } else {
            if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
              if (e.preventDefault) e.preventDefault();
              else e.returnValue = false;
            }

            if (isPageDown || isArrowDown) swiper.slideNext();
            if (isPageUp || isArrowUp) swiper.slidePrev();
          }

          swiper.emit("keyPress", kc);
          return undefined;
        },
        enable: function enable() {
          var swiper = this;
          var document = (0, _ssrWindow.getDocument)();
          if (swiper.keyboard.enabled) return;
          (0, _dom2.default)(document).on("keydown", swiper.keyboard.handle);
          swiper.keyboard.enabled = true;
        },
        disable: function disable() {
          var swiper = this;
          var document = (0, _ssrWindow.getDocument)();
          if (!swiper.keyboard.enabled) return;
          (0, _dom2.default)(document).off("keydown", swiper.keyboard.handle);
          swiper.keyboard.enabled = false;
        },
      };
      exports.default = {
        name: "keyboard",
        params: {
          keyboard: {
            enabled: false,
            onlyInViewport: true,
            pageUpDown: true,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            keyboard: _extends(
              {
                enabled: false,
              },
              Keyboard
            ),
          });
        },
        on: {
          init: function init(swiper) {
            if (swiper.params.keyboard.enabled) {
              swiper.keyboard.enable();
            }
          },
          destroy: function destroy(swiper) {
            if (swiper.keyboard.enabled) {
              swiper.keyboard.disable();
            }
          },
        },
      };

      /***/
    },

    /***/ 204: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function isEventSupported() {
        var document = (0, _ssrWindow.getDocument)();
        var eventName = "onwheel";
        var isSupported = eventName in document;

        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }

        if (
          !isSupported &&
          document.implementation &&
          document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
          // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
          document.implementation.hasFeature("", "") !== true
        ) {
          // This is the only way to test support for the `wheel` event in IE9+.
          isSupported = document.implementation.hasFeature(
            "Events.wheel",
            "3.0"
          );
        }

        return isSupported;
      } /* eslint-disable consistent-return */

      var Mousewheel = {
        lastScrollTime: (0, _utils.now)(),
        lastEventBeforeSnap: undefined,
        recentWheelEvents: [],
        event: function event() {
          var window = (0, _ssrWindow.getWindow)();
          if (window.navigator.userAgent.indexOf("firefox") > -1)
            return "DOMMouseScroll";
          return isEventSupported() ? "wheel" : "mousewheel";
        },
        normalize: function normalize(e) {
          // Reasonable defaults
          var PIXEL_STEP = 10;
          var LINE_HEIGHT = 40;
          var PAGE_HEIGHT = 800;
          var sX = 0;
          var sY = 0; // spinX, spinY

          var pX = 0;
          var pY = 0; // pixelX, pixelY
          // Legacy

          if ("detail" in e) {
            sY = e.detail;
          }

          if ("wheelDelta" in e) {
            sY = -e.wheelDelta / 120;
          }

          if ("wheelDeltaY" in e) {
            sY = -e.wheelDeltaY / 120;
          }

          if ("wheelDeltaX" in e) {
            sX = -e.wheelDeltaX / 120;
          } // side scrolling on FF with DOMMouseScroll

          if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
          }

          pX = sX * PIXEL_STEP;
          pY = sY * PIXEL_STEP;

          if ("deltaY" in e) {
            pY = e.deltaY;
          }

          if ("deltaX" in e) {
            pX = e.deltaX;
          }

          if (e.shiftKey && !pX) {
            // if user scrolls with shift he wants horizontal scroll
            pX = pY;
            pY = 0;
          }

          if ((pX || pY) && e.deltaMode) {
            if (e.deltaMode === 1) {
              // delta in LINE units
              pX *= LINE_HEIGHT;
              pY *= LINE_HEIGHT;
            } else {
              // delta in PAGE units
              pX *= PAGE_HEIGHT;
              pY *= PAGE_HEIGHT;
            }
          } // Fall-back if spin cannot be determined

          if (pX && !sX) {
            sX = pX < 1 ? -1 : 1;
          }

          if (pY && !sY) {
            sY = pY < 1 ? -1 : 1;
          }

          return {
            spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY,
          };
        },
        handleMouseEnter: function handleMouseEnter() {
          var swiper = this;
          if (!swiper.enabled) return;
          swiper.mouseEntered = true;
        },
        handleMouseLeave: function handleMouseLeave() {
          var swiper = this;
          if (!swiper.enabled) return;
          swiper.mouseEntered = false;
        },
        handle: function handle(event) {
          var e = event;
          var disableParentSwiper = true;
          var swiper = this;
          if (!swiper.enabled) return;
          var params = swiper.params.mousewheel;

          if (swiper.params.cssMode) {
            e.preventDefault();
          }

          var target = swiper.$el;

          if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = (0, _dom2.default)(swiper.params.mousewheel.eventsTarget);
          }

          if (
            !swiper.mouseEntered &&
            !target[0].contains(e.target) &&
            !params.releaseOnEdges
          )
            return true;
          if (e.originalEvent) e = e.originalEvent; // jquery fix

          var delta = 0;
          var rtlFactor = swiper.rtlTranslate ? -1 : 1;
          var data = Mousewheel.normalize(e);

          if (params.forceToAxis) {
            if (swiper.isHorizontal()) {
              if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
                delta = -data.pixelX * rtlFactor;
              else return true;
            } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
              delta = -data.pixelY;
            else return true;
          } else {
            delta =
              Math.abs(data.pixelX) > Math.abs(data.pixelY)
                ? -data.pixelX * rtlFactor
                : -data.pixelY;
          }

          if (delta === 0) return true;
          if (params.invert) delta = -delta; // Get the scroll positions

          var positions = swiper.getTranslate() + delta * params.sensitivity;
          if (positions >= swiper.minTranslate())
            positions = swiper.minTranslate();
          if (positions <= swiper.maxTranslate())
            positions = swiper.maxTranslate(); // When loop is true:
          //     the disableParentSwiper will be true.
          // When loop is false:
          //     if the scroll positions is not on edge,
          //     then the disableParentSwiper will be true.
          //     if the scroll on edge positions,
          //     then the disableParentSwiper will be false.

          disableParentSwiper = swiper.params.loop
            ? true
            : !(
                positions === swiper.minTranslate() ||
                positions === swiper.maxTranslate()
              );
          if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

          if (!swiper.params.freeMode) {
            // Register the new event in a variable which stores the relevant data
            var newEvent = {
              time: (0, _utils.now)(),
              delta: Math.abs(delta),
              direction: Math.sign(delta),
              raw: event,
            }; // Keep the most recent events

            var recentWheelEvents = swiper.mousewheel.recentWheelEvents;

            if (recentWheelEvents.length >= 2) {
              recentWheelEvents.shift(); // only store the last N events
            }

            var prevEvent = recentWheelEvents.length
              ? recentWheelEvents[recentWheelEvents.length - 1]
              : undefined;
            recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
            //   If direction has changed or
            //   if the scroll is quicker than the previous one:
            //     Animate the slider.
            // Else (this is the first time the wheel is moved):
            //     Animate the slider.

            if (prevEvent) {
              if (
                newEvent.direction !== prevEvent.direction ||
                newEvent.delta > prevEvent.delta ||
                newEvent.time > prevEvent.time + 150
              ) {
                swiper.mousewheel.animateSlider(newEvent);
              }
            } else {
              swiper.mousewheel.animateSlider(newEvent);
            } // If it's time to release the scroll:
            //   Return now so you don't hit the preventDefault.

            if (swiper.mousewheel.releaseScroll(newEvent)) {
              return true;
            }
          } else {
            // Freemode or scrollContainer:
            // If we recently snapped after a momentum scroll, then ignore wheel events
            // to give time for the deceleration to finish. Stop ignoring after 500 msecs
            // or if it's a new scroll (larger delta or inverse sign as last event before
            // an end-of-momentum snap).
            var _newEvent = {
              time: (0, _utils.now)(),
              delta: Math.abs(delta),
              direction: Math.sign(delta),
            };
            var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
            var ignoreWheelEvents =
              lastEventBeforeSnap &&
              _newEvent.time < lastEventBeforeSnap.time + 500 &&
              _newEvent.delta <= lastEventBeforeSnap.delta &&
              _newEvent.direction === lastEventBeforeSnap.direction;

            if (!ignoreWheelEvents) {
              swiper.mousewheel.lastEventBeforeSnap = undefined;

              if (swiper.params.loop) {
                swiper.loopFix();
              }

              var position = swiper.getTranslate() + delta * params.sensitivity;
              var wasBeginning = swiper.isBeginning;
              var wasEnd = swiper.isEnd;
              if (position >= swiper.minTranslate())
                position = swiper.minTranslate();
              if (position <= swiper.maxTranslate())
                position = swiper.maxTranslate();
              swiper.setTransition(0);
              swiper.setTranslate(position);
              swiper.updateProgress();
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses();

              if (
                (!wasBeginning && swiper.isBeginning) ||
                (!wasEnd && swiper.isEnd)
              ) {
                swiper.updateSlidesClasses();
              }

              if (swiper.params.freeModeSticky) {
                // When wheel scrolling starts with sticky (aka snap) enabled, then detect
                // the end of a momentum scroll by storing recent (N=15?) wheel events.
                // 1. do all N events have decreasing or same (absolute value) delta?
                // 2. did all N events arrive in the last M (M=500?) msecs?
                // 3. does the earliest event have an (absolute value) delta that's
                //    at least P (P=1?) larger than the most recent event's delta?
                // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
                // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
                // Snap immediately and ignore remaining wheel events in this scroll.
                // See comment above for "remaining wheel events in this scroll" determination.
                // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
                clearTimeout(swiper.mousewheel.timeout);
                swiper.mousewheel.timeout = undefined;
                var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;

                if (_recentWheelEvents.length >= 15) {
                  _recentWheelEvents.shift(); // only store the last N events
                }

                var _prevEvent = _recentWheelEvents.length
                  ? _recentWheelEvents[_recentWheelEvents.length - 1]
                  : undefined;

                var firstEvent = _recentWheelEvents[0];

                _recentWheelEvents.push(_newEvent);

                if (
                  _prevEvent &&
                  (_newEvent.delta > _prevEvent.delta ||
                    _newEvent.direction !== _prevEvent.direction)
                ) {
                  // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                  _recentWheelEvents.splice(0);
                } else if (
                  _recentWheelEvents.length >= 15 &&
                  _newEvent.time - firstEvent.time < 500 &&
                  firstEvent.delta - _newEvent.delta >= 1 &&
                  _newEvent.delta <= 6
                ) {
                  // We're at the end of the deceleration of a momentum scroll, so there's no need
                  // to wait for more events. Snap ASAP on the next tick.
                  // Also, because there's some remaining momentum we'll bias the snap in the
                  // direction of the ongoing scroll because it's better UX for the scroll to snap
                  // in the same direction as the scroll instead of reversing to snap.  Therefore,
                  // if it's already scrolled more than 20% in the current direction, keep going.
                  var snapToThreshold = delta > 0 ? 0.8 : 0.2;
                  swiper.mousewheel.lastEventBeforeSnap = _newEvent;

                  _recentWheelEvents.splice(0);

                  swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {
                    swiper.slideToClosest(
                      swiper.params.speed,
                      true,
                      undefined,
                      snapToThreshold
                    );
                  }, 0); // no delay; move on next tick
                }

                if (!swiper.mousewheel.timeout) {
                  // if we get here, then we haven't detected the end of a momentum scroll, so
                  // we'll consider a scroll "complete" when there haven't been any wheel events
                  // for 500ms.
                  swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {
                    var snapToThreshold = 0.5;
                    swiper.mousewheel.lastEventBeforeSnap = _newEvent;

                    _recentWheelEvents.splice(0);

                    swiper.slideToClosest(
                      swiper.params.speed,
                      true,
                      undefined,
                      snapToThreshold
                    );
                  }, 500);
                }
              } // Emit event

              if (!ignoreWheelEvents) swiper.emit("scroll", e); // Stop autoplay

              if (
                swiper.params.autoplay &&
                swiper.params.autoplayDisableOnInteraction
              )
                swiper.autoplay.stop(); // Return page scroll on edge positions

              if (
                position === swiper.minTranslate() ||
                position === swiper.maxTranslate()
              )
                return true;
            }
          }

          if (e.preventDefault) e.preventDefault();
          else e.returnValue = false;
          return false;
        },
        animateSlider: function animateSlider(newEvent) {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();

          if (
            this.params.mousewheel.thresholdDelta &&
            newEvent.delta < this.params.mousewheel.thresholdDelta
          ) {
            // Prevent if delta of wheel scroll delta is below configured threshold
            return false;
          }

          if (
            this.params.mousewheel.thresholdTime &&
            (0, _utils.now)() - swiper.mousewheel.lastScrollTime <
              this.params.mousewheel.thresholdTime
          ) {
            // Prevent if time between scrolls is below configured threshold
            return false;
          } // If the movement is NOT big enough and
          // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
          //   Don't go any further (avoid insignificant scroll movement).

          if (
            newEvent.delta >= 6 &&
            (0, _utils.now)() - swiper.mousewheel.lastScrollTime < 60
          ) {
            // Return false as a default
            return true;
          } // If user is scrolling towards the end:
          //   If the slider hasn't hit the latest slide or
          //   if the slider is a loop and
          //   if the slider isn't moving right now:
          //     Go to next slide and
          //     emit a scroll event.
          // Else (the user is scrolling towards the beginning) and
          // if the slider hasn't hit the first slide or
          // if the slider is a loop and
          // if the slider isn't moving right now:
          //   Go to prev slide and
          //   emit a scroll event.

          if (newEvent.direction < 0) {
            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
              swiper.slideNext();
              swiper.emit("scroll", newEvent.raw);
            }
          } else if (
            (!swiper.isBeginning || swiper.params.loop) &&
            !swiper.animating
          ) {
            swiper.slidePrev();
            swiper.emit("scroll", newEvent.raw);
          } // If you got here is because an animation has been triggered so store the current time

          swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default

          return false;
        },
        releaseScroll: function releaseScroll(newEvent) {
          var swiper = this;
          var params = swiper.params.mousewheel;

          if (newEvent.direction < 0) {
            if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
              // Return true to animate scroll on edges
              return true;
            }
          } else if (
            swiper.isBeginning &&
            !swiper.params.loop &&
            params.releaseOnEdges
          ) {
            // Return true to animate scroll on edges
            return true;
          }

          return false;
        },
        enable: function enable() {
          var swiper = this;
          var event = Mousewheel.event();

          if (swiper.params.cssMode) {
            swiper.wrapperEl.removeEventListener(
              event,
              swiper.mousewheel.handle
            );
            return true;
          }

          if (!event) return false;
          if (swiper.mousewheel.enabled) return false;
          var target = swiper.$el;

          if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = (0, _dom2.default)(swiper.params.mousewheel.eventsTarget);
          }

          target.on("mouseenter", swiper.mousewheel.handleMouseEnter);
          target.on("mouseleave", swiper.mousewheel.handleMouseLeave);
          target.on(event, swiper.mousewheel.handle);
          swiper.mousewheel.enabled = true;
          return true;
        },
        disable: function disable() {
          var swiper = this;
          var event = Mousewheel.event();

          if (swiper.params.cssMode) {
            swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
            return true;
          }

          if (!event) return false;
          if (!swiper.mousewheel.enabled) return false;
          var target = swiper.$el;

          if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = (0, _dom2.default)(swiper.params.mousewheel.eventsTarget);
          }

          target.off(event, swiper.mousewheel.handle);
          swiper.mousewheel.enabled = false;
          return true;
        },
      };
      exports.default = {
        name: "mousewheel",
        params: {
          mousewheel: {
            enabled: false,
            releaseOnEdges: false,
            invert: false,
            forceToAxis: false,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            mousewheel: {
              enabled: false,
              lastScrollTime: (0, _utils.now)(),
              lastEventBeforeSnap: undefined,
              recentWheelEvents: [],
              enable: Mousewheel.enable,
              disable: Mousewheel.disable,
              handle: Mousewheel.handle,
              handleMouseEnter: Mousewheel.handleMouseEnter,
              handleMouseLeave: Mousewheel.handleMouseLeave,
              animateSlider: Mousewheel.animateSlider,
              releaseScroll: Mousewheel.releaseScroll,
            },
          });
        },
        on: {
          init: function init(swiper) {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
              swiper.mousewheel.disable();
            }

            if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
          },
          destroy: function destroy(swiper) {
            if (swiper.params.cssMode) {
              swiper.mousewheel.enable();
            }

            if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
          },
        },
      };

      /***/
    },

    /***/ 205: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Navigation = {
        toggleEl: function toggleEl($el, disabled) {
          $el[disabled ? "addClass" : "removeClass"](
            this.params.navigation.disabledClass
          );
          if ($el[0] && $el[0].tagName === "BUTTON") $el[0].disabled = disabled;
        },
        update: function update() {
          // Update Navigation Buttons
          var swiper = this;
          var params = swiper.params.navigation;
          var toggleEl = swiper.navigation.toggleEl;
          if (swiper.params.loop) return;
          var _swiper$navigation = swiper.navigation,
            $nextEl = _swiper$navigation.$nextEl,
            $prevEl = _swiper$navigation.$prevEl;

          if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
              toggleEl($prevEl, true);
            } else {
              toggleEl($prevEl, false);
            }

            if (swiper.params.watchOverflow && swiper.enabled) {
              $prevEl[swiper.isLocked ? "addClass" : "removeClass"](
                params.lockClass
              );
            }
          }

          if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
              toggleEl($nextEl, true);
            } else {
              toggleEl($nextEl, false);
            }

            if (swiper.params.watchOverflow && swiper.enabled) {
              $nextEl[swiper.isLocked ? "addClass" : "removeClass"](
                params.lockClass
              );
            }
          }
        },
        onPrevClick: function onPrevClick(e) {
          var swiper = this;
          e.preventDefault();
          if (swiper.isBeginning && !swiper.params.loop) return;
          swiper.slidePrev();
        },
        onNextClick: function onNextClick(e) {
          var swiper = this;
          e.preventDefault();
          if (swiper.isEnd && !swiper.params.loop) return;
          swiper.slideNext();
        },
        init: function init() {
          var swiper = this;
          var params = swiper.params.navigation;
          swiper.params.navigation = (0, _utils.createElementIfNotDefined)(
            swiper.$el,
            swiper.params.navigation,
            swiper.params.createElements,
            {
              nextEl: "swiper-button-next",
              prevEl: "swiper-button-prev",
            }
          );
          if (!(params.nextEl || params.prevEl)) return;
          var $nextEl;
          var $prevEl;

          if (params.nextEl) {
            $nextEl = (0, _dom2.default)(params.nextEl);

            if (
              swiper.params.uniqueNavElements &&
              typeof params.nextEl === "string" &&
              $nextEl.length > 1 &&
              swiper.$el.find(params.nextEl).length === 1
            ) {
              $nextEl = swiper.$el.find(params.nextEl);
            }
          }

          if (params.prevEl) {
            $prevEl = (0, _dom2.default)(params.prevEl);

            if (
              swiper.params.uniqueNavElements &&
              typeof params.prevEl === "string" &&
              $prevEl.length > 1 &&
              swiper.$el.find(params.prevEl).length === 1
            ) {
              $prevEl = swiper.$el.find(params.prevEl);
            }
          }

          if ($nextEl && $nextEl.length > 0) {
            $nextEl.on("click", swiper.navigation.onNextClick);
          }

          if ($prevEl && $prevEl.length > 0) {
            $prevEl.on("click", swiper.navigation.onPrevClick);
          }

          (0, _utils.extend)(swiper.navigation, {
            $nextEl: $nextEl,
            nextEl: $nextEl && $nextEl[0],
            $prevEl: $prevEl,
            prevEl: $prevEl && $prevEl[0],
          });

          if (!swiper.enabled) {
            if ($nextEl) $nextEl.addClass(params.lockClass);
            if ($prevEl) $prevEl.addClass(params.lockClass);
          }
        },
        destroy: function destroy() {
          var swiper = this;
          var _swiper$navigation2 = swiper.navigation,
            $nextEl = _swiper$navigation2.$nextEl,
            $prevEl = _swiper$navigation2.$prevEl;

          if ($nextEl && $nextEl.length) {
            $nextEl.off("click", swiper.navigation.onNextClick);
            $nextEl.removeClass(swiper.params.navigation.disabledClass);
          }

          if ($prevEl && $prevEl.length) {
            $prevEl.off("click", swiper.navigation.onPrevClick);
            $prevEl.removeClass(swiper.params.navigation.disabledClass);
          }
        },
      };
      exports.default = {
        name: "navigation",
        params: {
          navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            navigation: _extends({}, Navigation),
          });
        },
        on: {
          init: function init(swiper) {
            swiper.navigation.init();
            swiper.navigation.update();
          },
          toEdge: function toEdge(swiper) {
            swiper.navigation.update();
          },
          fromEdge: function fromEdge(swiper) {
            swiper.navigation.update();
          },
          destroy: function destroy(swiper) {
            swiper.navigation.destroy();
          },
          "enable disable": function enableDisable(swiper) {
            var _swiper$navigation3 = swiper.navigation,
              $nextEl = _swiper$navigation3.$nextEl,
              $prevEl = _swiper$navigation3.$prevEl;

            if ($nextEl) {
              $nextEl[swiper.enabled ? "removeClass" : "addClass"](
                swiper.params.navigation.lockClass
              );
            }

            if ($prevEl) {
              $prevEl[swiper.enabled ? "removeClass" : "addClass"](
                swiper.params.navigation.lockClass
              );
            }
          },
          click: function click(swiper, e) {
            var _swiper$navigation4 = swiper.navigation,
              $nextEl = _swiper$navigation4.$nextEl,
              $prevEl = _swiper$navigation4.$prevEl;
            var targetEl = e.target;

            if (
              swiper.params.navigation.hideOnClick &&
              !(0, _dom2.default)(targetEl).is($prevEl) &&
              !(0, _dom2.default)(targetEl).is($nextEl)
            ) {
              if (
                swiper.pagination &&
                swiper.params.pagination &&
                swiper.params.pagination.clickable &&
                (swiper.pagination.el === targetEl ||
                  swiper.pagination.el.contains(targetEl))
              )
                return;
              var isHidden;

              if ($nextEl) {
                isHidden = $nextEl.hasClass(
                  swiper.params.navigation.hiddenClass
                );
              } else if ($prevEl) {
                isHidden = $prevEl.hasClass(
                  swiper.params.navigation.hiddenClass
                );
              }

              if (isHidden === true) {
                swiper.emit("navigationShow");
              } else {
                swiper.emit("navigationHide");
              }

              if ($nextEl) {
                $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
              }

              if ($prevEl) {
                $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
              }
            }
          },
        },
      };

      /***/
    },

    /***/ 206: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Pagination = {
        update: function update() {
          // Render || Update Pagination bullets/items
          var swiper = this;
          var rtl = swiper.rtl;
          var params = swiper.params.pagination;
          if (
            !params.el ||
            !swiper.pagination.el ||
            !swiper.pagination.$el ||
            swiper.pagination.$el.length === 0
          )
            return;
          var slidesLength =
            swiper.virtual && swiper.params.virtual.enabled
              ? swiper.virtual.slides.length
              : swiper.slides.length;
          var $el = swiper.pagination.$el; // Current/Total

          var current;
          var total = swiper.params.loop
            ? Math.ceil(
                (slidesLength - swiper.loopedSlides * 2) /
                  swiper.params.slidesPerGroup
              )
            : swiper.snapGrid.length;

          if (swiper.params.loop) {
            current = Math.ceil(
              (swiper.activeIndex - swiper.loopedSlides) /
                swiper.params.slidesPerGroup
            );

            if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
              current -= slidesLength - swiper.loopedSlides * 2;
            }

            if (current > total - 1) current -= total;
            if (current < 0 && swiper.params.paginationType !== "bullets")
              current = total + current;
          } else if (typeof swiper.snapIndex !== "undefined") {
            current = swiper.snapIndex;
          } else {
            current = swiper.activeIndex || 0;
          } // Types

          if (
            params.type === "bullets" &&
            swiper.pagination.bullets &&
            swiper.pagination.bullets.length > 0
          ) {
            var bullets = swiper.pagination.bullets;
            var firstIndex;
            var lastIndex;
            var midIndex;

            if (params.dynamicBullets) {
              swiper.pagination.bulletSize = bullets
                .eq(0)
                [swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
              $el.css(
                swiper.isHorizontal() ? "width" : "height",
                swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) +
                  "px"
              );

              if (
                params.dynamicMainBullets > 1 &&
                swiper.previousIndex !== undefined
              ) {
                swiper.pagination.dynamicBulletIndex +=
                  current - swiper.previousIndex;

                if (
                  swiper.pagination.dynamicBulletIndex >
                  params.dynamicMainBullets - 1
                ) {
                  swiper.pagination.dynamicBulletIndex =
                    params.dynamicMainBullets - 1;
                } else if (swiper.pagination.dynamicBulletIndex < 0) {
                  swiper.pagination.dynamicBulletIndex = 0;
                }
              }

              firstIndex = current - swiper.pagination.dynamicBulletIndex;
              lastIndex =
                firstIndex +
                (Math.min(bullets.length, params.dynamicMainBullets) - 1);
              midIndex = (lastIndex + firstIndex) / 2;
            }

            bullets.removeClass(
              params.bulletActiveClass +
                " " +
                params.bulletActiveClass +
                "-next " +
                params.bulletActiveClass +
                "-next-next " +
                params.bulletActiveClass +
                "-prev " +
                params.bulletActiveClass +
                "-prev-prev " +
                params.bulletActiveClass +
                "-main"
            );

            if ($el.length > 1) {
              bullets.each(function (bullet) {
                var $bullet = (0, _dom2.default)(bullet);
                var bulletIndex = $bullet.index();

                if (bulletIndex === current) {
                  $bullet.addClass(params.bulletActiveClass);
                }

                if (params.dynamicBullets) {
                  if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                    $bullet.addClass(params.bulletActiveClass + "-main");
                  }

                  if (bulletIndex === firstIndex) {
                    $bullet
                      .prev()
                      .addClass(params.bulletActiveClass + "-prev")
                      .prev()
                      .addClass(params.bulletActiveClass + "-prev-prev");
                  }

                  if (bulletIndex === lastIndex) {
                    $bullet
                      .next()
                      .addClass(params.bulletActiveClass + "-next")
                      .next()
                      .addClass(params.bulletActiveClass + "-next-next");
                  }
                }
              });
            } else {
              var $bullet = bullets.eq(current);
              var bulletIndex = $bullet.index();
              $bullet.addClass(params.bulletActiveClass);

              if (params.dynamicBullets) {
                var $firstDisplayedBullet = bullets.eq(firstIndex);
                var $lastDisplayedBullet = bullets.eq(lastIndex);

                for (var i = firstIndex; i <= lastIndex; i += 1) {
                  bullets.eq(i).addClass(params.bulletActiveClass + "-main");
                }

                if (swiper.params.loop) {
                  if (
                    bulletIndex >=
                    bullets.length - params.dynamicMainBullets
                  ) {
                    for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                      bullets
                        .eq(bullets.length - _i)
                        .addClass(params.bulletActiveClass + "-main");
                    }

                    bullets
                      .eq(bullets.length - params.dynamicMainBullets - 1)
                      .addClass(params.bulletActiveClass + "-prev");
                  } else {
                    $firstDisplayedBullet
                      .prev()
                      .addClass(params.bulletActiveClass + "-prev")
                      .prev()
                      .addClass(params.bulletActiveClass + "-prev-prev");
                    $lastDisplayedBullet
                      .next()
                      .addClass(params.bulletActiveClass + "-next")
                      .next()
                      .addClass(params.bulletActiveClass + "-next-next");
                  }
                } else {
                  $firstDisplayedBullet
                    .prev()
                    .addClass(params.bulletActiveClass + "-prev")
                    .prev()
                    .addClass(params.bulletActiveClass + "-prev-prev");
                  $lastDisplayedBullet
                    .next()
                    .addClass(params.bulletActiveClass + "-next")
                    .next()
                    .addClass(params.bulletActiveClass + "-next-next");
                }
              }
            }

            if (params.dynamicBullets) {
              var dynamicBulletsLength = Math.min(
                bullets.length,
                params.dynamicMainBullets + 4
              );
              var bulletsOffset =
                (swiper.pagination.bulletSize * dynamicBulletsLength -
                  swiper.pagination.bulletSize) /
                  2 -
                midIndex * swiper.pagination.bulletSize;
              var offsetProp = rtl ? "right" : "left";
              bullets.css(
                swiper.isHorizontal() ? offsetProp : "top",
                bulletsOffset + "px"
              );
            }
          }

          if (params.type === "fraction") {
            $el
              .find((0, _utils.classesToSelector)(params.currentClass))
              .text(params.formatFractionCurrent(current + 1));
            $el
              .find((0, _utils.classesToSelector)(params.totalClass))
              .text(params.formatFractionTotal(total));
          }

          if (params.type === "progressbar") {
            var progressbarDirection;

            if (params.progressbarOpposite) {
              progressbarDirection = swiper.isHorizontal()
                ? "vertical"
                : "horizontal";
            } else {
              progressbarDirection = swiper.isHorizontal()
                ? "horizontal"
                : "vertical";
            }

            var scale = (current + 1) / total;
            var scaleX = 1;
            var scaleY = 1;

            if (progressbarDirection === "horizontal") {
              scaleX = scale;
            } else {
              scaleY = scale;
            }

            $el
              .find((0, _utils.classesToSelector)(params.progressbarFillClass))
              .transform(
                "translate3d(0,0,0) scaleX(" +
                  scaleX +
                  ") scaleY(" +
                  scaleY +
                  ")"
              )
              .transition(swiper.params.speed);
          }

          if (params.type === "custom" && params.renderCustom) {
            $el.html(params.renderCustom(swiper, current + 1, total));
            swiper.emit("paginationRender", $el[0]);
          } else {
            swiper.emit("paginationUpdate", $el[0]);
          }

          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
          }
        },
        render: function render() {
          // Render Container
          var swiper = this;
          var params = swiper.params.pagination;
          if (
            !params.el ||
            !swiper.pagination.el ||
            !swiper.pagination.$el ||
            swiper.pagination.$el.length === 0
          )
            return;
          var slidesLength =
            swiper.virtual && swiper.params.virtual.enabled
              ? swiper.virtual.slides.length
              : swiper.slides.length;
          var $el = swiper.pagination.$el;
          var paginationHTML = "";

          if (params.type === "bullets") {
            var numberOfBullets = swiper.params.loop
              ? Math.ceil(
                  (slidesLength - swiper.loopedSlides * 2) /
                    swiper.params.slidesPerGroup
                )
              : swiper.snapGrid.length;

            if (
              swiper.params.freeMode &&
              !swiper.params.loop &&
              numberOfBullets > slidesLength
            ) {
              numberOfBullets = slidesLength;
            }

            for (var i = 0; i < numberOfBullets; i += 1) {
              if (params.renderBullet) {
                paginationHTML += params.renderBullet.call(
                  swiper,
                  i,
                  params.bulletClass
                );
              } else {
                paginationHTML +=
                  "<" +
                  params.bulletElement +
                  ' class="' +
                  params.bulletClass +
                  '"></' +
                  params.bulletElement +
                  ">";
              }
            }

            $el.html(paginationHTML);
            swiper.pagination.bullets = $el.find(
              (0, _utils.classesToSelector)(params.bulletClass)
            );
          }

          if (params.type === "fraction") {
            if (params.renderFraction) {
              paginationHTML = params.renderFraction.call(
                swiper,
                params.currentClass,
                params.totalClass
              );
            } else {
              paginationHTML =
                '<span class="' +
                params.currentClass +
                '"></span>' +
                " / " +
                ('<span class="' + params.totalClass + '"></span>');
            }

            $el.html(paginationHTML);
          }

          if (params.type === "progressbar") {
            if (params.renderProgressbar) {
              paginationHTML = params.renderProgressbar.call(
                swiper,
                params.progressbarFillClass
              );
            } else {
              paginationHTML =
                '<span class="' + params.progressbarFillClass + '"></span>';
            }

            $el.html(paginationHTML);
          }

          if (params.type !== "custom") {
            swiper.emit("paginationRender", swiper.pagination.$el[0]);
          }
        },
        init: function init() {
          var swiper = this;
          swiper.params.pagination = (0, _utils.createElementIfNotDefined)(
            swiper.$el,
            swiper.params.pagination,
            swiper.params.createElements,
            {
              el: "swiper-pagination",
            }
          );
          var params = swiper.params.pagination;
          if (!params.el) return;
          var $el = (0, _dom2.default)(params.el);
          if ($el.length === 0) return;

          if (
            swiper.params.uniqueNavElements &&
            typeof params.el === "string" &&
            $el.length > 1
          ) {
            $el = swiper.$el.find(params.el);
          }

          if (params.type === "bullets" && params.clickable) {
            $el.addClass(params.clickableClass);
          }

          $el.addClass(params.modifierClass + params.type);

          if (params.type === "bullets" && params.dynamicBullets) {
            $el.addClass("" + params.modifierClass + params.type + "-dynamic");
            swiper.pagination.dynamicBulletIndex = 0;

            if (params.dynamicMainBullets < 1) {
              params.dynamicMainBullets = 1;
            }
          }

          if (params.type === "progressbar" && params.progressbarOpposite) {
            $el.addClass(params.progressbarOppositeClass);
          }

          if (params.clickable) {
            $el.on(
              "click",
              (0, _utils.classesToSelector)(params.bulletClass),
              function onClick(e) {
                e.preventDefault();
                var index =
                  (0, _dom2.default)(this).index() *
                  swiper.params.slidesPerGroup;
                if (swiper.params.loop) index += swiper.loopedSlides;
                swiper.slideTo(index);
              }
            );
          }

          (0, _utils.extend)(swiper.pagination, {
            $el: $el,
            el: $el[0],
          });

          if (!swiper.enabled) {
            $el.addClass(params.lockClass);
          }
        },
        destroy: function destroy() {
          var swiper = this;
          var params = swiper.params.pagination;
          if (
            !params.el ||
            !swiper.pagination.el ||
            !swiper.pagination.$el ||
            swiper.pagination.$el.length === 0
          )
            return;
          var $el = swiper.pagination.$el;
          $el.removeClass(params.hiddenClass);
          $el.removeClass(params.modifierClass + params.type);
          if (swiper.pagination.bullets)
            swiper.pagination.bullets.removeClass(params.bulletActiveClass);

          if (params.clickable) {
            $el.off("click", (0, _utils.classesToSelector)(params.bulletClass));
          }
        },
      };
      exports.default = {
        name: "pagination",
        params: {
          pagination: {
            el: null,
            bulletElement: "span",
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: "bullets",
            // 'bullets' or 'progressbar' or 'fraction' or 'custom'
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: function formatFractionCurrent(number) {
              return number;
            },
            formatFractionTotal: function formatFractionTotal(number) {
              return number;
            },
            bulletClass: "swiper-pagination-bullet",
            bulletActiveClass: "swiper-pagination-bullet-active",
            modifierClass: "swiper-pagination-",
            // NEW
            currentClass: "swiper-pagination-current",
            totalClass: "swiper-pagination-total",
            hiddenClass: "swiper-pagination-hidden",
            progressbarFillClass: "swiper-pagination-progressbar-fill",
            progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
            clickableClass: "swiper-pagination-clickable",
            // NEW
            lockClass: "swiper-pagination-lock",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            pagination: _extends(
              {
                dynamicBulletIndex: 0,
              },
              Pagination
            ),
          });
        },
        on: {
          init: function init(swiper) {
            swiper.pagination.init();
            swiper.pagination.render();
            swiper.pagination.update();
          },
          activeIndexChange: function activeIndexChange(swiper) {
            if (swiper.params.loop) {
              swiper.pagination.update();
            } else if (typeof swiper.snapIndex === "undefined") {
              swiper.pagination.update();
            }
          },
          snapIndexChange: function snapIndexChange(swiper) {
            if (!swiper.params.loop) {
              swiper.pagination.update();
            }
          },
          slidesLengthChange: function slidesLengthChange(swiper) {
            if (swiper.params.loop) {
              swiper.pagination.render();
              swiper.pagination.update();
            }
          },
          snapGridLengthChange: function snapGridLengthChange(swiper) {
            if (!swiper.params.loop) {
              swiper.pagination.render();
              swiper.pagination.update();
            }
          },
          destroy: function destroy(swiper) {
            swiper.pagination.destroy();
          },
          "enable disable": function enableDisable(swiper) {
            var $el = swiper.pagination.$el;

            if ($el) {
              $el[swiper.enabled ? "removeClass" : "addClass"](
                swiper.params.pagination.lockClass
              );
            }
          },
          click: function click(swiper, e) {
            var targetEl = e.target;

            if (
              swiper.params.pagination.el &&
              swiper.params.pagination.hideOnClick &&
              swiper.pagination.$el.length > 0 &&
              !(0, _dom2.default)(targetEl).hasClass(
                swiper.params.pagination.bulletClass
              )
            ) {
              if (
                swiper.navigation &&
                ((swiper.navigation.nextEl &&
                  targetEl === swiper.navigation.nextEl) ||
                  (swiper.navigation.prevEl &&
                    targetEl === swiper.navigation.prevEl))
              )
                return;
              var isHidden = swiper.pagination.$el.hasClass(
                swiper.params.pagination.hiddenClass
              );

              if (isHidden === true) {
                swiper.emit("paginationShow");
              } else {
                swiper.emit("paginationHide");
              }

              swiper.pagination.$el.toggleClass(
                swiper.params.pagination.hiddenClass
              );
            }
          },
        },
      };

      /***/
    },

    /***/ 207: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Scrollbar = {
        setTranslate: function setTranslate() {
          var swiper = this;
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          var scrollbar = swiper.scrollbar,
            rtl = swiper.rtlTranslate,
            progress = swiper.progress;
          var dragSize = scrollbar.dragSize,
            trackSize = scrollbar.trackSize,
            $dragEl = scrollbar.$dragEl,
            $el = scrollbar.$el;
          var params = swiper.params.scrollbar;
          var newSize = dragSize;
          var newPos = (trackSize - dragSize) * progress;

          if (rtl) {
            newPos = -newPos;

            if (newPos > 0) {
              newSize = dragSize - newPos;
              newPos = 0;
            } else if (-newPos + dragSize > trackSize) {
              newSize = trackSize + newPos;
            }
          } else if (newPos < 0) {
            newSize = dragSize + newPos;
            newPos = 0;
          } else if (newPos + dragSize > trackSize) {
            newSize = trackSize - newPos;
          }

          if (swiper.isHorizontal()) {
            $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
            $dragEl[0].style.width = newSize + "px";
          } else {
            $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
            $dragEl[0].style.height = newSize + "px";
          }

          if (params.hide) {
            clearTimeout(swiper.scrollbar.timeout);
            $el[0].style.opacity = 1;
            swiper.scrollbar.timeout = setTimeout(function () {
              $el[0].style.opacity = 0;
              $el.transition(400);
            }, 1000);
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          swiper.scrollbar.$dragEl.transition(duration);
        },
        updateSize: function updateSize() {
          var swiper = this;
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          var scrollbar = swiper.scrollbar;
          var $dragEl = scrollbar.$dragEl,
            $el = scrollbar.$el;
          $dragEl[0].style.width = "";
          $dragEl[0].style.height = "";
          var trackSize = swiper.isHorizontal()
            ? $el[0].offsetWidth
            : $el[0].offsetHeight;
          var divider = swiper.size / swiper.virtualSize;
          var moveDivider = divider * (trackSize / swiper.size);
          var dragSize;

          if (swiper.params.scrollbar.dragSize === "auto") {
            dragSize = trackSize * divider;
          } else {
            dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
          }

          if (swiper.isHorizontal()) {
            $dragEl[0].style.width = dragSize + "px";
          } else {
            $dragEl[0].style.height = dragSize + "px";
          }

          if (divider >= 1) {
            $el[0].style.display = "none";
          } else {
            $el[0].style.display = "";
          }

          if (swiper.params.scrollbar.hide) {
            $el[0].style.opacity = 0;
          }

          (0, _utils.extend)(scrollbar, {
            trackSize: trackSize,
            divider: divider,
            moveDivider: moveDivider,
            dragSize: dragSize,
          });

          if (swiper.params.watchOverflow && swiper.enabled) {
            scrollbar.$el[swiper.isLocked ? "addClass" : "removeClass"](
              swiper.params.scrollbar.lockClass
            );
          }
        },
        getPointerPosition: function getPointerPosition(e) {
          var swiper = this;

          if (swiper.isHorizontal()) {
            return e.type === "touchstart" || e.type === "touchmove"
              ? e.targetTouches[0].clientX
              : e.clientX;
          }

          return e.type === "touchstart" || e.type === "touchmove"
            ? e.targetTouches[0].clientY
            : e.clientY;
        },
        setDragPosition: function setDragPosition(e) {
          var swiper = this;
          var scrollbar = swiper.scrollbar,
            rtl = swiper.rtlTranslate;
          var $el = scrollbar.$el,
            dragSize = scrollbar.dragSize,
            trackSize = scrollbar.trackSize,
            dragStartPos = scrollbar.dragStartPos;
          var positionRatio;
          positionRatio =
            (scrollbar.getPointerPosition(e) -
              $el.offset()[swiper.isHorizontal() ? "left" : "top"] -
              (dragStartPos !== null ? dragStartPos : dragSize / 2)) /
            (trackSize - dragSize);
          positionRatio = Math.max(Math.min(positionRatio, 1), 0);

          if (rtl) {
            positionRatio = 1 - positionRatio;
          }

          var position =
            swiper.minTranslate() +
            (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
          swiper.updateProgress(position);
          swiper.setTranslate(position);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        },
        onDragStart: function onDragStart(e) {
          var swiper = this;
          var params = swiper.params.scrollbar;
          var scrollbar = swiper.scrollbar,
            $wrapperEl = swiper.$wrapperEl;
          var $el = scrollbar.$el,
            $dragEl = scrollbar.$dragEl;
          swiper.scrollbar.isTouched = true;
          swiper.scrollbar.dragStartPos =
            e.target === $dragEl[0] || e.target === $dragEl
              ? scrollbar.getPointerPosition(e) -
                e.target.getBoundingClientRect()[
                  swiper.isHorizontal() ? "left" : "top"
                ]
              : null;
          e.preventDefault();
          e.stopPropagation();
          $wrapperEl.transition(100);
          $dragEl.transition(100);
          scrollbar.setDragPosition(e);
          clearTimeout(swiper.scrollbar.dragTimeout);
          $el.transition(0);

          if (params.hide) {
            $el.css("opacity", 1);
          }

          if (swiper.params.cssMode) {
            swiper.$wrapperEl.css("scroll-snap-type", "none");
          }

          swiper.emit("scrollbarDragStart", e);
        },
        onDragMove: function onDragMove(e) {
          var swiper = this;
          var scrollbar = swiper.scrollbar,
            $wrapperEl = swiper.$wrapperEl;
          var $el = scrollbar.$el,
            $dragEl = scrollbar.$dragEl;
          if (!swiper.scrollbar.isTouched) return;
          if (e.preventDefault) e.preventDefault();
          else e.returnValue = false;
          scrollbar.setDragPosition(e);
          $wrapperEl.transition(0);
          $el.transition(0);
          $dragEl.transition(0);
          swiper.emit("scrollbarDragMove", e);
        },
        onDragEnd: function onDragEnd(e) {
          var swiper = this;
          var params = swiper.params.scrollbar;
          var scrollbar = swiper.scrollbar,
            $wrapperEl = swiper.$wrapperEl;
          var $el = scrollbar.$el;
          if (!swiper.scrollbar.isTouched) return;
          swiper.scrollbar.isTouched = false;

          if (swiper.params.cssMode) {
            swiper.$wrapperEl.css("scroll-snap-type", "");
            $wrapperEl.transition("");
          }

          if (params.hide) {
            clearTimeout(swiper.scrollbar.dragTimeout);
            swiper.scrollbar.dragTimeout = (0, _utils.nextTick)(function () {
              $el.css("opacity", 0);
              $el.transition(400);
            }, 1000);
          }

          swiper.emit("scrollbarDragEnd", e);

          if (params.snapOnRelease) {
            swiper.slideToClosest();
          }
        },
        enableDraggable: function enableDraggable() {
          var swiper = this;
          if (!swiper.params.scrollbar.el) return;
          var document = (0, _ssrWindow.getDocument)();
          var scrollbar = swiper.scrollbar,
            touchEventsTouch = swiper.touchEventsTouch,
            touchEventsDesktop = swiper.touchEventsDesktop,
            params = swiper.params,
            support = swiper.support;
          var $el = scrollbar.$el;
          var target = $el[0];
          var activeListener =
            support.passiveListener && params.passiveListeners
              ? {
                  passive: false,
                  capture: false,
                }
              : false;
          var passiveListener =
            support.passiveListener && params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;
          if (!target) return;

          if (!support.touch) {
            target.addEventListener(
              touchEventsDesktop.start,
              swiper.scrollbar.onDragStart,
              activeListener
            );
            document.addEventListener(
              touchEventsDesktop.move,
              swiper.scrollbar.onDragMove,
              activeListener
            );
            document.addEventListener(
              touchEventsDesktop.end,
              swiper.scrollbar.onDragEnd,
              passiveListener
            );
          } else {
            target.addEventListener(
              touchEventsTouch.start,
              swiper.scrollbar.onDragStart,
              activeListener
            );
            target.addEventListener(
              touchEventsTouch.move,
              swiper.scrollbar.onDragMove,
              activeListener
            );
            target.addEventListener(
              touchEventsTouch.end,
              swiper.scrollbar.onDragEnd,
              passiveListener
            );
          }
        },
        disableDraggable: function disableDraggable() {
          var swiper = this;
          if (!swiper.params.scrollbar.el) return;
          var document = (0, _ssrWindow.getDocument)();
          var scrollbar = swiper.scrollbar,
            touchEventsTouch = swiper.touchEventsTouch,
            touchEventsDesktop = swiper.touchEventsDesktop,
            params = swiper.params,
            support = swiper.support;
          var $el = scrollbar.$el;
          var target = $el[0];
          var activeListener =
            support.passiveListener && params.passiveListeners
              ? {
                  passive: false,
                  capture: false,
                }
              : false;
          var passiveListener =
            support.passiveListener && params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;
          if (!target) return;

          if (!support.touch) {
            target.removeEventListener(
              touchEventsDesktop.start,
              swiper.scrollbar.onDragStart,
              activeListener
            );
            document.removeEventListener(
              touchEventsDesktop.move,
              swiper.scrollbar.onDragMove,
              activeListener
            );
            document.removeEventListener(
              touchEventsDesktop.end,
              swiper.scrollbar.onDragEnd,
              passiveListener
            );
          } else {
            target.removeEventListener(
              touchEventsTouch.start,
              swiper.scrollbar.onDragStart,
              activeListener
            );
            target.removeEventListener(
              touchEventsTouch.move,
              swiper.scrollbar.onDragMove,
              activeListener
            );
            target.removeEventListener(
              touchEventsTouch.end,
              swiper.scrollbar.onDragEnd,
              passiveListener
            );
          }
        },
        init: function init() {
          var swiper = this;
          var scrollbar = swiper.scrollbar,
            $swiperEl = swiper.$el;
          swiper.params.scrollbar = (0, _utils.createElementIfNotDefined)(
            $swiperEl,
            swiper.params.scrollbar,
            swiper.params.createElements,
            {
              el: "swiper-scrollbar",
            }
          );
          var params = swiper.params.scrollbar;
          if (!params.el) return;
          var $el = (0, _dom2.default)(params.el);

          if (
            swiper.params.uniqueNavElements &&
            typeof params.el === "string" &&
            $el.length > 1 &&
            $swiperEl.find(params.el).length === 1
          ) {
            $el = $swiperEl.find(params.el);
          }

          var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);

          if ($dragEl.length === 0) {
            $dragEl = (0, _dom2.default)(
              '<div class="' + swiper.params.scrollbar.dragClass + '"></div>'
            );
            $el.append($dragEl);
          }

          (0, _utils.extend)(scrollbar, {
            $el: $el,
            el: $el[0],
            $dragEl: $dragEl,
            dragEl: $dragEl[0],
          });

          if (params.draggable) {
            scrollbar.enableDraggable();
          }

          if ($el) {
            $el[swiper.enabled ? "removeClass" : "addClass"](
              swiper.params.scrollbar.lockClass
            );
          }
        },
        destroy: function destroy() {
          var swiper = this;
          swiper.scrollbar.disableDraggable();
        },
      };
      exports.default = {
        name: "scrollbar",
        params: {
          scrollbar: {
            el: null,
            dragSize: "auto",
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            scrollbar: _extends(
              {
                isTouched: false,
                timeout: null,
                dragTimeout: null,
              },
              Scrollbar
            ),
          });
        },
        on: {
          init: function init(swiper) {
            swiper.scrollbar.init();
            swiper.scrollbar.updateSize();
            swiper.scrollbar.setTranslate();
          },
          update: function update(swiper) {
            swiper.scrollbar.updateSize();
          },
          resize: function resize(swiper) {
            swiper.scrollbar.updateSize();
          },
          observerUpdate: function observerUpdate(swiper) {
            swiper.scrollbar.updateSize();
          },
          setTranslate: function setTranslate(swiper) {
            swiper.scrollbar.setTranslate();
          },
          setTransition: function setTransition(swiper, duration) {
            swiper.scrollbar.setTransition(duration);
          },
          "enable disable": function enableDisable(swiper) {
            var $el = swiper.scrollbar.$el;

            if ($el) {
              $el[swiper.enabled ? "removeClass" : "addClass"](
                swiper.params.scrollbar.lockClass
              );
            }
          },
          destroy: function destroy(swiper) {
            swiper.scrollbar.destroy();
          },
        },
      };

      /***/
    },

    /***/ 208: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Parallax = {
        setTransform: function setTransform(el, progress) {
          var swiper = this;
          var rtl = swiper.rtl;
          var $el = (0, _dom2.default)(el);
          var rtlFactor = rtl ? -1 : 1;
          var p = $el.attr("data-swiper-parallax") || "0";
          var x = $el.attr("data-swiper-parallax-x");
          var y = $el.attr("data-swiper-parallax-y");
          var scale = $el.attr("data-swiper-parallax-scale");
          var opacity = $el.attr("data-swiper-parallax-opacity");

          if (x || y) {
            x = x || "0";
            y = y || "0";
          } else if (swiper.isHorizontal()) {
            x = p;
            y = "0";
          } else {
            y = p;
            x = "0";
          }

          if (x.indexOf("%") >= 0) {
            x = parseInt(x, 10) * progress * rtlFactor + "%";
          } else {
            x = x * progress * rtlFactor + "px";
          }

          if (y.indexOf("%") >= 0) {
            y = parseInt(y, 10) * progress + "%";
          } else {
            y = y * progress + "px";
          }

          if (typeof opacity !== "undefined" && opacity !== null) {
            var currentOpacity =
              opacity - (opacity - 1) * (1 - Math.abs(progress));
            $el[0].style.opacity = currentOpacity;
          }

          if (typeof scale === "undefined" || scale === null) {
            $el.transform("translate3d(" + x + ", " + y + ", 0px)");
          } else {
            var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
            $el.transform(
              "translate3d(" +
                x +
                ", " +
                y +
                ", 0px) scale(" +
                currentScale +
                ")"
            );
          }
        },
        setTranslate: function setTranslate() {
          var swiper = this;
          var $el = swiper.$el,
            slides = swiper.slides,
            progress = swiper.progress,
            snapGrid = swiper.snapGrid;
          $el
            .children(
              "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
            )
            .each(function (el) {
              swiper.parallax.setTransform(el, progress);
            });
          slides.each(function (slideEl, slideIndex) {
            var slideProgress = slideEl.progress;

            if (
              swiper.params.slidesPerGroup > 1 &&
              swiper.params.slidesPerView !== "auto"
            ) {
              slideProgress +=
                Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
            }

            slideProgress = Math.min(Math.max(slideProgress, -1), 1);
            (0, _dom2.default)(slideEl)
              .find(
                "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
              )
              .each(function (el) {
                swiper.parallax.setTransform(el, slideProgress);
              });
          });
        },
        setTransition: function setTransition(duration) {
          if (duration === void 0) {
            duration = this.params.speed;
          }

          var swiper = this;
          var $el = swiper.$el;
          $el
            .find(
              "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
            )
            .each(function (parallaxEl) {
              var $parallaxEl = (0, _dom2.default)(parallaxEl);
              var parallaxDuration =
                parseInt(
                  $parallaxEl.attr("data-swiper-parallax-duration"),
                  10
                ) || duration;
              if (duration === 0) parallaxDuration = 0;
              $parallaxEl.transition(parallaxDuration);
            });
        },
      };
      exports.default = {
        name: "parallax",
        params: {
          parallax: {
            enabled: false,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            parallax: _extends({}, Parallax),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
          },
          init: function init(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTranslate();
          },
          setTranslate: function setTranslate(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTranslate();
          },
          setTransition: function setTransition(swiper, duration) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTransition(duration);
          },
        },
      };

      /***/
    },

    /***/ 209: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Zoom = {
        // Calc Scale From Multi-touches
        getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
          if (e.targetTouches.length < 2) return 1;
          var x1 = e.targetTouches[0].pageX;
          var y1 = e.targetTouches[0].pageY;
          var x2 = e.targetTouches[1].pageX;
          var y2 = e.targetTouches[1].pageY;
          var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          return distance;
        },
        // Events
        onGestureStart: function onGestureStart(e) {
          var swiper = this;
          var support = swiper.support;
          var params = swiper.params.zoom;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;
          zoom.fakeGestureTouched = false;
          zoom.fakeGestureMoved = false;

          if (!support.gestures) {
            if (
              e.type !== "touchstart" ||
              (e.type === "touchstart" && e.targetTouches.length < 2)
            ) {
              return;
            }

            zoom.fakeGestureTouched = true;
            gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
          }

          if (!gesture.$slideEl || !gesture.$slideEl.length) {
            gesture.$slideEl = (0, _dom2.default)(e.target).closest(
              "." + swiper.params.slideClass
            );
            if (gesture.$slideEl.length === 0)
              gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            gesture.$imageEl = gesture.$slideEl.find(
              "img, svg, canvas, picture, .swiper-zoom-target"
            );
            gesture.$imageWrapEl = gesture.$imageEl.parent(
              "." + params.containerClass
            );
            gesture.maxRatio =
              gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;

            if (gesture.$imageWrapEl.length === 0) {
              gesture.$imageEl = undefined;
              return;
            }
          }

          if (gesture.$imageEl) {
            gesture.$imageEl.transition(0);
          }

          swiper.zoom.isScaling = true;
        },
        onGestureChange: function onGestureChange(e) {
          var swiper = this;
          var support = swiper.support;
          var params = swiper.params.zoom;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;

          if (!support.gestures) {
            if (
              e.type !== "touchmove" ||
              (e.type === "touchmove" && e.targetTouches.length < 2)
            ) {
              return;
            }

            zoom.fakeGestureMoved = true;
            gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
          }

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            if (e.type === "gesturechange") zoom.onGestureStart(e);
            return;
          }

          if (support.gestures) {
            zoom.scale = e.scale * zoom.currentScale;
          } else {
            zoom.scale =
              (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
          }

          if (zoom.scale > gesture.maxRatio) {
            zoom.scale =
              gesture.maxRatio -
              1 +
              Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
          }

          if (zoom.scale < params.minRatio) {
            zoom.scale =
              params.minRatio +
              1 -
              Math.pow(params.minRatio - zoom.scale + 1, 0.5);
          }

          gesture.$imageEl.transform(
            "translate3d(0,0,0) scale(" + zoom.scale + ")"
          );
        },
        onGestureEnd: function onGestureEnd(e) {
          var swiper = this;
          var device = swiper.device;
          var support = swiper.support;
          var params = swiper.params.zoom;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;

          if (!support.gestures) {
            if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
              return;
            }

            if (
              e.type !== "touchend" ||
              (e.type === "touchend" &&
                e.changedTouches.length < 2 &&
                !device.android)
            ) {
              return;
            }

            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
          }

          if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
          zoom.scale = Math.max(
            Math.min(zoom.scale, gesture.maxRatio),
            params.minRatio
          );
          gesture.$imageEl
            .transition(swiper.params.speed)
            .transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
          zoom.currentScale = zoom.scale;
          zoom.isScaling = false;
          if (zoom.scale === 1) gesture.$slideEl = undefined;
        },
        onTouchStart: function onTouchStart(e) {
          var swiper = this;
          var device = swiper.device;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture,
            image = zoom.image;
          if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
          if (image.isTouched) return;
          if (device.android && e.cancelable) e.preventDefault();
          image.isTouched = true;
          image.touchesStart.x =
            e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
          image.touchesStart.y =
            e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        },
        onTouchMove: function onTouchMove(e) {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture,
            image = zoom.image,
            velocity = zoom.velocity;
          if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
          swiper.allowClick = false;
          if (!image.isTouched || !gesture.$slideEl) return;

          if (!image.isMoved) {
            image.width = gesture.$imageEl[0].offsetWidth;
            image.height = gesture.$imageEl[0].offsetHeight;
            image.startX =
              (0, _utils.getTranslate)(gesture.$imageWrapEl[0], "x") || 0;
            image.startY =
              (0, _utils.getTranslate)(gesture.$imageWrapEl[0], "y") || 0;
            gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
            gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
            gesture.$imageWrapEl.transition(0);
          } // Define if we need image drag

          var scaledWidth = image.width * zoom.scale;
          var scaledHeight = image.height * zoom.scale;
          if (
            scaledWidth < gesture.slideWidth &&
            scaledHeight < gesture.slideHeight
          )
            return;
          image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
          image.maxX = -image.minX;
          image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
          image.maxY = -image.minY;
          image.touchesCurrent.x =
            e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
          image.touchesCurrent.y =
            e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;

          if (!image.isMoved && !zoom.isScaling) {
            if (
              swiper.isHorizontal() &&
              ((Math.floor(image.minX) === Math.floor(image.startX) &&
                image.touchesCurrent.x < image.touchesStart.x) ||
                (Math.floor(image.maxX) === Math.floor(image.startX) &&
                  image.touchesCurrent.x > image.touchesStart.x))
            ) {
              image.isTouched = false;
              return;
            }

            if (
              !swiper.isHorizontal() &&
              ((Math.floor(image.minY) === Math.floor(image.startY) &&
                image.touchesCurrent.y < image.touchesStart.y) ||
                (Math.floor(image.maxY) === Math.floor(image.startY) &&
                  image.touchesCurrent.y > image.touchesStart.y))
            ) {
              image.isTouched = false;
              return;
            }
          }

          if (e.cancelable) {
            e.preventDefault();
          }

          e.stopPropagation();
          image.isMoved = true;
          image.currentX =
            image.touchesCurrent.x - image.touchesStart.x + image.startX;
          image.currentY =
            image.touchesCurrent.y - image.touchesStart.y + image.startY;

          if (image.currentX < image.minX) {
            image.currentX =
              image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
          }

          if (image.currentX > image.maxX) {
            image.currentX =
              image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
          }

          if (image.currentY < image.minY) {
            image.currentY =
              image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
          }

          if (image.currentY > image.maxY) {
            image.currentY =
              image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
          } // Velocity

          if (!velocity.prevPositionX)
            velocity.prevPositionX = image.touchesCurrent.x;
          if (!velocity.prevPositionY)
            velocity.prevPositionY = image.touchesCurrent.y;
          if (!velocity.prevTime) velocity.prevTime = Date.now();
          velocity.x =
            (image.touchesCurrent.x - velocity.prevPositionX) /
            (Date.now() - velocity.prevTime) /
            2;
          velocity.y =
            (image.touchesCurrent.y - velocity.prevPositionY) /
            (Date.now() - velocity.prevTime) /
            2;
          if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)
            velocity.x = 0;
          if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)
            velocity.y = 0;
          velocity.prevPositionX = image.touchesCurrent.x;
          velocity.prevPositionY = image.touchesCurrent.y;
          velocity.prevTime = Date.now();
          gesture.$imageWrapEl.transform(
            "translate3d(" + image.currentX + "px, " + image.currentY + "px,0)"
          );
        },
        onTouchEnd: function onTouchEnd() {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture,
            image = zoom.image,
            velocity = zoom.velocity;
          if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

          if (!image.isTouched || !image.isMoved) {
            image.isTouched = false;
            image.isMoved = false;
            return;
          }

          image.isTouched = false;
          image.isMoved = false;
          var momentumDurationX = 300;
          var momentumDurationY = 300;
          var momentumDistanceX = velocity.x * momentumDurationX;
          var newPositionX = image.currentX + momentumDistanceX;
          var momentumDistanceY = velocity.y * momentumDurationY;
          var newPositionY = image.currentY + momentumDistanceY; // Fix duration

          if (velocity.x !== 0)
            momentumDurationX = Math.abs(
              (newPositionX - image.currentX) / velocity.x
            );
          if (velocity.y !== 0)
            momentumDurationY = Math.abs(
              (newPositionY - image.currentY) / velocity.y
            );
          var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
          image.currentX = newPositionX;
          image.currentY = newPositionY; // Define if we need image drag

          var scaledWidth = image.width * zoom.scale;
          var scaledHeight = image.height * zoom.scale;
          image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
          image.maxX = -image.minX;
          image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
          image.maxY = -image.minY;
          image.currentX = Math.max(
            Math.min(image.currentX, image.maxX),
            image.minX
          );
          image.currentY = Math.max(
            Math.min(image.currentY, image.maxY),
            image.minY
          );
          gesture.$imageWrapEl
            .transition(momentumDuration)
            .transform(
              "translate3d(" +
                image.currentX +
                "px, " +
                image.currentY +
                "px,0)"
            );
        },
        onTransitionEnd: function onTransitionEnd() {
          var swiper = this;
          var zoom = swiper.zoom;
          var gesture = zoom.gesture;

          if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
            if (gesture.$imageEl) {
              gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
            }

            if (gesture.$imageWrapEl) {
              gesture.$imageWrapEl.transform("translate3d(0,0,0)");
            }

            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$slideEl = undefined;
            gesture.$imageEl = undefined;
            gesture.$imageWrapEl = undefined;
          }
        },
        // Toggle Zoom
        toggle: function toggle(e) {
          var swiper = this;
          var zoom = swiper.zoom;

          if (zoom.scale && zoom.scale !== 1) {
            // Zoom Out
            zoom.out();
          } else {
            // Zoom In
            zoom.in(e);
          }
        },
        in: function _in(e) {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();
          var zoom = swiper.zoom;
          var params = swiper.params.zoom;
          var gesture = zoom.gesture,
            image = zoom.image;

          if (!gesture.$slideEl) {
            if (e && e.target) {
              gesture.$slideEl = (0, _dom2.default)(e.target).closest(
                "." + swiper.params.slideClass
              );
            }

            if (!gesture.$slideEl) {
              if (
                swiper.params.virtual &&
                swiper.params.virtual.enabled &&
                swiper.virtual
              ) {
                gesture.$slideEl = swiper.$wrapperEl.children(
                  "." + swiper.params.slideActiveClass
                );
              } else {
                gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
              }
            }

            gesture.$imageEl = gesture.$slideEl.find(
              "img, svg, canvas, picture, .swiper-zoom-target"
            );
            gesture.$imageWrapEl = gesture.$imageEl.parent(
              "." + params.containerClass
            );
          }

          if (
            !gesture.$imageEl ||
            gesture.$imageEl.length === 0 ||
            !gesture.$imageWrapEl ||
            gesture.$imageWrapEl.length === 0
          )
            return;
          gesture.$slideEl.addClass("" + params.zoomedSlideClass);
          var touchX;
          var touchY;
          var offsetX;
          var offsetY;
          var diffX;
          var diffY;
          var translateX;
          var translateY;
          var imageWidth;
          var imageHeight;
          var scaledWidth;
          var scaledHeight;
          var translateMinX;
          var translateMinY;
          var translateMaxX;
          var translateMaxY;
          var slideWidth;
          var slideHeight;

          if (typeof image.touchesStart.x === "undefined" && e) {
            touchX =
              e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX;
            touchY =
              e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY;
          } else {
            touchX = image.touchesStart.x;
            touchY = image.touchesStart.y;
          }

          zoom.scale =
            gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
          zoom.currentScale =
            gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;

          if (e) {
            slideWidth = gesture.$slideEl[0].offsetWidth;
            slideHeight = gesture.$slideEl[0].offsetHeight;
            offsetX = gesture.$slideEl.offset().left + window.scrollX;
            offsetY = gesture.$slideEl.offset().top + window.scrollY;
            diffX = offsetX + slideWidth / 2 - touchX;
            diffY = offsetY + slideHeight / 2 - touchY;
            imageWidth = gesture.$imageEl[0].offsetWidth;
            imageHeight = gesture.$imageEl[0].offsetHeight;
            scaledWidth = imageWidth * zoom.scale;
            scaledHeight = imageHeight * zoom.scale;
            translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
            translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
            translateMaxX = -translateMinX;
            translateMaxY = -translateMinY;
            translateX = diffX * zoom.scale;
            translateY = diffY * zoom.scale;

            if (translateX < translateMinX) {
              translateX = translateMinX;
            }

            if (translateX > translateMaxX) {
              translateX = translateMaxX;
            }

            if (translateY < translateMinY) {
              translateY = translateMinY;
            }

            if (translateY > translateMaxY) {
              translateY = translateMaxY;
            }
          } else {
            translateX = 0;
            translateY = 0;
          }

          gesture.$imageWrapEl
            .transition(300)
            .transform(
              "translate3d(" + translateX + "px, " + translateY + "px,0)"
            );
          gesture.$imageEl
            .transition(300)
            .transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        },
        out: function out() {
          var swiper = this;
          var zoom = swiper.zoom;
          var params = swiper.params.zoom;
          var gesture = zoom.gesture;

          if (!gesture.$slideEl) {
            if (
              swiper.params.virtual &&
              swiper.params.virtual.enabled &&
              swiper.virtual
            ) {
              gesture.$slideEl = swiper.$wrapperEl.children(
                "." + swiper.params.slideActiveClass
              );
            } else {
              gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }

            gesture.$imageEl = gesture.$slideEl.find(
              "img, svg, canvas, picture, .swiper-zoom-target"
            );
            gesture.$imageWrapEl = gesture.$imageEl.parent(
              "." + params.containerClass
            );
          }

          if (
            !gesture.$imageEl ||
            gesture.$imageEl.length === 0 ||
            !gesture.$imageWrapEl ||
            gesture.$imageWrapEl.length === 0
          )
            return;
          zoom.scale = 1;
          zoom.currentScale = 1;
          gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)");
          gesture.$imageEl
            .transition(300)
            .transform("translate3d(0,0,0) scale(1)");
          gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
          gesture.$slideEl = undefined;
        },
        toggleGestures: function toggleGestures(method) {
          var swiper = this;
          var zoom = swiper.zoom;
          var selector = zoom.slideSelector,
            passive = zoom.passiveListener;
          swiper.$wrapperEl[method](
            "gesturestart",
            selector,
            zoom.onGestureStart,
            passive
          );
          swiper.$wrapperEl[method](
            "gesturechange",
            selector,
            zoom.onGestureChange,
            passive
          );
          swiper.$wrapperEl[method](
            "gestureend",
            selector,
            zoom.onGestureEnd,
            passive
          );
        },
        enableGestures: function enableGestures() {
          if (this.zoom.gesturesEnabled) return;
          this.zoom.gesturesEnabled = true;
          this.zoom.toggleGestures("on");
        },
        disableGestures: function disableGestures() {
          if (!this.zoom.gesturesEnabled) return;
          this.zoom.gesturesEnabled = false;
          this.zoom.toggleGestures("off");
        },
        // Attach/Detach Events
        enable: function enable() {
          var swiper = this;
          var support = swiper.support;
          var zoom = swiper.zoom;
          if (zoom.enabled) return;
          zoom.enabled = true;
          var passiveListener =
            swiper.touchEvents.start === "touchstart" &&
            support.passiveListener &&
            swiper.params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;
          var activeListenerWithCapture = support.passiveListener
            ? {
                passive: false,
                capture: true,
              }
            : true;
          var slideSelector = "." + swiper.params.slideClass;
          swiper.zoom.passiveListener = passiveListener;
          swiper.zoom.slideSelector = slideSelector; // Scale image

          if (support.gestures) {
            swiper.$wrapperEl.on(
              swiper.touchEvents.start,
              swiper.zoom.enableGestures,
              passiveListener
            );
            swiper.$wrapperEl.on(
              swiper.touchEvents.end,
              swiper.zoom.disableGestures,
              passiveListener
            );
          } else if (swiper.touchEvents.start === "touchstart") {
            swiper.$wrapperEl.on(
              swiper.touchEvents.start,
              slideSelector,
              zoom.onGestureStart,
              passiveListener
            );
            swiper.$wrapperEl.on(
              swiper.touchEvents.move,
              slideSelector,
              zoom.onGestureChange,
              activeListenerWithCapture
            );
            swiper.$wrapperEl.on(
              swiper.touchEvents.end,
              slideSelector,
              zoom.onGestureEnd,
              passiveListener
            );

            if (swiper.touchEvents.cancel) {
              swiper.$wrapperEl.on(
                swiper.touchEvents.cancel,
                slideSelector,
                zoom.onGestureEnd,
                passiveListener
              );
            }
          } // Move image

          swiper.$wrapperEl.on(
            swiper.touchEvents.move,
            "." + swiper.params.zoom.containerClass,
            zoom.onTouchMove,
            activeListenerWithCapture
          );
        },
        disable: function disable() {
          var swiper = this;
          var zoom = swiper.zoom;
          if (!zoom.enabled) return;
          var support = swiper.support;
          swiper.zoom.enabled = false;
          var passiveListener =
            swiper.touchEvents.start === "touchstart" &&
            support.passiveListener &&
            swiper.params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;
          var activeListenerWithCapture = support.passiveListener
            ? {
                passive: false,
                capture: true,
              }
            : true;
          var slideSelector = "." + swiper.params.slideClass; // Scale image

          if (support.gestures) {
            swiper.$wrapperEl.off(
              swiper.touchEvents.start,
              swiper.zoom.enableGestures,
              passiveListener
            );
            swiper.$wrapperEl.off(
              swiper.touchEvents.end,
              swiper.zoom.disableGestures,
              passiveListener
            );
          } else if (swiper.touchEvents.start === "touchstart") {
            swiper.$wrapperEl.off(
              swiper.touchEvents.start,
              slideSelector,
              zoom.onGestureStart,
              passiveListener
            );
            swiper.$wrapperEl.off(
              swiper.touchEvents.move,
              slideSelector,
              zoom.onGestureChange,
              activeListenerWithCapture
            );
            swiper.$wrapperEl.off(
              swiper.touchEvents.end,
              slideSelector,
              zoom.onGestureEnd,
              passiveListener
            );

            if (swiper.touchEvents.cancel) {
              swiper.$wrapperEl.off(
                swiper.touchEvents.cancel,
                slideSelector,
                zoom.onGestureEnd,
                passiveListener
              );
            }
          } // Move image

          swiper.$wrapperEl.off(
            swiper.touchEvents.move,
            "." + swiper.params.zoom.containerClass,
            zoom.onTouchMove,
            activeListenerWithCapture
          );
        },
      };
      exports.default = {
        name: "zoom",
        params: {
          zoom: {
            enabled: false,
            maxRatio: 3,
            minRatio: 1,
            toggle: true,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            zoom: _extends(
              {
                enabled: false,
                scale: 1,
                currentScale: 1,
                isScaling: false,
                gesture: {
                  $slideEl: undefined,
                  slideWidth: undefined,
                  slideHeight: undefined,
                  $imageEl: undefined,
                  $imageWrapEl: undefined,
                  maxRatio: 3,
                },
                image: {
                  isTouched: undefined,
                  isMoved: undefined,
                  currentX: undefined,
                  currentY: undefined,
                  minX: undefined,
                  minY: undefined,
                  maxX: undefined,
                  maxY: undefined,
                  width: undefined,
                  height: undefined,
                  startX: undefined,
                  startY: undefined,
                  touchesStart: {},
                  touchesCurrent: {},
                },
                velocity: {
                  x: undefined,
                  y: undefined,
                  prevPositionX: undefined,
                  prevPositionY: undefined,
                  prevTime: undefined,
                },
              },
              Zoom
            ),
          });
          var scale = 1;
          Object.defineProperty(swiper.zoom, "scale", {
            get: function get() {
              return scale;
            },
            set: function set(value) {
              if (scale !== value) {
                var imageEl = swiper.zoom.gesture.$imageEl
                  ? swiper.zoom.gesture.$imageEl[0]
                  : undefined;
                var slideEl = swiper.zoom.gesture.$slideEl
                  ? swiper.zoom.gesture.$slideEl[0]
                  : undefined;
                swiper.emit("zoomChange", value, imageEl, slideEl);
              }

              scale = value;
            },
          });
        },
        on: {
          init: function init(swiper) {
            if (swiper.params.zoom.enabled) {
              swiper.zoom.enable();
            }
          },
          destroy: function destroy(swiper) {
            swiper.zoom.disable();
          },
          touchStart: function touchStart(swiper, e) {
            if (!swiper.zoom.enabled) return;
            swiper.zoom.onTouchStart(e);
          },
          touchEnd: function touchEnd(swiper, e) {
            if (!swiper.zoom.enabled) return;
            swiper.zoom.onTouchEnd(e);
          },
          doubleTap: function doubleTap(swiper, e) {
            if (
              !swiper.animating &&
              swiper.params.zoom.enabled &&
              swiper.zoom.enabled &&
              swiper.params.zoom.toggle
            ) {
              swiper.zoom.toggle(e);
            }
          },
          transitionEnd: function transitionEnd(swiper) {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
              swiper.zoom.onTransitionEnd();
            }
          },
          slideChange: function slideChange(swiper) {
            if (
              swiper.zoom.enabled &&
              swiper.params.zoom.enabled &&
              swiper.params.cssMode
            ) {
              swiper.zoom.onTransitionEnd();
            }
          },
        },
      };

      /***/
    },

    /***/ 21: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var freeGlobal = __webpack_require__(50);

      /** Detect free variable `self`. */
      var freeSelf =
        (typeof self === "undefined" ? "undefined" : _typeof(self)) ==
          "object" &&
        self &&
        self.Object === Object &&
        self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function("return this")();

      module.exports = root;

      /***/
    },

    /***/ 210: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Lazy = {
        loadInSlide: function loadInSlide(index, loadInDuplicate) {
          if (loadInDuplicate === void 0) {
            loadInDuplicate = true;
          }

          var swiper = this;
          var params = swiper.params.lazy;
          if (typeof index === "undefined") return;
          if (swiper.slides.length === 0) return;
          var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          var $slideEl = isVirtual
            ? swiper.$wrapperEl.children(
                "." +
                  swiper.params.slideClass +
                  '[data-swiper-slide-index="' +
                  index +
                  '"]'
              )
            : swiper.slides.eq(index);
          var $images = $slideEl.find(
            "." +
              params.elementClass +
              ":not(." +
              params.loadedClass +
              "):not(." +
              params.loadingClass +
              ")"
          );

          if (
            $slideEl.hasClass(params.elementClass) &&
            !$slideEl.hasClass(params.loadedClass) &&
            !$slideEl.hasClass(params.loadingClass)
          ) {
            $images.push($slideEl[0]);
          }

          if ($images.length === 0) return;
          $images.each(function (imageEl) {
            var $imageEl = (0, _dom2.default)(imageEl);
            $imageEl.addClass(params.loadingClass);
            var background = $imageEl.attr("data-background");
            var src = $imageEl.attr("data-src");
            var srcset = $imageEl.attr("data-srcset");
            var sizes = $imageEl.attr("data-sizes");
            var $pictureEl = $imageEl.parent("picture");
            swiper.loadImage(
              $imageEl[0],
              src || background,
              srcset,
              sizes,
              false,
              function () {
                if (
                  typeof swiper === "undefined" ||
                  swiper === null ||
                  !swiper ||
                  (swiper && !swiper.params) ||
                  swiper.destroyed
                )
                  return;

                if (background) {
                  $imageEl.css("background-image", 'url("' + background + '")');
                  $imageEl.removeAttr("data-background");
                } else {
                  if (srcset) {
                    $imageEl.attr("srcset", srcset);
                    $imageEl.removeAttr("data-srcset");
                  }

                  if (sizes) {
                    $imageEl.attr("sizes", sizes);
                    $imageEl.removeAttr("data-sizes");
                  }

                  if ($pictureEl.length) {
                    $pictureEl.children("source").each(function (sourceEl) {
                      var $source = (0, _dom2.default)(sourceEl);

                      if ($source.attr("data-srcset")) {
                        $source.attr("srcset", $source.attr("data-srcset"));
                        $source.removeAttr("data-srcset");
                      }
                    });
                  }

                  if (src) {
                    $imageEl.attr("src", src);
                    $imageEl.removeAttr("data-src");
                  }
                }

                $imageEl
                  .addClass(params.loadedClass)
                  .removeClass(params.loadingClass);
                $slideEl.find("." + params.preloaderClass).remove();

                if (swiper.params.loop && loadInDuplicate) {
                  var slideOriginalIndex = $slideEl.attr(
                    "data-swiper-slide-index"
                  );

                  if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                    var originalSlide = swiper.$wrapperEl.children(
                      '[data-swiper-slide-index="' +
                        slideOriginalIndex +
                        '"]:not(.' +
                        swiper.params.slideDuplicateClass +
                        ")"
                    );
                    swiper.lazy.loadInSlide(originalSlide.index(), false);
                  } else {
                    var duplicatedSlide = swiper.$wrapperEl.children(
                      "." +
                        swiper.params.slideDuplicateClass +
                        '[data-swiper-slide-index="' +
                        slideOriginalIndex +
                        '"]'
                    );
                    swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                  }
                }

                swiper.emit("lazyImageReady", $slideEl[0], $imageEl[0]);

                if (swiper.params.autoHeight) {
                  swiper.updateAutoHeight();
                }
              }
            );
            swiper.emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
          });
        },
        load: function load() {
          var swiper = this;
          var $wrapperEl = swiper.$wrapperEl,
            swiperParams = swiper.params,
            slides = swiper.slides,
            activeIndex = swiper.activeIndex;
          var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
          var params = swiperParams.lazy;
          var slidesPerView = swiperParams.slidesPerView;

          if (slidesPerView === "auto") {
            slidesPerView = 0;
          }

          function slideExist(index) {
            if (isVirtual) {
              if (
                $wrapperEl.children(
                  "." +
                    swiperParams.slideClass +
                    '[data-swiper-slide-index="' +
                    index +
                    '"]'
                ).length
              ) {
                return true;
              }
            } else if (slides[index]) return true;

            return false;
          }

          function slideIndex(slideEl) {
            if (isVirtual) {
              return (0, _dom2.default)(slideEl).attr(
                "data-swiper-slide-index"
              );
            }

            return (0, _dom2.default)(slideEl).index();
          }

          if (!swiper.lazy.initialImageLoaded)
            swiper.lazy.initialImageLoaded = true;

          if (swiper.params.watchSlidesVisibility) {
            $wrapperEl
              .children("." + swiperParams.slideVisibleClass)
              .each(function (slideEl) {
                var index = isVirtual
                  ? (0, _dom2.default)(slideEl).attr("data-swiper-slide-index")
                  : (0, _dom2.default)(slideEl).index();
                swiper.lazy.loadInSlide(index);
              });
          } else if (slidesPerView > 1) {
            for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
              if (slideExist(i)) swiper.lazy.loadInSlide(i);
            }
          } else {
            swiper.lazy.loadInSlide(activeIndex);
          }

          if (params.loadPrevNext) {
            if (
              slidesPerView > 1 ||
              (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)
            ) {
              var amount = params.loadPrevNextAmount;
              var spv = slidesPerView;
              var maxIndex = Math.min(
                activeIndex + spv + Math.max(amount, spv),
                slides.length
              );
              var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

              for (
                var _i = activeIndex + slidesPerView;
                _i < maxIndex;
                _i += 1
              ) {
                if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
              } // Prev Slides

              for (var _i2 = minIndex; _i2 < activeIndex; _i2 += 1) {
                if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
              }
            } else {
              var nextSlide = $wrapperEl.children(
                "." + swiperParams.slideNextClass
              );
              if (nextSlide.length > 0)
                swiper.lazy.loadInSlide(slideIndex(nextSlide));
              var prevSlide = $wrapperEl.children(
                "." + swiperParams.slidePrevClass
              );
              if (prevSlide.length > 0)
                swiper.lazy.loadInSlide(slideIndex(prevSlide));
            }
          }
        },
        checkInViewOnLoad: function checkInViewOnLoad() {
          var window = (0, _ssrWindow.getWindow)();
          var swiper = this;
          if (!swiper || swiper.destroyed) return;
          var $scrollElement = swiper.params.lazy.scrollingElement
            ? (0, _dom2.default)(swiper.params.lazy.scrollingElement)
            : (0, _dom2.default)(window);
          var isWindow = $scrollElement[0] === window;
          var scrollElementWidth = isWindow
            ? window.innerWidth
            : $scrollElement[0].offsetWidth;
          var scrollElementHeight = isWindow
            ? window.innerHeight
            : $scrollElement[0].offsetHeight;
          var swiperOffset = swiper.$el.offset();
          var rtl = swiper.rtlTranslate;
          var inView = false;
          if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
          var swiperCoord = [
            [swiperOffset.left, swiperOffset.top],
            [swiperOffset.left + swiper.width, swiperOffset.top],
            [swiperOffset.left, swiperOffset.top + swiper.height],
            [
              swiperOffset.left + swiper.width,
              swiperOffset.top + swiper.height,
            ],
          ];

          for (var i = 0; i < swiperCoord.length; i += 1) {
            var point = swiperCoord[i];

            if (
              point[0] >= 0 &&
              point[0] <= scrollElementWidth &&
              point[1] >= 0 &&
              point[1] <= scrollElementHeight
            ) {
              if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

              inView = true;
            }
          }

          var passiveListener =
            swiper.touchEvents.start === "touchstart" &&
            swiper.support.passiveListener &&
            swiper.params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;

          if (inView) {
            swiper.lazy.load();
            $scrollElement.off(
              "scroll",
              swiper.lazy.checkInViewOnLoad,
              passiveListener
            );
          } else if (!swiper.lazy.scrollHandlerAttached) {
            swiper.lazy.scrollHandlerAttached = true;
            $scrollElement.on(
              "scroll",
              swiper.lazy.checkInViewOnLoad,
              passiveListener
            );
          }
        },
      };
      exports.default = {
        name: "lazy",
        params: {
          lazy: {
            checkInView: false,
            enabled: false,
            loadPrevNext: false,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: false,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            lazy: _extends(
              {
                initialImageLoaded: false,
              },
              Lazy
            ),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
              swiper.params.preloadImages = false;
            }
          },
          init: function init(swiper) {
            if (
              swiper.params.lazy.enabled &&
              !swiper.params.loop &&
              swiper.params.initialSlide === 0
            ) {
              if (swiper.params.lazy.checkInView) {
                swiper.lazy.checkInViewOnLoad();
              } else {
                swiper.lazy.load();
              }
            }
          },
          scroll: function scroll(swiper) {
            if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
              swiper.lazy.load();
            }
          },
          "scrollbarDragMove resize _freeModeNoMomentumRelease":
            function lazyLoad(swiper) {
              if (swiper.params.lazy.enabled) {
                swiper.lazy.load();
              }
            },
          transitionStart: function transitionStart(swiper) {
            if (swiper.params.lazy.enabled) {
              if (
                swiper.params.lazy.loadOnTransitionStart ||
                (!swiper.params.lazy.loadOnTransitionStart &&
                  !swiper.lazy.initialImageLoaded)
              ) {
                swiper.lazy.load();
              }
            }
          },
          transitionEnd: function transitionEnd(swiper) {
            if (
              swiper.params.lazy.enabled &&
              !swiper.params.lazy.loadOnTransitionStart
            ) {
              swiper.lazy.load();
            }
          },
          slideChange: function slideChange(swiper) {
            var _swiper$params = swiper.params,
              lazy = _swiper$params.lazy,
              cssMode = _swiper$params.cssMode,
              watchSlidesVisibility = _swiper$params.watchSlidesVisibility,
              watchSlidesProgress = _swiper$params.watchSlidesProgress,
              touchReleaseOnEdges = _swiper$params.touchReleaseOnEdges,
              resistanceRatio = _swiper$params.resistanceRatio;

            if (
              lazy.enabled &&
              (cssMode ||
                ((watchSlidesVisibility || watchSlidesProgress) &&
                  (touchReleaseOnEdges || resistanceRatio === 0)))
            ) {
              swiper.lazy.load();
            }
          },
        },
      };

      /***/
    },

    /***/ 211: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _utils = __webpack_require__(1);

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      /* eslint no-bitwise: ["error", { "allow": [">>"] }] */

      var Controller = {
        LinearSpline: function LinearSpline(x, y) {
          var binarySearch = (function search() {
            var maxIndex;
            var minIndex;
            var guess;
            return function (array, val) {
              minIndex = -1;
              maxIndex = array.length;

              while (maxIndex - minIndex > 1) {
                guess = (maxIndex + minIndex) >> 1;

                if (array[guess] <= val) {
                  minIndex = guess;
                } else {
                  maxIndex = guess;
                }
              }

              return maxIndex;
            };
          })();

          this.x = x;
          this.y = y;
          this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
          // (x1,y1) is the known point before given value,
          // (x3,y3) is the known point after given value.

          var i1;
          var i3;

          this.interpolate = function interpolate(x2) {
            if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

            i3 = binarySearch(this.x, x2);
            i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
            // y2 := ((x2x1)  (y3y1))  (x3x1) + y1

            return (
              ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) /
                (this.x[i3] - this.x[i1]) +
              this.y[i1]
            );
          };

          return this;
        },
        // xxx: for now i will just save one spline function to to
        getInterpolateFunction: function getInterpolateFunction(c) {
          var swiper = this;

          if (!swiper.controller.spline) {
            swiper.controller.spline = swiper.params.loop
              ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
              : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
          }
        },
        setTranslate: function setTranslate(_setTranslate, byController) {
          var swiper = this;
          var controlled = swiper.controller.control;
          var multiplier;
          var controlledTranslate;
          var Swiper = swiper.constructor;

          function setControlledTranslate(c) {
            // this will create an Interpolate function based on the snapGrids
            // x is the Grid of the scrolled scroller and y will be the controlled scroller
            // it makes sense to create this only once and recall it for the interpolation
            // the function does a lot of value caching for performance
            var translate = swiper.rtlTranslate
              ? -swiper.translate
              : swiper.translate;

            if (swiper.params.controller.by === "slide") {
              swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
              // but it did not work out

              controlledTranslate = -swiper.controller.spline.interpolate(
                -translate
              );
            }

            if (
              !controlledTranslate ||
              swiper.params.controller.by === "container"
            ) {
              multiplier =
                (c.maxTranslate() - c.minTranslate()) /
                (swiper.maxTranslate() - swiper.minTranslate());
              controlledTranslate =
                (translate - swiper.minTranslate()) * multiplier +
                c.minTranslate();
            }

            if (swiper.params.controller.inverse) {
              controlledTranslate = c.maxTranslate() - controlledTranslate;
            }

            c.updateProgress(controlledTranslate);
            c.setTranslate(controlledTranslate, swiper);
            c.updateActiveIndex();
            c.updateSlidesClasses();
          }

          if (Array.isArray(controlled)) {
            for (var i = 0; i < controlled.length; i += 1) {
              if (
                controlled[i] !== byController &&
                controlled[i] instanceof Swiper
              ) {
                setControlledTranslate(controlled[i]);
              }
            }
          } else if (
            controlled instanceof Swiper &&
            byController !== controlled
          ) {
            setControlledTranslate(controlled);
          }
        },
        setTransition: function setTransition(duration, byController) {
          var swiper = this;
          var Swiper = swiper.constructor;
          var controlled = swiper.controller.control;
          var i;

          function setControlledTransition(c) {
            c.setTransition(duration, swiper);

            if (duration !== 0) {
              c.transitionStart();

              if (c.params.autoHeight) {
                (0, _utils.nextTick)(function () {
                  c.updateAutoHeight();
                });
              }

              c.$wrapperEl.transitionEnd(function () {
                if (!controlled) return;

                if (c.params.loop && swiper.params.controller.by === "slide") {
                  c.loopFix();
                }

                c.transitionEnd();
              });
            }
          }

          if (Array.isArray(controlled)) {
            for (i = 0; i < controlled.length; i += 1) {
              if (
                controlled[i] !== byController &&
                controlled[i] instanceof Swiper
              ) {
                setControlledTransition(controlled[i]);
              }
            }
          } else if (
            controlled instanceof Swiper &&
            byController !== controlled
          ) {
            setControlledTransition(controlled);
          }
        },
      };
      exports.default = {
        name: "controller",
        params: {
          controller: {
            control: undefined,
            inverse: false,
            by: "slide", // or 'container'
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            controller: _extends(
              {
                control: swiper.params.controller.control,
              },
              Controller
            ),
          });
        },
        on: {
          update: function update(swiper) {
            if (!swiper.controller.control) return;

            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          },
          resize: function resize(swiper) {
            if (!swiper.controller.control) return;

            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          },
          observerUpdate: function observerUpdate(swiper) {
            if (!swiper.controller.control) return;

            if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline;
            }
          },
          setTranslate: function setTranslate(swiper, translate, byController) {
            if (!swiper.controller.control) return;
            swiper.controller.setTranslate(translate, byController);
          },
          setTransition: function setTransition(
            swiper,
            duration,
            byController
          ) {
            if (!swiper.controller.control) return;
            swiper.controller.setTransition(duration, byController);
          },
        },
      };

      /***/
    },

    /***/ 212: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var A11y = {
        getRandomNumber: function getRandomNumber(size) {
          if (size === void 0) {
            size = 16;
          }

          var randomChar = function randomChar() {
            return Math.round(16 * Math.random()).toString(16);
          };

          return "x".repeat(size).replace(/x/g, randomChar);
        },
        makeElFocusable: function makeElFocusable($el) {
          $el.attr("tabIndex", "0");
          return $el;
        },
        makeElNotFocusable: function makeElNotFocusable($el) {
          $el.attr("tabIndex", "-1");
          return $el;
        },
        addElRole: function addElRole($el, role) {
          $el.attr("role", role);
          return $el;
        },
        addElRoleDescription: function addElRoleDescription($el, description) {
          $el.attr("aria-roledescription", description);
          return $el;
        },
        addElControls: function addElControls($el, controls) {
          $el.attr("aria-controls", controls);
          return $el;
        },
        addElLabel: function addElLabel($el, label) {
          $el.attr("aria-label", label);
          return $el;
        },
        addElId: function addElId($el, id) {
          $el.attr("id", id);
          return $el;
        },
        addElLive: function addElLive($el, live) {
          $el.attr("aria-live", live);
          return $el;
        },
        disableEl: function disableEl($el) {
          $el.attr("aria-disabled", true);
          return $el;
        },
        enableEl: function enableEl($el) {
          $el.attr("aria-disabled", false);
          return $el;
        },
        onEnterOrSpaceKey: function onEnterOrSpaceKey(e) {
          if (e.keyCode !== 13 && e.keyCode !== 32) return;
          var swiper = this;
          var params = swiper.params.a11y;
          var $targetEl = (0, _dom2.default)(e.target);

          if (
            swiper.navigation &&
            swiper.navigation.$nextEl &&
            $targetEl.is(swiper.navigation.$nextEl)
          ) {
            if (!(swiper.isEnd && !swiper.params.loop)) {
              swiper.slideNext();
            }

            if (swiper.isEnd) {
              swiper.a11y.notify(params.lastSlideMessage);
            } else {
              swiper.a11y.notify(params.nextSlideMessage);
            }
          }

          if (
            swiper.navigation &&
            swiper.navigation.$prevEl &&
            $targetEl.is(swiper.navigation.$prevEl)
          ) {
            if (!(swiper.isBeginning && !swiper.params.loop)) {
              swiper.slidePrev();
            }

            if (swiper.isBeginning) {
              swiper.a11y.notify(params.firstSlideMessage);
            } else {
              swiper.a11y.notify(params.prevSlideMessage);
            }
          }

          if (
            swiper.pagination &&
            $targetEl.is(
              (0, _utils.classesToSelector)(
                swiper.params.pagination.bulletClass
              )
            )
          ) {
            $targetEl[0].click();
          }
        },
        notify: function notify(message) {
          var swiper = this;
          var notification = swiper.a11y.liveRegion;
          if (notification.length === 0) return;
          notification.html("");
          notification.html(message);
        },
        updateNavigation: function updateNavigation() {
          var swiper = this;
          if (swiper.params.loop || !swiper.navigation) return;
          var _swiper$navigation = swiper.navigation,
            $nextEl = _swiper$navigation.$nextEl,
            $prevEl = _swiper$navigation.$prevEl;

          if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
              swiper.a11y.disableEl($prevEl);
              swiper.a11y.makeElNotFocusable($prevEl);
            } else {
              swiper.a11y.enableEl($prevEl);
              swiper.a11y.makeElFocusable($prevEl);
            }
          }

          if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
              swiper.a11y.disableEl($nextEl);
              swiper.a11y.makeElNotFocusable($nextEl);
            } else {
              swiper.a11y.enableEl($nextEl);
              swiper.a11y.makeElFocusable($nextEl);
            }
          }
        },
        updatePagination: function updatePagination() {
          var swiper = this;
          var params = swiper.params.a11y;

          if (
            swiper.pagination &&
            swiper.params.pagination.clickable &&
            swiper.pagination.bullets &&
            swiper.pagination.bullets.length
          ) {
            swiper.pagination.bullets.each(function (bulletEl) {
              var $bulletEl = (0, _dom2.default)(bulletEl);
              swiper.a11y.makeElFocusable($bulletEl);

              if (!swiper.params.pagination.renderBullet) {
                swiper.a11y.addElRole($bulletEl, "button");
                swiper.a11y.addElLabel(
                  $bulletEl,
                  params.paginationBulletMessage.replace(
                    /\{\{index\}\}/,
                    $bulletEl.index() + 1
                  )
                );
              }
            });
          }
        },
        init: function init() {
          var swiper = this;
          var params = swiper.params.a11y;
          swiper.$el.append(swiper.a11y.liveRegion); // Container

          var $containerEl = swiper.$el;

          if (params.containerRoleDescriptionMessage) {
            swiper.a11y.addElRoleDescription(
              $containerEl,
              params.containerRoleDescriptionMessage
            );
          }

          if (params.containerMessage) {
            swiper.a11y.addElLabel($containerEl, params.containerMessage);
          } // Wrapper

          var $wrapperEl = swiper.$wrapperEl;
          var wrapperId =
            $wrapperEl.attr("id") ||
            "swiper-wrapper-" + swiper.a11y.getRandomNumber(16);
          var live =
            swiper.params.autoplay && swiper.params.autoplay.enabled
              ? "off"
              : "polite";
          swiper.a11y.addElId($wrapperEl, wrapperId);
          swiper.a11y.addElLive($wrapperEl, live); // Slide

          if (params.itemRoleDescriptionMessage) {
            swiper.a11y.addElRoleDescription(
              (0, _dom2.default)(swiper.slides),
              params.itemRoleDescriptionMessage
            );
          }

          swiper.a11y.addElRole(
            (0, _dom2.default)(swiper.slides),
            params.slideRole
          );
          var slidesLength = swiper.params.loop
            ? swiper.slides.filter(function (el) {
                return !el.classList.contains(
                  swiper.params.slideDuplicateClass
                );
              }).length
            : swiper.slides.length;
          swiper.slides.each(function (slideEl, index) {
            var $slideEl = (0, _dom2.default)(slideEl);
            var slideIndex = swiper.params.loop
              ? parseInt($slideEl.attr("data-swiper-slide-index"), 10)
              : index;
            var ariaLabelMessage = params.slideLabelMessage
              .replace(/\{\{index\}\}/, slideIndex + 1)
              .replace(/\{\{slidesLength\}\}/, slidesLength);
            swiper.a11y.addElLabel($slideEl, ariaLabelMessage);
          }); // Navigation

          var $nextEl;
          var $prevEl;

          if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
          }

          if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
          }

          if ($nextEl && $nextEl.length) {
            swiper.a11y.makeElFocusable($nextEl);

            if ($nextEl[0].tagName !== "BUTTON") {
              swiper.a11y.addElRole($nextEl, "button");
              $nextEl.on("keydown", swiper.a11y.onEnterOrSpaceKey);
            }

            swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
            swiper.a11y.addElControls($nextEl, wrapperId);
          }

          if ($prevEl && $prevEl.length) {
            swiper.a11y.makeElFocusable($prevEl);

            if ($prevEl[0].tagName !== "BUTTON") {
              swiper.a11y.addElRole($prevEl, "button");
              $prevEl.on("keydown", swiper.a11y.onEnterOrSpaceKey);
            }

            swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
            swiper.a11y.addElControls($prevEl, wrapperId);
          } // Pagination

          if (
            swiper.pagination &&
            swiper.params.pagination.clickable &&
            swiper.pagination.bullets &&
            swiper.pagination.bullets.length
          ) {
            swiper.pagination.$el.on(
              "keydown",
              (0, _utils.classesToSelector)(
                swiper.params.pagination.bulletClass
              ),
              swiper.a11y.onEnterOrSpaceKey
            );
          }
        },
        destroy: function destroy() {
          var swiper = this;
          if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0)
            swiper.a11y.liveRegion.remove();
          var $nextEl;
          var $prevEl;

          if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
          }

          if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
          }

          if ($nextEl) {
            $nextEl.off("keydown", swiper.a11y.onEnterOrSpaceKey);
          }

          if ($prevEl) {
            $prevEl.off("keydown", swiper.a11y.onEnterOrSpaceKey);
          } // Pagination

          if (
            swiper.pagination &&
            swiper.params.pagination.clickable &&
            swiper.pagination.bullets &&
            swiper.pagination.bullets.length
          ) {
            swiper.pagination.$el.off(
              "keydown",
              (0, _utils.classesToSelector)(
                swiper.params.pagination.bulletClass
              ),
              swiper.a11y.onEnterOrSpaceKey
            );
          }
        },
      };
      exports.default = {
        name: "a11y",
        params: {
          a11y: {
            enabled: true,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            a11y: _extends({}, A11y, {
              liveRegion: (0, _dom2.default)(
                '<span class="' +
                  swiper.params.a11y.notificationClass +
                  '" aria-live="assertive" aria-atomic="true"></span>'
              ),
            }),
          });
        },
        on: {
          afterInit: function afterInit(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.init();
            swiper.a11y.updateNavigation();
          },
          toEdge: function toEdge(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updateNavigation();
          },
          fromEdge: function fromEdge(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updateNavigation();
          },
          paginationUpdate: function paginationUpdate(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updatePagination();
          },
          destroy: function destroy(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.destroy();
          },
        },
      };

      /***/
    },

    /***/ 213: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _utils = __webpack_require__(1);

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var History = {
        init: function init() {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();
          if (!swiper.params.history) return;

          if (!window.history || !window.history.pushState) {
            swiper.params.history.enabled = false;
            swiper.params.hashNavigation.enabled = true;
            return;
          }

          var history = swiper.history;
          history.initialized = true;
          history.paths = History.getPathValues(swiper.params.url);
          if (!history.paths.key && !history.paths.value) return;
          history.scrollToSlide(
            0,
            history.paths.value,
            swiper.params.runCallbacksOnInit
          );

          if (!swiper.params.history.replaceState) {
            window.addEventListener(
              "popstate",
              swiper.history.setHistoryPopState
            );
          }
        },
        destroy: function destroy() {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();

          if (!swiper.params.history.replaceState) {
            window.removeEventListener(
              "popstate",
              swiper.history.setHistoryPopState
            );
          }
        },
        setHistoryPopState: function setHistoryPopState() {
          var swiper = this;
          swiper.history.paths = History.getPathValues(swiper.params.url);
          swiper.history.scrollToSlide(
            swiper.params.speed,
            swiper.history.paths.value,
            false
          );
        },
        getPathValues: function getPathValues(urlOverride) {
          var window = (0, _ssrWindow.getWindow)();
          var location;

          if (urlOverride) {
            location = new URL(urlOverride);
          } else {
            location = window.location;
          }

          var pathArray = location.pathname
            .slice(1)
            .split("/")
            .filter(function (part) {
              return part !== "";
            });
          var total = pathArray.length;
          var key = pathArray[total - 2];
          var value = pathArray[total - 1];
          return {
            key: key,
            value: value,
          };
        },
        setHistory: function setHistory(key, index) {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();
          if (!swiper.history.initialized || !swiper.params.history.enabled)
            return;
          var location;

          if (swiper.params.url) {
            location = new URL(swiper.params.url);
          } else {
            location = window.location;
          }

          var slide = swiper.slides.eq(index);
          var value = History.slugify(slide.attr("data-history"));

          if (swiper.params.history.root.length > 0) {
            var root = swiper.params.history.root;
            if (root[root.length - 1] === "/")
              root = root.slice(0, root.length - 1);
            value = root + "/" + key + "/" + value;
          } else if (!location.pathname.includes(key)) {
            value = key + "/" + value;
          }

          var currentState = window.history.state;

          if (currentState && currentState.value === value) {
            return;
          }

          if (swiper.params.history.replaceState) {
            window.history.replaceState(
              {
                value: value,
              },
              null,
              value
            );
          } else {
            window.history.pushState(
              {
                value: value,
              },
              null,
              value
            );
          }
        },
        slugify: function slugify(text) {
          return text
            .toString()
            .replace(/\s+/g, "-")
            .replace(/[^\w-]+/g, "")
            .replace(/--+/g, "-")
            .replace(/^-+/, "")
            .replace(/-+$/, "");
        },
        scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
          var swiper = this;

          if (value) {
            for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
              var slide = swiper.slides.eq(i);
              var slideHistory = History.slugify(slide.attr("data-history"));

              if (
                slideHistory === value &&
                !slide.hasClass(swiper.params.slideDuplicateClass)
              ) {
                var index = slide.index();
                swiper.slideTo(index, speed, runCallbacks);
              }
            }
          } else {
            swiper.slideTo(0, speed, runCallbacks);
          }
        },
      };
      exports.default = {
        name: "history",
        params: {
          history: {
            enabled: false,
            root: "",
            replaceState: false,
            key: "slides",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            history: _extends({}, History),
          });
        },
        on: {
          init: function init(swiper) {
            if (swiper.params.history.enabled) {
              swiper.history.init();
            }
          },
          destroy: function destroy(swiper) {
            if (swiper.params.history.enabled) {
              swiper.history.destroy();
            }
          },
          "transitionEnd _freeModeNoMomentumRelease":
            function transitionEnd_freeModeNoMomentumRelease(swiper) {
              if (swiper.history.initialized) {
                swiper.history.setHistory(
                  swiper.params.history.key,
                  swiper.activeIndex
                );
              }
            },
          slideChange: function slideChange(swiper) {
            if (swiper.history.initialized && swiper.params.cssMode) {
              swiper.history.setHistory(
                swiper.params.history.key,
                swiper.activeIndex
              );
            }
          },
        },
      };

      /***/
    },

    /***/ 214: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var HashNavigation = {
        onHashChange: function onHashChange() {
          var swiper = this;
          var document = (0, _ssrWindow.getDocument)();
          swiper.emit("hashChange");
          var newHash = document.location.hash.replace("#", "");
          var activeSlideHash = swiper.slides
            .eq(swiper.activeIndex)
            .attr("data-hash");

          if (newHash !== activeSlideHash) {
            var newIndex = swiper.$wrapperEl
              .children(
                "." + swiper.params.slideClass + '[data-hash="' + newHash + '"]'
              )
              .index();
            if (typeof newIndex === "undefined") return;
            swiper.slideTo(newIndex);
          }
        },
        setHash: function setHash() {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();
          var document = (0, _ssrWindow.getDocument)();
          if (
            !swiper.hashNavigation.initialized ||
            !swiper.params.hashNavigation.enabled
          )
            return;

          if (
            swiper.params.hashNavigation.replaceState &&
            window.history &&
            window.history.replaceState
          ) {
            window.history.replaceState(
              null,
              null,
              "#" + swiper.slides.eq(swiper.activeIndex).attr("data-hash") || ""
            );
            swiper.emit("hashSet");
          } else {
            var slide = swiper.slides.eq(swiper.activeIndex);
            var hash = slide.attr("data-hash") || slide.attr("data-history");
            document.location.hash = hash || "";
            swiper.emit("hashSet");
          }
        },
        init: function init() {
          var swiper = this;
          var document = (0, _ssrWindow.getDocument)();
          var window = (0, _ssrWindow.getWindow)();
          if (
            !swiper.params.hashNavigation.enabled ||
            (swiper.params.history && swiper.params.history.enabled)
          )
            return;
          swiper.hashNavigation.initialized = true;
          var hash = document.location.hash.replace("#", "");

          if (hash) {
            var speed = 0;

            for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
              var slide = swiper.slides.eq(i);
              var slideHash =
                slide.attr("data-hash") || slide.attr("data-history");

              if (
                slideHash === hash &&
                !slide.hasClass(swiper.params.slideDuplicateClass)
              ) {
                var index = slide.index();
                swiper.slideTo(
                  index,
                  speed,
                  swiper.params.runCallbacksOnInit,
                  true
                );
              }
            }
          }

          if (swiper.params.hashNavigation.watchState) {
            (0, _dom2.default)(window).on(
              "hashchange",
              swiper.hashNavigation.onHashChange
            );
          }
        },
        destroy: function destroy() {
          var swiper = this;
          var window = (0, _ssrWindow.getWindow)();

          if (swiper.params.hashNavigation.watchState) {
            (0, _dom2.default)(window).off(
              "hashchange",
              swiper.hashNavigation.onHashChange
            );
          }
        },
      };
      exports.default = {
        name: "hash-navigation",
        params: {
          hashNavigation: {
            enabled: false,
            replaceState: false,
            watchState: false,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            hashNavigation: _extends(
              {
                initialized: false,
              },
              HashNavigation
            ),
          });
        },
        on: {
          init: function init(swiper) {
            if (swiper.params.hashNavigation.enabled) {
              swiper.hashNavigation.init();
            }
          },
          destroy: function destroy(swiper) {
            if (swiper.params.hashNavigation.enabled) {
              swiper.hashNavigation.destroy();
            }
          },
          "transitionEnd _freeModeNoMomentumRelease":
            function transitionEnd_freeModeNoMomentumRelease(swiper) {
              if (swiper.hashNavigation.initialized) {
                swiper.hashNavigation.setHash();
              }
            },
          slideChange: function slideChange(swiper) {
            if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
              swiper.hashNavigation.setHash();
            }
          },
        },
      };

      /***/
    },

    /***/ 215: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _ssrWindow = __webpack_require__(5);

      var _utils = __webpack_require__(1);

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      /* eslint no-underscore-dangle: "off" */

      var Autoplay = {
        run: function run() {
          var swiper = this;
          var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
          var delay = swiper.params.autoplay.delay;

          if ($activeSlideEl.attr("data-swiper-autoplay")) {
            delay =
              $activeSlideEl.attr("data-swiper-autoplay") ||
              swiper.params.autoplay.delay;
          }

          clearTimeout(swiper.autoplay.timeout);
          swiper.autoplay.timeout = (0, _utils.nextTick)(function () {
            var autoplayResult;

            if (swiper.params.autoplay.reverseDirection) {
              if (swiper.params.loop) {
                swiper.loopFix();
                autoplayResult = swiper.slidePrev(
                  swiper.params.speed,
                  true,
                  true
                );
                swiper.emit("autoplay");
              } else if (!swiper.isBeginning) {
                autoplayResult = swiper.slidePrev(
                  swiper.params.speed,
                  true,
                  true
                );
                swiper.emit("autoplay");
              } else if (!swiper.params.autoplay.stopOnLastSlide) {
                autoplayResult = swiper.slideTo(
                  swiper.slides.length - 1,
                  swiper.params.speed,
                  true,
                  true
                );
                swiper.emit("autoplay");
              } else {
                swiper.autoplay.stop();
              }
            } else if (swiper.params.loop) {
              swiper.loopFix();
              autoplayResult = swiper.slideNext(
                swiper.params.speed,
                true,
                true
              );
              swiper.emit("autoplay");
            } else if (!swiper.isEnd) {
              autoplayResult = swiper.slideNext(
                swiper.params.speed,
                true,
                true
              );
              swiper.emit("autoplay");
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              autoplayResult = swiper.slideTo(
                0,
                swiper.params.speed,
                true,
                true
              );
              swiper.emit("autoplay");
            } else {
              swiper.autoplay.stop();
            }

            if (swiper.params.cssMode && swiper.autoplay.running)
              swiper.autoplay.run();
            else if (autoplayResult === false) {
              swiper.autoplay.run();
            }
          }, delay);
        },
        start: function start() {
          var swiper = this;
          if (typeof swiper.autoplay.timeout !== "undefined") return false;
          if (swiper.autoplay.running) return false;
          swiper.autoplay.running = true;
          swiper.emit("autoplayStart");
          swiper.autoplay.run();
          return true;
        },
        stop: function stop() {
          var swiper = this;
          if (!swiper.autoplay.running) return false;
          if (typeof swiper.autoplay.timeout === "undefined") return false;

          if (swiper.autoplay.timeout) {
            clearTimeout(swiper.autoplay.timeout);
            swiper.autoplay.timeout = undefined;
          }

          swiper.autoplay.running = false;
          swiper.emit("autoplayStop");
          return true;
        },
        pause: function pause(speed) {
          var swiper = this;
          if (!swiper.autoplay.running) return;
          if (swiper.autoplay.paused) return;
          if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
          swiper.autoplay.paused = true;

          if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
            swiper.autoplay.paused = false;
            swiper.autoplay.run();
          } else {
            ["transitionend", "webkitTransitionEnd"].forEach(function (event) {
              swiper.$wrapperEl[0].addEventListener(
                event,
                swiper.autoplay.onTransitionEnd
              );
            });
          }
        },
        onVisibilityChange: function onVisibilityChange() {
          var swiper = this;
          var document = (0, _ssrWindow.getDocument)();

          if (
            document.visibilityState === "hidden" &&
            swiper.autoplay.running
          ) {
            swiper.autoplay.pause();
          }

          if (
            document.visibilityState === "visible" &&
            swiper.autoplay.paused
          ) {
            swiper.autoplay.run();
            swiper.autoplay.paused = false;
          }
        },
        onTransitionEnd: function onTransitionEnd(e) {
          var swiper = this;
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== swiper.$wrapperEl[0]) return;
          ["transitionend", "webkitTransitionEnd"].forEach(function (event) {
            swiper.$wrapperEl[0].removeEventListener(
              event,
              swiper.autoplay.onTransitionEnd
            );
          });
          swiper.autoplay.paused = false;

          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
        onMouseEnter: function onMouseEnter() {
          var swiper = this;

          if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.pause();
          }

          ["transitionend", "webkitTransitionEnd"].forEach(function (event) {
            swiper.$wrapperEl[0].removeEventListener(
              event,
              swiper.autoplay.onTransitionEnd
            );
          });
        },
        onMouseLeave: function onMouseLeave() {
          var swiper = this;

          if (swiper.params.autoplay.disableOnInteraction) {
            return;
          }

          swiper.autoplay.paused = false;
          swiper.autoplay.run();
        },
        attachMouseEvents: function attachMouseEvents() {
          var swiper = this;

          if (swiper.params.autoplay.pauseOnMouseEnter) {
            swiper.$el.on("mouseenter", swiper.autoplay.onMouseEnter);
            swiper.$el.on("mouseleave", swiper.autoplay.onMouseLeave);
          }
        },
        detachMouseEvents: function detachMouseEvents() {
          var swiper = this;
          swiper.$el.off("mouseenter", swiper.autoplay.onMouseEnter);
          swiper.$el.off("mouseleave", swiper.autoplay.onMouseLeave);
        },
      };
      exports.default = {
        name: "autoplay",
        params: {
          autoplay: {
            enabled: false,
            delay: 3000,
            waitForTransition: true,
            disableOnInteraction: true,
            stopOnLastSlide: false,
            reverseDirection: false,
            pauseOnMouseEnter: false,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            autoplay: _extends({}, Autoplay, {
              running: false,
              paused: false,
            }),
          });
        },
        on: {
          init: function init(swiper) {
            if (swiper.params.autoplay.enabled) {
              swiper.autoplay.start();
              var document = (0, _ssrWindow.getDocument)();
              document.addEventListener(
                "visibilitychange",
                swiper.autoplay.onVisibilityChange
              );
              swiper.autoplay.attachMouseEvents();
            }
          },
          beforeTransitionStart: function beforeTransitionStart(
            swiper,
            speed,
            internal
          ) {
            if (swiper.autoplay.running) {
              if (internal || !swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.pause(speed);
              } else {
                swiper.autoplay.stop();
              }
            }
          },
          sliderFirstMove: function sliderFirstMove(swiper) {
            if (swiper.autoplay.running) {
              if (swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.stop();
              } else {
                swiper.autoplay.pause();
              }
            }
          },
          touchEnd: function touchEnd(swiper) {
            if (
              swiper.params.cssMode &&
              swiper.autoplay.paused &&
              !swiper.params.autoplay.disableOnInteraction
            ) {
              swiper.autoplay.run();
            }
          },
          destroy: function destroy(swiper) {
            swiper.autoplay.detachMouseEvents();

            if (swiper.autoplay.running) {
              swiper.autoplay.stop();
            }

            var document = (0, _ssrWindow.getDocument)();
            document.removeEventListener(
              "visibilitychange",
              swiper.autoplay.onVisibilityChange
            );
          },
        },
      };

      /***/
    },

    /***/ 216: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _utils = __webpack_require__(1);

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Fade = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var slides = swiper.slides;

          for (var i = 0; i < slides.length; i += 1) {
            var $slideEl = swiper.slides.eq(i);
            var offset = $slideEl[0].swiperSlideOffset;
            var tx = -offset;
            if (!swiper.params.virtualTranslate) tx -= swiper.translate;
            var ty = 0;

            if (!swiper.isHorizontal()) {
              ty = tx;
              tx = 0;
            }

            var slideOpacity = swiper.params.fadeEffect.crossFade
              ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
              : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
            $slideEl
              .css({
                opacity: slideOpacity,
              })
              .transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          var slides = swiper.slides,
            $wrapperEl = swiper.$wrapperEl;
          slides.transition(duration);

          if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false;
            slides.transitionEnd(function () {
              if (eventTriggered) return;
              if (!swiper || swiper.destroyed) return;
              eventTriggered = true;
              swiper.animating = false;
              var triggerEvents = ["webkitTransitionEnd", "transitionend"];

              for (var i = 0; i < triggerEvents.length; i += 1) {
                $wrapperEl.trigger(triggerEvents[i]);
              }
            });
          }
        },
      };
      exports.default = {
        name: "effect-fade",
        params: {
          fadeEffect: {
            crossFade: false,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            fadeEffect: _extends({}, Fade),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (swiper.params.effect !== "fade") return;
            swiper.classNames.push(
              swiper.params.containerModifierClass + "fade"
            );
            var overwriteParams = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: true,
            };
            (0, _utils.extend)(swiper.params, overwriteParams);
            (0, _utils.extend)(swiper.originalParams, overwriteParams);
          },
          setTranslate: function setTranslate(swiper) {
            if (swiper.params.effect !== "fade") return;
            swiper.fadeEffect.setTranslate();
          },
          setTransition: function setTransition(swiper, duration) {
            if (swiper.params.effect !== "fade") return;
            swiper.fadeEffect.setTransition(duration);
          },
        },
      };

      /***/
    },

    /***/ 217: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Cube = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var $el = swiper.$el,
            $wrapperEl = swiper.$wrapperEl,
            slides = swiper.slides,
            swiperWidth = swiper.width,
            swiperHeight = swiper.height,
            rtl = swiper.rtlTranslate,
            swiperSize = swiper.size,
            browser = swiper.browser;
          var params = swiper.params.cubeEffect;
          var isHorizontal = swiper.isHorizontal();
          var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          var wrapperRotate = 0;
          var $cubeShadowEl;

          if (params.shadow) {
            if (isHorizontal) {
              $cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");

              if ($cubeShadowEl.length === 0) {
                $cubeShadowEl = (0, _dom2.default)(
                  '<div class="swiper-cube-shadow"></div>'
                );
                $wrapperEl.append($cubeShadowEl);
              }

              $cubeShadowEl.css({
                height: swiperWidth + "px",
              });
            } else {
              $cubeShadowEl = $el.find(".swiper-cube-shadow");

              if ($cubeShadowEl.length === 0) {
                $cubeShadowEl = (0, _dom2.default)(
                  '<div class="swiper-cube-shadow"></div>'
                );
                $el.append($cubeShadowEl);
              }
            }
          }

          for (var i = 0; i < slides.length; i += 1) {
            var $slideEl = slides.eq(i);
            var slideIndex = i;

            if (isVirtual) {
              slideIndex = parseInt(
                $slideEl.attr("data-swiper-slide-index"),
                10
              );
            }

            var slideAngle = slideIndex * 90;
            var round = Math.floor(slideAngle / 360);

            if (rtl) {
              slideAngle = -slideAngle;
              round = Math.floor(-slideAngle / 360);
            }

            var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            var tx = 0;
            var ty = 0;
            var tz = 0;

            if (slideIndex % 4 === 0) {
              tx = -round * 4 * swiperSize;
              tz = 0;
            } else if ((slideIndex - 1) % 4 === 0) {
              tx = 0;
              tz = -round * 4 * swiperSize;
            } else if ((slideIndex - 2) % 4 === 0) {
              tx = swiperSize + round * 4 * swiperSize;
              tz = swiperSize;
            } else if ((slideIndex - 3) % 4 === 0) {
              tx = -swiperSize;
              tz = 3 * swiperSize + swiperSize * 4 * round;
            }

            if (rtl) {
              tx = -tx;
            }

            if (!isHorizontal) {
              ty = tx;
              tx = 0;
            }

            var transform =
              "rotateX(" +
              (isHorizontal ? 0 : -slideAngle) +
              "deg) rotateY(" +
              (isHorizontal ? slideAngle : 0) +
              "deg) translate3d(" +
              tx +
              "px, " +
              ty +
              "px, " +
              tz +
              "px)";

            if (progress <= 1 && progress > -1) {
              wrapperRotate = slideIndex * 90 + progress * 90;
              if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
            }

            $slideEl.transform(transform);

            if (params.slideShadows) {
              // Set shadows
              var shadowBefore = isHorizontal
                ? $slideEl.find(".swiper-slide-shadow-left")
                : $slideEl.find(".swiper-slide-shadow-top");
              var shadowAfter = isHorizontal
                ? $slideEl.find(".swiper-slide-shadow-right")
                : $slideEl.find(".swiper-slide-shadow-bottom");

              if (shadowBefore.length === 0) {
                shadowBefore = (0, _dom2.default)(
                  '<div class="swiper-slide-shadow-' +
                    (isHorizontal ? "left" : "top") +
                    '"></div>'
                );
                $slideEl.append(shadowBefore);
              }

              if (shadowAfter.length === 0) {
                shadowAfter = (0, _dom2.default)(
                  '<div class="swiper-slide-shadow-' +
                    (isHorizontal ? "right" : "bottom") +
                    '"></div>'
                );
                $slideEl.append(shadowAfter);
              }

              if (shadowBefore.length)
                shadowBefore[0].style.opacity = Math.max(-progress, 0);
              if (shadowAfter.length)
                shadowAfter[0].style.opacity = Math.max(progress, 0);
            }
          }

          $wrapperEl.css({
            "-webkit-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "-moz-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "-ms-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "transform-origin": "50% 50% -" + swiperSize / 2 + "px",
          });

          if (params.shadow) {
            if (isHorizontal) {
              $cubeShadowEl.transform(
                "translate3d(0px, " +
                  (swiperWidth / 2 + params.shadowOffset) +
                  "px, " +
                  -swiperWidth / 2 +
                  "px) rotateX(90deg) rotateZ(0deg) scale(" +
                  params.shadowScale +
                  ")"
              );
            } else {
              var shadowAngle =
                Math.abs(wrapperRotate) -
                Math.floor(Math.abs(wrapperRotate) / 90) * 90;
              var multiplier =
                1.5 -
                (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +
                  Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);
              var scale1 = params.shadowScale;
              var scale2 = params.shadowScale / multiplier;
              var offset = params.shadowOffset;
              $cubeShadowEl.transform(
                "scale3d(" +
                  scale1 +
                  ", 1, " +
                  scale2 +
                  ") translate3d(0px, " +
                  (swiperHeight / 2 + offset) +
                  "px, " +
                  -swiperHeight / 2 / scale2 +
                  "px) rotateX(-90deg)"
              );
            }
          }

          var zFactor =
            browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
          $wrapperEl.transform(
            "translate3d(0px,0," +
              zFactor +
              "px) rotateX(" +
              (swiper.isHorizontal() ? 0 : wrapperRotate) +
              "deg) rotateY(" +
              (swiper.isHorizontal() ? -wrapperRotate : 0) +
              "deg)"
          );
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          var $el = swiper.$el,
            slides = swiper.slides;
          slides
            .transition(duration)
            .find(
              ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
            )
            .transition(duration);

          if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
            $el.find(".swiper-cube-shadow").transition(duration);
          }
        },
      };
      exports.default = {
        name: "effect-cube",
        params: {
          cubeEffect: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            cubeEffect: _extends({}, Cube),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (swiper.params.effect !== "cube") return;
            swiper.classNames.push(
              swiper.params.containerModifierClass + "cube"
            );
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              resistanceRatio: 0,
              spaceBetween: 0,
              centeredSlides: false,
              virtualTranslate: true,
            };
            (0, _utils.extend)(swiper.params, overwriteParams);
            (0, _utils.extend)(swiper.originalParams, overwriteParams);
          },
          setTranslate: function setTranslate(swiper) {
            if (swiper.params.effect !== "cube") return;
            swiper.cubeEffect.setTranslate();
          },
          setTransition: function setTransition(swiper, duration) {
            if (swiper.params.effect !== "cube") return;
            swiper.cubeEffect.setTransition(duration);
          },
        },
      };

      /***/
    },

    /***/ 218: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Flip = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var slides = swiper.slides,
            rtl = swiper.rtlTranslate;

          for (var i = 0; i < slides.length; i += 1) {
            var $slideEl = slides.eq(i);
            var progress = $slideEl[0].progress;

            if (swiper.params.flipEffect.limitRotation) {
              progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            }

            var offset = $slideEl[0].swiperSlideOffset;
            var rotate = -180 * progress;
            var rotateY = rotate;
            var rotateX = 0;
            var tx = -offset;
            var ty = 0;

            if (!swiper.isHorizontal()) {
              ty = tx;
              tx = 0;
              rotateX = -rotateY;
              rotateY = 0;
            } else if (rtl) {
              rotateY = -rotateY;
            }

            $slideEl[0].style.zIndex =
              -Math.abs(Math.round(progress)) + slides.length;

            if (swiper.params.flipEffect.slideShadows) {
              // Set shadows
              var shadowBefore = swiper.isHorizontal()
                ? $slideEl.find(".swiper-slide-shadow-left")
                : $slideEl.find(".swiper-slide-shadow-top");
              var shadowAfter = swiper.isHorizontal()
                ? $slideEl.find(".swiper-slide-shadow-right")
                : $slideEl.find(".swiper-slide-shadow-bottom");

              if (shadowBefore.length === 0) {
                shadowBefore = (0, _dom2.default)(
                  '<div class="swiper-slide-shadow-' +
                    (swiper.isHorizontal() ? "left" : "top") +
                    '"></div>'
                );
                $slideEl.append(shadowBefore);
              }

              if (shadowAfter.length === 0) {
                shadowAfter = (0, _dom2.default)(
                  '<div class="swiper-slide-shadow-' +
                    (swiper.isHorizontal() ? "right" : "bottom") +
                    '"></div>'
                );
                $slideEl.append(shadowAfter);
              }

              if (shadowBefore.length)
                shadowBefore[0].style.opacity = Math.max(-progress, 0);
              if (shadowAfter.length)
                shadowAfter[0].style.opacity = Math.max(progress, 0);
            }

            $slideEl.transform(
              "translate3d(" +
                tx +
                "px, " +
                ty +
                "px, 0px) rotateX(" +
                rotateX +
                "deg) rotateY(" +
                rotateY +
                "deg)"
            );
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          var slides = swiper.slides,
            activeIndex = swiper.activeIndex,
            $wrapperEl = swiper.$wrapperEl;
          slides
            .transition(duration)
            .find(
              ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
            )
            .transition(duration);

          if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false; // eslint-disable-next-line

            slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
              if (eventTriggered) return;
              if (!swiper || swiper.destroyed) return; // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;

              eventTriggered = true;
              swiper.animating = false;
              var triggerEvents = ["webkitTransitionEnd", "transitionend"];

              for (var i = 0; i < triggerEvents.length; i += 1) {
                $wrapperEl.trigger(triggerEvents[i]);
              }
            });
          }
        },
      };
      exports.default = {
        name: "effect-flip",
        params: {
          flipEffect: {
            slideShadows: true,
            limitRotation: true,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            flipEffect: _extends({}, Flip),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (swiper.params.effect !== "flip") return;
            swiper.classNames.push(
              swiper.params.containerModifierClass + "flip"
            );
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: true,
            };
            (0, _utils.extend)(swiper.params, overwriteParams);
            (0, _utils.extend)(swiper.originalParams, overwriteParams);
          },
          setTranslate: function setTranslate(swiper) {
            if (swiper.params.effect !== "flip") return;
            swiper.flipEffect.setTranslate();
          },
          setTransition: function setTransition(swiper, duration) {
            if (swiper.params.effect !== "flip") return;
            swiper.flipEffect.setTransition(duration);
          },
        },
      };

      /***/
    },

    /***/ 219: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      var _utils = __webpack_require__(1);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Coverflow = {
        setTranslate: function setTranslate() {
          var swiper = this;
          var swiperWidth = swiper.width,
            swiperHeight = swiper.height,
            slides = swiper.slides,
            slidesSizesGrid = swiper.slidesSizesGrid;
          var params = swiper.params.coverflowEffect;
          var isHorizontal = swiper.isHorizontal();
          var transform = swiper.translate;
          var center = isHorizontal
            ? -transform + swiperWidth / 2
            : -transform + swiperHeight / 2;
          var rotate = isHorizontal ? params.rotate : -params.rotate;
          var translate = params.depth; // Each slide offset from center

          for (var i = 0, length = slides.length; i < length; i += 1) {
            var $slideEl = slides.eq(i);
            var slideSize = slidesSizesGrid[i];
            var slideOffset = $slideEl[0].swiperSlideOffset;
            var offsetMultiplier =
              ((center - slideOffset - slideSize / 2) / slideSize) *
              params.modifier;
            var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
            var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

            var translateZ = -translate * Math.abs(offsetMultiplier);
            var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

            if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
              stretch = (parseFloat(params.stretch) / 100) * slideSize;
            }

            var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
            var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
            var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

            if (Math.abs(translateX) < 0.001) translateX = 0;
            if (Math.abs(translateY) < 0.001) translateY = 0;
            if (Math.abs(translateZ) < 0.001) translateZ = 0;
            if (Math.abs(rotateY) < 0.001) rotateY = 0;
            if (Math.abs(rotateX) < 0.001) rotateX = 0;
            if (Math.abs(scale) < 0.001) scale = 0;
            var slideTransform =
              "translate3d(" +
              translateX +
              "px," +
              translateY +
              "px," +
              translateZ +
              "px)  rotateX(" +
              rotateX +
              "deg) rotateY(" +
              rotateY +
              "deg) scale(" +
              scale +
              ")";
            $slideEl.transform(slideTransform);
            $slideEl[0].style.zIndex =
              -Math.abs(Math.round(offsetMultiplier)) + 1;

            if (params.slideShadows) {
              // Set shadows
              var $shadowBeforeEl = isHorizontal
                ? $slideEl.find(".swiper-slide-shadow-left")
                : $slideEl.find(".swiper-slide-shadow-top");
              var $shadowAfterEl = isHorizontal
                ? $slideEl.find(".swiper-slide-shadow-right")
                : $slideEl.find(".swiper-slide-shadow-bottom");

              if ($shadowBeforeEl.length === 0) {
                $shadowBeforeEl = (0, _dom2.default)(
                  '<div class="swiper-slide-shadow-' +
                    (isHorizontal ? "left" : "top") +
                    '"></div>'
                );
                $slideEl.append($shadowBeforeEl);
              }

              if ($shadowAfterEl.length === 0) {
                $shadowAfterEl = (0, _dom2.default)(
                  '<div class="swiper-slide-shadow-' +
                    (isHorizontal ? "right" : "bottom") +
                    '"></div>'
                );
                $slideEl.append($shadowAfterEl);
              }

              if ($shadowBeforeEl.length)
                $shadowBeforeEl[0].style.opacity =
                  offsetMultiplier > 0 ? offsetMultiplier : 0;
              if ($shadowAfterEl.length)
                $shadowAfterEl[0].style.opacity =
                  -offsetMultiplier > 0 ? -offsetMultiplier : 0;
            }
          }
        },
        setTransition: function setTransition(duration) {
          var swiper = this;
          swiper.slides
            .transition(duration)
            .find(
              ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
            )
            .transition(duration);
        },
      };
      exports.default = {
        name: "effect-coverflow",
        params: {
          coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: true,
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            coverflowEffect: _extends({}, Coverflow),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.classNames.push(
              swiper.params.containerModifierClass + "coverflow"
            );
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
          },
          setTranslate: function setTranslate(swiper) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.coverflowEffect.setTranslate();
          },
          setTransition: function setTransition(swiper, duration) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.coverflowEffect.setTransition(duration);
          },
        },
      };

      /***/
    },

    /***/ 22: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };

      /***/
    },

    /***/ 220: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _utils = __webpack_require__(1);

      var _dom = __webpack_require__(4);

      var _dom2 = _interopRequireDefault(_dom);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _extends() {
        _extends =
          Object.assign ||
          function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
        return _extends.apply(this, arguments);
      }

      var Thumbs = {
        init: function init() {
          var swiper = this;
          var thumbsParams = swiper.params.thumbs;
          if (swiper.thumbs.initialized) return false;
          swiper.thumbs.initialized = true;
          var SwiperClass = swiper.constructor;

          if (thumbsParams.swiper instanceof SwiperClass) {
            swiper.thumbs.swiper = thumbsParams.swiper;
            (0, _utils.extend)(swiper.thumbs.swiper.originalParams, {
              watchSlidesProgress: true,
              slideToClickedSlide: false,
            });
            (0, _utils.extend)(swiper.thumbs.swiper.params, {
              watchSlidesProgress: true,
              slideToClickedSlide: false,
            });
          } else if ((0, _utils.isObject)(thumbsParams.swiper)) {
            swiper.thumbs.swiper = new SwiperClass(
              (0, _utils.extend)({}, thumbsParams.swiper, {
                watchSlidesVisibility: true,
                watchSlidesProgress: true,
                slideToClickedSlide: false,
              })
            );
            swiper.thumbs.swiperCreated = true;
          }

          swiper.thumbs.swiper.$el.addClass(
            swiper.params.thumbs.thumbsContainerClass
          );
          swiper.thumbs.swiper.on("tap", swiper.thumbs.onThumbClick);
          return true;
        },
        onThumbClick: function onThumbClick() {
          var swiper = this;
          var thumbsSwiper = swiper.thumbs.swiper;
          if (!thumbsSwiper) return;
          var clickedIndex = thumbsSwiper.clickedIndex;
          var clickedSlide = thumbsSwiper.clickedSlide;
          if (
            clickedSlide &&
            (0, _dom2.default)(clickedSlide).hasClass(
              swiper.params.thumbs.slideThumbActiveClass
            )
          )
            return;
          if (typeof clickedIndex === "undefined" || clickedIndex === null)
            return;
          var slideToIndex;

          if (thumbsSwiper.params.loop) {
            slideToIndex = parseInt(
              (0, _dom2.default)(thumbsSwiper.clickedSlide).attr(
                "data-swiper-slide-index"
              ),
              10
            );
          } else {
            slideToIndex = clickedIndex;
          }

          if (swiper.params.loop) {
            var currentIndex = swiper.activeIndex;

            if (
              swiper.slides
                .eq(currentIndex)
                .hasClass(swiper.params.slideDuplicateClass)
            ) {
              swiper.loopFix(); // eslint-disable-next-line

              swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
              currentIndex = swiper.activeIndex;
            }

            var prevIndex = swiper.slides
              .eq(currentIndex)
              .prevAll('[data-swiper-slide-index="' + slideToIndex + '"]')
              .eq(0)
              .index();
            var nextIndex = swiper.slides
              .eq(currentIndex)
              .nextAll('[data-swiper-slide-index="' + slideToIndex + '"]')
              .eq(0)
              .index();
            if (typeof prevIndex === "undefined") slideToIndex = nextIndex;
            else if (typeof nextIndex === "undefined") slideToIndex = prevIndex;
            else if (nextIndex - currentIndex < currentIndex - prevIndex)
              slideToIndex = nextIndex;
            else slideToIndex = prevIndex;
          }

          swiper.slideTo(slideToIndex);
        },
        update: function update(initial) {
          var swiper = this;
          var thumbsSwiper = swiper.thumbs.swiper;
          if (!thumbsSwiper) return;
          var slidesPerView =
            thumbsSwiper.params.slidesPerView === "auto"
              ? thumbsSwiper.slidesPerViewDynamic()
              : thumbsSwiper.params.slidesPerView;
          var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
          var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

          if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
            var currentThumbsIndex = thumbsSwiper.activeIndex;
            var newThumbsIndex;
            var direction;

            if (thumbsSwiper.params.loop) {
              if (
                thumbsSwiper.slides
                  .eq(currentThumbsIndex)
                  .hasClass(thumbsSwiper.params.slideDuplicateClass)
              ) {
                thumbsSwiper.loopFix(); // eslint-disable-next-line

                thumbsSwiper._clientLeft =
                  thumbsSwiper.$wrapperEl[0].clientLeft;
                currentThumbsIndex = thumbsSwiper.activeIndex;
              } // Find actual thumbs index to slide to

              var prevThumbsIndex = thumbsSwiper.slides
                .eq(currentThumbsIndex)
                .prevAll('[data-swiper-slide-index="' + swiper.realIndex + '"]')
                .eq(0)
                .index();
              var nextThumbsIndex = thumbsSwiper.slides
                .eq(currentThumbsIndex)
                .nextAll('[data-swiper-slide-index="' + swiper.realIndex + '"]')
                .eq(0)
                .index();

              if (typeof prevThumbsIndex === "undefined") {
                newThumbsIndex = nextThumbsIndex;
              } else if (typeof nextThumbsIndex === "undefined") {
                newThumbsIndex = prevThumbsIndex;
              } else if (
                nextThumbsIndex - currentThumbsIndex ===
                currentThumbsIndex - prevThumbsIndex
              ) {
                newThumbsIndex =
                  thumbsSwiper.params.slidesPerGroup > 1
                    ? nextThumbsIndex
                    : currentThumbsIndex;
              } else if (
                nextThumbsIndex - currentThumbsIndex <
                currentThumbsIndex - prevThumbsIndex
              ) {
                newThumbsIndex = nextThumbsIndex;
              } else {
                newThumbsIndex = prevThumbsIndex;
              }

              direction =
                swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
            } else {
              newThumbsIndex = swiper.realIndex;
              direction =
                newThumbsIndex > swiper.previousIndex ? "next" : "prev";
            }

            if (useOffset) {
              newThumbsIndex +=
                direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
            }

            if (
              thumbsSwiper.visibleSlidesIndexes &&
              thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0
            ) {
              if (thumbsSwiper.params.centeredSlides) {
                if (newThumbsIndex > currentThumbsIndex) {
                  newThumbsIndex =
                    newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                } else {
                  newThumbsIndex =
                    newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                }
              } else if (
                newThumbsIndex > currentThumbsIndex &&
                thumbsSwiper.params.slidesPerGroup === 1
              ) {
                // newThumbsIndex = newThumbsIndex - slidesPerView + 1;
              }

              thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
            }
          } // Activate thumbs

          var thumbsToActivate = 1;
          var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

          if (
            swiper.params.slidesPerView > 1 &&
            !swiper.params.centeredSlides
          ) {
            thumbsToActivate = swiper.params.slidesPerView;
          }

          if (!swiper.params.thumbs.multipleActiveThumbs) {
            thumbsToActivate = 1;
          }

          thumbsToActivate = Math.floor(thumbsToActivate);
          thumbsSwiper.slides.removeClass(thumbActiveClass);

          if (
            thumbsSwiper.params.loop ||
            (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)
          ) {
            for (var i = 0; i < thumbsToActivate; i += 1) {
              thumbsSwiper.$wrapperEl
                .children(
                  '[data-swiper-slide-index="' + (swiper.realIndex + i) + '"]'
                )
                .addClass(thumbActiveClass);
            }
          } else {
            for (var _i = 0; _i < thumbsToActivate; _i += 1) {
              thumbsSwiper.slides
                .eq(swiper.realIndex + _i)
                .addClass(thumbActiveClass);
            }
          }
        },
      };
      exports.default = {
        name: "thumbs",
        params: {
          thumbs: {
            swiper: null,
            multipleActiveThumbs: true,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-container-thumbs",
          },
        },
        create: function create() {
          var swiper = this;
          (0, _utils.bindModuleMethods)(swiper, {
            thumbs: _extends(
              {
                swiper: null,
                initialized: false,
              },
              Thumbs
            ),
          });
        },
        on: {
          beforeInit: function beforeInit(swiper) {
            var thumbs = swiper.params.thumbs;
            if (!thumbs || !thumbs.swiper) return;
            swiper.thumbs.init();
            swiper.thumbs.update(true);
          },
          slideChange: function slideChange(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
          },
          update: function update(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
          },
          resize: function resize(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
          },
          observerUpdate: function observerUpdate(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
          },
          setTransition: function setTransition(swiper, duration) {
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) return;
            thumbsSwiper.setTransition(duration);
          },
          beforeDestroy: function beforeDestroy(swiper) {
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) return;

            if (swiper.thumbs.swiperCreated && thumbsSwiper) {
              thumbsSwiper.destroy();
            }
          },
        },
      };

      /***/
    },

    /***/ 222: /***/ function (module, exports) {
      // removed by extract-text-webpack-plugin
      /***/
    },

    /***/ 23: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      function encode(val) {
        return encodeURIComponent(val)
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",")
          .replace(/%20/g, "+")
          .replace(/%5B/gi, "[")
          .replace(/%5D/gi, "]");
      }

      /**
       * Build a URL by appending params to the end
       *
       * @param {string} url The base of the url (e.g., http://www.google.com)
       * @param {object} [params] The params to be appended
       * @returns {string} The formatted url
       */
      module.exports = function buildURL(url, params, paramsSerializer) {
        /*eslint no-param-reassign:0*/
        if (!params) {
          return url;
        }

        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];

          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }

            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }

            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });

          serializedParams = parts.join("&");
        }

        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }

          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }

        return url;
      };

      /***/
    },

    /***/ 230: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });
      var parallaxElements = [];
      var hasScrollEventListener = false;

      function init() {
        var domElements = document.querySelectorAll(".b-parallax-element");

        if (domElements.length) {
          for (var i = 0; i < domElements.length; i++) {
            var domElement = domElements[i];

            parallaxElements.push({
              domElement: domElement,
              speed: parseFloat(domElement.dataset.speed) || 0,
            });
          }

          var resizeTimeout = void 0;

          window.addEventListener(
            "resize",
            function () {
              clearTimeout(resizeTimeout);
              resizeTimeout = setTimeout(onResize, 250);
            },
            false
          );

          onResize();
          // window.requestAnimationFrame(onResize);
        }
      }

      function getElementOffsetTop(element) {
        var offsetTop = 0;

        while (element.tagName !== "BODY") {
          offsetTop += element.offsetTop;
          element = element.parentNode;
        }

        return offsetTop;
      }

      function onResize() {
        // window.requestAnimationFrame(onResize);

        if (window.matchMedia("(min-width: 1025px)").matches) {
          parallaxElements.forEach(function (parallaxElement) {
            parallaxElement.offsetTop = getElementOffsetTop(
              parallaxElement.domElement
            );
          });

          if (!hasScrollEventListener) {
            hasScrollEventListener = true;
            window.addEventListener(
              "scroll",
              function () {
                window.requestAnimationFrame(onScroll);
              },
              false
            );
            onScroll();
            // window.requestAnimationFrame(onScroll);
          }
        } else {
          if (hasScrollEventListener) {
            hasScrollEventListener = false;
            window.removeEventListener("scroll", onScroll, false);
          }
        }
      }

      function onScroll() {
        var windowScrollY = window.innerHeight / 2 + window.scrollY;

        parallaxElements.forEach(function (parallaxElement) {
          var elementTranslateY = parallaxElement.offsetTop - windowScrollY;
          parallaxElement.domElement.style.transform =
            "translateY(" + elementTranslateY * parallaxElement.speed + "px)";
        });
      }

      init();

      // window.requestAnimationFrame(init);

      exports.init = init;

      /***/
    },

    /***/ 24: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false,
      };

      /***/
    },

    /***/ 25: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (Buffer) {
        var _typeof =
          typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
            ? function (obj) {
                return typeof obj;
              }
            : function (obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };

        var utils = __webpack_require__(0);

        /**
         * Convert a data object to FormData
         * @param {Object} obj
         * @param {?Object} [formData]
         * @returns {Object}
         **/

        function toFormData(obj, formData) {
          // eslint-disable-next-line no-param-reassign
          formData = formData || new FormData();

          var stack = [];

          function convertValue(value) {
            if (value === null) return "";

            if (utils.isDate(value)) {
              return value.toISOString();
            }

            if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
              return typeof Blob === "function"
                ? new Blob([value])
                : Buffer.from(value);
            }

            return value;
          }

          function build(data, parentKey) {
            if (utils.isPlainObject(data) || utils.isArray(data)) {
              if (stack.indexOf(data) !== -1) {
                throw Error("Circular reference detected in " + parentKey);
              }

              stack.push(data);

              utils.forEach(data, function each(value, key) {
                if (utils.isUndefined(value)) return;
                var fullKey = parentKey ? parentKey + "." + key : key;
                var arr;

                if (
                  value &&
                  !parentKey &&
                  (typeof value === "undefined"
                    ? "undefined"
                    : _typeof(value)) === "object"
                ) {
                  if (utils.endsWith(key, "{}")) {
                    // eslint-disable-next-line no-param-reassign
                    value = JSON.stringify(value);
                  } else if (
                    utils.endsWith(key, "[]") &&
                    (arr = utils.toArray(value))
                  ) {
                    // eslint-disable-next-line func-names
                    arr.forEach(function (el) {
                      !utils.isUndefined(el) &&
                        formData.append(fullKey, convertValue(el));
                    });
                    return;
                  }
                }

                build(value, fullKey);
              });

              stack.pop();
            } else {
              formData.append(parentKey, convertValue(data));
            }
          }

          build(obj);

          return formData;
        }

        module.exports = toFormData;
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(57).Buffer);

      /***/
    },

    /***/ 250: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

      var _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };

      var _typeof2 =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      typeof navigator !== "undefined" &&
        (function (global, factory) {
          (false ? "undefined" : _typeof2(exports)) === "object" &&
          typeof module !== "undefined"
            ? (module.exports = factory())
            : true
            ? !((__WEBPACK_AMD_DEFINE_FACTORY__ = factory),
              (__WEBPACK_AMD_DEFINE_RESULT__ =
                typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                  ? __WEBPACK_AMD_DEFINE_FACTORY__.call(
                      exports,
                      __webpack_require__,
                      exports,
                      module
                    )
                  : __WEBPACK_AMD_DEFINE_FACTORY__),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
            : ((global =
                typeof globalThis !== "undefined"
                  ? globalThis
                  : global || self),
              (global.lottie = factory()));
        })(undefined, function () {
          "use strict";

          var svgNS = "http://www.w3.org/2000/svg";
          var locationHref = "";
          var _useWebWorker = false;
          var initialDefaultFrame = -999999;

          var setWebWorker = function setWebWorker(flag) {
            _useWebWorker = !!flag;
          };

          var getWebWorker = function getWebWorker() {
            return _useWebWorker;
          };

          var setLocationHref = function setLocationHref(value) {
            locationHref = value;
          };

          var getLocationHref = function getLocationHref() {
            return locationHref;
          };

          function createTag(type) {
            // return {appendChild:function(){},setAttribute:function(){},style:{}}
            return document.createElement(type);
          }

          function extendPrototype(sources, destination) {
            var i;
            var len = sources.length;
            var sourcePrototype;

            for (i = 0; i < len; i += 1) {
              sourcePrototype = sources[i].prototype;

              for (var attr in sourcePrototype) {
                if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr))
                  destination.prototype[attr] = sourcePrototype[attr];
              }
            }
          }

          function getDescriptor(object, prop) {
            return Object.getOwnPropertyDescriptor(object, prop);
          }

          function createProxyFunction(prototype) {
            function ProxyFunction() {}

            ProxyFunction.prototype = prototype;
            return ProxyFunction;
          }

          // import Howl from '../../3rd_party/howler';
          var audioControllerFactory = (function () {
            function AudioController(audioFactory) {
              this.audios = [];
              this.audioFactory = audioFactory;
              this._volume = 1;
              this._isMuted = false;
            }

            AudioController.prototype = {
              addAudio: function addAudio(audio) {
                this.audios.push(audio);
              },
              pause: function pause() {
                var i;
                var len = this.audios.length;

                for (i = 0; i < len; i += 1) {
                  this.audios[i].pause();
                }
              },
              resume: function resume() {
                var i;
                var len = this.audios.length;

                for (i = 0; i < len; i += 1) {
                  this.audios[i].resume();
                }
              },
              setRate: function setRate(rateValue) {
                var i;
                var len = this.audios.length;

                for (i = 0; i < len; i += 1) {
                  this.audios[i].setRate(rateValue);
                }
              },
              createAudio: function createAudio(assetPath) {
                if (this.audioFactory) {
                  return this.audioFactory(assetPath);
                }

                if (window.Howl) {
                  return new window.Howl({
                    src: [assetPath],
                  });
                }

                return {
                  isPlaying: false,
                  play: function play() {
                    this.isPlaying = true;
                  },
                  seek: function seek() {
                    this.isPlaying = false;
                  },
                  playing: function playing() {},
                  rate: function rate() {},
                  setVolume: function setVolume() {},
                };
              },
              setAudioFactory: function setAudioFactory(audioFactory) {
                this.audioFactory = audioFactory;
              },
              setVolume: function setVolume(value) {
                this._volume = value;

                this._updateVolume();
              },
              mute: function mute() {
                this._isMuted = true;

                this._updateVolume();
              },
              unmute: function unmute() {
                this._isMuted = false;

                this._updateVolume();
              },
              getVolume: function getVolume() {
                return this._volume;
              },
              _updateVolume: function _updateVolume() {
                var i;
                var len = this.audios.length;

                for (i = 0; i < len; i += 1) {
                  this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
                }
              },
            };
            return function () {
              return new AudioController();
            };
          })();

          var createTypedArray = (function () {
            function createRegularArray(type, len) {
              var i = 0;
              var arr = [];
              var value;

              switch (type) {
                case "int16":
                case "uint8c":
                  value = 1;
                  break;

                default:
                  value = 1.1;
                  break;
              }

              for (i = 0; i < len; i += 1) {
                arr.push(value);
              }

              return arr;
            }

            function createTypedArrayFactory(type, len) {
              if (type === "float32") {
                return new Float32Array(len);
              }

              if (type === "int16") {
                return new Int16Array(len);
              }

              if (type === "uint8c") {
                return new Uint8ClampedArray(len);
              }

              return createRegularArray(type, len);
            }

            if (
              typeof Uint8ClampedArray === "function" &&
              typeof Float32Array === "function"
            ) {
              return createTypedArrayFactory;
            }

            return createRegularArray;
          })();

          function createSizedArray(len) {
            return Array.apply(null, {
              length: len,
            });
          }

          function _typeof$6(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof$6 = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof$6 = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof$6(obj);
          }
          var subframeEnabled = true;
          var expressionsPlugin = null;
          var idPrefix = "";
          var isSafari = /^((?!chrome|android).)*safari/i.test(
            navigator.userAgent
          );
          var _shouldRoundValues = false;
          var bmPow = Math.pow;
          var bmSqrt = Math.sqrt;
          var bmFloor = Math.floor;
          var bmMax = Math.max;
          var bmMin = Math.min;
          var BMMath = {};

          (function () {
            var propertyNames = [
              "abs",
              "acos",
              "acosh",
              "asin",
              "asinh",
              "atan",
              "atanh",
              "atan2",
              "ceil",
              "cbrt",
              "expm1",
              "clz32",
              "cos",
              "cosh",
              "exp",
              "floor",
              "fround",
              "hypot",
              "imul",
              "log",
              "log1p",
              "log2",
              "log10",
              "max",
              "min",
              "pow",
              "random",
              "round",
              "sign",
              "sin",
              "sinh",
              "sqrt",
              "tan",
              "tanh",
              "trunc",
              "E",
              "LN10",
              "LN2",
              "LOG10E",
              "LOG2E",
              "PI",
              "SQRT1_2",
              "SQRT2",
            ];
            var i;
            var len = propertyNames.length;

            for (i = 0; i < len; i += 1) {
              BMMath[propertyNames[i]] = Math[propertyNames[i]];
            }
          })();

          function ProjectInterface$1() {
            return {};
          }

          BMMath.random = Math.random;

          BMMath.abs = function (val) {
            var tOfVal = _typeof$6(val);

            if (tOfVal === "object" && val.length) {
              var absArr = createSizedArray(val.length);
              var i;
              var len = val.length;

              for (i = 0; i < len; i += 1) {
                absArr[i] = Math.abs(val[i]);
              }

              return absArr;
            }

            return Math.abs(val);
          };

          var defaultCurveSegments = 150;
          var degToRads = Math.PI / 180;
          var roundCorner = 0.5519;

          function roundValues(flag) {
            _shouldRoundValues = !!flag;
          }

          function bmRnd(value) {
            if (_shouldRoundValues) {
              return Math.round(value);
            }

            return value;
          }

          function styleDiv(element) {
            element.style.position = "absolute";
            element.style.top = 0;
            element.style.left = 0;
            element.style.display = "block";
            element.style.transformOrigin = "0 0";
            element.style.webkitTransformOrigin = "0 0";
            element.style.backfaceVisibility = "visible";
            element.style.webkitBackfaceVisibility = "visible";
            element.style.transformStyle = "preserve-3d";
            element.style.webkitTransformStyle = "preserve-3d";
            element.style.mozTransformStyle = "preserve-3d";
          }

          function BMEnterFrameEvent(
            type,
            currentTime,
            totalTime,
            frameMultiplier
          ) {
            this.type = type;
            this.currentTime = currentTime;
            this.totalTime = totalTime;
            this.direction = frameMultiplier < 0 ? -1 : 1;
          }

          function BMCompleteEvent(type, frameMultiplier) {
            this.type = type;
            this.direction = frameMultiplier < 0 ? -1 : 1;
          }

          function BMCompleteLoopEvent(
            type,
            totalLoops,
            currentLoop,
            frameMultiplier
          ) {
            this.type = type;
            this.currentLoop = currentLoop;
            this.totalLoops = totalLoops;
            this.direction = frameMultiplier < 0 ? -1 : 1;
          }

          function BMSegmentStartEvent(type, firstFrame, totalFrames) {
            this.type = type;
            this.firstFrame = firstFrame;
            this.totalFrames = totalFrames;
          }

          function BMDestroyEvent(type, target) {
            this.type = type;
            this.target = target;
          }

          function BMRenderFrameErrorEvent(nativeError, currentTime) {
            this.type = "renderFrameError";
            this.nativeError = nativeError;
            this.currentTime = currentTime;
          }

          function BMConfigErrorEvent(nativeError) {
            this.type = "configError";
            this.nativeError = nativeError;
          }

          function BMAnimationConfigErrorEvent(type, nativeError) {
            this.type = type;
            this.nativeError = nativeError;
          }

          var createElementID = (function () {
            var _count = 0;
            return function createID() {
              _count += 1;
              return idPrefix + "__lottie_element_" + _count;
            };
          })();

          function HSVtoRGB(h, s, v) {
            var r;
            var g;
            var b;
            var i;
            var f;
            var p;
            var q;
            var t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);

            switch (i % 6) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;

              case 1:
                r = q;
                g = v;
                b = p;
                break;

              case 2:
                r = p;
                g = v;
                b = t;
                break;

              case 3:
                r = p;
                g = q;
                b = v;
                break;

              case 4:
                r = t;
                g = p;
                b = v;
                break;

              case 5:
                r = v;
                g = p;
                b = q;
                break;

              default:
                break;
            }

            return [r, g, b];
          }

          function RGBtoHSV(r, g, b) {
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var d = max - min;
            var h;
            var s = max === 0 ? 0 : d / max;
            var v = max / 255;

            switch (max) {
              case min:
                h = 0;
                break;

              case r:
                h = g - b + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;

              case g:
                h = b - r + d * 2;
                h /= 6 * d;
                break;

              case b:
                h = r - g + d * 4;
                h /= 6 * d;
                break;

              default:
                break;
            }

            return [h, s, v];
          }

          function addSaturationToRGB(color, offset) {
            var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
            hsv[1] += offset;

            if (hsv[1] > 1) {
              hsv[1] = 1;
            } else if (hsv[1] <= 0) {
              hsv[1] = 0;
            }

            return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
          }

          function addBrightnessToRGB(color, offset) {
            var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
            hsv[2] += offset;

            if (hsv[2] > 1) {
              hsv[2] = 1;
            } else if (hsv[2] < 0) {
              hsv[2] = 0;
            }

            return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
          }

          function addHueToRGB(color, offset) {
            var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
            hsv[0] += offset / 360;

            if (hsv[0] > 1) {
              hsv[0] -= 1;
            } else if (hsv[0] < 0) {
              hsv[0] += 1;
            }

            return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
          }

          var rgbToHex = (function () {
            var colorMap = [];
            var i;
            var hex;

            for (i = 0; i < 256; i += 1) {
              hex = i.toString(16);
              colorMap[i] = hex.length === 1 ? "0" + hex : hex;
            }

            return function (r, g, b) {
              if (r < 0) {
                r = 0;
              }

              if (g < 0) {
                g = 0;
              }

              if (b < 0) {
                b = 0;
              }

              return "#" + colorMap[r] + colorMap[g] + colorMap[b];
            };
          })();

          var setSubframeEnabled = function setSubframeEnabled(flag) {
            subframeEnabled = !!flag;
          };

          var getSubframeEnabled = function getSubframeEnabled() {
            return subframeEnabled;
          };

          var setExpressionsPlugin = function setExpressionsPlugin(value) {
            expressionsPlugin = value;
          };

          var getExpressionsPlugin = function getExpressionsPlugin() {
            return expressionsPlugin;
          };

          var setDefaultCurveSegments = function setDefaultCurveSegments(
            value
          ) {
            defaultCurveSegments = value;
          };

          var getDefaultCurveSegments = function getDefaultCurveSegments() {
            return defaultCurveSegments;
          };

          var setIdPrefix = function setIdPrefix(value) {
            idPrefix = value;
          };

          var getIdPrefix = function getIdPrefix() {
            return idPrefix;
          };

          function createNS(type) {
            // return {appendChild:function(){},setAttribute:function(){},style:{}}
            return document.createElementNS(svgNS, type);
          }

          function _typeof$5(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof$5 = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof$5 = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof$5(obj);
          }

          var dataManager = (function () {
            var _counterId = 1;
            var processes = [];
            var workerFn;
            var workerInstance;
            var workerProxy = {
              onmessage: function onmessage() {},
              postMessage: function postMessage(path) {
                workerFn({
                  data: path,
                });
              },
            };
            var _workerSelf = {
              postMessage: function postMessage(data) {
                workerProxy.onmessage({
                  data: data,
                });
              },
            };

            function createWorker(fn) {
              if (window.Worker && window.Blob && getWebWorker()) {
                var blob = new Blob(
                  ["var _workerSelf = self; self.onmessage = ", fn.toString()],
                  {
                    type: "text/javascript",
                  }
                ); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });

                var url = URL.createObjectURL(blob);
                return new Worker(url);
              }

              workerFn = fn;
              return workerProxy;
            }

            function setupWorker() {
              if (!workerInstance) {
                workerInstance = createWorker(function workerStart(e) {
                  function dataFunctionManager() {
                    function completeLayers(layers, comps) {
                      var layerData;
                      var i;
                      var len = layers.length;
                      var j;
                      var jLen;
                      var k;
                      var kLen;

                      for (i = 0; i < len; i += 1) {
                        layerData = layers[i];

                        if ("ks" in layerData && !layerData.completed) {
                          layerData.completed = true;

                          if (layerData.tt) {
                            layers[i - 1].td = layerData.tt;
                          }

                          if (layerData.hasMask) {
                            var maskProps = layerData.masksProperties;
                            jLen = maskProps.length;

                            for (j = 0; j < jLen; j += 1) {
                              if (maskProps[j].pt.k.i) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k);
                              } else {
                                kLen = maskProps[j].pt.k.length;

                                for (k = 0; k < kLen; k += 1) {
                                  if (maskProps[j].pt.k[k].s) {
                                    convertPathsToAbsoluteValues(
                                      maskProps[j].pt.k[k].s[0]
                                    );
                                  }

                                  if (maskProps[j].pt.k[k].e) {
                                    convertPathsToAbsoluteValues(
                                      maskProps[j].pt.k[k].e[0]
                                    );
                                  }
                                }
                              }
                            }
                          }

                          if (layerData.ty === 0) {
                            layerData.layers = findCompLayers(
                              layerData.refId,
                              comps
                            );
                            completeLayers(layerData.layers, comps);
                          } else if (layerData.ty === 4) {
                            completeShapes(layerData.shapes);
                          } else if (layerData.ty === 5) {
                            completeText(layerData);
                          }
                        }
                      }
                    }

                    function completeChars(chars, assets) {
                      if (chars) {
                        var i = 0;
                        var len = chars.length;

                        for (i = 0; i < len; i += 1) {
                          if (chars[i].t === 1) {
                            // var compData = findComp(chars[i].data.refId, assets);
                            chars[i].data.layers = findCompLayers(
                              chars[i].data.refId,
                              assets
                            ); // chars[i].data.ip = 0;
                            // chars[i].data.op = 99999;
                            // chars[i].data.st = 0;
                            // chars[i].data.sr = 1;
                            // chars[i].w = compData.w;
                            // chars[i].data.ks = {
                            //   a: { k: [0, 0, 0], a: 0 },
                            //   p: { k: [0, -compData.h, 0], a: 0 },
                            //   r: { k: 0, a: 0 },
                            //   s: { k: [100, 100], a: 0 },
                            //   o: { k: 100, a: 0 },
                            // };

                            completeLayers(chars[i].data.layers, assets);
                          }
                        }
                      }
                    }

                    function findComp(id, comps) {
                      var i = 0;
                      var len = comps.length;

                      while (i < len) {
                        if (comps[i].id === id) {
                          return comps[i];
                        }

                        i += 1;
                      }

                      return null;
                    }

                    function findCompLayers(id, comps) {
                      var comp = findComp(id, comps);

                      if (comp) {
                        if (!comp.layers.__used) {
                          comp.layers.__used = true;
                          return comp.layers;
                        }

                        return JSON.parse(JSON.stringify(comp.layers));
                      }

                      return null;
                    }

                    function completeShapes(arr) {
                      var i;
                      var len = arr.length;
                      var j;
                      var jLen;

                      for (i = len - 1; i >= 0; i -= 1) {
                        if (arr[i].ty === "sh") {
                          if (arr[i].ks.k.i) {
                            convertPathsToAbsoluteValues(arr[i].ks.k);
                          } else {
                            jLen = arr[i].ks.k.length;

                            for (j = 0; j < jLen; j += 1) {
                              if (arr[i].ks.k[j].s) {
                                convertPathsToAbsoluteValues(
                                  arr[i].ks.k[j].s[0]
                                );
                              }

                              if (arr[i].ks.k[j].e) {
                                convertPathsToAbsoluteValues(
                                  arr[i].ks.k[j].e[0]
                                );
                              }
                            }
                          }
                        } else if (arr[i].ty === "gr") {
                          completeShapes(arr[i].it);
                        }
                      }
                    }

                    function convertPathsToAbsoluteValues(path) {
                      var i;
                      var len = path.i.length;

                      for (i = 0; i < len; i += 1) {
                        path.i[i][0] += path.v[i][0];
                        path.i[i][1] += path.v[i][1];
                        path.o[i][0] += path.v[i][0];
                        path.o[i][1] += path.v[i][1];
                      }
                    }

                    function checkVersion(minimum, animVersionString) {
                      var animVersion = animVersionString
                        ? animVersionString.split(".")
                        : [100, 100, 100];

                      if (minimum[0] > animVersion[0]) {
                        return true;
                      }

                      if (animVersion[0] > minimum[0]) {
                        return false;
                      }

                      if (minimum[1] > animVersion[1]) {
                        return true;
                      }

                      if (animVersion[1] > minimum[1]) {
                        return false;
                      }

                      if (minimum[2] > animVersion[2]) {
                        return true;
                      }

                      if (animVersion[2] > minimum[2]) {
                        return false;
                      }

                      return null;
                    }

                    var checkText = (function () {
                      var minimumVersion = [4, 4, 14];

                      function updateTextLayer(textLayer) {
                        var documentData = textLayer.t.d;
                        textLayer.t.d = {
                          k: [
                            {
                              s: documentData,
                              t: 0,
                            },
                          ],
                        };
                      }

                      function iterateLayers(layers) {
                        var i;
                        var len = layers.length;

                        for (i = 0; i < len; i += 1) {
                          if (layers[i].ty === 5) {
                            updateTextLayer(layers[i]);
                          }
                        }
                      }

                      return function (animationData) {
                        if (checkVersion(minimumVersion, animationData.v)) {
                          iterateLayers(animationData.layers);

                          if (animationData.assets) {
                            var i;
                            var len = animationData.assets.length;

                            for (i = 0; i < len; i += 1) {
                              if (animationData.assets[i].layers) {
                                iterateLayers(animationData.assets[i].layers);
                              }
                            }
                          }
                        }
                      };
                    })();

                    var checkChars = (function () {
                      var minimumVersion = [4, 7, 99];
                      return function (animationData) {
                        if (
                          animationData.chars &&
                          !checkVersion(minimumVersion, animationData.v)
                        ) {
                          var i;
                          var len = animationData.chars.length;

                          for (i = 0; i < len; i += 1) {
                            var charData = animationData.chars[i];

                            if (charData.data && charData.data.shapes) {
                              completeShapes(charData.data.shapes);
                              charData.data.ip = 0;
                              charData.data.op = 99999;
                              charData.data.st = 0;
                              charData.data.sr = 1;
                              charData.data.ks = {
                                p: {
                                  k: [0, 0],
                                  a: 0,
                                },
                                s: {
                                  k: [100, 100],
                                  a: 0,
                                },
                                a: {
                                  k: [0, 0],
                                  a: 0,
                                },
                                r: {
                                  k: 0,
                                  a: 0,
                                },
                                o: {
                                  k: 100,
                                  a: 0,
                                },
                              };

                              if (!animationData.chars[i].t) {
                                charData.data.shapes.push({
                                  ty: "no",
                                });
                                charData.data.shapes[0].it.push({
                                  p: {
                                    k: [0, 0],
                                    a: 0,
                                  },
                                  s: {
                                    k: [100, 100],
                                    a: 0,
                                  },
                                  a: {
                                    k: [0, 0],
                                    a: 0,
                                  },
                                  r: {
                                    k: 0,
                                    a: 0,
                                  },
                                  o: {
                                    k: 100,
                                    a: 0,
                                  },
                                  sk: {
                                    k: 0,
                                    a: 0,
                                  },
                                  sa: {
                                    k: 0,
                                    a: 0,
                                  },
                                  ty: "tr",
                                });
                              }
                            }
                          }
                        }
                      };
                    })();

                    var checkPathProperties = (function () {
                      var minimumVersion = [5, 7, 15];

                      function updateTextLayer(textLayer) {
                        var pathData = textLayer.t.p;

                        if (typeof pathData.a === "number") {
                          pathData.a = {
                            a: 0,
                            k: pathData.a,
                          };
                        }

                        if (typeof pathData.p === "number") {
                          pathData.p = {
                            a: 0,
                            k: pathData.p,
                          };
                        }

                        if (typeof pathData.r === "number") {
                          pathData.r = {
                            a: 0,
                            k: pathData.r,
                          };
                        }
                      }

                      function iterateLayers(layers) {
                        var i;
                        var len = layers.length;

                        for (i = 0; i < len; i += 1) {
                          if (layers[i].ty === 5) {
                            updateTextLayer(layers[i]);
                          }
                        }
                      }

                      return function (animationData) {
                        if (checkVersion(minimumVersion, animationData.v)) {
                          iterateLayers(animationData.layers);

                          if (animationData.assets) {
                            var i;
                            var len = animationData.assets.length;

                            for (i = 0; i < len; i += 1) {
                              if (animationData.assets[i].layers) {
                                iterateLayers(animationData.assets[i].layers);
                              }
                            }
                          }
                        }
                      };
                    })();

                    var checkColors = (function () {
                      var minimumVersion = [4, 1, 9];

                      function iterateShapes(shapes) {
                        var i;
                        var len = shapes.length;
                        var j;
                        var jLen;

                        for (i = 0; i < len; i += 1) {
                          if (shapes[i].ty === "gr") {
                            iterateShapes(shapes[i].it);
                          } else if (
                            shapes[i].ty === "fl" ||
                            shapes[i].ty === "st"
                          ) {
                            if (shapes[i].c.k && shapes[i].c.k[0].i) {
                              jLen = shapes[i].c.k.length;

                              for (j = 0; j < jLen; j += 1) {
                                if (shapes[i].c.k[j].s) {
                                  shapes[i].c.k[j].s[0] /= 255;
                                  shapes[i].c.k[j].s[1] /= 255;
                                  shapes[i].c.k[j].s[2] /= 255;
                                  shapes[i].c.k[j].s[3] /= 255;
                                }

                                if (shapes[i].c.k[j].e) {
                                  shapes[i].c.k[j].e[0] /= 255;
                                  shapes[i].c.k[j].e[1] /= 255;
                                  shapes[i].c.k[j].e[2] /= 255;
                                  shapes[i].c.k[j].e[3] /= 255;
                                }
                              }
                            } else {
                              shapes[i].c.k[0] /= 255;
                              shapes[i].c.k[1] /= 255;
                              shapes[i].c.k[2] /= 255;
                              shapes[i].c.k[3] /= 255;
                            }
                          }
                        }
                      }

                      function iterateLayers(layers) {
                        var i;
                        var len = layers.length;

                        for (i = 0; i < len; i += 1) {
                          if (layers[i].ty === 4) {
                            iterateShapes(layers[i].shapes);
                          }
                        }
                      }

                      return function (animationData) {
                        if (checkVersion(minimumVersion, animationData.v)) {
                          iterateLayers(animationData.layers);

                          if (animationData.assets) {
                            var i;
                            var len = animationData.assets.length;

                            for (i = 0; i < len; i += 1) {
                              if (animationData.assets[i].layers) {
                                iterateLayers(animationData.assets[i].layers);
                              }
                            }
                          }
                        }
                      };
                    })();

                    var checkShapes = (function () {
                      var minimumVersion = [4, 4, 18];

                      function completeClosingShapes(arr) {
                        var i;
                        var len = arr.length;
                        var j;
                        var jLen;

                        for (i = len - 1; i >= 0; i -= 1) {
                          if (arr[i].ty === "sh") {
                            if (arr[i].ks.k.i) {
                              arr[i].ks.k.c = arr[i].closed;
                            } else {
                              jLen = arr[i].ks.k.length;

                              for (j = 0; j < jLen; j += 1) {
                                if (arr[i].ks.k[j].s) {
                                  arr[i].ks.k[j].s[0].c = arr[i].closed;
                                }

                                if (arr[i].ks.k[j].e) {
                                  arr[i].ks.k[j].e[0].c = arr[i].closed;
                                }
                              }
                            }
                          } else if (arr[i].ty === "gr") {
                            completeClosingShapes(arr[i].it);
                          }
                        }
                      }

                      function iterateLayers(layers) {
                        var layerData;
                        var i;
                        var len = layers.length;
                        var j;
                        var jLen;
                        var k;
                        var kLen;

                        for (i = 0; i < len; i += 1) {
                          layerData = layers[i];

                          if (layerData.hasMask) {
                            var maskProps = layerData.masksProperties;
                            jLen = maskProps.length;

                            for (j = 0; j < jLen; j += 1) {
                              if (maskProps[j].pt.k.i) {
                                maskProps[j].pt.k.c = maskProps[j].cl;
                              } else {
                                kLen = maskProps[j].pt.k.length;

                                for (k = 0; k < kLen; k += 1) {
                                  if (maskProps[j].pt.k[k].s) {
                                    maskProps[j].pt.k[k].s[0].c =
                                      maskProps[j].cl;
                                  }

                                  if (maskProps[j].pt.k[k].e) {
                                    maskProps[j].pt.k[k].e[0].c =
                                      maskProps[j].cl;
                                  }
                                }
                              }
                            }
                          }

                          if (layerData.ty === 4) {
                            completeClosingShapes(layerData.shapes);
                          }
                        }
                      }

                      return function (animationData) {
                        if (checkVersion(minimumVersion, animationData.v)) {
                          iterateLayers(animationData.layers);

                          if (animationData.assets) {
                            var i;
                            var len = animationData.assets.length;

                            for (i = 0; i < len; i += 1) {
                              if (animationData.assets[i].layers) {
                                iterateLayers(animationData.assets[i].layers);
                              }
                            }
                          }
                        }
                      };
                    })();

                    function completeData(animationData) {
                      if (animationData.__complete) {
                        return;
                      }

                      checkColors(animationData);
                      checkText(animationData);
                      checkChars(animationData);
                      checkPathProperties(animationData);
                      checkShapes(animationData);
                      completeLayers(
                        animationData.layers,
                        animationData.assets
                      );
                      completeChars(animationData.chars, animationData.assets);
                      animationData.__complete = true;
                    }

                    function completeText(data) {
                      if (data.t.a.length === 0 && !("m" in data.t.p)) {
                        // data.singleShape = true;
                      }
                    }

                    var moduleOb = {};
                    moduleOb.completeData = completeData;
                    moduleOb.checkColors = checkColors;
                    moduleOb.checkChars = checkChars;
                    moduleOb.checkPathProperties = checkPathProperties;
                    moduleOb.checkShapes = checkShapes;
                    moduleOb.completeLayers = completeLayers;
                    return moduleOb;
                  }

                  if (!_workerSelf.dataManager) {
                    _workerSelf.dataManager = dataFunctionManager();
                  }

                  if (!_workerSelf.assetLoader) {
                    _workerSelf.assetLoader = (function () {
                      function formatResponse(xhr) {
                        // using typeof doubles the time of execution of this method,
                        // so if available, it's better to use the header to validate the type
                        var contentTypeHeader =
                          xhr.getResponseHeader("content-type");

                        if (
                          contentTypeHeader &&
                          xhr.responseType === "json" &&
                          contentTypeHeader.indexOf("json") !== -1
                        ) {
                          return xhr.response;
                        }

                        if (
                          xhr.response &&
                          _typeof$5(xhr.response) === "object"
                        ) {
                          return xhr.response;
                        }

                        if (xhr.response && typeof xhr.response === "string") {
                          return JSON.parse(xhr.response);
                        }

                        if (xhr.responseText) {
                          return JSON.parse(xhr.responseText);
                        }

                        return null;
                      }

                      function loadAsset(
                        path,
                        fullPath,
                        callback,
                        errorCallback
                      ) {
                        var response;
                        var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.

                        try {
                          // This crashes on Android WebView prior to KitKat
                          xhr.responseType = "json";
                        } catch (err) {} // eslint-disable-line no-empty

                        xhr.onreadystatechange = function () {
                          if (xhr.readyState === 4) {
                            if (xhr.status === 200) {
                              response = formatResponse(xhr);
                              callback(response);
                            } else {
                              try {
                                response = formatResponse(xhr);
                                callback(response);
                              } catch (err) {
                                if (errorCallback) {
                                  errorCallback(err);
                                }
                              }
                            }
                          }
                        };

                        try {
                          xhr.open("GET", path, true);
                        } catch (error) {
                          xhr.open("GET", fullPath + "/" + path, true);
                        }

                        xhr.send();
                      }

                      return {
                        load: loadAsset,
                      };
                    })();
                  }

                  if (e.data.type === "loadAnimation") {
                    _workerSelf.assetLoader.load(
                      e.data.path,
                      e.data.fullPath,
                      function (data) {
                        _workerSelf.dataManager.completeData(data);

                        _workerSelf.postMessage({
                          id: e.data.id,
                          payload: data,
                          status: "success",
                        });
                      },
                      function () {
                        _workerSelf.postMessage({
                          id: e.data.id,
                          status: "error",
                        });
                      }
                    );
                  } else if (e.data.type === "complete") {
                    var animation = e.data.animation;

                    _workerSelf.dataManager.completeData(animation);

                    _workerSelf.postMessage({
                      id: e.data.id,
                      payload: animation,
                      status: "success",
                    });
                  } else if (e.data.type === "loadData") {
                    _workerSelf.assetLoader.load(
                      e.data.path,
                      e.data.fullPath,
                      function (data) {
                        _workerSelf.postMessage({
                          id: e.data.id,
                          payload: data,
                          status: "success",
                        });
                      },
                      function () {
                        _workerSelf.postMessage({
                          id: e.data.id,
                          status: "error",
                        });
                      }
                    );
                  }
                });

                workerInstance.onmessage = function (event) {
                  var data = event.data;
                  var id = data.id;
                  var process = processes[id];
                  processes[id] = null;

                  if (data.status === "success") {
                    process.onComplete(data.payload);
                  } else if (process.onError) {
                    process.onError();
                  }
                };
              }
            }

            function createProcess(onComplete, onError) {
              _counterId += 1;
              var id = "processId_" + _counterId;
              processes[id] = {
                onComplete: onComplete,
                onError: onError,
              };
              return id;
            }

            function loadAnimation(path, onComplete, onError) {
              setupWorker();
              var processId = createProcess(onComplete, onError);
              workerInstance.postMessage({
                type: "loadAnimation",
                path: path,
                fullPath: window.location.origin + window.location.pathname,
                id: processId,
              });
            }

            function loadData(path, onComplete, onError) {
              setupWorker();
              var processId = createProcess(onComplete, onError);
              workerInstance.postMessage({
                type: "loadData",
                path: path,
                fullPath: window.location.origin + window.location.pathname,
                id: processId,
              });
            }

            function completeAnimation(anim, onComplete, onError) {
              setupWorker();
              var processId = createProcess(onComplete, onError);
              workerInstance.postMessage({
                type: "complete",
                animation: anim,
                id: processId,
              });
            }

            return {
              loadAnimation: loadAnimation,
              loadData: loadData,
              completeAnimation: completeAnimation,
            };
          })();

          var ImagePreloader = (function () {
            var proxyImage = (function () {
              var canvas = createTag("canvas");
              canvas.width = 1;
              canvas.height = 1;
              var ctx = canvas.getContext("2d");
              ctx.fillStyle = "rgba(0,0,0,0)";
              ctx.fillRect(0, 0, 1, 1);
              return canvas;
            })();

            function imageLoaded() {
              this.loadedAssets += 1;

              if (
                this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages
              ) {
                if (this.imagesLoadedCb) {
                  this.imagesLoadedCb(null);
                }
              }
            }

            function footageLoaded() {
              this.loadedFootagesCount += 1;

              if (
                this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages
              ) {
                if (this.imagesLoadedCb) {
                  this.imagesLoadedCb(null);
                }
              }
            }

            function getAssetsPath(assetData, assetsPath, originalPath) {
              var path = "";

              if (assetData.e) {
                path = assetData.p;
              } else if (assetsPath) {
                var imagePath = assetData.p;

                if (imagePath.indexOf("images/") !== -1) {
                  imagePath = imagePath.split("/")[1];
                }

                path = assetsPath + imagePath;
              } else {
                path = originalPath;
                path += assetData.u ? assetData.u : "";
                path += assetData.p;
              }

              return path;
            }

            function testImageLoaded(img) {
              var _count = 0;
              var intervalId = setInterval(
                function () {
                  var box = img.getBBox();

                  if (box.width || _count > 500) {
                    this._imageLoaded();

                    clearInterval(intervalId);
                  }

                  _count += 1;
                }.bind(this),
                50
              );
            }

            function createImageData(assetData) {
              var path = getAssetsPath(assetData, this.assetsPath, this.path);
              var img = createNS("image");

              if (isSafari) {
                this.testImageLoaded(img);
              } else {
                img.addEventListener("load", this._imageLoaded, false);
              }

              img.addEventListener(
                "error",
                function () {
                  ob.img = proxyImage;

                  this._imageLoaded();
                }.bind(this),
                false
              );
              img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);

              if (this._elementHelper.append) {
                this._elementHelper.append(img);
              } else {
                this._elementHelper.appendChild(img);
              }

              var ob = {
                img: img,
                assetData: assetData,
              };
              return ob;
            }

            function createImgData(assetData) {
              var path = getAssetsPath(assetData, this.assetsPath, this.path);
              var img = createTag("img");
              img.crossOrigin = "anonymous";
              img.addEventListener("load", this._imageLoaded, false);
              img.addEventListener(
                "error",
                function () {
                  ob.img = proxyImage;

                  this._imageLoaded();
                }.bind(this),
                false
              );
              img.src = path;
              var ob = {
                img: img,
                assetData: assetData,
              };
              return ob;
            }

            function createFootageData(data) {
              var ob = {
                assetData: data,
              };
              var path = getAssetsPath(data, this.assetsPath, this.path);
              dataManager.loadData(
                path,
                function (footageData) {
                  ob.img = footageData;

                  this._footageLoaded();
                }.bind(this),
                function () {
                  ob.img = {};

                  this._footageLoaded();
                }.bind(this)
              );
              return ob;
            }

            function loadAssets(assets, cb) {
              this.imagesLoadedCb = cb;
              var i;
              var len = assets.length;

              for (i = 0; i < len; i += 1) {
                if (!assets[i].layers) {
                  if (!assets[i].t || assets[i].t === "seq") {
                    this.totalImages += 1;
                    this.images.push(this._createImageData(assets[i]));
                  } else if (assets[i].t === 3) {
                    this.totalFootages += 1;
                    this.images.push(this.createFootageData(assets[i]));
                  }
                }
              }
            }

            function setPath(path) {
              this.path = path || "";
            }

            function setAssetsPath(path) {
              this.assetsPath = path || "";
            }

            function getAsset(assetData) {
              var i = 0;
              var len = this.images.length;

              while (i < len) {
                if (this.images[i].assetData === assetData) {
                  return this.images[i].img;
                }

                i += 1;
              }

              return null;
            }

            function destroy() {
              this.imagesLoadedCb = null;
              this.images.length = 0;
            }

            function loadedImages() {
              return this.totalImages === this.loadedAssets;
            }

            function loadedFootages() {
              return this.totalFootages === this.loadedFootagesCount;
            }

            function setCacheType(type, elementHelper) {
              if (type === "svg") {
                this._elementHelper = elementHelper;
                this._createImageData = this.createImageData.bind(this);
              } else {
                this._createImageData = this.createImgData.bind(this);
              }
            }

            function ImagePreloaderFactory() {
              this._imageLoaded = imageLoaded.bind(this);
              this._footageLoaded = footageLoaded.bind(this);
              this.testImageLoaded = testImageLoaded.bind(this);
              this.createFootageData = createFootageData.bind(this);
              this.assetsPath = "";
              this.path = "";
              this.totalImages = 0;
              this.totalFootages = 0;
              this.loadedAssets = 0;
              this.loadedFootagesCount = 0;
              this.imagesLoadedCb = null;
              this.images = [];
            }

            ImagePreloaderFactory.prototype = {
              loadAssets: loadAssets,
              setAssetsPath: setAssetsPath,
              setPath: setPath,
              loadedImages: loadedImages,
              loadedFootages: loadedFootages,
              destroy: destroy,
              getAsset: getAsset,
              createImgData: createImgData,
              createImageData: createImageData,
              imageLoaded: imageLoaded,
              footageLoaded: footageLoaded,
              setCacheType: setCacheType,
            };
            return ImagePreloaderFactory;
          })();

          function BaseEvent() {}

          BaseEvent.prototype = {
            triggerEvent: function triggerEvent(eventName, args) {
              if (this._cbs[eventName]) {
                var callbacks = this._cbs[eventName];

                for (var i = 0; i < callbacks.length; i += 1) {
                  callbacks[i](args);
                }
              }
            },
            addEventListener: function addEventListener(eventName, callback) {
              if (!this._cbs[eventName]) {
                this._cbs[eventName] = [];
              }

              this._cbs[eventName].push(callback);

              return function () {
                this.removeEventListener(eventName, callback);
              }.bind(this);
            },
            removeEventListener: function removeEventListener(
              eventName,
              callback
            ) {
              if (!callback) {
                this._cbs[eventName] = null;
              } else if (this._cbs[eventName]) {
                var i = 0;
                var len = this._cbs[eventName].length;

                while (i < len) {
                  if (this._cbs[eventName][i] === callback) {
                    this._cbs[eventName].splice(i, 1);

                    i -= 1;
                    len -= 1;
                  }

                  i += 1;
                }

                if (!this._cbs[eventName].length) {
                  this._cbs[eventName] = null;
                }
              }
            },
          };

          var markerParser = (function () {
            function parsePayloadLines(payload) {
              var lines = payload.split("\r\n");
              var keys = {};
              var line;
              var keysCount = 0;

              for (var i = 0; i < lines.length; i += 1) {
                line = lines[i].split(":");

                if (line.length === 2) {
                  keys[line[0]] = line[1].trim();
                  keysCount += 1;
                }
              }

              if (keysCount === 0) {
                throw new Error();
              }

              return keys;
            }

            return function (_markers) {
              var markers = [];

              for (var i = 0; i < _markers.length; i += 1) {
                var _marker = _markers[i];
                var markerData = {
                  time: _marker.tm,
                  duration: _marker.dr,
                };

                try {
                  markerData.payload = JSON.parse(_markers[i].cm);
                } catch (_) {
                  try {
                    markerData.payload = parsePayloadLines(_markers[i].cm);
                  } catch (__) {
                    markerData.payload = {
                      name: _markers[i],
                    };
                  }
                }

                markers.push(markerData);
              }

              return markers;
            };
          })();

          var ProjectInterface = (function () {
            function registerComposition(comp) {
              this.compositions.push(comp);
            }

            return function () {
              function _thisProjectFunction(name) {
                var i = 0;
                var len = this.compositions.length;

                while (i < len) {
                  if (
                    this.compositions[i].data &&
                    this.compositions[i].data.nm === name
                  ) {
                    if (
                      this.compositions[i].prepareFrame &&
                      this.compositions[i].data.xt
                    ) {
                      this.compositions[i].prepareFrame(this.currentFrame);
                    }

                    return this.compositions[i].compInterface;
                  }

                  i += 1;
                }

                return null;
              }

              _thisProjectFunction.compositions = [];
              _thisProjectFunction.currentFrame = 0;
              _thisProjectFunction.registerComposition = registerComposition;
              return _thisProjectFunction;
            };
          })();

          var renderers = {};

          var registerRenderer = function registerRenderer(key, value) {
            renderers[key] = value;
          };

          function getRenderer(key) {
            return renderers[key];
          }

          function _typeof$4(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof$4 = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof$4 = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof$4(obj);
          }

          var AnimationItem = function AnimationItem() {
            this._cbs = [];
            this.name = "";
            this.path = "";
            this.isLoaded = false;
            this.currentFrame = 0;
            this.currentRawFrame = 0;
            this.firstFrame = 0;
            this.totalFrames = 0;
            this.frameRate = 0;
            this.frameMult = 0;
            this.playSpeed = 1;
            this.playDirection = 1;
            this.playCount = 0;
            this.animationData = {};
            this.assets = [];
            this.isPaused = true;
            this.autoplay = false;
            this.loop = true;
            this.renderer = null;
            this.animationID = createElementID();
            this.assetsPath = "";
            this.timeCompleted = 0;
            this.segmentPos = 0;
            this.isSubframeEnabled = getSubframeEnabled();
            this.segments = [];
            this._idle = true;
            this._completedLoop = false;
            this.projectInterface = ProjectInterface();
            this.imagePreloader = new ImagePreloader();
            this.audioController = audioControllerFactory();
            this.markers = [];
            this.configAnimation = this.configAnimation.bind(this);
            this.onSetupError = this.onSetupError.bind(this);
            this.onSegmentComplete = this.onSegmentComplete.bind(this);
          };

          extendPrototype([BaseEvent], AnimationItem);

          AnimationItem.prototype.setParams = function (params) {
            if (params.wrapper || params.container) {
              this.wrapper = params.wrapper || params.container;
            }

            var animType = "svg";

            if (params.animType) {
              animType = params.animType;
            } else if (params.renderer) {
              animType = params.renderer;
            }

            var RendererClass = getRenderer(animType);
            this.renderer = new RendererClass(this, params.rendererSettings);
            this.imagePreloader.setCacheType(
              animType,
              this.renderer.globalData.defs
            );
            this.renderer.setProjectInterface(this.projectInterface);
            this.animType = animType;

            if (
              params.loop === "" ||
              params.loop === null ||
              params.loop === undefined ||
              params.loop === true
            ) {
              this.loop = true;
            } else if (params.loop === false) {
              this.loop = false;
            } else {
              this.loop = parseInt(params.loop, 10);
            }

            this.autoplay = "autoplay" in params ? params.autoplay : true;
            this.name = params.name ? params.name : "";
            this.autoloadSegments = Object.prototype.hasOwnProperty.call(
              params,
              "autoloadSegments"
            )
              ? params.autoloadSegments
              : true;
            this.assetsPath = params.assetsPath;
            this.initialSegment = params.initialSegment;

            if (params.audioFactory) {
              this.audioController.setAudioFactory(params.audioFactory);
            }

            if (params.animationData) {
              this.setupAnimation(params.animationData);
            } else if (params.path) {
              if (params.path.lastIndexOf("\\") !== -1) {
                this.path = params.path.substr(
                  0,
                  params.path.lastIndexOf("\\") + 1
                );
              } else {
                this.path = params.path.substr(
                  0,
                  params.path.lastIndexOf("/") + 1
                );
              }

              this.fileName = params.path.substr(
                params.path.lastIndexOf("/") + 1
              );
              this.fileName = this.fileName.substr(
                0,
                this.fileName.lastIndexOf(".json")
              );
              dataManager.loadAnimation(
                params.path,
                this.configAnimation,
                this.onSetupError
              );
            }
          };

          AnimationItem.prototype.onSetupError = function () {
            this.trigger("data_failed");
          };

          AnimationItem.prototype.setupAnimation = function (data) {
            dataManager.completeAnimation(data, this.configAnimation);
          };

          AnimationItem.prototype.setData = function (wrapper, animationData) {
            if (animationData) {
              if (_typeof$4(animationData) !== "object") {
                animationData = JSON.parse(animationData);
              }
            }

            var params = {
              wrapper: wrapper,
              animationData: animationData,
            };
            var wrapperAttributes = wrapper.attributes;
            params.path = wrapperAttributes.getNamedItem("data-animation-path") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-animation-path").value
              : wrapperAttributes.getNamedItem("data-bm-path") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-path").value
              : wrapperAttributes.getNamedItem("bm-path")
              ? wrapperAttributes.getNamedItem("bm-path").value
              : "";
            params.animType = wrapperAttributes.getNamedItem("data-anim-type") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-anim-type").value
              : wrapperAttributes.getNamedItem("data-bm-type") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-type").value
              : wrapperAttributes.getNamedItem("bm-type") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("bm-type").value
              : wrapperAttributes.getNamedItem("data-bm-renderer") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-renderer").value
              : wrapperAttributes.getNamedItem("bm-renderer")
              ? wrapperAttributes.getNamedItem("bm-renderer").value
              : "canvas";
            var loop = wrapperAttributes.getNamedItem("data-anim-loop") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-anim-loop").value
              : wrapperAttributes.getNamedItem("data-bm-loop") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-loop").value
              : wrapperAttributes.getNamedItem("bm-loop")
              ? wrapperAttributes.getNamedItem("bm-loop").value
              : "";

            if (loop === "false") {
              params.loop = false;
            } else if (loop === "true") {
              params.loop = true;
            } else if (loop !== "") {
              params.loop = parseInt(loop, 10);
            }

            var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-anim-autoplay").value
              : wrapperAttributes.getNamedItem("data-bm-autoplay") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-autoplay").value
              : wrapperAttributes.getNamedItem("bm-autoplay")
              ? wrapperAttributes.getNamedItem("bm-autoplay").value
              : true;
            params.autoplay = autoplay !== "false";
            params.name = wrapperAttributes.getNamedItem("data-name") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-name").value
              : wrapperAttributes.getNamedItem("data-bm-name") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-name").value
              : wrapperAttributes.getNamedItem("bm-name")
              ? wrapperAttributes.getNamedItem("bm-name").value
              : "";
            var prerender = wrapperAttributes.getNamedItem(
              "data-anim-prerender"
            ) // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-anim-prerender").value
              : wrapperAttributes.getNamedItem("data-bm-prerender") // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem("data-bm-prerender").value
              : wrapperAttributes.getNamedItem("bm-prerender")
              ? wrapperAttributes.getNamedItem("bm-prerender").value
              : "";

            if (prerender === "false") {
              params.prerender = false;
            }

            this.setParams(params);
          };

          AnimationItem.prototype.includeLayers = function (data) {
            if (data.op > this.animationData.op) {
              this.animationData.op = data.op;
              this.totalFrames = Math.floor(data.op - this.animationData.ip);
            }

            var layers = this.animationData.layers;
            var i;
            var len = layers.length;
            var newLayers = data.layers;
            var j;
            var jLen = newLayers.length;

            for (j = 0; j < jLen; j += 1) {
              i = 0;

              while (i < len) {
                if (layers[i].id === newLayers[j].id) {
                  layers[i] = newLayers[j];
                  break;
                }

                i += 1;
              }
            }

            if (data.chars || data.fonts) {
              this.renderer.globalData.fontManager.addChars(data.chars);
              this.renderer.globalData.fontManager.addFonts(
                data.fonts,
                this.renderer.globalData.defs
              );
            }

            if (data.assets) {
              len = data.assets.length;

              for (i = 0; i < len; i += 1) {
                this.animationData.assets.push(data.assets[i]);
              }
            }

            this.animationData.__complete = false;
            dataManager.completeAnimation(
              this.animationData,
              this.onSegmentComplete
            );
          };

          AnimationItem.prototype.onSegmentComplete = function (data) {
            this.animationData = data;
            var expressionsPlugin = getExpressionsPlugin();

            if (expressionsPlugin) {
              expressionsPlugin.initExpressions(this);
            }

            this.loadNextSegment();
          };

          AnimationItem.prototype.loadNextSegment = function () {
            var segments = this.animationData.segments;

            if (!segments || segments.length === 0 || !this.autoloadSegments) {
              this.trigger("data_ready");
              this.timeCompleted = this.totalFrames;
              return;
            }

            var segment = segments.shift();
            this.timeCompleted = segment.time * this.frameRate;
            var segmentPath =
              this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1;
            dataManager.loadData(
              segmentPath,
              this.includeLayers.bind(this),
              function () {
                this.trigger("data_failed");
              }.bind(this)
            );
          };

          AnimationItem.prototype.loadSegments = function () {
            var segments = this.animationData.segments;

            if (!segments) {
              this.timeCompleted = this.totalFrames;
            }

            this.loadNextSegment();
          };

          AnimationItem.prototype.imagesLoaded = function () {
            this.trigger("loaded_images");
            this.checkLoaded();
          };

          AnimationItem.prototype.preloadImages = function () {
            this.imagePreloader.setAssetsPath(this.assetsPath);
            this.imagePreloader.setPath(this.path);
            this.imagePreloader.loadAssets(
              this.animationData.assets,
              this.imagesLoaded.bind(this)
            );
          };

          AnimationItem.prototype.configAnimation = function (animData) {
            if (!this.renderer) {
              return;
            }

            try {
              this.animationData = animData;

              if (this.initialSegment) {
                this.totalFrames = Math.floor(
                  this.initialSegment[1] - this.initialSegment[0]
                );
                this.firstFrame = Math.round(this.initialSegment[0]);
              } else {
                this.totalFrames = Math.floor(
                  this.animationData.op - this.animationData.ip
                );
                this.firstFrame = Math.round(this.animationData.ip);
              }

              this.renderer.configAnimation(animData);

              if (!animData.assets) {
                animData.assets = [];
              }

              this.assets = this.animationData.assets;
              this.frameRate = this.animationData.fr;
              this.frameMult = this.animationData.fr / 1000;
              this.renderer.searchExtraCompositions(animData.assets);
              this.markers = markerParser(animData.markers || []);
              this.trigger("config_ready");
              this.preloadImages();
              this.loadSegments();
              this.updaFrameModifier();
              this.waitForFontsLoaded();

              if (this.isPaused) {
                this.audioController.pause();
              }
            } catch (error) {
              this.triggerConfigError(error);
            }
          };

          AnimationItem.prototype.waitForFontsLoaded = function () {
            if (!this.renderer) {
              return;
            }

            if (this.renderer.globalData.fontManager.isLoaded) {
              this.checkLoaded();
            } else {
              setTimeout(this.waitForFontsLoaded.bind(this), 20);
            }
          };

          AnimationItem.prototype.checkLoaded = function () {
            if (
              !this.isLoaded &&
              this.renderer.globalData.fontManager.isLoaded &&
              (this.imagePreloader.loadedImages() ||
                this.renderer.rendererType !== "canvas") &&
              this.imagePreloader.loadedFootages()
            ) {
              this.isLoaded = true;
              var expressionsPlugin = getExpressionsPlugin();

              if (expressionsPlugin) {
                expressionsPlugin.initExpressions(this);
              }

              this.renderer.initItems();
              setTimeout(
                function () {
                  this.trigger("DOMLoaded");
                }.bind(this),
                0
              );
              this.gotoFrame();

              if (this.autoplay) {
                this.play();
              }
            }
          };

          AnimationItem.prototype.resize = function () {
            this.renderer.updateContainerSize();
          };

          AnimationItem.prototype.setSubframe = function (flag) {
            this.isSubframeEnabled = !!flag;
          };

          AnimationItem.prototype.gotoFrame = function () {
            this.currentFrame = this.isSubframeEnabled
              ? this.currentRawFrame
              : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

            if (
              this.timeCompleted !== this.totalFrames &&
              this.currentFrame > this.timeCompleted
            ) {
              this.currentFrame = this.timeCompleted;
            }

            this.trigger("enterFrame");
            this.renderFrame();
            this.trigger("drawnFrame");
          };

          AnimationItem.prototype.renderFrame = function () {
            if (this.isLoaded === false || !this.renderer) {
              return;
            }

            try {
              this.renderer.renderFrame(this.currentFrame + this.firstFrame);
            } catch (error) {
              this.triggerRenderFrameError(error);
            }
          };

          AnimationItem.prototype.play = function (name) {
            if (name && this.name !== name) {
              return;
            }

            if (this.isPaused === true) {
              this.isPaused = false;
              this.audioController.resume();

              if (this._idle) {
                this._idle = false;
                this.trigger("_active");
              }
            }
          };

          AnimationItem.prototype.pause = function (name) {
            if (name && this.name !== name) {
              return;
            }

            if (this.isPaused === false) {
              this.isPaused = true;
              this._idle = true;
              this.trigger("_idle");
              this.audioController.pause();
            }
          };

          AnimationItem.prototype.togglePause = function (name) {
            if (name && this.name !== name) {
              return;
            }

            if (this.isPaused === true) {
              this.play();
            } else {
              this.pause();
            }
          };

          AnimationItem.prototype.stop = function (name) {
            if (name && this.name !== name) {
              return;
            }

            this.pause();
            this.playCount = 0;
            this._completedLoop = false;
            this.setCurrentRawFrameValue(0);
          };

          AnimationItem.prototype.getMarkerData = function (markerName) {
            var marker;

            for (var i = 0; i < this.markers.length; i += 1) {
              marker = this.markers[i];

              if (marker.payload && marker.payload.name.cm === markerName) {
                return marker;
              }
            }

            return null;
          };

          AnimationItem.prototype.goToAndStop = function (
            value,
            isFrame,
            name
          ) {
            if (name && this.name !== name) {
              return;
            }

            var numValue = Number(value);

            if (isNaN(numValue)) {
              var marker = this.getMarkerData(value);

              if (marker) {
                this.goToAndStop(marker.time, true);
              }
            } else if (isFrame) {
              this.setCurrentRawFrameValue(value);
            } else {
              this.setCurrentRawFrameValue(value * this.frameModifier);
            }

            this.pause();
          };

          AnimationItem.prototype.goToAndPlay = function (
            value,
            isFrame,
            name
          ) {
            if (name && this.name !== name) {
              return;
            }

            var numValue = Number(value);

            if (isNaN(numValue)) {
              var marker = this.getMarkerData(value);

              if (marker) {
                if (!marker.duration) {
                  this.goToAndStop(marker.time, true);
                } else {
                  this.playSegments(
                    [marker.time, marker.time + marker.duration],
                    true
                  );
                }
              }
            } else {
              this.goToAndStop(numValue, isFrame, name);
            }

            this.play();
          };

          AnimationItem.prototype.advanceTime = function (value) {
            if (this.isPaused === true || this.isLoaded === false) {
              return;
            }

            var nextValue = this.currentRawFrame + value * this.frameModifier;
            var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
            // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.

            if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
              if (!this.loop || this.playCount === this.loop) {
                if (
                  !this.checkSegments(
                    nextValue > this.totalFrames
                      ? nextValue % this.totalFrames
                      : 0
                  )
                ) {
                  _isComplete = true;
                  nextValue = this.totalFrames - 1;
                }
              } else if (nextValue >= this.totalFrames) {
                this.playCount += 1;

                if (!this.checkSegments(nextValue % this.totalFrames)) {
                  this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                  this._completedLoop = true;
                  this.trigger("loopComplete");
                }
              } else {
                this.setCurrentRawFrameValue(nextValue);
              }
            } else if (nextValue < 0) {
              if (!this.checkSegments(nextValue % this.totalFrames)) {
                if (
                  this.loop &&
                  !(this.playCount-- <= 0 && this.loop !== true)
                ) {
                  // eslint-disable-line no-plusplus
                  this.setCurrentRawFrameValue(
                    this.totalFrames + (nextValue % this.totalFrames)
                  );

                  if (!this._completedLoop) {
                    this._completedLoop = true;
                  } else {
                    this.trigger("loopComplete");
                  }
                } else {
                  _isComplete = true;
                  nextValue = 0;
                }
              }
            } else {
              this.setCurrentRawFrameValue(nextValue);
            }

            if (_isComplete) {
              this.setCurrentRawFrameValue(nextValue);
              this.pause();
              this.trigger("complete");
            }
          };

          AnimationItem.prototype.adjustSegment = function (arr, offset) {
            this.playCount = 0;

            if (arr[1] < arr[0]) {
              if (this.frameModifier > 0) {
                if (this.playSpeed < 0) {
                  this.setSpeed(-this.playSpeed);
                } else {
                  this.setDirection(-1);
                }
              }

              this.totalFrames = arr[0] - arr[1];
              this.timeCompleted = this.totalFrames;
              this.firstFrame = arr[1];
              this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
            } else if (arr[1] > arr[0]) {
              if (this.frameModifier < 0) {
                if (this.playSpeed < 0) {
                  this.setSpeed(-this.playSpeed);
                } else {
                  this.setDirection(1);
                }
              }

              this.totalFrames = arr[1] - arr[0];
              this.timeCompleted = this.totalFrames;
              this.firstFrame = arr[0];
              this.setCurrentRawFrameValue(0.001 + offset);
            }

            this.trigger("segmentStart");
          };

          AnimationItem.prototype.setSegment = function (init, end) {
            var pendingFrame = -1;

            if (this.isPaused) {
              if (this.currentRawFrame + this.firstFrame < init) {
                pendingFrame = init;
              } else if (this.currentRawFrame + this.firstFrame > end) {
                pendingFrame = end - init;
              }
            }

            this.firstFrame = init;
            this.totalFrames = end - init;
            this.timeCompleted = this.totalFrames;

            if (pendingFrame !== -1) {
              this.goToAndStop(pendingFrame, true);
            }
          };

          AnimationItem.prototype.playSegments = function (arr, forceFlag) {
            if (forceFlag) {
              this.segments.length = 0;
            }

            if (_typeof$4(arr[0]) === "object") {
              var i;
              var len = arr.length;

              for (i = 0; i < len; i += 1) {
                this.segments.push(arr[i]);
              }
            } else {
              this.segments.push(arr);
            }

            if (this.segments.length && forceFlag) {
              this.adjustSegment(this.segments.shift(), 0);
            }

            if (this.isPaused) {
              this.play();
            }
          };

          AnimationItem.prototype.resetSegments = function (forceFlag) {
            this.segments.length = 0;
            this.segments.push([this.animationData.ip, this.animationData.op]);

            if (forceFlag) {
              this.checkSegments(0);
            }
          };

          AnimationItem.prototype.checkSegments = function (offset) {
            if (this.segments.length) {
              this.adjustSegment(this.segments.shift(), offset);
              return true;
            }

            return false;
          };

          AnimationItem.prototype.destroy = function (name) {
            if ((name && this.name !== name) || !this.renderer) {
              return;
            }

            this.renderer.destroy();
            this.imagePreloader.destroy();
            this.trigger("destroy");
            this._cbs = null;
            this.onEnterFrame = null;
            this.onLoopComplete = null;
            this.onComplete = null;
            this.onSegmentStart = null;
            this.onDestroy = null;
            this.renderer = null;
            this.renderer = null;
            this.imagePreloader = null;
            this.projectInterface = null;
          };

          AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
            this.currentRawFrame = value;
            this.gotoFrame();
          };

          AnimationItem.prototype.setSpeed = function (val) {
            this.playSpeed = val;
            this.updaFrameModifier();
          };

          AnimationItem.prototype.setDirection = function (val) {
            this.playDirection = val < 0 ? -1 : 1;
            this.updaFrameModifier();
          };

          AnimationItem.prototype.setVolume = function (val, name) {
            if (name && this.name !== name) {
              return;
            }

            this.audioController.setVolume(val);
          };

          AnimationItem.prototype.getVolume = function () {
            return this.audioController.getVolume();
          };

          AnimationItem.prototype.mute = function (name) {
            if (name && this.name !== name) {
              return;
            }

            this.audioController.mute();
          };

          AnimationItem.prototype.unmute = function (name) {
            if (name && this.name !== name) {
              return;
            }

            this.audioController.unmute();
          };

          AnimationItem.prototype.updaFrameModifier = function () {
            this.frameModifier =
              this.frameMult * this.playSpeed * this.playDirection;
            this.audioController.setRate(this.playSpeed * this.playDirection);
          };

          AnimationItem.prototype.getPath = function () {
            return this.path;
          };

          AnimationItem.prototype.getAssetsPath = function (assetData) {
            var path = "";

            if (assetData.e) {
              path = assetData.p;
            } else if (this.assetsPath) {
              var imagePath = assetData.p;

              if (imagePath.indexOf("images/") !== -1) {
                imagePath = imagePath.split("/")[1];
              }

              path = this.assetsPath + imagePath;
            } else {
              path = this.path;
              path += assetData.u ? assetData.u : "";
              path += assetData.p;
            }

            return path;
          };

          AnimationItem.prototype.getAssetData = function (id) {
            var i = 0;
            var len = this.assets.length;

            while (i < len) {
              if (id === this.assets[i].id) {
                return this.assets[i];
              }

              i += 1;
            }

            return null;
          };

          AnimationItem.prototype.hide = function () {
            this.renderer.hide();
          };

          AnimationItem.prototype.show = function () {
            this.renderer.show();
          };

          AnimationItem.prototype.getDuration = function (isFrame) {
            return isFrame
              ? this.totalFrames
              : this.totalFrames / this.frameRate;
          };

          AnimationItem.prototype.trigger = function (name) {
            if (this._cbs && this._cbs[name]) {
              switch (name) {
                case "enterFrame":
                case "drawnFrame":
                  this.triggerEvent(
                    name,
                    new BMEnterFrameEvent(
                      name,
                      this.currentFrame,
                      this.totalFrames,
                      this.frameModifier
                    )
                  );
                  break;

                case "loopComplete":
                  this.triggerEvent(
                    name,
                    new BMCompleteLoopEvent(
                      name,
                      this.loop,
                      this.playCount,
                      this.frameMult
                    )
                  );
                  break;

                case "complete":
                  this.triggerEvent(
                    name,
                    new BMCompleteEvent(name, this.frameMult)
                  );
                  break;

                case "segmentStart":
                  this.triggerEvent(
                    name,
                    new BMSegmentStartEvent(
                      name,
                      this.firstFrame,
                      this.totalFrames
                    )
                  );
                  break;

                case "destroy":
                  this.triggerEvent(name, new BMDestroyEvent(name, this));
                  break;

                default:
                  this.triggerEvent(name);
              }
            }

            if (name === "enterFrame" && this.onEnterFrame) {
              this.onEnterFrame.call(
                this,
                new BMEnterFrameEvent(
                  name,
                  this.currentFrame,
                  this.totalFrames,
                  this.frameMult
                )
              );
            }

            if (name === "loopComplete" && this.onLoopComplete) {
              this.onLoopComplete.call(
                this,
                new BMCompleteLoopEvent(
                  name,
                  this.loop,
                  this.playCount,
                  this.frameMult
                )
              );
            }

            if (name === "complete" && this.onComplete) {
              this.onComplete.call(
                this,
                new BMCompleteEvent(name, this.frameMult)
              );
            }

            if (name === "segmentStart" && this.onSegmentStart) {
              this.onSegmentStart.call(
                this,
                new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames)
              );
            }

            if (name === "destroy" && this.onDestroy) {
              this.onDestroy.call(this, new BMDestroyEvent(name, this));
            }
          };

          AnimationItem.prototype.triggerRenderFrameError = function (
            nativeError
          ) {
            var error = new BMRenderFrameErrorEvent(
              nativeError,
              this.currentFrame
            );
            this.triggerEvent("error", error);

            if (this.onError) {
              this.onError.call(this, error);
            }
          };

          AnimationItem.prototype.triggerConfigError = function (nativeError) {
            var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
            this.triggerEvent("error", error);

            if (this.onError) {
              this.onError.call(this, error);
            }
          };

          var animationManager = (function () {
            var moduleOb = {};
            var registeredAnimations = [];
            var initTime = 0;
            var len = 0;
            var playingAnimationsNum = 0;
            var _stopped = true;
            var _isFrozen = false;

            function removeElement(ev) {
              var i = 0;
              var animItem = ev.target;

              while (i < len) {
                if (registeredAnimations[i].animation === animItem) {
                  registeredAnimations.splice(i, 1);
                  i -= 1;
                  len -= 1;

                  if (!animItem.isPaused) {
                    subtractPlayingCount();
                  }
                }

                i += 1;
              }
            }

            function registerAnimation(element, animationData) {
              if (!element) {
                return null;
              }

              var i = 0;

              while (i < len) {
                if (
                  registeredAnimations[i].elem === element &&
                  registeredAnimations[i].elem !== null
                ) {
                  return registeredAnimations[i].animation;
                }

                i += 1;
              }

              var animItem = new AnimationItem();
              setupAnimation(animItem, element);
              animItem.setData(element, animationData);
              return animItem;
            }

            function getRegisteredAnimations() {
              var i;
              var lenAnims = registeredAnimations.length;
              var animations = [];

              for (i = 0; i < lenAnims; i += 1) {
                animations.push(registeredAnimations[i].animation);
              }

              return animations;
            }

            function addPlayingCount() {
              playingAnimationsNum += 1;
              activate();
            }

            function subtractPlayingCount() {
              playingAnimationsNum -= 1;
            }

            function setupAnimation(animItem, element) {
              animItem.addEventListener("destroy", removeElement);
              animItem.addEventListener("_active", addPlayingCount);
              animItem.addEventListener("_idle", subtractPlayingCount);
              registeredAnimations.push({
                elem: element,
                animation: animItem,
              });
              len += 1;
            }

            function loadAnimation(params) {
              var animItem = new AnimationItem();
              setupAnimation(animItem, null);
              animItem.setParams(params);
              return animItem;
            }

            function setSpeed(val, animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.setSpeed(val, animation);
              }
            }

            function setDirection(val, animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.setDirection(val, animation);
              }
            }

            function play(animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.play(animation);
              }
            }

            function resume(nowTime) {
              var elapsedTime = nowTime - initTime;
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.advanceTime(elapsedTime);
              }

              initTime = nowTime;

              if (playingAnimationsNum && !_isFrozen) {
                window.requestAnimationFrame(resume);
              } else {
                _stopped = true;
              }
            }

            function first(nowTime) {
              initTime = nowTime;
              window.requestAnimationFrame(resume);
            }

            function pause(animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.pause(animation);
              }
            }

            function goToAndStop(value, isFrame, animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.goToAndStop(
                  value,
                  isFrame,
                  animation
                );
              }
            }

            function stop(animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.stop(animation);
              }
            }

            function togglePause(animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.togglePause(animation);
              }
            }

            function destroy(animation) {
              var i;

              for (i = len - 1; i >= 0; i -= 1) {
                registeredAnimations[i].animation.destroy(animation);
              }
            }

            function searchAnimations(animationData, standalone, renderer) {
              var animElements = [].concat(
                [].slice.call(document.getElementsByClassName("lottie")),
                [].slice.call(document.getElementsByClassName("bodymovin"))
              );
              var i;
              var lenAnims = animElements.length;

              for (i = 0; i < lenAnims; i += 1) {
                if (renderer) {
                  animElements[i].setAttribute("data-bm-type", renderer);
                }

                registerAnimation(animElements[i], animationData);
              }

              if (standalone && lenAnims === 0) {
                if (!renderer) {
                  renderer = "svg";
                }

                var body = document.getElementsByTagName("body")[0];
                body.innerText = "";
                var div = createTag("div");
                div.style.width = "100%";
                div.style.height = "100%";
                div.setAttribute("data-bm-type", renderer);
                body.appendChild(div);
                registerAnimation(div, animationData);
              }
            }

            function resize() {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.resize();
              }
            }

            function activate() {
              if (!_isFrozen && playingAnimationsNum) {
                if (_stopped) {
                  window.requestAnimationFrame(first);
                  _stopped = false;
                }
              }
            }

            function freeze() {
              _isFrozen = true;
            }

            function unfreeze() {
              _isFrozen = false;
              activate();
            }

            function setVolume(val, animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.setVolume(val, animation);
              }
            }

            function mute(animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.mute(animation);
              }
            }

            function unmute(animation) {
              var i;

              for (i = 0; i < len; i += 1) {
                registeredAnimations[i].animation.unmute(animation);
              }
            }

            moduleOb.registerAnimation = registerAnimation;
            moduleOb.loadAnimation = loadAnimation;
            moduleOb.setSpeed = setSpeed;
            moduleOb.setDirection = setDirection;
            moduleOb.play = play;
            moduleOb.pause = pause;
            moduleOb.stop = stop;
            moduleOb.togglePause = togglePause;
            moduleOb.searchAnimations = searchAnimations;
            moduleOb.resize = resize; // moduleOb.start = start;

            moduleOb.goToAndStop = goToAndStop;
            moduleOb.destroy = destroy;
            moduleOb.freeze = freeze;
            moduleOb.unfreeze = unfreeze;
            moduleOb.setVolume = setVolume;
            moduleOb.mute = mute;
            moduleOb.unmute = unmute;
            moduleOb.getRegisteredAnimations = getRegisteredAnimations;
            return moduleOb;
          })();

          /* eslint-disable */
          var BezierFactory = (function () {
            /**
             * BezierEasing - use bezier curve for transition easing function
             * by Gatan Renaudeau 2014 - 2015  MIT License
             *
             * Credits: is based on Firefox's nsSMILKeySpline.cpp
             * Usage:
             * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
             * spline.get(x) => returns the easing value | x must be in [0, 1] range
             *
             */
            var ob = {};
            ob.getBezierEasing = getBezierEasing;
            var beziers = {};

            function getBezierEasing(a, b, c, d, nm) {
              var str =
                nm ||
                ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");

              if (beziers[str]) {
                return beziers[str];
              }

              var bezEasing = new BezierEasing([a, b, c, d]);
              beziers[str] = bezEasing;
              return bezEasing;
            } // These values are established by empiricism with tests (tradeoff: performance VS precision)

            var NEWTON_ITERATIONS = 4;
            var NEWTON_MIN_SLOPE = 0.001;
            var SUBDIVISION_PRECISION = 0.0000001;
            var SUBDIVISION_MAX_ITERATIONS = 10;
            var kSplineTableSize = 11;
            var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
            var float32ArraySupported = typeof Float32Array === "function";

            function A(aA1, aA2) {
              return 1.0 - 3.0 * aA2 + 3.0 * aA1;
            }

            function B(aA1, aA2) {
              return 3.0 * aA2 - 6.0 * aA1;
            }

            function C(aA1) {
              return 3.0 * aA1;
            } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.

            function calcBezier(aT, aA1, aA2) {
              return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
            } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.

            function getSlope(aT, aA1, aA2) {
              return (
                3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1)
              );
            }

            function binarySubdivide(aX, aA, aB, mX1, mX2) {
              var currentX,
                currentT,
                i = 0;

              do {
                currentT = aA + (aB - aA) / 2.0;
                currentX = calcBezier(currentT, mX1, mX2) - aX;

                if (currentX > 0.0) {
                  aB = currentT;
                } else {
                  aA = currentT;
                }
              } while (
                Math.abs(currentX) > SUBDIVISION_PRECISION &&
                ++i < SUBDIVISION_MAX_ITERATIONS
              );

              return currentT;
            }

            function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
              for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
              }

              return aGuessT;
            }
            /**
             * points is an array of [ mX1, mY1, mX2, mY2 ]
             */

            function BezierEasing(points) {
              this._p = points;
              this._mSampleValues = float32ArraySupported
                ? new Float32Array(kSplineTableSize)
                : new Array(kSplineTableSize);
              this._precomputed = false;
              this.get = this.get.bind(this);
            }

            BezierEasing.prototype = {
              get: function get(x) {
                var mX1 = this._p[0],
                  mY1 = this._p[1],
                  mX2 = this._p[2],
                  mY2 = this._p[3];
                if (!this._precomputed) this._precompute();
                if (mX1 === mY1 && mX2 === mY2) return x; // linear
                // Because JavaScript number are imprecise, we should guarantee the extremes are right.

                if (x === 0) return 0;
                if (x === 1) return 1;
                return calcBezier(this._getTForX(x), mY1, mY2);
              },
              // Private part
              _precompute: function _precompute() {
                var mX1 = this._p[0],
                  mY1 = this._p[1],
                  mX2 = this._p[2],
                  mY2 = this._p[3];
                this._precomputed = true;

                if (mX1 !== mY1 || mX2 !== mY2) {
                  this._calcSampleValues();
                }
              },
              _calcSampleValues: function _calcSampleValues() {
                var mX1 = this._p[0],
                  mX2 = this._p[2];

                for (var i = 0; i < kSplineTableSize; ++i) {
                  this._mSampleValues[i] = calcBezier(
                    i * kSampleStepSize,
                    mX1,
                    mX2
                  );
                }
              },

              /**
               * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
               */
              _getTForX: function _getTForX(aX) {
                var mX1 = this._p[0],
                  mX2 = this._p[2],
                  mSampleValues = this._mSampleValues;
                var intervalStart = 0.0;
                var currentSample = 1;
                var lastSample = kSplineTableSize - 1;

                for (
                  ;
                  currentSample !== lastSample &&
                  mSampleValues[currentSample] <= aX;
                  ++currentSample
                ) {
                  intervalStart += kSampleStepSize;
                }

                --currentSample; // Interpolate to provide an initial guess for t

                var dist =
                  (aX - mSampleValues[currentSample]) /
                  (mSampleValues[currentSample + 1] -
                    mSampleValues[currentSample]);
                var guessForT = intervalStart + dist * kSampleStepSize;
                var initialSlope = getSlope(guessForT, mX1, mX2);

                if (initialSlope >= NEWTON_MIN_SLOPE) {
                  return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                }

                if (initialSlope === 0.0) {
                  return guessForT;
                }

                return binarySubdivide(
                  aX,
                  intervalStart,
                  intervalStart + kSampleStepSize,
                  mX1,
                  mX2
                );
              },
            };
            return ob;
          })();

          var pooling = (function () {
            function _double(arr) {
              return arr.concat(createSizedArray(arr.length));
            }

            return {
              double: _double,
            };
          })();

          var poolFactory = (function () {
            return function (initialLength, _create, _release) {
              var _length = 0;
              var _maxLength = initialLength;
              var pool = createSizedArray(_maxLength);
              var ob = {
                newElement: newElement,
                release: release,
              };

              function newElement() {
                var element;

                if (_length) {
                  _length -= 1;
                  element = pool[_length];
                } else {
                  element = _create();
                }

                return element;
              }

              function release(element) {
                if (_length === _maxLength) {
                  pool = pooling["double"](pool);
                  _maxLength *= 2;
                }

                if (_release) {
                  _release(element);
                }

                pool[_length] = element;
                _length += 1;
              }

              return ob;
            };
          })();

          var bezierLengthPool = (function () {
            function create() {
              return {
                addedLength: 0,
                percents: createTypedArray(
                  "float32",
                  getDefaultCurveSegments()
                ),
                lengths: createTypedArray("float32", getDefaultCurveSegments()),
              };
            }

            return poolFactory(8, create);
          })();

          var segmentsLengthPool = (function () {
            function create() {
              return {
                lengths: [],
                totalLength: 0,
              };
            }

            function release(element) {
              var i;
              var len = element.lengths.length;

              for (i = 0; i < len; i += 1) {
                bezierLengthPool.release(element.lengths[i]);
              }

              element.lengths.length = 0;
            }

            return poolFactory(8, create, release);
          })();

          function bezFunction() {
            var math = Math;

            function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
              var det1 =
                x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
              return det1 > -0.001 && det1 < 0.001;
            }

            function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
              if (z1 === 0 && z2 === 0 && z3 === 0) {
                return pointOnLine2D(x1, y1, x2, y2, x3, y3);
              }

              var dist1 = math.sqrt(
                math.pow(x2 - x1, 2) +
                  math.pow(y2 - y1, 2) +
                  math.pow(z2 - z1, 2)
              );
              var dist2 = math.sqrt(
                math.pow(x3 - x1, 2) +
                  math.pow(y3 - y1, 2) +
                  math.pow(z3 - z1, 2)
              );
              var dist3 = math.sqrt(
                math.pow(x3 - x2, 2) +
                  math.pow(y3 - y2, 2) +
                  math.pow(z3 - z2, 2)
              );
              var diffDist;

              if (dist1 > dist2) {
                if (dist1 > dist3) {
                  diffDist = dist1 - dist2 - dist3;
                } else {
                  diffDist = dist3 - dist2 - dist1;
                }
              } else if (dist3 > dist2) {
                diffDist = dist3 - dist2 - dist1;
              } else {
                diffDist = dist2 - dist1 - dist3;
              }

              return diffDist > -0.0001 && diffDist < 0.0001;
            }

            var getBezierLength = (function () {
              return function (pt1, pt2, pt3, pt4) {
                var curveSegments = getDefaultCurveSegments();
                var k;
                var i;
                var len;
                var ptCoord;
                var perc;
                var addedLength = 0;
                var ptDistance;
                var point = [];
                var lastPoint = [];
                var lengthData = bezierLengthPool.newElement();
                len = pt3.length;

                for (k = 0; k < curveSegments; k += 1) {
                  perc = k / (curveSegments - 1);
                  ptDistance = 0;

                  for (i = 0; i < len; i += 1) {
                    ptCoord =
                      bmPow(1 - perc, 3) * pt1[i] +
                      3 * bmPow(1 - perc, 2) * perc * pt3[i] +
                      3 * (1 - perc) * bmPow(perc, 2) * pt4[i] +
                      bmPow(perc, 3) * pt2[i];
                    point[i] = ptCoord;

                    if (lastPoint[i] !== null) {
                      ptDistance += bmPow(point[i] - lastPoint[i], 2);
                    }

                    lastPoint[i] = point[i];
                  }

                  if (ptDistance) {
                    ptDistance = bmSqrt(ptDistance);
                    addedLength += ptDistance;
                  }

                  lengthData.percents[k] = perc;
                  lengthData.lengths[k] = addedLength;
                }

                lengthData.addedLength = addedLength;
                return lengthData;
              };
            })();

            function getSegmentsLength(shapeData) {
              var segmentsLength = segmentsLengthPool.newElement();
              var closed = shapeData.c;
              var pathV = shapeData.v;
              var pathO = shapeData.o;
              var pathI = shapeData.i;
              var i;
              var len = shapeData._length;
              var lengths = segmentsLength.lengths;
              var totalLength = 0;

              for (i = 0; i < len - 1; i += 1) {
                lengths[i] = getBezierLength(
                  pathV[i],
                  pathV[i + 1],
                  pathO[i],
                  pathI[i + 1]
                );
                totalLength += lengths[i].addedLength;
              }

              if (closed && len) {
                lengths[i] = getBezierLength(
                  pathV[i],
                  pathV[0],
                  pathO[i],
                  pathI[0]
                );
                totalLength += lengths[i].addedLength;
              }

              segmentsLength.totalLength = totalLength;
              return segmentsLength;
            }

            function BezierData(length) {
              this.segmentLength = 0;
              this.points = new Array(length);
            }

            function PointData(partial, point) {
              this.partialLength = partial;
              this.point = point;
            }

            var buildBezierData = (function () {
              var storedData = {};
              return function (pt1, pt2, pt3, pt4) {
                var bezierName = (
                  pt1[0] +
                  "_" +
                  pt1[1] +
                  "_" +
                  pt2[0] +
                  "_" +
                  pt2[1] +
                  "_" +
                  pt3[0] +
                  "_" +
                  pt3[1] +
                  "_" +
                  pt4[0] +
                  "_" +
                  pt4[1]
                ).replace(/\./g, "p");

                if (!storedData[bezierName]) {
                  var curveSegments = getDefaultCurveSegments();
                  var k;
                  var i;
                  var len;
                  var ptCoord;
                  var perc;
                  var addedLength = 0;
                  var ptDistance;
                  var point;
                  var lastPoint = null;

                  if (
                    pt1.length === 2 &&
                    (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) &&
                    pointOnLine2D(
                      pt1[0],
                      pt1[1],
                      pt2[0],
                      pt2[1],
                      pt1[0] + pt3[0],
                      pt1[1] + pt3[1]
                    ) &&
                    pointOnLine2D(
                      pt1[0],
                      pt1[1],
                      pt2[0],
                      pt2[1],
                      pt2[0] + pt4[0],
                      pt2[1] + pt4[1]
                    )
                  ) {
                    curveSegments = 2;
                  }

                  var bezierData = new BezierData(curveSegments);
                  len = pt3.length;

                  for (k = 0; k < curveSegments; k += 1) {
                    point = createSizedArray(len);
                    perc = k / (curveSegments - 1);
                    ptDistance = 0;

                    for (i = 0; i < len; i += 1) {
                      ptCoord =
                        bmPow(1 - perc, 3) * pt1[i] +
                        3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) +
                        3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) +
                        bmPow(perc, 3) * pt2[i];
                      point[i] = ptCoord;

                      if (lastPoint !== null) {
                        ptDistance += bmPow(point[i] - lastPoint[i], 2);
                      }
                    }

                    ptDistance = bmSqrt(ptDistance);
                    addedLength += ptDistance;
                    bezierData.points[k] = new PointData(ptDistance, point);
                    lastPoint = point;
                  }

                  bezierData.segmentLength = addedLength;
                  storedData[bezierName] = bezierData;
                }

                return storedData[bezierName];
              };
            })();

            function getDistancePerc(perc, bezierData) {
              var percents = bezierData.percents;
              var lengths = bezierData.lengths;
              var len = percents.length;
              var initPos = bmFloor((len - 1) * perc);
              var lengthPos = perc * bezierData.addedLength;
              var lPerc = 0;

              if (
                initPos === len - 1 ||
                initPos === 0 ||
                lengthPos === lengths[initPos]
              ) {
                return percents[initPos];
              }

              var dir = lengths[initPos] > lengthPos ? -1 : 1;
              var flag = true;

              while (flag) {
                if (
                  lengths[initPos] <= lengthPos &&
                  lengths[initPos + 1] > lengthPos
                ) {
                  lPerc =
                    (lengthPos - lengths[initPos]) /
                    (lengths[initPos + 1] - lengths[initPos]);
                  flag = false;
                } else {
                  initPos += dir;
                }

                if (initPos < 0 || initPos >= len - 1) {
                  // FIX for TypedArrays that don't store floating point values with enough accuracy
                  if (initPos === len - 1) {
                    return percents[initPos];
                  }

                  flag = false;
                }
              }

              return (
                percents[initPos] +
                (percents[initPos + 1] - percents[initPos]) * lPerc
              );
            }

            function getPointInSegment(
              pt1,
              pt2,
              pt3,
              pt4,
              percent,
              bezierData
            ) {
              var t1 = getDistancePerc(percent, bezierData);
              var u1 = 1 - t1;
              var ptX =
                math.round(
                  (u1 * u1 * u1 * pt1[0] +
                    (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] +
                    (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] +
                    t1 * t1 * t1 * pt2[0]) *
                    1000
                ) / 1000;
              var ptY =
                math.round(
                  (u1 * u1 * u1 * pt1[1] +
                    (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] +
                    (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] +
                    t1 * t1 * t1 * pt2[1]) *
                    1000
                ) / 1000;
              return [ptX, ptY];
            }

            var bezierSegmentPoints = createTypedArray("float32", 8);

            function getNewSegment(
              pt1,
              pt2,
              pt3,
              pt4,
              startPerc,
              endPerc,
              bezierData
            ) {
              if (startPerc < 0) {
                startPerc = 0;
              } else if (startPerc > 1) {
                startPerc = 1;
              }

              var t0 = getDistancePerc(startPerc, bezierData);
              endPerc = endPerc > 1 ? 1 : endPerc;
              var t1 = getDistancePerc(endPerc, bezierData);
              var i;
              var len = pt1.length;
              var u0 = 1 - t0;
              var u1 = 1 - t1;
              var u0u0u0 = u0 * u0 * u0;
              var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase

              var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase

              var t0t0t0 = t0 * t0 * t0; //

              var u0u0u1 = u0 * u0 * u1;
              var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase

              var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase

              var t0t0t1 = t0 * t0 * t1; //

              var u0u1u1 = u0 * u1 * u1;
              var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase

              var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase

              var t0t1t1 = t0 * t1 * t1; //

              var u1u1u1 = u1 * u1 * u1;
              var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase

              var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase

              var t1t1t1 = t1 * t1 * t1;

              for (i = 0; i < len; i += 1) {
                bezierSegmentPoints[i * 4] =
                  math.round(
                    (u0u0u0 * pt1[i] +
                      t0u0u0_3 * pt3[i] +
                      t0t0u0_3 * pt4[i] +
                      t0t0t0 * pt2[i]) *
                      1000
                  ) / 1000; // eslint-disable-line camelcase

                bezierSegmentPoints[i * 4 + 1] =
                  math.round(
                    (u0u0u1 * pt1[i] +
                      t0u0u1_3 * pt3[i] +
                      t0t0u1_3 * pt4[i] +
                      t0t0t1 * pt2[i]) *
                      1000
                  ) / 1000; // eslint-disable-line camelcase

                bezierSegmentPoints[i * 4 + 2] =
                  math.round(
                    (u0u1u1 * pt1[i] +
                      t0u1u1_3 * pt3[i] +
                      t0t1u1_3 * pt4[i] +
                      t0t1t1 * pt2[i]) *
                      1000
                  ) / 1000; // eslint-disable-line camelcase

                bezierSegmentPoints[i * 4 + 3] =
                  math.round(
                    (u1u1u1 * pt1[i] +
                      t1u1u1_3 * pt3[i] +
                      t1t1u1_3 * pt4[i] +
                      t1t1t1 * pt2[i]) *
                      1000
                  ) / 1000; // eslint-disable-line camelcase
              }

              return bezierSegmentPoints;
            }

            return {
              getSegmentsLength: getSegmentsLength,
              getNewSegment: getNewSegment,
              getPointInSegment: getPointInSegment,
              buildBezierData: buildBezierData,
              pointOnLine2D: pointOnLine2D,
              pointOnLine3D: pointOnLine3D,
            };
          }

          var bez = bezFunction();

          var PropertyFactory = (function () {
            var initFrame = initialDefaultFrame;
            var mathAbs = Math.abs;

            function interpolateValue(frameNum, caching) {
              var offsetTime = this.offsetTime;
              var newValue;

              if (this.propType === "multidimensional") {
                newValue = createTypedArray("float32", this.pv.length);
              }

              var iterationIndex = caching.lastIndex;
              var i = iterationIndex;
              var len = this.keyframes.length - 1;
              var flag = true;
              var keyData;
              var nextKeyData;
              var keyframeMetadata;

              while (flag) {
                keyData = this.keyframes[i];
                nextKeyData = this.keyframes[i + 1];

                if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                  if (keyData.h) {
                    keyData = nextKeyData;
                  }

                  iterationIndex = 0;
                  break;
                }

                if (nextKeyData.t - offsetTime > frameNum) {
                  iterationIndex = i;
                  break;
                }

                if (i < len - 1) {
                  i += 1;
                } else {
                  iterationIndex = 0;
                  flag = false;
                }
              }

              keyframeMetadata = this.keyframesMetadata[i] || {};
              var k;
              var kLen;
              var perc;
              var jLen;
              var j;
              var fnc;
              var nextKeyTime = nextKeyData.t - offsetTime;
              var keyTime = keyData.t - offsetTime;
              var endValue;

              if (keyData.to) {
                if (!keyframeMetadata.bezierData) {
                  keyframeMetadata.bezierData = bez.buildBezierData(
                    keyData.s,
                    nextKeyData.s || keyData.e,
                    keyData.to,
                    keyData.ti
                  );
                }

                var bezierData = keyframeMetadata.bezierData;

                if (frameNum >= nextKeyTime || frameNum < keyTime) {
                  var ind =
                    frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                  kLen = bezierData.points[ind].point.length;

                  for (k = 0; k < kLen; k += 1) {
                    newValue[k] = bezierData.points[ind].point[k];
                  } // caching._lastKeyframeIndex = -1;
                } else {
                  if (keyframeMetadata.__fnct) {
                    fnc = keyframeMetadata.__fnct;
                  } else {
                    fnc = BezierFactory.getBezierEasing(
                      keyData.o.x,
                      keyData.o.y,
                      keyData.i.x,
                      keyData.i.y,
                      keyData.n
                    ).get;
                    keyframeMetadata.__fnct = fnc;
                  }

                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                  var distanceInLine = bezierData.segmentLength * perc;
                  var segmentPerc;
                  var addedLength =
                    caching.lastFrame < frameNum &&
                    caching._lastKeyframeIndex === i
                      ? caching._lastAddedLength
                      : 0;
                  j =
                    caching.lastFrame < frameNum &&
                    caching._lastKeyframeIndex === i
                      ? caching._lastPoint
                      : 0;
                  flag = true;
                  jLen = bezierData.points.length;

                  while (flag) {
                    addedLength += bezierData.points[j].partialLength;

                    if (
                      distanceInLine === 0 ||
                      perc === 0 ||
                      j === bezierData.points.length - 1
                    ) {
                      kLen = bezierData.points[j].point.length;

                      for (k = 0; k < kLen; k += 1) {
                        newValue[k] = bezierData.points[j].point[k];
                      }

                      break;
                    } else if (
                      distanceInLine >= addedLength &&
                      distanceInLine <
                        addedLength + bezierData.points[j + 1].partialLength
                    ) {
                      segmentPerc =
                        (distanceInLine - addedLength) /
                        bezierData.points[j + 1].partialLength;
                      kLen = bezierData.points[j].point.length;

                      for (k = 0; k < kLen; k += 1) {
                        newValue[k] =
                          bezierData.points[j].point[k] +
                          (bezierData.points[j + 1].point[k] -
                            bezierData.points[j].point[k]) *
                            segmentPerc;
                      }

                      break;
                    }

                    if (j < jLen - 1) {
                      j += 1;
                    } else {
                      flag = false;
                    }
                  }

                  caching._lastPoint = j;
                  caching._lastAddedLength =
                    addedLength - bezierData.points[j].partialLength;
                  caching._lastKeyframeIndex = i;
                }
              } else {
                var outX;
                var outY;
                var inX;
                var inY;
                var keyValue;
                len = keyData.s.length;
                endValue = nextKeyData.s || keyData.e;

                if (this.sh && keyData.h !== 1) {
                  if (frameNum >= nextKeyTime) {
                    newValue[0] = endValue[0];
                    newValue[1] = endValue[1];
                    newValue[2] = endValue[2];
                  } else if (frameNum <= keyTime) {
                    newValue[0] = keyData.s[0];
                    newValue[1] = keyData.s[1];
                    newValue[2] = keyData.s[2];
                  } else {
                    var quatStart = createQuaternion(keyData.s);
                    var quatEnd = createQuaternion(endValue);
                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                    quaternionToEuler(
                      newValue,
                      slerp(quatStart, quatEnd, time)
                    );
                  }
                } else {
                  for (i = 0; i < len; i += 1) {
                    if (keyData.h !== 1) {
                      if (frameNum >= nextKeyTime) {
                        perc = 1;
                      } else if (frameNum < keyTime) {
                        perc = 0;
                      } else {
                        if (keyData.o.x.constructor === Array) {
                          if (!keyframeMetadata.__fnct) {
                            keyframeMetadata.__fnct = [];
                          }

                          if (!keyframeMetadata.__fnct[i]) {
                            outX =
                              keyData.o.x[i] === undefined
                                ? keyData.o.x[0]
                                : keyData.o.x[i];
                            outY =
                              keyData.o.y[i] === undefined
                                ? keyData.o.y[0]
                                : keyData.o.y[i];
                            inX =
                              keyData.i.x[i] === undefined
                                ? keyData.i.x[0]
                                : keyData.i.x[i];
                            inY =
                              keyData.i.y[i] === undefined
                                ? keyData.i.y[0]
                                : keyData.i.y[i];
                            fnc = BezierFactory.getBezierEasing(
                              outX,
                              outY,
                              inX,
                              inY
                            ).get;
                            keyframeMetadata.__fnct[i] = fnc;
                          } else {
                            fnc = keyframeMetadata.__fnct[i];
                          }
                        } else if (!keyframeMetadata.__fnct) {
                          outX = keyData.o.x;
                          outY = keyData.o.y;
                          inX = keyData.i.x;
                          inY = keyData.i.y;
                          fnc = BezierFactory.getBezierEasing(
                            outX,
                            outY,
                            inX,
                            inY
                          ).get;
                          keyData.keyframeMetadata = fnc;
                        } else {
                          fnc = keyframeMetadata.__fnct;
                        }

                        perc = fnc(
                          (frameNum - keyTime) / (nextKeyTime - keyTime)
                        );
                      }
                    }

                    endValue = nextKeyData.s || keyData.e;
                    keyValue =
                      keyData.h === 1
                        ? keyData.s[i]
                        : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

                    if (this.propType === "multidimensional") {
                      newValue[i] = keyValue;
                    } else {
                      newValue = keyValue;
                    }
                  }
                }
              }

              caching.lastIndex = iterationIndex;
              return newValue;
            } // based on @Toji's https://github.com/toji/gl-matrix/

            function slerp(a, b, t) {
              var out = [];
              var ax = a[0];
              var ay = a[1];
              var az = a[2];
              var aw = a[3];
              var bx = b[0];
              var by = b[1];
              var bz = b[2];
              var bw = b[3];
              var omega;
              var cosom;
              var sinom;
              var scale0;
              var scale1;
              cosom = ax * bx + ay * by + az * bz + aw * bw;

              if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
              }

              if (1.0 - cosom > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
              } else {
                scale0 = 1.0 - t;
                scale1 = t;
              }

              out[0] = scale0 * ax + scale1 * bx;
              out[1] = scale0 * ay + scale1 * by;
              out[2] = scale0 * az + scale1 * bz;
              out[3] = scale0 * aw + scale1 * bw;
              return out;
            }

            function quaternionToEuler(out, quat) {
              var qx = quat[0];
              var qy = quat[1];
              var qz = quat[2];
              var qw = quat[3];
              var heading = Math.atan2(
                2 * qy * qw - 2 * qx * qz,
                1 - 2 * qy * qy - 2 * qz * qz
              );
              var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
              var bank = Math.atan2(
                2 * qx * qw - 2 * qy * qz,
                1 - 2 * qx * qx - 2 * qz * qz
              );
              out[0] = heading / degToRads;
              out[1] = attitude / degToRads;
              out[2] = bank / degToRads;
            }

            function createQuaternion(values) {
              var heading = values[0] * degToRads;
              var attitude = values[1] * degToRads;
              var bank = values[2] * degToRads;
              var c1 = Math.cos(heading / 2);
              var c2 = Math.cos(attitude / 2);
              var c3 = Math.cos(bank / 2);
              var s1 = Math.sin(heading / 2);
              var s2 = Math.sin(attitude / 2);
              var s3 = Math.sin(bank / 2);
              var w = c1 * c2 * c3 - s1 * s2 * s3;
              var x = s1 * s2 * c3 + c1 * c2 * s3;
              var y = s1 * c2 * c3 + c1 * s2 * s3;
              var z = c1 * s2 * c3 - s1 * c2 * s3;
              return [x, y, z, w];
            }

            function getValueAtCurrentTime() {
              var frameNum = this.comp.renderedFrame - this.offsetTime;
              var initTime = this.keyframes[0].t - this.offsetTime;
              var endTime =
                this.keyframes[this.keyframes.length - 1].t - this.offsetTime;

              if (
                !(
                  frameNum === this._caching.lastFrame ||
                  (this._caching.lastFrame !== initFrame &&
                    ((this._caching.lastFrame >= endTime &&
                      frameNum >= endTime) ||
                      (this._caching.lastFrame < initTime &&
                        frameNum < initTime)))
                )
              ) {
                if (this._caching.lastFrame >= frameNum) {
                  this._caching._lastKeyframeIndex = -1;
                  this._caching.lastIndex = 0;
                }

                var renderResult = this.interpolateValue(
                  frameNum,
                  this._caching
                );
                this.pv = renderResult;
              }

              this._caching.lastFrame = frameNum;
              return this.pv;
            }

            function setVValue(val) {
              var multipliedValue;

              if (this.propType === "unidimensional") {
                multipliedValue = val * this.mult;

                if (mathAbs(this.v - multipliedValue) > 0.00001) {
                  this.v = multipliedValue;
                  this._mdf = true;
                }
              } else {
                var i = 0;
                var len = this.v.length;

                while (i < len) {
                  multipliedValue = val[i] * this.mult;

                  if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
                    this.v[i] = multipliedValue;
                    this._mdf = true;
                  }

                  i += 1;
                }
              }
            }

            function processEffectsSequence() {
              if (
                this.elem.globalData.frameId === this.frameId ||
                !this.effectsSequence.length
              ) {
                return;
              }

              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }

              this.lock = true;
              this._mdf = this._isFirstFrame;
              var i;
              var len = this.effectsSequence.length;
              var finalValue = this.kf ? this.pv : this.data.k;

              for (i = 0; i < len; i += 1) {
                finalValue = this.effectsSequence[i](finalValue);
              }

              this.setVValue(finalValue);
              this._isFirstFrame = false;
              this.lock = false;
              this.frameId = this.elem.globalData.frameId;
            }

            function addEffect(effectFunction) {
              this.effectsSequence.push(effectFunction);
              this.container.addDynamicProperty(this);
            }

            function ValueProperty(elem, data, mult, container) {
              this.propType = "unidimensional";
              this.mult = mult || 1;
              this.data = data;
              this.v = mult ? data.k * mult : data.k;
              this.pv = data.k;
              this._mdf = false;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.k = false;
              this.kf = false;
              this.vel = 0;
              this.effectsSequence = [];
              this._isFirstFrame = true;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.addEffect = addEffect;
            }

            function MultiDimensionalProperty(elem, data, mult, container) {
              this.propType = "multidimensional";
              this.mult = mult || 1;
              this.data = data;
              this._mdf = false;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.k = false;
              this.kf = false;
              this.frameId = -1;
              var i;
              var len = data.k.length;
              this.v = createTypedArray("float32", len);
              this.pv = createTypedArray("float32", len);
              this.vel = createTypedArray("float32", len);

              for (i = 0; i < len; i += 1) {
                this.v[i] = data.k[i] * this.mult;
                this.pv[i] = data.k[i];
              }

              this._isFirstFrame = true;
              this.effectsSequence = [];
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.addEffect = addEffect;
            }

            function KeyframedValueProperty(elem, data, mult, container) {
              this.propType = "unidimensional";
              this.keyframes = data.k;
              this.keyframesMetadata = [];
              this.offsetTime = elem.data.st;
              this.frameId = -1;
              this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1,
              };
              this.k = true;
              this.kf = true;
              this.data = data;
              this.mult = mult || 1;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.v = initFrame;
              this.pv = initFrame;
              this._isFirstFrame = true;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.interpolateValue = interpolateValue;
              this.effectsSequence = [getValueAtCurrentTime.bind(this)];
              this.addEffect = addEffect;
            }

            function KeyframedMultidimensionalProperty(
              elem,
              data,
              mult,
              container
            ) {
              this.propType = "multidimensional";
              var i;
              var len = data.k.length;
              var s;
              var e;
              var to;
              var ti;

              for (i = 0; i < len - 1; i += 1) {
                if (
                  data.k[i].to &&
                  data.k[i].s &&
                  data.k[i + 1] &&
                  data.k[i + 1].s
                ) {
                  s = data.k[i].s;
                  e = data.k[i + 1].s;
                  to = data.k[i].to;
                  ti = data.k[i].ti;

                  if (
                    (s.length === 2 &&
                      !(s[0] === e[0] && s[1] === e[1]) &&
                      bez.pointOnLine2D(
                        s[0],
                        s[1],
                        e[0],
                        e[1],
                        s[0] + to[0],
                        s[1] + to[1]
                      ) &&
                      bez.pointOnLine2D(
                        s[0],
                        s[1],
                        e[0],
                        e[1],
                        e[0] + ti[0],
                        e[1] + ti[1]
                      )) ||
                    (s.length === 3 &&
                      !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) &&
                      bez.pointOnLine3D(
                        s[0],
                        s[1],
                        s[2],
                        e[0],
                        e[1],
                        e[2],
                        s[0] + to[0],
                        s[1] + to[1],
                        s[2] + to[2]
                      ) &&
                      bez.pointOnLine3D(
                        s[0],
                        s[1],
                        s[2],
                        e[0],
                        e[1],
                        e[2],
                        e[0] + ti[0],
                        e[1] + ti[1],
                        e[2] + ti[2]
                      ))
                  ) {
                    data.k[i].to = null;
                    data.k[i].ti = null;
                  }

                  if (
                    s[0] === e[0] &&
                    s[1] === e[1] &&
                    to[0] === 0 &&
                    to[1] === 0 &&
                    ti[0] === 0 &&
                    ti[1] === 0
                  ) {
                    if (
                      s.length === 2 ||
                      (s[2] === e[2] && to[2] === 0 && ti[2] === 0)
                    ) {
                      data.k[i].to = null;
                      data.k[i].ti = null;
                    }
                  }
                }
              }

              this.effectsSequence = [getValueAtCurrentTime.bind(this)];
              this.data = data;
              this.keyframes = data.k;
              this.keyframesMetadata = [];
              this.offsetTime = elem.data.st;
              this.k = true;
              this.kf = true;
              this._isFirstFrame = true;
              this.mult = mult || 1;
              this.elem = elem;
              this.container = container;
              this.comp = elem.comp;
              this.getValue = processEffectsSequence;
              this.setVValue = setVValue;
              this.interpolateValue = interpolateValue;
              this.frameId = -1;
              var arrLen = data.k[0].s.length;
              this.v = createTypedArray("float32", arrLen);
              this.pv = createTypedArray("float32", arrLen);

              for (i = 0; i < arrLen; i += 1) {
                this.v[i] = initFrame;
                this.pv[i] = initFrame;
              }

              this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", arrLen),
              };
              this.addEffect = addEffect;
            }

            function getProp(elem, data, type, mult, container) {
              var p;

              if (!data.k.length) {
                p = new ValueProperty(elem, data, mult, container);
              } else if (typeof data.k[0] === "number") {
                p = new MultiDimensionalProperty(elem, data, mult, container);
              } else {
                switch (type) {
                  case 0:
                    p = new KeyframedValueProperty(elem, data, mult, container);
                    break;

                  case 1:
                    p = new KeyframedMultidimensionalProperty(
                      elem,
                      data,
                      mult,
                      container
                    );
                    break;

                  default:
                    break;
                }
              }

              if (p.effectsSequence.length) {
                container.addDynamicProperty(p);
              }

              return p;
            }

            var ob = {
              getProp: getProp,
            };
            return ob;
          })();

          function DynamicPropertyContainer() {}

          DynamicPropertyContainer.prototype = {
            addDynamicProperty: function addDynamicProperty(prop) {
              if (this.dynamicProperties.indexOf(prop) === -1) {
                this.dynamicProperties.push(prop);
                this.container.addDynamicProperty(this);
                this._isAnimated = true;
              }
            },
            iterateDynamicProperties: function iterateDynamicProperties() {
              this._mdf = false;
              var i;
              var len = this.dynamicProperties.length;

              for (i = 0; i < len; i += 1) {
                this.dynamicProperties[i].getValue();

                if (this.dynamicProperties[i]._mdf) {
                  this._mdf = true;
                }
              }
            },
            initDynamicPropertyContainer: function initDynamicPropertyContainer(
              container
            ) {
              this.container = container;
              this.dynamicProperties = [];
              this._mdf = false;
              this._isAnimated = false;
            },
          };

          var pointPool = (function () {
            function create() {
              return createTypedArray("float32", 2);
            }

            return poolFactory(8, create);
          })();

          function ShapePath() {
            this.c = false;
            this._length = 0;
            this._maxLength = 8;
            this.v = createSizedArray(this._maxLength);
            this.o = createSizedArray(this._maxLength);
            this.i = createSizedArray(this._maxLength);
          }

          ShapePath.prototype.setPathData = function (closed, len) {
            this.c = closed;
            this.setLength(len);
            var i = 0;

            while (i < len) {
              this.v[i] = pointPool.newElement();
              this.o[i] = pointPool.newElement();
              this.i[i] = pointPool.newElement();
              i += 1;
            }
          };

          ShapePath.prototype.setLength = function (len) {
            while (this._maxLength < len) {
              this.doubleArrayLength();
            }

            this._length = len;
          };

          ShapePath.prototype.doubleArrayLength = function () {
            this.v = this.v.concat(createSizedArray(this._maxLength));
            this.i = this.i.concat(createSizedArray(this._maxLength));
            this.o = this.o.concat(createSizedArray(this._maxLength));
            this._maxLength *= 2;
          };

          ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
            var arr;
            this._length = Math.max(this._length, pos + 1);

            if (this._length >= this._maxLength) {
              this.doubleArrayLength();
            }

            switch (type) {
              case "v":
                arr = this.v;
                break;

              case "i":
                arr = this.i;
                break;

              case "o":
                arr = this.o;
                break;

              default:
                arr = [];
                break;
            }

            if (!arr[pos] || (arr[pos] && !replace)) {
              arr[pos] = pointPool.newElement();
            }

            arr[pos][0] = x;
            arr[pos][1] = y;
          };

          ShapePath.prototype.setTripleAt = function (
            vX,
            vY,
            oX,
            oY,
            iX,
            iY,
            pos,
            replace
          ) {
            this.setXYAt(vX, vY, "v", pos, replace);
            this.setXYAt(oX, oY, "o", pos, replace);
            this.setXYAt(iX, iY, "i", pos, replace);
          };

          ShapePath.prototype.reverse = function () {
            var newPath = new ShapePath();
            newPath.setPathData(this.c, this._length);
            var vertices = this.v;
            var outPoints = this.o;
            var inPoints = this.i;
            var init = 0;

            if (this.c) {
              newPath.setTripleAt(
                vertices[0][0],
                vertices[0][1],
                inPoints[0][0],
                inPoints[0][1],
                outPoints[0][0],
                outPoints[0][1],
                0,
                false
              );
              init = 1;
            }

            var cnt = this._length - 1;
            var len = this._length;
            var i;

            for (i = init; i < len; i += 1) {
              newPath.setTripleAt(
                vertices[cnt][0],
                vertices[cnt][1],
                inPoints[cnt][0],
                inPoints[cnt][1],
                outPoints[cnt][0],
                outPoints[cnt][1],
                i,
                false
              );
              cnt -= 1;
            }

            return newPath;
          };

          var shapePool = (function () {
            function create() {
              return new ShapePath();
            }

            function release(shapePath) {
              var len = shapePath._length;
              var i;

              for (i = 0; i < len; i += 1) {
                pointPool.release(shapePath.v[i]);
                pointPool.release(shapePath.i[i]);
                pointPool.release(shapePath.o[i]);
                shapePath.v[i] = null;
                shapePath.i[i] = null;
                shapePath.o[i] = null;
              }

              shapePath._length = 0;
              shapePath.c = false;
            }

            function clone(shape) {
              var cloned = factory.newElement();
              var i;
              var len =
                shape._length === undefined ? shape.v.length : shape._length;
              cloned.setLength(len);
              cloned.c = shape.c;

              for (i = 0; i < len; i += 1) {
                cloned.setTripleAt(
                  shape.v[i][0],
                  shape.v[i][1],
                  shape.o[i][0],
                  shape.o[i][1],
                  shape.i[i][0],
                  shape.i[i][1],
                  i
                );
              }

              return cloned;
            }

            var factory = poolFactory(4, create, release);
            factory.clone = clone;
            return factory;
          })();

          function ShapeCollection() {
            this._length = 0;
            this._maxLength = 4;
            this.shapes = createSizedArray(this._maxLength);
          }

          ShapeCollection.prototype.addShape = function (shapeData) {
            if (this._length === this._maxLength) {
              this.shapes = this.shapes.concat(
                createSizedArray(this._maxLength)
              );
              this._maxLength *= 2;
            }

            this.shapes[this._length] = shapeData;
            this._length += 1;
          };

          ShapeCollection.prototype.releaseShapes = function () {
            var i;

            for (i = 0; i < this._length; i += 1) {
              shapePool.release(this.shapes[i]);
            }

            this._length = 0;
          };

          var shapeCollectionPool = (function () {
            var ob = {
              newShapeCollection: newShapeCollection,
              release: release,
            };
            var _length = 0;
            var _maxLength = 4;
            var pool = createSizedArray(_maxLength);

            function newShapeCollection() {
              var shapeCollection;

              if (_length) {
                _length -= 1;
                shapeCollection = pool[_length];
              } else {
                shapeCollection = new ShapeCollection();
              }

              return shapeCollection;
            }

            function release(shapeCollection) {
              var i;
              var len = shapeCollection._length;

              for (i = 0; i < len; i += 1) {
                shapePool.release(shapeCollection.shapes[i]);
              }

              shapeCollection._length = 0;

              if (_length === _maxLength) {
                pool = pooling["double"](pool);
                _maxLength *= 2;
              }

              pool[_length] = shapeCollection;
              _length += 1;
            }

            return ob;
          })();

          var ShapePropertyFactory = (function () {
            var initFrame = -999999;

            function interpolateShape(frameNum, previousValue, caching) {
              var iterationIndex = caching.lastIndex;
              var keyPropS;
              var keyPropE;
              var isHold;
              var j;
              var k;
              var jLen;
              var kLen;
              var perc;
              var vertexValue;
              var kf = this.keyframes;

              if (frameNum < kf[0].t - this.offsetTime) {
                keyPropS = kf[0].s[0];
                isHold = true;
                iterationIndex = 0;
              } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
                keyPropS = kf[kf.length - 1].s
                  ? kf[kf.length - 1].s[0]
                  : kf[kf.length - 2].e[0];
                /* if(kf[kf.length - 1].s){
                  keyPropS = kf[kf.length - 1].s[0];
              }else{
                  keyPropS = kf[kf.length - 2].e[0];
              } */

                isHold = true;
              } else {
                var i = iterationIndex;
                var len = kf.length - 1;
                var flag = true;
                var keyData;
                var nextKeyData;
                var keyframeMetadata;

                while (flag) {
                  keyData = kf[i];
                  nextKeyData = kf[i + 1];

                  if (nextKeyData.t - this.offsetTime > frameNum) {
                    break;
                  }

                  if (i < len - 1) {
                    i += 1;
                  } else {
                    flag = false;
                  }
                }

                keyframeMetadata = this.keyframesMetadata[i] || {};
                isHold = keyData.h === 1;
                iterationIndex = i;

                if (!isHold) {
                  if (frameNum >= nextKeyData.t - this.offsetTime) {
                    perc = 1;
                  } else if (frameNum < keyData.t - this.offsetTime) {
                    perc = 0;
                  } else {
                    var fnc;

                    if (keyframeMetadata.__fnct) {
                      fnc = keyframeMetadata.__fnct;
                    } else {
                      fnc = BezierFactory.getBezierEasing(
                        keyData.o.x,
                        keyData.o.y,
                        keyData.i.x,
                        keyData.i.y
                      ).get;
                      keyframeMetadata.__fnct = fnc;
                    }

                    perc = fnc(
                      (frameNum - (keyData.t - this.offsetTime)) /
                        (nextKeyData.t -
                          this.offsetTime -
                          (keyData.t - this.offsetTime))
                    );
                  }

                  keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
                }

                keyPropS = keyData.s[0];
              }

              jLen = previousValue._length;
              kLen = keyPropS.i[0].length;
              caching.lastIndex = iterationIndex;

              for (j = 0; j < jLen; j += 1) {
                for (k = 0; k < kLen; k += 1) {
                  vertexValue = isHold
                    ? keyPropS.i[j][k]
                    : keyPropS.i[j][k] +
                      (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
                  previousValue.i[j][k] = vertexValue;
                  vertexValue = isHold
                    ? keyPropS.o[j][k]
                    : keyPropS.o[j][k] +
                      (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
                  previousValue.o[j][k] = vertexValue;
                  vertexValue = isHold
                    ? keyPropS.v[j][k]
                    : keyPropS.v[j][k] +
                      (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
                  previousValue.v[j][k] = vertexValue;
                }
              }
            }

            function interpolateShapeCurrentTime() {
              var frameNum = this.comp.renderedFrame - this.offsetTime;
              var initTime = this.keyframes[0].t - this.offsetTime;
              var endTime =
                this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
              var lastFrame = this._caching.lastFrame;

              if (
                !(
                  lastFrame !== initFrame &&
                  ((lastFrame < initTime && frameNum < initTime) ||
                    (lastFrame > endTime && frameNum > endTime))
                )
              ) {
                /// /
                this._caching.lastIndex =
                  lastFrame < frameNum ? this._caching.lastIndex : 0;
                this.interpolateShape(frameNum, this.pv, this._caching); /// /
              }

              this._caching.lastFrame = frameNum;
              return this.pv;
            }

            function resetShape() {
              this.paths = this.localShapeCollection;
            }

            function shapesEqual(shape1, shape2) {
              if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
                return false;
              }

              var i;
              var len = shape1._length;

              for (i = 0; i < len; i += 1) {
                if (
                  shape1.v[i][0] !== shape2.v[i][0] ||
                  shape1.v[i][1] !== shape2.v[i][1] ||
                  shape1.o[i][0] !== shape2.o[i][0] ||
                  shape1.o[i][1] !== shape2.o[i][1] ||
                  shape1.i[i][0] !== shape2.i[i][0] ||
                  shape1.i[i][1] !== shape2.i[i][1]
                ) {
                  return false;
                }
              }

              return true;
            }

            function setVValue(newPath) {
              if (!shapesEqual(this.v, newPath)) {
                this.v = shapePool.clone(newPath);
                this.localShapeCollection.releaseShapes();
                this.localShapeCollection.addShape(this.v);
                this._mdf = true;
                this.paths = this.localShapeCollection;
              }
            }

            function processEffectsSequence() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }

              if (!this.effectsSequence.length) {
                this._mdf = false;
                return;
              }

              if (this.lock) {
                this.setVValue(this.pv);
                return;
              }

              this.lock = true;
              this._mdf = false;
              var finalValue;

              if (this.kf) {
                finalValue = this.pv;
              } else if (this.data.ks) {
                finalValue = this.data.ks.k;
              } else {
                finalValue = this.data.pt.k;
              }

              var i;
              var len = this.effectsSequence.length;

              for (i = 0; i < len; i += 1) {
                finalValue = this.effectsSequence[i](finalValue);
              }

              this.setVValue(finalValue);
              this.lock = false;
              this.frameId = this.elem.globalData.frameId;
            }

            function ShapeProperty(elem, data, type) {
              this.propType = "shape";
              this.comp = elem.comp;
              this.container = elem;
              this.elem = elem;
              this.data = data;
              this.k = false;
              this.kf = false;
              this._mdf = false;
              var pathData = type === 3 ? data.pt.k : data.ks.k;
              this.v = shapePool.clone(pathData);
              this.pv = shapePool.clone(this.v);
              this.localShapeCollection =
                shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.paths.addShape(this.v);
              this.reset = resetShape;
              this.effectsSequence = [];
            }

            function addEffect(effectFunction) {
              this.effectsSequence.push(effectFunction);
              this.container.addDynamicProperty(this);
            }

            ShapeProperty.prototype.interpolateShape = interpolateShape;
            ShapeProperty.prototype.getValue = processEffectsSequence;
            ShapeProperty.prototype.setVValue = setVValue;
            ShapeProperty.prototype.addEffect = addEffect;

            function KeyframedShapeProperty(elem, data, type) {
              this.propType = "shape";
              this.comp = elem.comp;
              this.elem = elem;
              this.container = elem;
              this.offsetTime = elem.data.st;
              this.keyframes = type === 3 ? data.pt.k : data.ks.k;
              this.keyframesMetadata = [];
              this.k = true;
              this.kf = true;
              var len = this.keyframes[0].s[0].i.length;
              this.v = shapePool.newElement();
              this.v.setPathData(this.keyframes[0].s[0].c, len);
              this.pv = shapePool.clone(this.v);
              this.localShapeCollection =
                shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.paths.addShape(this.v);
              this.lastFrame = initFrame;
              this.reset = resetShape;
              this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
              };
              this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
            }

            KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
            KeyframedShapeProperty.prototype.interpolateShape =
              interpolateShape;
            KeyframedShapeProperty.prototype.setVValue = setVValue;
            KeyframedShapeProperty.prototype.addEffect = addEffect;

            var EllShapeProperty = (function () {
              var cPoint = roundCorner;

              function EllShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.setPathData(true, 4);
                this.localShapeCollection =
                  shapeCollectionPool.newShapeCollection();
                this.paths = this.localShapeCollection;
                this.localShapeCollection.addShape(this.v);
                this.d = data.d;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);

                if (this.dynamicProperties.length) {
                  this.k = true;
                } else {
                  this.k = false;
                  this.convertEllToPath();
                }
              }

              EllShapePropertyFactory.prototype = {
                reset: resetShape,
                getValue: function getValue() {
                  if (this.elem.globalData.frameId === this.frameId) {
                    return;
                  }

                  this.frameId = this.elem.globalData.frameId;
                  this.iterateDynamicProperties();

                  if (this._mdf) {
                    this.convertEllToPath();
                  }
                },
                convertEllToPath: function convertEllToPath() {
                  var p0 = this.p.v[0];
                  var p1 = this.p.v[1];
                  var s0 = this.s.v[0] / 2;
                  var s1 = this.s.v[1] / 2;

                  var _cw = this.d !== 3;

                  var _v = this.v;
                  _v.v[0][0] = p0;
                  _v.v[0][1] = p1 - s1;
                  _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                  _v.v[1][1] = p1;
                  _v.v[2][0] = p0;
                  _v.v[2][1] = p1 + s1;
                  _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                  _v.v[3][1] = p1;
                  _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                  _v.i[0][1] = p1 - s1;
                  _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                  _v.i[1][1] = p1 - s1 * cPoint;
                  _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                  _v.i[2][1] = p1 + s1;
                  _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                  _v.i[3][1] = p1 + s1 * cPoint;
                  _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                  _v.o[0][1] = p1 - s1;
                  _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                  _v.o[1][1] = p1 + s1 * cPoint;
                  _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                  _v.o[2][1] = p1 + s1;
                  _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                  _v.o[3][1] = p1 - s1 * cPoint;
                },
              };
              extendPrototype(
                [DynamicPropertyContainer],
                EllShapePropertyFactory
              );
              return EllShapePropertyFactory;
            })();

            var StarShapeProperty = (function () {
              function StarShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.setPathData(true, 0);
                this.elem = elem;
                this.comp = elem.comp;
                this.data = data;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);

                if (data.sy === 1) {
                  this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
                  this.is = PropertyFactory.getProp(
                    elem,
                    data.is,
                    0,
                    0.01,
                    this
                  );
                  this.convertToPath = this.convertStarToPath;
                } else {
                  this.convertToPath = this.convertPolygonToPath;
                }

                this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.r = PropertyFactory.getProp(
                  elem,
                  data.r,
                  0,
                  degToRads,
                  this
                );
                this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
                this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
                this.localShapeCollection =
                  shapeCollectionPool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;

                if (this.dynamicProperties.length) {
                  this.k = true;
                } else {
                  this.k = false;
                  this.convertToPath();
                }
              }

              StarShapePropertyFactory.prototype = {
                reset: resetShape,
                getValue: function getValue() {
                  if (this.elem.globalData.frameId === this.frameId) {
                    return;
                  }

                  this.frameId = this.elem.globalData.frameId;
                  this.iterateDynamicProperties();

                  if (this._mdf) {
                    this.convertToPath();
                  }
                },
                convertStarToPath: function convertStarToPath() {
                  var numPts = Math.floor(this.pt.v) * 2;
                  var angle = (Math.PI * 2) / numPts;
                  /* this.v.v.length = numPts;
                  this.v.i.length = numPts;
                  this.v.o.length = numPts; */

                  var longFlag = true;
                  var longRad = this.or.v;
                  var shortRad = this.ir.v;
                  var longRound = this.os.v;
                  var shortRound = this.is.v;
                  var longPerimSegment = (2 * Math.PI * longRad) / (numPts * 2);
                  var shortPerimSegment =
                    (2 * Math.PI * shortRad) / (numPts * 2);
                  var i;
                  var rad;
                  var roundness;
                  var perimSegment;
                  var currentAng = -Math.PI / 2;
                  currentAng += this.r.v;
                  var dir = this.data.d === 3 ? -1 : 1;
                  this.v._length = 0;

                  for (i = 0; i < numPts; i += 1) {
                    rad = longFlag ? longRad : shortRad;
                    roundness = longFlag ? longRound : shortRound;
                    perimSegment = longFlag
                      ? longPerimSegment
                      : shortPerimSegment;
                    var x = rad * Math.cos(currentAng);
                    var y = rad * Math.sin(currentAng);
                    var ox =
                      x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                    var oy =
                      x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                    x += +this.p.v[0];
                    y += +this.p.v[1];
                    this.v.setTripleAt(
                      x,
                      y,
                      x - ox * perimSegment * roundness * dir,
                      y - oy * perimSegment * roundness * dir,
                      x + ox * perimSegment * roundness * dir,
                      y + oy * perimSegment * roundness * dir,
                      i,
                      true
                    );
                    /* this.v.v[i] = [x,y];
                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                      this.v._length = numPts; */

                    longFlag = !longFlag;
                    currentAng += angle * dir;
                  }
                },
                convertPolygonToPath: function convertPolygonToPath() {
                  var numPts = Math.floor(this.pt.v);
                  var angle = (Math.PI * 2) / numPts;
                  var rad = this.or.v;
                  var roundness = this.os.v;
                  var perimSegment = (2 * Math.PI * rad) / (numPts * 4);
                  var i;
                  var currentAng = -Math.PI * 0.5;
                  var dir = this.data.d === 3 ? -1 : 1;
                  currentAng += this.r.v;
                  this.v._length = 0;

                  for (i = 0; i < numPts; i += 1) {
                    var x = rad * Math.cos(currentAng);
                    var y = rad * Math.sin(currentAng);
                    var ox =
                      x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                    var oy =
                      x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                    x += +this.p.v[0];
                    y += +this.p.v[1];
                    this.v.setTripleAt(
                      x,
                      y,
                      x - ox * perimSegment * roundness * dir,
                      y - oy * perimSegment * roundness * dir,
                      x + ox * perimSegment * roundness * dir,
                      y + oy * perimSegment * roundness * dir,
                      i,
                      true
                    );
                    currentAng += angle * dir;
                  }

                  this.paths.length = 0;
                  this.paths[0] = this.v;
                },
              };
              extendPrototype(
                [DynamicPropertyContainer],
                StarShapePropertyFactory
              );
              return StarShapePropertyFactory;
            })();

            var RectShapeProperty = (function () {
              function RectShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.c = true;
                this.localShapeCollection =
                  shapeCollectionPool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);

                if (this.dynamicProperties.length) {
                  this.k = true;
                } else {
                  this.k = false;
                  this.convertRectToPath();
                }
              }

              RectShapePropertyFactory.prototype = {
                convertRectToPath: function convertRectToPath() {
                  var p0 = this.p.v[0];
                  var p1 = this.p.v[1];
                  var v0 = this.s.v[0] / 2;
                  var v1 = this.s.v[1] / 2;
                  var round = bmMin(v0, v1, this.r.v);
                  var cPoint = round * (1 - roundCorner);
                  this.v._length = 0;

                  if (this.d === 2 || this.d === 1) {
                    this.v.setTripleAt(
                      p0 + v0,
                      p1 - v1 + round,
                      p0 + v0,
                      p1 - v1 + round,
                      p0 + v0,
                      p1 - v1 + cPoint,
                      0,
                      true
                    );
                    this.v.setTripleAt(
                      p0 + v0,
                      p1 + v1 - round,
                      p0 + v0,
                      p1 + v1 - cPoint,
                      p0 + v0,
                      p1 + v1 - round,
                      1,
                      true
                    );

                    if (round !== 0) {
                      this.v.setTripleAt(
                        p0 + v0 - round,
                        p1 + v1,
                        p0 + v0 - round,
                        p1 + v1,
                        p0 + v0 - cPoint,
                        p1 + v1,
                        2,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0 + round,
                        p1 + v1,
                        p0 - v0 + cPoint,
                        p1 + v1,
                        p0 - v0 + round,
                        p1 + v1,
                        3,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 + v1 - round,
                        p0 - v0,
                        p1 + v1 - round,
                        p0 - v0,
                        p1 + v1 - cPoint,
                        4,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 - v1 + round,
                        p0 - v0,
                        p1 - v1 + cPoint,
                        p0 - v0,
                        p1 - v1 + round,
                        5,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0 + round,
                        p1 - v1,
                        p0 - v0 + round,
                        p1 - v1,
                        p0 - v0 + cPoint,
                        p1 - v1,
                        6,
                        true
                      );
                      this.v.setTripleAt(
                        p0 + v0 - round,
                        p1 - v1,
                        p0 + v0 - cPoint,
                        p1 - v1,
                        p0 + v0 - round,
                        p1 - v1,
                        7,
                        true
                      );
                    } else {
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 + v1,
                        p0 - v0 + cPoint,
                        p1 + v1,
                        p0 - v0,
                        p1 + v1,
                        2
                      );
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 - v1,
                        p0 - v0,
                        p1 - v1 + cPoint,
                        p0 - v0,
                        p1 - v1,
                        3
                      );
                    }
                  } else {
                    this.v.setTripleAt(
                      p0 + v0,
                      p1 - v1 + round,
                      p0 + v0,
                      p1 - v1 + cPoint,
                      p0 + v0,
                      p1 - v1 + round,
                      0,
                      true
                    );

                    if (round !== 0) {
                      this.v.setTripleAt(
                        p0 + v0 - round,
                        p1 - v1,
                        p0 + v0 - round,
                        p1 - v1,
                        p0 + v0 - cPoint,
                        p1 - v1,
                        1,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0 + round,
                        p1 - v1,
                        p0 - v0 + cPoint,
                        p1 - v1,
                        p0 - v0 + round,
                        p1 - v1,
                        2,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 - v1 + round,
                        p0 - v0,
                        p1 - v1 + round,
                        p0 - v0,
                        p1 - v1 + cPoint,
                        3,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 + v1 - round,
                        p0 - v0,
                        p1 + v1 - cPoint,
                        p0 - v0,
                        p1 + v1 - round,
                        4,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0 + round,
                        p1 + v1,
                        p0 - v0 + round,
                        p1 + v1,
                        p0 - v0 + cPoint,
                        p1 + v1,
                        5,
                        true
                      );
                      this.v.setTripleAt(
                        p0 + v0 - round,
                        p1 + v1,
                        p0 + v0 - cPoint,
                        p1 + v1,
                        p0 + v0 - round,
                        p1 + v1,
                        6,
                        true
                      );
                      this.v.setTripleAt(
                        p0 + v0,
                        p1 + v1 - round,
                        p0 + v0,
                        p1 + v1 - round,
                        p0 + v0,
                        p1 + v1 - cPoint,
                        7,
                        true
                      );
                    } else {
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 - v1,
                        p0 - v0 + cPoint,
                        p1 - v1,
                        p0 - v0,
                        p1 - v1,
                        1,
                        true
                      );
                      this.v.setTripleAt(
                        p0 - v0,
                        p1 + v1,
                        p0 - v0,
                        p1 + v1 - cPoint,
                        p0 - v0,
                        p1 + v1,
                        2,
                        true
                      );
                      this.v.setTripleAt(
                        p0 + v0,
                        p1 + v1,
                        p0 + v0 - cPoint,
                        p1 + v1,
                        p0 + v0,
                        p1 + v1,
                        3,
                        true
                      );
                    }
                  }
                },
                getValue: function getValue() {
                  if (this.elem.globalData.frameId === this.frameId) {
                    return;
                  }

                  this.frameId = this.elem.globalData.frameId;
                  this.iterateDynamicProperties();

                  if (this._mdf) {
                    this.convertRectToPath();
                  }
                },
                reset: resetShape,
              };
              extendPrototype(
                [DynamicPropertyContainer],
                RectShapePropertyFactory
              );
              return RectShapePropertyFactory;
            })();

            function getShapeProp(elem, data, type) {
              var prop;

              if (type === 3 || type === 4) {
                var dataProp = type === 3 ? data.pt : data.ks;
                var keys = dataProp.k;

                if (keys.length) {
                  prop = new KeyframedShapeProperty(elem, data, type);
                } else {
                  prop = new ShapeProperty(elem, data, type);
                }
              } else if (type === 5) {
                prop = new RectShapeProperty(elem, data);
              } else if (type === 6) {
                prop = new EllShapeProperty(elem, data);
              } else if (type === 7) {
                prop = new StarShapeProperty(elem, data);
              }

              if (prop.k) {
                elem.addDynamicProperty(prop);
              }

              return prop;
            }

            function getConstructorFunction() {
              return ShapeProperty;
            }

            function getKeyframedConstructorFunction() {
              return KeyframedShapeProperty;
            }

            var ob = {};
            ob.getShapeProp = getShapeProp;
            ob.getConstructorFunction = getConstructorFunction;
            ob.getKeyframedConstructorFunction =
              getKeyframedConstructorFunction;
            return ob;
          })();

          /*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   */

          /**
           * 2D transformation matrix object initialized with identity matrix.
           *
           * The matrix can synchronize a canvas context by supplying the context
           * as an argument, or later apply current absolute transform to an
           * existing context.
           *
           * All values are handled as floating point values.
           *
           * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
           * @prop {number} a - scale x
           * @prop {number} b - shear y
           * @prop {number} c - shear x
           * @prop {number} d - scale y
           * @prop {number} e - translate x
           * @prop {number} f - translate y
           * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
           * @constructor
           */

          var Matrix = (function () {
            var _cos = Math.cos;
            var _sin = Math.sin;
            var _tan = Math.tan;
            var _rnd = Math.round;

            function reset() {
              this.props[0] = 1;
              this.props[1] = 0;
              this.props[2] = 0;
              this.props[3] = 0;
              this.props[4] = 0;
              this.props[5] = 1;
              this.props[6] = 0;
              this.props[7] = 0;
              this.props[8] = 0;
              this.props[9] = 0;
              this.props[10] = 1;
              this.props[11] = 0;
              this.props[12] = 0;
              this.props[13] = 0;
              this.props[14] = 0;
              this.props[15] = 1;
              return this;
            }

            function rotate(angle) {
              if (angle === 0) {
                return this;
              }

              var mCos = _cos(angle);

              var mSin = _sin(angle);

              return this._t(
                mCos,
                -mSin,
                0,
                0,
                mSin,
                mCos,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              );
            }

            function rotateX(angle) {
              if (angle === 0) {
                return this;
              }

              var mCos = _cos(angle);

              var mSin = _sin(angle);

              return this._t(
                1,
                0,
                0,
                0,
                0,
                mCos,
                -mSin,
                0,
                0,
                mSin,
                mCos,
                0,
                0,
                0,
                0,
                1
              );
            }

            function rotateY(angle) {
              if (angle === 0) {
                return this;
              }

              var mCos = _cos(angle);

              var mSin = _sin(angle);

              return this._t(
                mCos,
                0,
                mSin,
                0,
                0,
                1,
                0,
                0,
                -mSin,
                0,
                mCos,
                0,
                0,
                0,
                0,
                1
              );
            }

            function rotateZ(angle) {
              if (angle === 0) {
                return this;
              }

              var mCos = _cos(angle);

              var mSin = _sin(angle);

              return this._t(
                mCos,
                -mSin,
                0,
                0,
                mSin,
                mCos,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              );
            }

            function shear(sx, sy) {
              return this._t(1, sy, sx, 1, 0, 0);
            }

            function skew(ax, ay) {
              return this.shear(_tan(ax), _tan(ay));
            }

            function skewFromAxis(ax, angle) {
              var mCos = _cos(angle);

              var mSin = _sin(angle);

              return this._t(
                mCos,
                mSin,
                0,
                0,
                -mSin,
                mCos,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
              )
                ._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                ._t(
                  mCos,
                  -mSin,
                  0,
                  0,
                  mSin,
                  mCos,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  1
                ); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
            }

            function scale(sx, sy, sz) {
              if (!sz && sz !== 0) {
                sz = 1;
              }

              if (sx === 1 && sy === 1 && sz === 1) {
                return this;
              }

              return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
            }

            function setTransform(
              a,
              b,
              c,
              d,
              e,
              f,
              g,
              h,
              i,
              j,
              k,
              l,
              m,
              n,
              o,
              p
            ) {
              this.props[0] = a;
              this.props[1] = b;
              this.props[2] = c;
              this.props[3] = d;
              this.props[4] = e;
              this.props[5] = f;
              this.props[6] = g;
              this.props[7] = h;
              this.props[8] = i;
              this.props[9] = j;
              this.props[10] = k;
              this.props[11] = l;
              this.props[12] = m;
              this.props[13] = n;
              this.props[14] = o;
              this.props[15] = p;
              return this;
            }

            function translate(tx, ty, tz) {
              tz = tz || 0;

              if (tx !== 0 || ty !== 0 || tz !== 0) {
                return this._t(
                  1,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  tx,
                  ty,
                  tz,
                  1
                );
              }

              return this;
            }

            function transform(
              a2,
              b2,
              c2,
              d2,
              e2,
              f2,
              g2,
              h2,
              i2,
              j2,
              k2,
              l2,
              m2,
              n2,
              o2,
              p2
            ) {
              var _p = this.props;

              if (
                a2 === 1 &&
                b2 === 0 &&
                c2 === 0 &&
                d2 === 0 &&
                e2 === 0 &&
                f2 === 1 &&
                g2 === 0 &&
                h2 === 0 &&
                i2 === 0 &&
                j2 === 0 &&
                k2 === 1 &&
                l2 === 0
              ) {
                // NOTE: commenting this condition because TurboFan deoptimizes code when present
                // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
                _p[12] = _p[12] * a2 + _p[15] * m2;
                _p[13] = _p[13] * f2 + _p[15] * n2;
                _p[14] = _p[14] * k2 + _p[15] * o2;
                _p[15] *= p2; // }

                this._identityCalculated = false;
                return this;
              }

              var a1 = _p[0];
              var b1 = _p[1];
              var c1 = _p[2];
              var d1 = _p[3];
              var e1 = _p[4];
              var f1 = _p[5];
              var g1 = _p[6];
              var h1 = _p[7];
              var i1 = _p[8];
              var j1 = _p[9];
              var k1 = _p[10];
              var l1 = _p[11];
              var m1 = _p[12];
              var n1 = _p[13];
              var o1 = _p[14];
              var p1 = _p[15];
              /* matrix order (canvas compatible):
               * ace
               * bdf
               * 001
               */

              _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
              _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
              _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
              _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
              _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
              _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
              _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
              _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
              _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
              _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
              _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
              _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
              _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
              _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
              _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
              _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
              this._identityCalculated = false;
              return this;
            }

            function isIdentity() {
              if (!this._identityCalculated) {
                this._identity = !(
                  this.props[0] !== 1 ||
                  this.props[1] !== 0 ||
                  this.props[2] !== 0 ||
                  this.props[3] !== 0 ||
                  this.props[4] !== 0 ||
                  this.props[5] !== 1 ||
                  this.props[6] !== 0 ||
                  this.props[7] !== 0 ||
                  this.props[8] !== 0 ||
                  this.props[9] !== 0 ||
                  this.props[10] !== 1 ||
                  this.props[11] !== 0 ||
                  this.props[12] !== 0 ||
                  this.props[13] !== 0 ||
                  this.props[14] !== 0 ||
                  this.props[15] !== 1
                );
                this._identityCalculated = true;
              }

              return this._identity;
            }

            function equals(matr) {
              var i = 0;

              while (i < 16) {
                if (matr.props[i] !== this.props[i]) {
                  return false;
                }

                i += 1;
              }

              return true;
            }

            function clone(matr) {
              var i;

              for (i = 0; i < 16; i += 1) {
                matr.props[i] = this.props[i];
              }

              return matr;
            }

            function cloneFromProps(props) {
              var i;

              for (i = 0; i < 16; i += 1) {
                this.props[i] = props[i];
              }
            }

            function applyToPoint(x, y, z) {
              return {
                x:
                  x * this.props[0] +
                  y * this.props[4] +
                  z * this.props[8] +
                  this.props[12],
                y:
                  x * this.props[1] +
                  y * this.props[5] +
                  z * this.props[9] +
                  this.props[13],
                z:
                  x * this.props[2] +
                  y * this.props[6] +
                  z * this.props[10] +
                  this.props[14],
              };
              /* return {
           x: x * me.a + y * me.c + me.e,
           y: x * me.b + y * me.d + me.f
           }; */
            }

            function applyToX(x, y, z) {
              return (
                x * this.props[0] +
                y * this.props[4] +
                z * this.props[8] +
                this.props[12]
              );
            }

            function applyToY(x, y, z) {
              return (
                x * this.props[1] +
                y * this.props[5] +
                z * this.props[9] +
                this.props[13]
              );
            }

            function applyToZ(x, y, z) {
              return (
                x * this.props[2] +
                y * this.props[6] +
                z * this.props[10] +
                this.props[14]
              );
            }

            function getInverseMatrix() {
              var determinant =
                this.props[0] * this.props[5] - this.props[1] * this.props[4];
              var a = this.props[5] / determinant;
              var b = -this.props[1] / determinant;
              var c = -this.props[4] / determinant;
              var d = this.props[0] / determinant;
              var e =
                (this.props[4] * this.props[13] -
                  this.props[5] * this.props[12]) /
                determinant;
              var f =
                -(
                  this.props[0] * this.props[13] -
                  this.props[1] * this.props[12]
                ) / determinant;
              var inverseMatrix = new Matrix();
              inverseMatrix.props[0] = a;
              inverseMatrix.props[1] = b;
              inverseMatrix.props[4] = c;
              inverseMatrix.props[5] = d;
              inverseMatrix.props[12] = e;
              inverseMatrix.props[13] = f;
              return inverseMatrix;
            }

            function inversePoint(pt) {
              var inverseMatrix = this.getInverseMatrix();
              return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
            }

            function inversePoints(pts) {
              var i;
              var len = pts.length;
              var retPts = [];

              for (i = 0; i < len; i += 1) {
                retPts[i] = inversePoint(pts[i]);
              }

              return retPts;
            }

            function applyToTriplePoints(pt1, pt2, pt3) {
              var arr = createTypedArray("float32", 6);

              if (this.isIdentity()) {
                arr[0] = pt1[0];
                arr[1] = pt1[1];
                arr[2] = pt2[0];
                arr[3] = pt2[1];
                arr[4] = pt3[0];
                arr[5] = pt3[1];
              } else {
                var p0 = this.props[0];
                var p1 = this.props[1];
                var p4 = this.props[4];
                var p5 = this.props[5];
                var p12 = this.props[12];
                var p13 = this.props[13];
                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
              }

              return arr;
            }

            function applyToPointArray(x, y, z) {
              var arr;

              if (this.isIdentity()) {
                arr = [x, y, z];
              } else {
                arr = [
                  x * this.props[0] +
                    y * this.props[4] +
                    z * this.props[8] +
                    this.props[12],
                  x * this.props[1] +
                    y * this.props[5] +
                    z * this.props[9] +
                    this.props[13],
                  x * this.props[2] +
                    y * this.props[6] +
                    z * this.props[10] +
                    this.props[14],
                ];
              }

              return arr;
            }

            function applyToPointStringified(x, y) {
              if (this.isIdentity()) {
                return x + "," + y;
              }

              var _p = this.props;
              return (
                Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 +
                "," +
                Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100
              );
            }

            function toCSS() {
              // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

              /* if(this.isIdentity()) {
              return '';
          } */
              var i = 0;
              var props = this.props;
              var cssValue = "matrix3d(";
              var v = 10000;

              while (i < 16) {
                cssValue += _rnd(props[i] * v) / v;
                cssValue += i === 15 ? ")" : ",";
                i += 1;
              }

              return cssValue;
            }

            function roundMatrixProperty(val) {
              var v = 10000;

              if ((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
                return _rnd(val * v) / v;
              }

              return val;
            }

            function to2dCSS() {
              // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

              /* if(this.isIdentity()) {
              return '';
          } */
              var props = this.props;

              var _a = roundMatrixProperty(props[0]);

              var _b = roundMatrixProperty(props[1]);

              var _c = roundMatrixProperty(props[4]);

              var _d = roundMatrixProperty(props[5]);

              var _e = roundMatrixProperty(props[12]);

              var _f = roundMatrixProperty(props[13]);

              return (
                "matrix(" +
                _a +
                "," +
                _b +
                "," +
                _c +
                "," +
                _d +
                "," +
                _e +
                "," +
                _f +
                ")"
              );
            }

            return function () {
              this.reset = reset;
              this.rotate = rotate;
              this.rotateX = rotateX;
              this.rotateY = rotateY;
              this.rotateZ = rotateZ;
              this.skew = skew;
              this.skewFromAxis = skewFromAxis;
              this.shear = shear;
              this.scale = scale;
              this.setTransform = setTransform;
              this.translate = translate;
              this.transform = transform;
              this.applyToPoint = applyToPoint;
              this.applyToX = applyToX;
              this.applyToY = applyToY;
              this.applyToZ = applyToZ;
              this.applyToPointArray = applyToPointArray;
              this.applyToTriplePoints = applyToTriplePoints;
              this.applyToPointStringified = applyToPointStringified;
              this.toCSS = toCSS;
              this.to2dCSS = to2dCSS;
              this.clone = clone;
              this.cloneFromProps = cloneFromProps;
              this.equals = equals;
              this.inversePoints = inversePoints;
              this.inversePoint = inversePoint;
              this.getInverseMatrix = getInverseMatrix;
              this._t = this.transform;
              this.isIdentity = isIdentity;
              this._identity = true;
              this._identityCalculated = false;
              this.props = createTypedArray("float32", 16);
              this.reset();
            };
          })();

          function _typeof$3(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof$3 = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof$3 = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof$3(obj);
          }
          var lottie = {};
          var standalone = "__[STANDALONE]__";
          var animationData = "__[ANIMATIONDATA]__";
          var renderer = "";

          function setLocation(href) {
            setLocationHref(href);
          }

          function searchAnimations() {
            if (standalone === true) {
              animationManager.searchAnimations(
                animationData,
                standalone,
                renderer
              );
            } else {
              animationManager.searchAnimations();
            }
          }

          function setSubframeRendering(flag) {
            setSubframeEnabled(flag);
          }

          function setPrefix(prefix) {
            setIdPrefix(prefix);
          }

          function loadAnimation(params) {
            if (standalone === true) {
              params.animationData = JSON.parse(animationData);
            }

            return animationManager.loadAnimation(params);
          }

          function setQuality(value) {
            if (typeof value === "string") {
              switch (value) {
                case "high":
                  setDefaultCurveSegments(200);
                  break;

                default:
                case "medium":
                  setDefaultCurveSegments(50);
                  break;

                case "low":
                  setDefaultCurveSegments(10);
                  break;
              }
            } else if (!isNaN(value) && value > 1) {
              setDefaultCurveSegments(value);
            }

            if (getDefaultCurveSegments() >= 50) {
              roundValues(false);
            } else {
              roundValues(true);
            }
          }

          function inBrowser() {
            return typeof navigator !== "undefined";
          }

          function installPlugin(type, plugin) {
            if (type === "expressions") {
              setExpressionsPlugin(plugin);
            }
          }

          function getFactory(name) {
            switch (name) {
              case "propertyFactory":
                return PropertyFactory;

              case "shapePropertyFactory":
                return ShapePropertyFactory;

              case "matrix":
                return Matrix;

              default:
                return null;
            }
          }

          lottie.play = animationManager.play;
          lottie.pause = animationManager.pause;
          lottie.setLocationHref = setLocation;
          lottie.togglePause = animationManager.togglePause;
          lottie.setSpeed = animationManager.setSpeed;
          lottie.setDirection = animationManager.setDirection;
          lottie.stop = animationManager.stop;
          lottie.searchAnimations = searchAnimations;
          lottie.registerAnimation = animationManager.registerAnimation;
          lottie.loadAnimation = loadAnimation;
          lottie.setSubframeRendering = setSubframeRendering;
          lottie.resize = animationManager.resize; // lottie.start = start;

          lottie.goToAndStop = animationManager.goToAndStop;
          lottie.destroy = animationManager.destroy;
          lottie.setQuality = setQuality;
          lottie.inBrowser = inBrowser;
          lottie.installPlugin = installPlugin;
          lottie.freeze = animationManager.freeze;
          lottie.unfreeze = animationManager.unfreeze;
          lottie.setVolume = animationManager.setVolume;
          lottie.mute = animationManager.mute;
          lottie.unmute = animationManager.unmute;
          lottie.getRegisteredAnimations =
            animationManager.getRegisteredAnimations;
          lottie.useWebWorker = setWebWorker;
          lottie.setIDPrefix = setPrefix;
          lottie.__getFactory = getFactory;
          lottie.version = "5.9.2";

          function checkReady() {
            if (document.readyState === "complete") {
              clearInterval(readyStateCheckInterval);
              searchAnimations();
            }
          }

          function getQueryVariable(variable) {
            var vars = queryString.split("&");

            for (var i = 0; i < vars.length; i += 1) {
              var pair = vars[i].split("=");

              if (decodeURIComponent(pair[0]) == variable) {
                // eslint-disable-line eqeqeq
                return decodeURIComponent(pair[1]);
              }
            }

            return null;
          }

          var queryString;

          if (standalone) {
            var scripts = document.getElementsByTagName("script");
            var index = scripts.length - 1;
            var myScript = scripts[index] || {
              src: "",
            };
            queryString = myScript.src.replace(/^[^\?]+\??/, ""); // eslint-disable-line no-useless-escape

            renderer = getQueryVariable("renderer");
          }

          var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility

          try {
            if (
              !(
                (false ? "undefined" : _typeof$3(exports)) === "object" &&
                typeof module !== "undefined"
              ) &&
              !("function" === "function" && __webpack_require__(134)) // eslint-disable-line no-undef
            ) {
              window.bodymovin = lottie;
            }
          } catch (err) {
            //
          }

          var ShapeModifiers = (function () {
            var ob = {};
            var modifiers = {};
            ob.registerModifier = registerModifier;
            ob.getModifier = getModifier;

            function registerModifier(nm, factory) {
              if (!modifiers[nm]) {
                modifiers[nm] = factory;
              }
            }

            function getModifier(nm, elem, data) {
              return new modifiers[nm](elem, data);
            }

            return ob;
          })();

          function ShapeModifier() {}

          ShapeModifier.prototype.initModifierProperties = function () {};

          ShapeModifier.prototype.addShapeToModifier = function () {};

          ShapeModifier.prototype.addShape = function (data) {
            if (!this.closed) {
              // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
              data.sh.container.addDynamicProperty(data.sh);
              var shapeData = {
                shape: data.sh,
                data: data,
                localShapeCollection: shapeCollectionPool.newShapeCollection(),
              };
              this.shapes.push(shapeData);
              this.addShapeToModifier(shapeData);

              if (this._isAnimated) {
                data.setAsAnimated();
              }
            }
          };

          ShapeModifier.prototype.init = function (elem, data) {
            this.shapes = [];
            this.elem = elem;
            this.initDynamicPropertyContainer(elem);
            this.initModifierProperties(elem, data);
            this.frameId = initialDefaultFrame;
            this.closed = false;
            this.k = false;

            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.getValue(true);
            }
          };

          ShapeModifier.prototype.processKeys = function () {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }

            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
          };

          extendPrototype([DynamicPropertyContainer], ShapeModifier);

          function TrimModifier() {}

          extendPrototype([ShapeModifier], TrimModifier);

          TrimModifier.prototype.initModifierProperties = function (
            elem,
            data
          ) {
            this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
            this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
            this.sValue = 0;
            this.eValue = 0;
            this.getValue = this.processKeys;
            this.m = data.m;
            this._isAnimated =
              !!this.s.effectsSequence.length ||
              !!this.e.effectsSequence.length ||
              !!this.o.effectsSequence.length;
          };

          TrimModifier.prototype.addShapeToModifier = function (shapeData) {
            shapeData.pathsData = [];
          };

          TrimModifier.prototype.calculateShapeEdges = function (
            s,
            e,
            shapeLength,
            addedLength,
            totalModifierLength
          ) {
            var segments = [];

            if (e <= 1) {
              segments.push({
                s: s,
                e: e,
              });
            } else if (s >= 1) {
              segments.push({
                s: s - 1,
                e: e - 1,
              });
            } else {
              segments.push({
                s: s,
                e: 1,
              });
              segments.push({
                s: 0,
                e: e - 1,
              });
            }

            var shapeSegments = [];
            var i;
            var len = segments.length;
            var segmentOb;

            for (i = 0; i < len; i += 1) {
              segmentOb = segments[i];

              if (
                !(
                  segmentOb.e * totalModifierLength < addedLength ||
                  segmentOb.s * totalModifierLength > addedLength + shapeLength
                )
              ) {
                var shapeS;
                var shapeE;

                if (segmentOb.s * totalModifierLength <= addedLength) {
                  shapeS = 0;
                } else {
                  shapeS =
                    (segmentOb.s * totalModifierLength - addedLength) /
                    shapeLength;
                }

                if (
                  segmentOb.e * totalModifierLength >=
                  addedLength + shapeLength
                ) {
                  shapeE = 1;
                } else {
                  shapeE =
                    (segmentOb.e * totalModifierLength - addedLength) /
                    shapeLength;
                }

                shapeSegments.push([shapeS, shapeE]);
              }
            }

            if (!shapeSegments.length) {
              shapeSegments.push([0, 0]);
            }

            return shapeSegments;
          };

          TrimModifier.prototype.releasePathsData = function (pathsData) {
            var i;
            var len = pathsData.length;

            for (i = 0; i < len; i += 1) {
              segmentsLengthPool.release(pathsData[i]);
            }

            pathsData.length = 0;
            return pathsData;
          };

          TrimModifier.prototype.processShapes = function (_isFirstFrame) {
            var s;
            var e;

            if (this._mdf || _isFirstFrame) {
              var o = (this.o.v % 360) / 360;

              if (o < 0) {
                o += 1;
              }

              if (this.s.v > 1) {
                s = 1 + o;
              } else if (this.s.v < 0) {
                s = 0 + o;
              } else {
                s = this.s.v + o;
              }

              if (this.e.v > 1) {
                e = 1 + o;
              } else if (this.e.v < 0) {
                e = 0 + o;
              } else {
                e = this.e.v + o;
              }

              if (s > e) {
                var _s = s;
                s = e;
                e = _s;
              }

              s = Math.round(s * 10000) * 0.0001;
              e = Math.round(e * 10000) * 0.0001;
              this.sValue = s;
              this.eValue = e;
            } else {
              s = this.sValue;
              e = this.eValue;
            }

            var shapePaths;
            var i;
            var len = this.shapes.length;
            var j;
            var jLen;
            var pathsData;
            var pathData;
            var totalShapeLength;
            var totalModifierLength = 0;

            if (e === s) {
              for (i = 0; i < len; i += 1) {
                this.shapes[i].localShapeCollection.releaseShapes();
                this.shapes[i].shape._mdf = true;
                this.shapes[i].shape.paths =
                  this.shapes[i].localShapeCollection;

                if (this._mdf) {
                  this.shapes[i].pathsData.length = 0;
                }
              }
            } else if (!((e === 1 && s === 0) || (e === 0 && s === 1))) {
              var segments = [];
              var shapeData;
              var localShapeCollection;

              for (i = 0; i < len; i += 1) {
                shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used

                if (
                  !shapeData.shape._mdf &&
                  !this._mdf &&
                  !_isFirstFrame &&
                  this.m !== 2
                ) {
                  shapeData.shape.paths = shapeData.localShapeCollection;
                } else {
                  shapePaths = shapeData.shape.paths;
                  jLen = shapePaths._length;
                  totalShapeLength = 0;

                  if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                    totalShapeLength = shapeData.totalShapeLength;
                  } else {
                    pathsData = this.releasePathsData(shapeData.pathsData);

                    for (j = 0; j < jLen; j += 1) {
                      pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                      pathsData.push(pathData);
                      totalShapeLength += pathData.totalLength;
                    }

                    shapeData.totalShapeLength = totalShapeLength;
                    shapeData.pathsData = pathsData;
                  }

                  totalModifierLength += totalShapeLength;
                  shapeData.shape._mdf = true;
                }
              }

              var shapeS = s;
              var shapeE = e;
              var addedLength = 0;
              var edges;

              for (i = len - 1; i >= 0; i -= 1) {
                shapeData = this.shapes[i];

                if (shapeData.shape._mdf) {
                  localShapeCollection = shapeData.localShapeCollection;
                  localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group

                  if (this.m === 2 && len > 1) {
                    edges = this.calculateShapeEdges(
                      s,
                      e,
                      shapeData.totalShapeLength,
                      addedLength,
                      totalModifierLength
                    );
                    addedLength += shapeData.totalShapeLength;
                  } else {
                    edges = [[shapeS, shapeE]];
                  }

                  jLen = edges.length;

                  for (j = 0; j < jLen; j += 1) {
                    shapeS = edges[j][0];
                    shapeE = edges[j][1];
                    segments.length = 0;

                    if (shapeE <= 1) {
                      segments.push({
                        s: shapeData.totalShapeLength * shapeS,
                        e: shapeData.totalShapeLength * shapeE,
                      });
                    } else if (shapeS >= 1) {
                      segments.push({
                        s: shapeData.totalShapeLength * (shapeS - 1),
                        e: shapeData.totalShapeLength * (shapeE - 1),
                      });
                    } else {
                      segments.push({
                        s: shapeData.totalShapeLength * shapeS,
                        e: shapeData.totalShapeLength,
                      });
                      segments.push({
                        s: 0,
                        e: shapeData.totalShapeLength * (shapeE - 1),
                      });
                    }

                    var newShapesData = this.addShapes(shapeData, segments[0]);

                    if (segments[0].s !== segments[0].e) {
                      if (segments.length > 1) {
                        var lastShapeInCollection =
                          shapeData.shape.paths.shapes[
                            shapeData.shape.paths._length - 1
                          ];

                        if (lastShapeInCollection.c) {
                          var lastShape = newShapesData.pop();
                          this.addPaths(newShapesData, localShapeCollection);
                          newShapesData = this.addShapes(
                            shapeData,
                            segments[1],
                            lastShape
                          );
                        } else {
                          this.addPaths(newShapesData, localShapeCollection);
                          newShapesData = this.addShapes(
                            shapeData,
                            segments[1]
                          );
                        }
                      }

                      this.addPaths(newShapesData, localShapeCollection);
                    }
                  }

                  shapeData.shape.paths = localShapeCollection;
                }
              }
            } else if (this._mdf) {
              for (i = 0; i < len; i += 1) {
                // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
                // Don't remove this even if it's losing cached info.
                this.shapes[i].pathsData.length = 0;
                this.shapes[i].shape._mdf = true;
              }
            }
          };

          TrimModifier.prototype.addPaths = function (
            newPaths,
            localShapeCollection
          ) {
            var i;
            var len = newPaths.length;

            for (i = 0; i < len; i += 1) {
              localShapeCollection.addShape(newPaths[i]);
            }
          };

          TrimModifier.prototype.addSegment = function (
            pt1,
            pt2,
            pt3,
            pt4,
            shapePath,
            pos,
            newShape
          ) {
            shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
            shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);

            if (newShape) {
              shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
            }

            shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
          };

          TrimModifier.prototype.addSegmentFromArray = function (
            points,
            shapePath,
            pos,
            newShape
          ) {
            shapePath.setXYAt(points[1], points[5], "o", pos);
            shapePath.setXYAt(points[2], points[6], "i", pos + 1);

            if (newShape) {
              shapePath.setXYAt(points[0], points[4], "v", pos);
            }

            shapePath.setXYAt(points[3], points[7], "v", pos + 1);
          };

          TrimModifier.prototype.addShapes = function (
            shapeData,
            shapeSegment,
            shapePath
          ) {
            var pathsData = shapeData.pathsData;
            var shapePaths = shapeData.shape.paths.shapes;
            var i;
            var len = shapeData.shape.paths._length;
            var j;
            var jLen;
            var addedLength = 0;
            var currentLengthData;
            var segmentCount;
            var lengths;
            var segment;
            var shapes = [];
            var initPos;
            var newShape = true;

            if (!shapePath) {
              shapePath = shapePool.newElement();
              segmentCount = 0;
              initPos = 0;
            } else {
              segmentCount = shapePath._length;
              initPos = shapePath._length;
            }

            shapes.push(shapePath);

            for (i = 0; i < len; i += 1) {
              lengths = pathsData[i].lengths;
              shapePath.c = shapePaths[i].c;
              jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;

              for (j = 1; j < jLen; j += 1) {
                currentLengthData = lengths[j - 1];

                if (
                  addedLength + currentLengthData.addedLength <
                  shapeSegment.s
                ) {
                  addedLength += currentLengthData.addedLength;
                  shapePath.c = false;
                } else if (addedLength > shapeSegment.e) {
                  shapePath.c = false;
                  break;
                } else {
                  if (
                    shapeSegment.s <= addedLength &&
                    shapeSegment.e >=
                      addedLength + currentLengthData.addedLength
                  ) {
                    this.addSegment(
                      shapePaths[i].v[j - 1],
                      shapePaths[i].o[j - 1],
                      shapePaths[i].i[j],
                      shapePaths[i].v[j],
                      shapePath,
                      segmentCount,
                      newShape
                    );
                    newShape = false;
                  } else {
                    segment = bez.getNewSegment(
                      shapePaths[i].v[j - 1],
                      shapePaths[i].v[j],
                      shapePaths[i].o[j - 1],
                      shapePaths[i].i[j],
                      (shapeSegment.s - addedLength) /
                        currentLengthData.addedLength,
                      (shapeSegment.e - addedLength) /
                        currentLengthData.addedLength,
                      lengths[j - 1]
                    );
                    this.addSegmentFromArray(
                      segment,
                      shapePath,
                      segmentCount,
                      newShape
                    ); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

                    newShape = false;
                    shapePath.c = false;
                  }

                  addedLength += currentLengthData.addedLength;
                  segmentCount += 1;
                }
              }

              if (shapePaths[i].c && lengths.length) {
                currentLengthData = lengths[j - 1];

                if (addedLength <= shapeSegment.e) {
                  var segmentLength = lengths[j - 1].addedLength;

                  if (
                    shapeSegment.s <= addedLength &&
                    shapeSegment.e >= addedLength + segmentLength
                  ) {
                    this.addSegment(
                      shapePaths[i].v[j - 1],
                      shapePaths[i].o[j - 1],
                      shapePaths[i].i[0],
                      shapePaths[i].v[0],
                      shapePath,
                      segmentCount,
                      newShape
                    );
                    newShape = false;
                  } else {
                    segment = bez.getNewSegment(
                      shapePaths[i].v[j - 1],
                      shapePaths[i].v[0],
                      shapePaths[i].o[j - 1],
                      shapePaths[i].i[0],
                      (shapeSegment.s - addedLength) / segmentLength,
                      (shapeSegment.e - addedLength) / segmentLength,
                      lengths[j - 1]
                    );
                    this.addSegmentFromArray(
                      segment,
                      shapePath,
                      segmentCount,
                      newShape
                    ); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

                    newShape = false;
                    shapePath.c = false;
                  }
                } else {
                  shapePath.c = false;
                }

                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
              }

              if (shapePath._length) {
                shapePath.setXYAt(
                  shapePath.v[initPos][0],
                  shapePath.v[initPos][1],
                  "i",
                  initPos
                );
                shapePath.setXYAt(
                  shapePath.v[shapePath._length - 1][0],
                  shapePath.v[shapePath._length - 1][1],
                  "o",
                  shapePath._length - 1
                );
              }

              if (addedLength > shapeSegment.e) {
                break;
              }

              if (i < len - 1) {
                shapePath = shapePool.newElement();
                newShape = true;
                shapes.push(shapePath);
                segmentCount = 0;
              }
            }

            return shapes;
          };

          function PuckerAndBloatModifier() {}

          extendPrototype([ShapeModifier], PuckerAndBloatModifier);

          PuckerAndBloatModifier.prototype.initModifierProperties = function (
            elem,
            data
          ) {
            this.getValue = this.processKeys;
            this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
            this._isAnimated = !!this.amount.effectsSequence.length;
          };

          PuckerAndBloatModifier.prototype.processPath = function (
            path,
            amount
          ) {
            var percent = amount / 100;
            var centerPoint = [0, 0];
            var pathLength = path._length;
            var i = 0;

            for (i = 0; i < pathLength; i += 1) {
              centerPoint[0] += path.v[i][0];
              centerPoint[1] += path.v[i][1];
            }

            centerPoint[0] /= pathLength;
            centerPoint[1] /= pathLength;
            var clonedPath = shapePool.newElement();
            clonedPath.c = path.c;
            var vX;
            var vY;
            var oX;
            var oY;
            var iX;
            var iY;

            for (i = 0; i < pathLength; i += 1) {
              vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
              vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
              oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
              oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
              iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
              iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
            }

            return clonedPath;
          };

          PuckerAndBloatModifier.prototype.processShapes = function (
            _isFirstFrame
          ) {
            var shapePaths;
            var i;
            var len = this.shapes.length;
            var j;
            var jLen;
            var amount = this.amount.v;

            if (amount !== 0) {
              var shapeData;
              var localShapeCollection;

              for (i = 0; i < len; i += 1) {
                shapeData = this.shapes[i];
                localShapeCollection = shapeData.localShapeCollection;

                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                  localShapeCollection.releaseShapes();
                  shapeData.shape._mdf = true;
                  shapePaths = shapeData.shape.paths.shapes;
                  jLen = shapeData.shape.paths._length;

                  for (j = 0; j < jLen; j += 1) {
                    localShapeCollection.addShape(
                      this.processPath(shapePaths[j], amount)
                    );
                  }
                }

                shapeData.shape.paths = shapeData.localShapeCollection;
              }
            }

            if (!this.dynamicProperties.length) {
              this._mdf = false;
            }
          };

          var TransformPropertyFactory = (function () {
            var defaultVector = [0, 0];

            function applyToMatrix(mat) {
              var _mdf = this._mdf;
              this.iterateDynamicProperties();
              this._mdf = this._mdf || _mdf;

              if (this.a) {
                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              }

              if (this.s) {
                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              }

              if (this.sk) {
                mat.skewFromAxis(-this.sk.v, this.sa.v);
              }

              if (this.r) {
                mat.rotate(-this.r.v);
              } else {
                mat
                  .rotateZ(-this.rz.v)
                  .rotateY(this.ry.v)
                  .rotateX(this.rx.v)
                  .rotateZ(-this.or.v[2])
                  .rotateY(this.or.v[1])
                  .rotateX(this.or.v[0]);
              }

              if (this.data.p.s) {
                if (this.data.p.z) {
                  mat.translate(this.px.v, this.py.v, -this.pz.v);
                } else {
                  mat.translate(this.px.v, this.py.v, 0);
                }
              } else {
                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
              }
            }

            function processKeys(forceRender) {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }

              if (this._isDirty) {
                this.precalculateMatrix();
                this._isDirty = false;
              }

              this.iterateDynamicProperties();

              if (this._mdf || forceRender) {
                var frameRate;
                this.v.cloneFromProps(this.pre.props);

                if (this.appliedTransformations < 1) {
                  this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                }

                if (this.appliedTransformations < 2) {
                  this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                }

                if (this.sk && this.appliedTransformations < 3) {
                  this.v.skewFromAxis(-this.sk.v, this.sa.v);
                }

                if (this.r && this.appliedTransformations < 4) {
                  this.v.rotate(-this.r.v);
                } else if (!this.r && this.appliedTransformations < 4) {
                  this.v
                    .rotateZ(-this.rz.v)
                    .rotateY(this.ry.v)
                    .rotateX(this.rx.v)
                    .rotateZ(-this.or.v[2])
                    .rotateY(this.or.v[1])
                    .rotateX(this.or.v[0]);
                }

                if (this.autoOriented) {
                  var v1;
                  var v2;
                  frameRate = this.elem.globalData.frameRate;

                  if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                    if (
                      this.p._caching.lastFrame + this.p.offsetTime <=
                      this.p.keyframes[0].t
                    ) {
                      v1 = this.p.getValueAtTime(
                        (this.p.keyframes[0].t + 0.01) / frameRate,
                        0
                      );
                      v2 = this.p.getValueAtTime(
                        this.p.keyframes[0].t / frameRate,
                        0
                      );
                    } else if (
                      this.p._caching.lastFrame + this.p.offsetTime >=
                      this.p.keyframes[this.p.keyframes.length - 1].t
                    ) {
                      v1 = this.p.getValueAtTime(
                        this.p.keyframes[this.p.keyframes.length - 1].t /
                          frameRate,
                        0
                      );
                      v2 = this.p.getValueAtTime(
                        (this.p.keyframes[this.p.keyframes.length - 1].t -
                          0.05) /
                          frameRate,
                        0
                      );
                    } else {
                      v1 = this.p.pv;
                      v2 = this.p.getValueAtTime(
                        (this.p._caching.lastFrame + this.p.offsetTime - 0.01) /
                          frameRate,
                        this.p.offsetTime
                      );
                    }
                  } else if (
                    this.px &&
                    this.px.keyframes &&
                    this.py.keyframes &&
                    this.px.getValueAtTime &&
                    this.py.getValueAtTime
                  ) {
                    v1 = [];
                    v2 = [];
                    var px = this.px;
                    var py = this.py;

                    if (
                      px._caching.lastFrame + px.offsetTime <=
                      px.keyframes[0].t
                    ) {
                      v1[0] = px.getValueAtTime(
                        (px.keyframes[0].t + 0.01) / frameRate,
                        0
                      );
                      v1[1] = py.getValueAtTime(
                        (py.keyframes[0].t + 0.01) / frameRate,
                        0
                      );
                      v2[0] = px.getValueAtTime(
                        px.keyframes[0].t / frameRate,
                        0
                      );
                      v2[1] = py.getValueAtTime(
                        py.keyframes[0].t / frameRate,
                        0
                      );
                    } else if (
                      px._caching.lastFrame + px.offsetTime >=
                      px.keyframes[px.keyframes.length - 1].t
                    ) {
                      v1[0] = px.getValueAtTime(
                        px.keyframes[px.keyframes.length - 1].t / frameRate,
                        0
                      );
                      v1[1] = py.getValueAtTime(
                        py.keyframes[py.keyframes.length - 1].t / frameRate,
                        0
                      );
                      v2[0] = px.getValueAtTime(
                        (px.keyframes[px.keyframes.length - 1].t - 0.01) /
                          frameRate,
                        0
                      );
                      v2[1] = py.getValueAtTime(
                        (py.keyframes[py.keyframes.length - 1].t - 0.01) /
                          frameRate,
                        0
                      );
                    } else {
                      v1 = [px.pv, py.pv];
                      v2[0] = px.getValueAtTime(
                        (px._caching.lastFrame + px.offsetTime - 0.01) /
                          frameRate,
                        px.offsetTime
                      );
                      v2[1] = py.getValueAtTime(
                        (py._caching.lastFrame + py.offsetTime - 0.01) /
                          frameRate,
                        py.offsetTime
                      );
                    }
                  } else {
                    v2 = defaultVector;
                    v1 = v2;
                  }

                  this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
                }

                if (this.data.p && this.data.p.s) {
                  if (this.data.p.z) {
                    this.v.translate(this.px.v, this.py.v, -this.pz.v);
                  } else {
                    this.v.translate(this.px.v, this.py.v, 0);
                  }
                } else {
                  this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
                }
              }

              this.frameId = this.elem.globalData.frameId;
            }

            function precalculateMatrix() {
              if (!this.a.k) {
                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                this.appliedTransformations = 1;
              } else {
                return;
              }

              if (!this.s.effectsSequence.length) {
                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                this.appliedTransformations = 2;
              } else {
                return;
              }

              if (this.sk) {
                if (
                  !this.sk.effectsSequence.length &&
                  !this.sa.effectsSequence.length
                ) {
                  this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                  this.appliedTransformations = 3;
                } else {
                  return;
                }
              }

              if (this.r) {
                if (!this.r.effectsSequence.length) {
                  this.pre.rotate(-this.r.v);
                  this.appliedTransformations = 4;
                }
              } else if (
                !this.rz.effectsSequence.length &&
                !this.ry.effectsSequence.length &&
                !this.rx.effectsSequence.length &&
                !this.or.effectsSequence.length
              ) {
                this.pre
                  .rotateZ(-this.rz.v)
                  .rotateY(this.ry.v)
                  .rotateX(this.rx.v)
                  .rotateZ(-this.or.v[2])
                  .rotateY(this.or.v[1])
                  .rotateX(this.or.v[0]);
                this.appliedTransformations = 4;
              }
            }

            function autoOrient() {
              //
              // var prevP = this.getValueAtTime();
            }

            function addDynamicProperty(prop) {
              this._addDynamicProperty(prop);

              this.elem.addDynamicProperty(prop);
              this._isDirty = true;
            }

            function TransformProperty(elem, data, container) {
              this.elem = elem;
              this.frameId = -1;
              this.propType = "transform";
              this.data = data;
              this.v = new Matrix(); // Precalculated matrix with non animated properties

              this.pre = new Matrix();
              this.appliedTransformations = 0;
              this.initDynamicPropertyContainer(container || elem);

              if (data.p && data.p.s) {
                this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
                this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);

                if (data.p.z) {
                  this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
                }
              } else {
                this.p = PropertyFactory.getProp(
                  elem,
                  data.p || {
                    k: [0, 0, 0],
                  },
                  1,
                  0,
                  this
                );
              }

              if (data.rx) {
                this.rx = PropertyFactory.getProp(
                  elem,
                  data.rx,
                  0,
                  degToRads,
                  this
                );
                this.ry = PropertyFactory.getProp(
                  elem,
                  data.ry,
                  0,
                  degToRads,
                  this
                );
                this.rz = PropertyFactory.getProp(
                  elem,
                  data.rz,
                  0,
                  degToRads,
                  this
                );

                if (data.or.k[0].ti) {
                  var i;
                  var len = data.or.k.length;

                  for (i = 0; i < len; i += 1) {
                    data.or.k[i].to = null;
                    data.or.k[i].ti = null;
                  }
                }

                this.or = PropertyFactory.getProp(
                  elem,
                  data.or,
                  1,
                  degToRads,
                  this
                ); // sh Indicates it needs to be capped between -180 and 180

                this.or.sh = true;
              } else {
                this.r = PropertyFactory.getProp(
                  elem,
                  data.r || {
                    k: 0,
                  },
                  0,
                  degToRads,
                  this
                );
              }

              if (data.sk) {
                this.sk = PropertyFactory.getProp(
                  elem,
                  data.sk,
                  0,
                  degToRads,
                  this
                );
                this.sa = PropertyFactory.getProp(
                  elem,
                  data.sa,
                  0,
                  degToRads,
                  this
                );
              }

              this.a = PropertyFactory.getProp(
                elem,
                data.a || {
                  k: [0, 0, 0],
                },
                1,
                0,
                this
              );
              this.s = PropertyFactory.getProp(
                elem,
                data.s || {
                  k: [100, 100, 100],
                },
                1,
                0.01,
                this
              ); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.

              if (data.o) {
                this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
              } else {
                this.o = {
                  _mdf: false,
                  v: 1,
                };
              }

              this._isDirty = true;

              if (!this.dynamicProperties.length) {
                this.getValue(true);
              }
            }

            TransformProperty.prototype = {
              applyToMatrix: applyToMatrix,
              getValue: processKeys,
              precalculateMatrix: precalculateMatrix,
              autoOrient: autoOrient,
            };
            extendPrototype([DynamicPropertyContainer], TransformProperty);
            TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
            TransformProperty.prototype._addDynamicProperty =
              DynamicPropertyContainer.prototype.addDynamicProperty;

            function getTransformProperty(elem, data, container) {
              return new TransformProperty(elem, data, container);
            }

            return {
              getTransformProperty: getTransformProperty,
            };
          })();

          function RepeaterModifier() {}

          extendPrototype([ShapeModifier], RepeaterModifier);

          RepeaterModifier.prototype.initModifierProperties = function (
            elem,
            data
          ) {
            this.getValue = this.processKeys;
            this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
            this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
            this.tr = TransformPropertyFactory.getTransformProperty(
              elem,
              data.tr,
              this
            );
            this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
            this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
            this.data = data;

            if (!this.dynamicProperties.length) {
              this.getValue(true);
            }

            this._isAnimated = !!this.dynamicProperties.length;
            this.pMatrix = new Matrix();
            this.rMatrix = new Matrix();
            this.sMatrix = new Matrix();
            this.tMatrix = new Matrix();
            this.matrix = new Matrix();
          };

          RepeaterModifier.prototype.applyTransforms = function (
            pMatrix,
            rMatrix,
            sMatrix,
            transform,
            perc,
            inv
          ) {
            var dir = inv ? -1 : 1;
            var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
            var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
            pMatrix.translate(
              transform.p.v[0] * dir * perc,
              transform.p.v[1] * dir * perc,
              transform.p.v[2]
            );
            rMatrix.translate(
              -transform.a.v[0],
              -transform.a.v[1],
              transform.a.v[2]
            );
            rMatrix.rotate(-transform.r.v * dir * perc);
            rMatrix.translate(
              transform.a.v[0],
              transform.a.v[1],
              transform.a.v[2]
            );
            sMatrix.translate(
              -transform.a.v[0],
              -transform.a.v[1],
              transform.a.v[2]
            );
            sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
            sMatrix.translate(
              transform.a.v[0],
              transform.a.v[1],
              transform.a.v[2]
            );
          };

          RepeaterModifier.prototype.init = function (
            elem,
            arr,
            pos,
            elemsData
          ) {
            this.elem = elem;
            this.arr = arr;
            this.pos = pos;
            this.elemsData = elemsData;
            this._currentCopies = 0;
            this._elements = [];
            this._groups = [];
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem);
            this.initModifierProperties(elem, arr[pos]);

            while (pos > 0) {
              pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);

              this._elements.unshift(arr[pos]);
            }

            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.getValue(true);
            }
          };

          RepeaterModifier.prototype.resetElements = function (elements) {
            var i;
            var len = elements.length;

            for (i = 0; i < len; i += 1) {
              elements[i]._processed = false;

              if (elements[i].ty === "gr") {
                this.resetElements(elements[i].it);
              }
            }
          };

          RepeaterModifier.prototype.cloneElements = function (elements) {
            var newElements = JSON.parse(JSON.stringify(elements));
            this.resetElements(newElements);
            return newElements;
          };

          RepeaterModifier.prototype.changeGroupRender = function (
            elements,
            renderFlag
          ) {
            var i;
            var len = elements.length;

            for (i = 0; i < len; i += 1) {
              elements[i]._render = renderFlag;

              if (elements[i].ty === "gr") {
                this.changeGroupRender(elements[i].it, renderFlag);
              }
            }
          };

          RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
            var items;
            var itemsTransform;
            var i;
            var dir;
            var cont;
            var hasReloaded = false;

            if (this._mdf || _isFirstFrame) {
              var copies = Math.ceil(this.c.v);

              if (this._groups.length < copies) {
                while (this._groups.length < copies) {
                  var group = {
                    it: this.cloneElements(this._elements),
                    ty: "gr",
                  };
                  group.it.push({
                    a: {
                      a: 0,
                      ix: 1,
                      k: [0, 0],
                    },
                    nm: "Transform",
                    o: {
                      a: 0,
                      ix: 7,
                      k: 100,
                    },
                    p: {
                      a: 0,
                      ix: 2,
                      k: [0, 0],
                    },
                    r: {
                      a: 1,
                      ix: 6,
                      k: [
                        {
                          s: 0,
                          e: 0,
                          t: 0,
                        },
                        {
                          s: 0,
                          e: 0,
                          t: 1,
                        },
                      ],
                    },
                    s: {
                      a: 0,
                      ix: 3,
                      k: [100, 100],
                    },
                    sa: {
                      a: 0,
                      ix: 5,
                      k: 0,
                    },
                    sk: {
                      a: 0,
                      ix: 4,
                      k: 0,
                    },
                    ty: "tr",
                  });
                  this.arr.splice(0, 0, group);

                  this._groups.splice(0, 0, group);

                  this._currentCopies += 1;
                }

                this.elem.reloadShapes();
                hasReloaded = true;
              }

              cont = 0;
              var renderFlag;

              for (i = 0; i <= this._groups.length - 1; i += 1) {
                renderFlag = cont < copies;
                this._groups[i]._render = renderFlag;
                this.changeGroupRender(this._groups[i].it, renderFlag);

                if (!renderFlag) {
                  var elems = this.elemsData[i].it;
                  var transformData = elems[elems.length - 1];

                  if (transformData.transform.op.v !== 0) {
                    transformData.transform.op._mdf = true;
                    transformData.transform.op.v = 0;
                  } else {
                    transformData.transform.op._mdf = false;
                  }
                }

                cont += 1;
              }

              this._currentCopies = copies; /// /

              var offset = this.o.v;
              var offsetModulo = offset % 1;
              var roundOffset =
                offset > 0 ? Math.floor(offset) : Math.ceil(offset);
              var pProps = this.pMatrix.props;
              var rProps = this.rMatrix.props;
              var sProps = this.sMatrix.props;
              this.pMatrix.reset();
              this.rMatrix.reset();
              this.sMatrix.reset();
              this.tMatrix.reset();
              this.matrix.reset();
              var iteration = 0;

              if (offset > 0) {
                while (iteration < roundOffset) {
                  this.applyTransforms(
                    this.pMatrix,
                    this.rMatrix,
                    this.sMatrix,
                    this.tr,
                    1,
                    false
                  );
                  iteration += 1;
                }

                if (offsetModulo) {
                  this.applyTransforms(
                    this.pMatrix,
                    this.rMatrix,
                    this.sMatrix,
                    this.tr,
                    offsetModulo,
                    false
                  );
                  iteration += offsetModulo;
                }
              } else if (offset < 0) {
                while (iteration > roundOffset) {
                  this.applyTransforms(
                    this.pMatrix,
                    this.rMatrix,
                    this.sMatrix,
                    this.tr,
                    1,
                    true
                  );
                  iteration -= 1;
                }

                if (offsetModulo) {
                  this.applyTransforms(
                    this.pMatrix,
                    this.rMatrix,
                    this.sMatrix,
                    this.tr,
                    -offsetModulo,
                    true
                  );
                  iteration -= offsetModulo;
                }
              }

              i = this.data.m === 1 ? 0 : this._currentCopies - 1;
              dir = this.data.m === 1 ? 1 : -1;
              cont = this._currentCopies;
              var j;
              var jLen;

              while (cont) {
                items = this.elemsData[i].it;
                itemsTransform =
                  items[items.length - 1].transform.mProps.v.props;
                jLen = itemsTransform.length;
                items[items.length - 1].transform.mProps._mdf = true;
                items[items.length - 1].transform.op._mdf = true;
                items[items.length - 1].transform.op.v =
                  this._currentCopies === 1
                    ? this.so.v
                    : this.so.v +
                      (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

                if (iteration !== 0) {
                  if (
                    (i !== 0 && dir === 1) ||
                    (i !== this._currentCopies - 1 && dir === -1)
                  ) {
                    this.applyTransforms(
                      this.pMatrix,
                      this.rMatrix,
                      this.sMatrix,
                      this.tr,
                      1,
                      false
                    );
                  }

                  this.matrix.transform(
                    rProps[0],
                    rProps[1],
                    rProps[2],
                    rProps[3],
                    rProps[4],
                    rProps[5],
                    rProps[6],
                    rProps[7],
                    rProps[8],
                    rProps[9],
                    rProps[10],
                    rProps[11],
                    rProps[12],
                    rProps[13],
                    rProps[14],
                    rProps[15]
                  );
                  this.matrix.transform(
                    sProps[0],
                    sProps[1],
                    sProps[2],
                    sProps[3],
                    sProps[4],
                    sProps[5],
                    sProps[6],
                    sProps[7],
                    sProps[8],
                    sProps[9],
                    sProps[10],
                    sProps[11],
                    sProps[12],
                    sProps[13],
                    sProps[14],
                    sProps[15]
                  );
                  this.matrix.transform(
                    pProps[0],
                    pProps[1],
                    pProps[2],
                    pProps[3],
                    pProps[4],
                    pProps[5],
                    pProps[6],
                    pProps[7],
                    pProps[8],
                    pProps[9],
                    pProps[10],
                    pProps[11],
                    pProps[12],
                    pProps[13],
                    pProps[14],
                    pProps[15]
                  );

                  for (j = 0; j < jLen; j += 1) {
                    itemsTransform[j] = this.matrix.props[j];
                  }

                  this.matrix.reset();
                } else {
                  this.matrix.reset();

                  for (j = 0; j < jLen; j += 1) {
                    itemsTransform[j] = this.matrix.props[j];
                  }
                }

                iteration += 1;
                cont -= 1;
                i += dir;
              }
            } else {
              cont = this._currentCopies;
              i = 0;
              dir = 1;

              while (cont) {
                items = this.elemsData[i].it;
                itemsTransform =
                  items[items.length - 1].transform.mProps.v.props;
                items[items.length - 1].transform.mProps._mdf = false;
                items[items.length - 1].transform.op._mdf = false;
                cont -= 1;
                i += dir;
              }
            }

            return hasReloaded;
          };

          RepeaterModifier.prototype.addShape = function () {};

          function RoundCornersModifier() {}

          extendPrototype([ShapeModifier], RoundCornersModifier);

          RoundCornersModifier.prototype.initModifierProperties = function (
            elem,
            data
          ) {
            this.getValue = this.processKeys;
            this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
            this._isAnimated = !!this.rd.effectsSequence.length;
          };

          RoundCornersModifier.prototype.processPath = function (path, round) {
            var clonedPath = shapePool.newElement();
            clonedPath.c = path.c;
            var i;
            var len = path._length;
            var currentV;
            var currentI;
            var currentO;
            var closerV;
            var distance;
            var newPosPerc;
            var index = 0;
            var vX;
            var vY;
            var oX;
            var oY;
            var iX;
            var iY;

            for (i = 0; i < len; i += 1) {
              currentV = path.v[i];
              currentO = path.o[i];
              currentI = path.i[i];

              if (
                currentV[0] === currentO[0] &&
                currentV[1] === currentO[1] &&
                currentV[0] === currentI[0] &&
                currentV[1] === currentI[1]
              ) {
                if ((i === 0 || i === len - 1) && !path.c) {
                  clonedPath.setTripleAt(
                    currentV[0],
                    currentV[1],
                    currentO[0],
                    currentO[1],
                    currentI[0],
                    currentI[1],
                    index
                  );
                  /* clonedPath.v[index] = currentV;
                  clonedPath.o[index] = currentO;
                  clonedPath.i[index] = currentI; */

                  index += 1;
                } else {
                  if (i === 0) {
                    closerV = path.v[len - 1];
                  } else {
                    closerV = path.v[i - 1];
                  }

                  distance = Math.sqrt(
                    Math.pow(currentV[0] - closerV[0], 2) +
                      Math.pow(currentV[1] - closerV[1], 2)
                  );
                  newPosPerc = distance
                    ? Math.min(distance / 2, round) / distance
                    : 0;
                  iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                  vX = iX;
                  iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                  vY = iY;
                  oX = vX - (vX - currentV[0]) * roundCorner;
                  oY = vY - (vY - currentV[1]) * roundCorner;
                  clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                  index += 1;

                  if (i === len - 1) {
                    closerV = path.v[0];
                  } else {
                    closerV = path.v[i + 1];
                  }

                  distance = Math.sqrt(
                    Math.pow(currentV[0] - closerV[0], 2) +
                      Math.pow(currentV[1] - closerV[1], 2)
                  );
                  newPosPerc = distance
                    ? Math.min(distance / 2, round) / distance
                    : 0;
                  oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                  vX = oX;
                  oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                  vY = oY;
                  iX = vX - (vX - currentV[0]) * roundCorner;
                  iY = vY - (vY - currentV[1]) * roundCorner;
                  clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                  index += 1;
                }
              } else {
                clonedPath.setTripleAt(
                  path.v[i][0],
                  path.v[i][1],
                  path.o[i][0],
                  path.o[i][1],
                  path.i[i][0],
                  path.i[i][1],
                  index
                );
                index += 1;
              }
            }

            return clonedPath;
          };

          RoundCornersModifier.prototype.processShapes = function (
            _isFirstFrame
          ) {
            var shapePaths;
            var i;
            var len = this.shapes.length;
            var j;
            var jLen;
            var rd = this.rd.v;

            if (rd !== 0) {
              var shapeData;
              var localShapeCollection;

              for (i = 0; i < len; i += 1) {
                shapeData = this.shapes[i];
                localShapeCollection = shapeData.localShapeCollection;

                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                  localShapeCollection.releaseShapes();
                  shapeData.shape._mdf = true;
                  shapePaths = shapeData.shape.paths.shapes;
                  jLen = shapeData.shape.paths._length;

                  for (j = 0; j < jLen; j += 1) {
                    localShapeCollection.addShape(
                      this.processPath(shapePaths[j], rd)
                    );
                  }
                }

                shapeData.shape.paths = shapeData.localShapeCollection;
              }
            }

            if (!this.dynamicProperties.length) {
              this._mdf = false;
            }
          };

          function getFontProperties(fontData) {
            var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
            var fWeight = "normal";
            var fStyle = "normal";
            var len = styles.length;
            var styleName;

            for (var i = 0; i < len; i += 1) {
              styleName = styles[i].toLowerCase();

              switch (styleName) {
                case "italic":
                  fStyle = "italic";
                  break;

                case "bold":
                  fWeight = "700";
                  break;

                case "black":
                  fWeight = "900";
                  break;

                case "medium":
                  fWeight = "500";
                  break;

                case "regular":
                case "normal":
                  fWeight = "400";
                  break;

                case "light":
                case "thin":
                  fWeight = "200";
                  break;

                default:
                  break;
              }
            }

            return {
              style: fStyle,
              weight: fontData.fWeight || fWeight,
            };
          }

          var FontManager = (function () {
            var maxWaitingTime = 5000;
            var emptyChar = {
              w: 0,
              size: 0,
              shapes: [],
              data: {
                shapes: [],
              },
            };
            var combinedCharacters = []; // Hindi characters

            combinedCharacters = combinedCharacters.concat([
              2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368,
              2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
              2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403,
            ]);
            var surrogateModifiers = [
              "d83cdffb",
              "d83cdffc",
              "d83cdffd",
              "d83cdffe",
              "d83cdfff",
            ];
            var zeroWidthJoiner = [65039, 8205];

            function trimFontOptions(font) {
              var familyArray = font.split(",");
              var i;
              var len = familyArray.length;
              var enabledFamilies = [];

              for (i = 0; i < len; i += 1) {
                if (
                  familyArray[i] !== "sans-serif" &&
                  familyArray[i] !== "monospace"
                ) {
                  enabledFamilies.push(familyArray[i]);
                }
              }

              return enabledFamilies.join(",");
            }

            function setUpNode(font, family) {
              var parentNode = createTag("span"); // Node is invisible to screen readers.

              parentNode.setAttribute("aria-hidden", true);
              parentNode.style.fontFamily = family;
              var node = createTag("span"); // Characters that vary significantly among different fonts

              node.innerText = "giItT1WQy@!-/#"; // Visible - so we can measure it - but not on the screen

              parentNode.style.position = "absolute";
              parentNode.style.left = "-10000px";
              parentNode.style.top = "-10000px"; // Large font size makes even subtle changes obvious

              parentNode.style.fontSize = "300px"; // Reset any font properties

              parentNode.style.fontVariant = "normal";
              parentNode.style.fontStyle = "normal";
              parentNode.style.fontWeight = "normal";
              parentNode.style.letterSpacing = "0";
              parentNode.appendChild(node);
              document.body.appendChild(parentNode); // Remember width with no applied web font

              var width = node.offsetWidth;
              node.style.fontFamily = trimFontOptions(font) + ", " + family;
              return {
                node: node,
                w: width,
                parent: parentNode,
              };
            }

            function checkLoadedFonts() {
              var i;
              var len = this.fonts.length;
              var node;
              var w;
              var loadedCount = len;

              for (i = 0; i < len; i += 1) {
                if (this.fonts[i].loaded) {
                  loadedCount -= 1;
                } else if (
                  this.fonts[i].fOrigin === "n" ||
                  this.fonts[i].origin === 0
                ) {
                  this.fonts[i].loaded = true;
                } else {
                  node = this.fonts[i].monoCase.node;
                  w = this.fonts[i].monoCase.w;

                  if (node.offsetWidth !== w) {
                    loadedCount -= 1;
                    this.fonts[i].loaded = true;
                  } else {
                    node = this.fonts[i].sansCase.node;
                    w = this.fonts[i].sansCase.w;

                    if (node.offsetWidth !== w) {
                      loadedCount -= 1;
                      this.fonts[i].loaded = true;
                    }
                  }

                  if (this.fonts[i].loaded) {
                    this.fonts[i].sansCase.parent.parentNode.removeChild(
                      this.fonts[i].sansCase.parent
                    );
                    this.fonts[i].monoCase.parent.parentNode.removeChild(
                      this.fonts[i].monoCase.parent
                    );
                  }
                }
              }

              if (
                loadedCount !== 0 &&
                Date.now() - this.initTime < maxWaitingTime
              ) {
                setTimeout(this.checkLoadedFontsBinded, 20);
              } else {
                setTimeout(this.setIsLoadedBinded, 10);
              }
            }

            function createHelper(def, fontData) {
              var tHelper = createNS("text");
              tHelper.style.fontSize = "100px"; // tHelper.style.fontFamily = fontData.fFamily;

              var fontProps = getFontProperties(fontData);
              tHelper.setAttribute("font-family", fontData.fFamily);
              tHelper.setAttribute("font-style", fontProps.style);
              tHelper.setAttribute("font-weight", fontProps.weight);
              tHelper.textContent = "1";

              if (fontData.fClass) {
                tHelper.style.fontFamily = "inherit";
                tHelper.setAttribute("class", fontData.fClass);
              } else {
                tHelper.style.fontFamily = fontData.fFamily;
              }

              def.appendChild(tHelper);
              var tCanvasHelper = createTag("canvas").getContext("2d");
              tCanvasHelper.font =
                fontData.fWeight +
                " " +
                fontData.fStyle +
                " 100px " +
                fontData.fFamily; // tCanvasHelper.font = ' 100px '+ fontData.fFamily;

              return tHelper;
            }

            function addFonts(fontData, defs) {
              if (!fontData) {
                this.isLoaded = true;
                return;
              }

              if (this.chars) {
                this.isLoaded = true;
                this.fonts = fontData.list;
                return;
              }

              var fontArr = fontData.list;
              var i;
              var len = fontArr.length;
              var _pendingFonts = len;

              for (i = 0; i < len; i += 1) {
                var shouldLoadFont = true;
                var loadedSelector;
                var j;
                fontArr[i].loaded = false;
                fontArr[i].monoCase = setUpNode(
                  fontArr[i].fFamily,
                  "monospace"
                );
                fontArr[i].sansCase = setUpNode(
                  fontArr[i].fFamily,
                  "sans-serif"
                );

                if (!fontArr[i].fPath) {
                  fontArr[i].loaded = true;
                  _pendingFonts -= 1;
                } else if (
                  fontArr[i].fOrigin === "p" ||
                  fontArr[i].origin === 3
                ) {
                  loadedSelector = document.querySelectorAll(
                    'style[f-forigin="p"][f-family="' +
                      fontArr[i].fFamily +
                      '"], style[f-origin="3"][f-family="' +
                      fontArr[i].fFamily +
                      '"]'
                  );

                  if (loadedSelector.length > 0) {
                    shouldLoadFont = false;
                  }

                  if (shouldLoadFont) {
                    var s = createTag("style");
                    s.setAttribute("f-forigin", fontArr[i].fOrigin);
                    s.setAttribute("f-origin", fontArr[i].origin);
                    s.setAttribute("f-family", fontArr[i].fFamily);
                    s.type = "text/css";
                    s.innerText =
                      "@font-face {font-family: " +
                      fontArr[i].fFamily +
                      "; font-style: normal; src: url('" +
                      fontArr[i].fPath +
                      "');}";
                    defs.appendChild(s);
                  }
                } else if (
                  fontArr[i].fOrigin === "g" ||
                  fontArr[i].origin === 1
                ) {
                  loadedSelector = document.querySelectorAll(
                    'link[f-forigin="g"], link[f-origin="1"]'
                  );

                  for (j = 0; j < loadedSelector.length; j += 1) {
                    if (
                      loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1
                    ) {
                      // Font is already loaded
                      shouldLoadFont = false;
                    }
                  }

                  if (shouldLoadFont) {
                    var l = createTag("link");
                    l.setAttribute("f-forigin", fontArr[i].fOrigin);
                    l.setAttribute("f-origin", fontArr[i].origin);
                    l.type = "text/css";
                    l.rel = "stylesheet";
                    l.href = fontArr[i].fPath;
                    document.body.appendChild(l);
                  }
                } else if (
                  fontArr[i].fOrigin === "t" ||
                  fontArr[i].origin === 2
                ) {
                  loadedSelector = document.querySelectorAll(
                    'script[f-forigin="t"], script[f-origin="2"]'
                  );

                  for (j = 0; j < loadedSelector.length; j += 1) {
                    if (fontArr[i].fPath === loadedSelector[j].src) {
                      // Font is already loaded
                      shouldLoadFont = false;
                    }
                  }

                  if (shouldLoadFont) {
                    var sc = createTag("link");
                    sc.setAttribute("f-forigin", fontArr[i].fOrigin);
                    sc.setAttribute("f-origin", fontArr[i].origin);
                    sc.setAttribute("rel", "stylesheet");
                    sc.setAttribute("href", fontArr[i].fPath);
                    defs.appendChild(sc);
                  }
                }

                fontArr[i].helper = createHelper(defs, fontArr[i]);
                fontArr[i].cache = {};
                this.fonts.push(fontArr[i]);
              }

              if (_pendingFonts === 0) {
                this.isLoaded = true;
              } else {
                // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
                // Adding this timeout seems to fix it
                setTimeout(this.checkLoadedFonts.bind(this), 100);
              }
            }

            function addChars(chars) {
              if (!chars) {
                return;
              }

              if (!this.chars) {
                this.chars = [];
              }

              var i;
              var len = chars.length;
              var j;
              var jLen = this.chars.length;
              var found;

              for (i = 0; i < len; i += 1) {
                j = 0;
                found = false;

                while (j < jLen) {
                  if (
                    this.chars[j].style === chars[i].style &&
                    this.chars[j].fFamily === chars[i].fFamily &&
                    this.chars[j].ch === chars[i].ch
                  ) {
                    found = true;
                  }

                  j += 1;
                }

                if (!found) {
                  this.chars.push(chars[i]);
                  jLen += 1;
                }
              }
            }

            function getCharData(_char, style, font) {
              var i = 0;
              var len = this.chars.length;

              while (i < len) {
                if (
                  this.chars[i].ch === _char &&
                  this.chars[i].style === style &&
                  this.chars[i].fFamily === font
                ) {
                  return this.chars[i];
                }

                i += 1;
              }

              if (
                ((typeof _char === "string" && _char.charCodeAt(0) !== 13) ||
                  !_char) &&
                console &&
                console.warn && // eslint-disable-line no-console
                !this._warned
              ) {
                this._warned = true;
                console.warn(
                  "Missing character from exported characters list: ",
                  _char,
                  style,
                  font
                ); // eslint-disable-line no-console
              }

              return emptyChar;
            }

            function measureText(_char2, fontName, size) {
              var fontData = this.getFontByName(fontName);

              var index = _char2.charCodeAt(0);

              if (!fontData.cache[index + 1]) {
                var tHelper = fontData.helper; // Canvas version
                // fontData.cache[index] = tHelper.measureText(char).width / 100;
                // SVG version
                // console.log(tHelper.getBBox().width)

                if (_char2 === " ") {
                  tHelper.textContent = "|" + _char2 + "|";
                  var doubleSize = tHelper.getComputedTextLength();
                  tHelper.textContent = "||";
                  var singleSize = tHelper.getComputedTextLength();
                  fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
                } else {
                  tHelper.textContent = _char2;
                  fontData.cache[index + 1] =
                    tHelper.getComputedTextLength() / 100;
                }
              }

              return fontData.cache[index + 1] * size;
            }

            function getFontByName(name) {
              var i = 0;
              var len = this.fonts.length;

              while (i < len) {
                if (this.fonts[i].fName === name) {
                  return this.fonts[i];
                }

                i += 1;
              }

              return this.fonts[0];
            }

            function isModifier(firstCharCode, secondCharCode) {
              var sum =
                firstCharCode.toString(16) + secondCharCode.toString(16);
              return surrogateModifiers.indexOf(sum) !== -1;
            }

            function isZeroWidthJoiner(firstCharCode, secondCharCode) {
              if (!secondCharCode) {
                return firstCharCode === zeroWidthJoiner[1];
              }

              return (
                firstCharCode === zeroWidthJoiner[0] &&
                secondCharCode === zeroWidthJoiner[1]
              );
            }

            function isCombinedCharacter(_char3) {
              return combinedCharacters.indexOf(_char3) !== -1;
            }

            function setIsLoaded() {
              this.isLoaded = true;
            }

            var Font = function Font() {
              this.fonts = [];
              this.chars = null;
              this.typekitLoaded = 0;
              this.isLoaded = false;
              this._warned = false;
              this.initTime = Date.now();
              this.setIsLoadedBinded = this.setIsLoaded.bind(this);
              this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
            };

            Font.isModifier = isModifier;
            Font.isZeroWidthJoiner = isZeroWidthJoiner;
            Font.isCombinedCharacter = isCombinedCharacter;
            var fontPrototype = {
              addChars: addChars,
              addFonts: addFonts,
              getCharData: getCharData,
              getFontByName: getFontByName,
              measureText: measureText,
              checkLoadedFonts: checkLoadedFonts,
              setIsLoaded: setIsLoaded,
            };
            Font.prototype = fontPrototype;
            return Font;
          })();

          function RenderableElement() {}

          RenderableElement.prototype = {
            initRenderable: function initRenderable() {
              // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
              this.isInRange = false; // layer's display state

              this.hidden = false; // If layer's transparency equals 0, it can be hidden

              this.isTransparent = false; // list of animated components

              this.renderableComponents = [];
            },
            addRenderableComponent: function addRenderableComponent(component) {
              if (this.renderableComponents.indexOf(component) === -1) {
                this.renderableComponents.push(component);
              }
            },
            removeRenderableComponent: function removeRenderableComponent(
              component
            ) {
              if (this.renderableComponents.indexOf(component) !== -1) {
                this.renderableComponents.splice(
                  this.renderableComponents.indexOf(component),
                  1
                );
              }
            },
            prepareRenderableFrame: function prepareRenderableFrame(num) {
              this.checkLayerLimits(num);
            },
            checkTransparency: function checkTransparency() {
              if (this.finalTransform.mProp.o.v <= 0) {
                if (
                  !this.isTransparent &&
                  this.globalData.renderConfig.hideOnTransparent
                ) {
                  this.isTransparent = true;
                  this.hide();
                }
              } else if (this.isTransparent) {
                this.isTransparent = false;
                this.show();
              }
            },

            /**
             * @function
             * Initializes frame related properties.
             *
             * @param {number} num
             * current frame number in Layer's time
             *
             */
            checkLayerLimits: function checkLayerLimits(num) {
              if (
                this.data.ip - this.data.st <= num &&
                this.data.op - this.data.st > num
              ) {
                if (this.isInRange !== true) {
                  this.globalData._mdf = true;
                  this._mdf = true;
                  this.isInRange = true;
                  this.show();
                }
              } else if (this.isInRange !== false) {
                this.globalData._mdf = true;
                this.isInRange = false;
                this.hide();
              }
            },
            renderRenderable: function renderRenderable() {
              var i;
              var len = this.renderableComponents.length;

              for (i = 0; i < len; i += 1) {
                this.renderableComponents[i].renderFrame(this._isFirstFrame);
              }
              /* this.maskManager.renderFrame(this.finalTransform.mat);
          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
            },
            sourceRectAtTime: function sourceRectAtTime() {
              return {
                top: 0,
                left: 0,
                width: 100,
                height: 100,
              };
            },
            getLayerSize: function getLayerSize() {
              if (this.data.ty === 5) {
                return {
                  w: this.data.textData.width,
                  h: this.data.textData.height,
                };
              }

              return {
                w: this.data.width,
                h: this.data.height,
              };
            },
          };

          var MaskManagerInterface = (function () {
            function MaskInterface(mask, data) {
              this._mask = mask;
              this._data = data;
            }

            Object.defineProperty(MaskInterface.prototype, "maskPath", {
              get: function get() {
                if (this._mask.prop.k) {
                  this._mask.prop.getValue();
                }

                return this._mask.prop;
              },
            });
            Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
              get: function get() {
                if (this._mask.op.k) {
                  this._mask.op.getValue();
                }

                return this._mask.op.v * 100;
              },
            });

            var MaskManager = function MaskManager(maskManager) {
              var _masksInterfaces = createSizedArray(
                maskManager.viewData.length
              );

              var i;
              var len = maskManager.viewData.length;

              for (i = 0; i < len; i += 1) {
                _masksInterfaces[i] = new MaskInterface(
                  maskManager.viewData[i],
                  maskManager.masksProperties[i]
                );
              }

              var maskFunction = function maskFunction(name) {
                i = 0;

                while (i < len) {
                  if (maskManager.masksProperties[i].nm === name) {
                    return _masksInterfaces[i];
                  }

                  i += 1;
                }

                return null;
              };

              return maskFunction;
            };

            return MaskManager;
          })();

          var ExpressionPropertyInterface = (function () {
            var defaultUnidimensionalValue = {
              pv: 0,
              v: 0,
              mult: 1,
            };
            var defaultMultidimensionalValue = {
              pv: [0, 0, 0],
              v: [0, 0, 0],
              mult: 1,
            };

            function completeProperty(expressionValue, property, type) {
              Object.defineProperty(expressionValue, "velocity", {
                get: function get() {
                  return property.getVelocityAtTime(property.comp.currentFrame);
                },
              });
              expressionValue.numKeys = property.keyframes
                ? property.keyframes.length
                : 0;

              expressionValue.key = function (pos) {
                if (!expressionValue.numKeys) {
                  return 0;
                }

                var value = "";

                if ("s" in property.keyframes[pos - 1]) {
                  value = property.keyframes[pos - 1].s;
                } else if ("e" in property.keyframes[pos - 2]) {
                  value = property.keyframes[pos - 2].e;
                } else {
                  value = property.keyframes[pos - 2].s;
                }

                var valueProp =
                  type === "unidimensional"
                    ? new Number(value)
                    : _extends({}, value); // eslint-disable-line no-new-wrappers

                valueProp.time =
                  property.keyframes[pos - 1].t /
                  property.elem.comp.globalData.frameRate;
                valueProp.value = type === "unidimensional" ? value[0] : value;
                return valueProp;
              };

              expressionValue.valueAtTime = property.getValueAtTime;
              expressionValue.speedAtTime = property.getSpeedAtTime;
              expressionValue.velocityAtTime = property.getVelocityAtTime;
              expressionValue.propertyGroup = property.propertyGroup;
            }

            function UnidimensionalPropertyInterface(property) {
              if (!property || !("pv" in property)) {
                property = defaultUnidimensionalValue;
              }

              var mult = 1 / property.mult;
              var val = property.pv * mult;
              var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

              expressionValue.value = val;
              completeProperty(expressionValue, property, "unidimensional");
              return function () {
                if (property.k) {
                  property.getValue();
                }

                val = property.v * mult;

                if (expressionValue.value !== val) {
                  expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

                  expressionValue.value = val;
                  completeProperty(expressionValue, property, "unidimensional");
                }

                return expressionValue;
              };
            }

            function MultidimensionalPropertyInterface(property) {
              if (!property || !("pv" in property)) {
                property = defaultMultidimensionalValue;
              }

              var mult = 1 / property.mult;
              var len =
                (property.data && property.data.l) || property.pv.length;
              var expressionValue = createTypedArray("float32", len);
              var arrValue = createTypedArray("float32", len);
              expressionValue.value = arrValue;
              completeProperty(expressionValue, property, "multidimensional");
              return function () {
                if (property.k) {
                  property.getValue();
                }

                for (var i = 0; i < len; i += 1) {
                  arrValue[i] = property.v[i] * mult;
                  expressionValue[i] = arrValue[i];
                }

                return expressionValue;
              };
            } // TODO: try to avoid using this getter

            function defaultGetter() {
              return defaultUnidimensionalValue;
            }

            return function (property) {
              if (!property) {
                return defaultGetter;
              }

              if (property.propType === "unidimensional") {
                return UnidimensionalPropertyInterface(property);
              }

              return MultidimensionalPropertyInterface(property);
            };
          })();

          var TransformExpressionInterface = (function () {
            return function (transform) {
              function _thisFunction(name) {
                switch (name) {
                  case "scale":
                  case "Scale":
                  case "ADBE Scale":
                  case 6:
                    return _thisFunction.scale;

                  case "rotation":
                  case "Rotation":
                  case "ADBE Rotation":
                  case "ADBE Rotate Z":
                  case 10:
                    return _thisFunction.rotation;

                  case "ADBE Rotate X":
                    return _thisFunction.xRotation;

                  case "ADBE Rotate Y":
                    return _thisFunction.yRotation;

                  case "position":
                  case "Position":
                  case "ADBE Position":
                  case 2:
                    return _thisFunction.position;

                  case "ADBE Position_0":
                    return _thisFunction.xPosition;

                  case "ADBE Position_1":
                    return _thisFunction.yPosition;

                  case "ADBE Position_2":
                    return _thisFunction.zPosition;

                  case "anchorPoint":
                  case "AnchorPoint":
                  case "Anchor Point":
                  case "ADBE AnchorPoint":
                  case 1:
                    return _thisFunction.anchorPoint;

                  case "opacity":
                  case "Opacity":
                  case 11:
                    return _thisFunction.opacity;

                  default:
                    return null;
                }
              }

              Object.defineProperty(_thisFunction, "rotation", {
                get: ExpressionPropertyInterface(transform.r || transform.rz),
              });
              Object.defineProperty(_thisFunction, "zRotation", {
                get: ExpressionPropertyInterface(transform.rz || transform.r),
              });
              Object.defineProperty(_thisFunction, "xRotation", {
                get: ExpressionPropertyInterface(transform.rx),
              });
              Object.defineProperty(_thisFunction, "yRotation", {
                get: ExpressionPropertyInterface(transform.ry),
              });
              Object.defineProperty(_thisFunction, "scale", {
                get: ExpressionPropertyInterface(transform.s),
              });

              var _px;

              var _py;

              var _pz;

              var _transformFactory;

              if (transform.p) {
                _transformFactory = ExpressionPropertyInterface(transform.p);
              } else {
                _px = ExpressionPropertyInterface(transform.px);
                _py = ExpressionPropertyInterface(transform.py);

                if (transform.pz) {
                  _pz = ExpressionPropertyInterface(transform.pz);
                }
              }

              Object.defineProperty(_thisFunction, "position", {
                get: function get() {
                  if (transform.p) {
                    return _transformFactory();
                  }

                  return [_px(), _py(), _pz ? _pz() : 0];
                },
              });
              Object.defineProperty(_thisFunction, "xPosition", {
                get: ExpressionPropertyInterface(transform.px),
              });
              Object.defineProperty(_thisFunction, "yPosition", {
                get: ExpressionPropertyInterface(transform.py),
              });
              Object.defineProperty(_thisFunction, "zPosition", {
                get: ExpressionPropertyInterface(transform.pz),
              });
              Object.defineProperty(_thisFunction, "anchorPoint", {
                get: ExpressionPropertyInterface(transform.a),
              });
              Object.defineProperty(_thisFunction, "opacity", {
                get: ExpressionPropertyInterface(transform.o),
              });
              Object.defineProperty(_thisFunction, "skew", {
                get: ExpressionPropertyInterface(transform.sk),
              });
              Object.defineProperty(_thisFunction, "skewAxis", {
                get: ExpressionPropertyInterface(transform.sa),
              });
              Object.defineProperty(_thisFunction, "orientation", {
                get: ExpressionPropertyInterface(transform.or),
              });
              return _thisFunction;
            };
          })();

          var LayerExpressionInterface = (function () {
            function getMatrix(time) {
              var toWorldMat = new Matrix();

              if (time !== undefined) {
                var propMatrix =
                  this._elem.finalTransform.mProp.getValueAtTime(time);

                propMatrix.clone(toWorldMat);
              } else {
                var transformMat = this._elem.finalTransform.mProp;
                transformMat.applyToMatrix(toWorldMat);
              }

              return toWorldMat;
            }

            function toWorldVec(arr, time) {
              var toWorldMat = this.getMatrix(time);
              toWorldMat.props[12] = 0;
              toWorldMat.props[13] = 0;
              toWorldMat.props[14] = 0;
              return this.applyPoint(toWorldMat, arr);
            }

            function toWorld(arr, time) {
              var toWorldMat = this.getMatrix(time);
              return this.applyPoint(toWorldMat, arr);
            }

            function fromWorldVec(arr, time) {
              var toWorldMat = this.getMatrix(time);
              toWorldMat.props[12] = 0;
              toWorldMat.props[13] = 0;
              toWorldMat.props[14] = 0;
              return this.invertPoint(toWorldMat, arr);
            }

            function fromWorld(arr, time) {
              var toWorldMat = this.getMatrix(time);
              return this.invertPoint(toWorldMat, arr);
            }

            function applyPoint(matrix, arr) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i;
                var len = this._elem.hierarchy.length;

                for (i = 0; i < len; i += 1) {
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(
                    matrix
                  );
                }
              }

              return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
            }

            function invertPoint(matrix, arr) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i;
                var len = this._elem.hierarchy.length;

                for (i = 0; i < len; i += 1) {
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(
                    matrix
                  );
                }
              }

              return matrix.inversePoint(arr);
            }

            function fromComp(arr) {
              var toWorldMat = new Matrix();
              toWorldMat.reset();

              this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);

              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i;
                var len = this._elem.hierarchy.length;

                for (i = 0; i < len; i += 1) {
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(
                    toWorldMat
                  );
                }

                return toWorldMat.inversePoint(arr);
              }

              return toWorldMat.inversePoint(arr);
            }

            function sampleImage() {
              return [1, 1, 1, 1];
            }

            return function (elem) {
              var transformInterface;

              function _registerMaskInterface(maskManager) {
                _thisLayerFunction.mask = new MaskManagerInterface(
                  maskManager,
                  elem
                );
              }

              function _registerEffectsInterface(effects) {
                _thisLayerFunction.effect = effects;
              }

              function _thisLayerFunction(name) {
                switch (name) {
                  case "ADBE Root Vectors Group":
                  case "Contents":
                  case 2:
                    return _thisLayerFunction.shapeInterface;

                  case 1:
                  case 6:
                  case "Transform":
                  case "transform":
                  case "ADBE Transform Group":
                    return transformInterface;

                  case 4:
                  case "ADBE Effect Parade":
                  case "effects":
                  case "Effects":
                    return _thisLayerFunction.effect;

                  case "ADBE Text Properties":
                    return _thisLayerFunction.textInterface;

                  default:
                    return null;
                }
              }

              _thisLayerFunction.getMatrix = getMatrix;
              _thisLayerFunction.invertPoint = invertPoint;
              _thisLayerFunction.applyPoint = applyPoint;
              _thisLayerFunction.toWorld = toWorld;
              _thisLayerFunction.toWorldVec = toWorldVec;
              _thisLayerFunction.fromWorld = fromWorld;
              _thisLayerFunction.fromWorldVec = fromWorldVec;
              _thisLayerFunction.toComp = toWorld;
              _thisLayerFunction.fromComp = fromComp;
              _thisLayerFunction.sampleImage = sampleImage;
              _thisLayerFunction.sourceRectAtTime =
                elem.sourceRectAtTime.bind(elem);
              _thisLayerFunction._elem = elem;
              transformInterface = TransformExpressionInterface(
                elem.finalTransform.mProp
              );
              var anchorPointDescriptor = getDescriptor(
                transformInterface,
                "anchorPoint"
              );
              Object.defineProperties(_thisLayerFunction, {
                hasParent: {
                  get: function get() {
                    return elem.hierarchy.length;
                  },
                },
                parent: {
                  get: function get() {
                    return elem.hierarchy[0].layerInterface;
                  },
                },
                rotation: getDescriptor(transformInterface, "rotation"),
                scale: getDescriptor(transformInterface, "scale"),
                position: getDescriptor(transformInterface, "position"),
                opacity: getDescriptor(transformInterface, "opacity"),
                anchorPoint: anchorPointDescriptor,
                anchor_point: anchorPointDescriptor,
                transform: {
                  get: function get() {
                    return transformInterface;
                  },
                },
                active: {
                  get: function get() {
                    return elem.isInRange;
                  },
                },
              });
              _thisLayerFunction.startTime = elem.data.st;
              _thisLayerFunction.index = elem.data.ind;
              _thisLayerFunction.source = elem.data.refId;
              _thisLayerFunction.height =
                elem.data.ty === 0 ? elem.data.h : 100;
              _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
              _thisLayerFunction.inPoint =
                elem.data.ip / elem.comp.globalData.frameRate;
              _thisLayerFunction.outPoint =
                elem.data.op / elem.comp.globalData.frameRate;
              _thisLayerFunction._name = elem.data.nm;
              _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
              _thisLayerFunction.registerEffectsInterface =
                _registerEffectsInterface;
              return _thisLayerFunction;
            };
          })();

          var propertyGroupFactory = (function () {
            return function (interfaceFunction, parentPropertyGroup) {
              return function (val) {
                val = val === undefined ? 1 : val;

                if (val <= 0) {
                  return interfaceFunction;
                }

                return parentPropertyGroup(val - 1);
              };
            };
          })();

          var PropertyInterface = (function () {
            return function (propertyName, propertyGroup) {
              var interfaceFunction = {
                _name: propertyName,
              };

              function _propertyGroup(val) {
                val = val === undefined ? 1 : val;

                if (val <= 0) {
                  return interfaceFunction;
                }

                return propertyGroup(val - 1);
              }

              return _propertyGroup;
            };
          })();

          var EffectsExpressionInterface = (function () {
            var ob = {
              createEffectsInterface: createEffectsInterface,
            };

            function createEffectsInterface(elem, propertyGroup) {
              if (elem.effectsManager) {
                var effectElements = [];
                var effectsData = elem.data.ef;
                var i;
                var len = elem.effectsManager.effectElements.length;

                for (i = 0; i < len; i += 1) {
                  effectElements.push(
                    createGroupInterface(
                      effectsData[i],
                      elem.effectsManager.effectElements[i],
                      propertyGroup,
                      elem
                    )
                  );
                }

                var effects = elem.data.ef || [];

                var groupInterface = function groupInterface(name) {
                  i = 0;
                  len = effects.length;

                  while (i < len) {
                    if (
                      name === effects[i].nm ||
                      name === effects[i].mn ||
                      name === effects[i].ix
                    ) {
                      return effectElements[i];
                    }

                    i += 1;
                  }

                  return null;
                };

                Object.defineProperty(groupInterface, "numProperties", {
                  get: function get() {
                    return effects.length;
                  },
                });
                return groupInterface;
              }

              return null;
            }

            function createGroupInterface(data, elements, propertyGroup, elem) {
              function groupInterface(name) {
                var effects = data.ef;
                var i = 0;
                var len = effects.length;

                while (i < len) {
                  if (
                    name === effects[i].nm ||
                    name === effects[i].mn ||
                    name === effects[i].ix
                  ) {
                    if (effects[i].ty === 5) {
                      return effectElements[i];
                    }

                    return effectElements[i]();
                  }

                  i += 1;
                }

                throw new Error();
              }

              var _propertyGroup = propertyGroupFactory(
                groupInterface,
                propertyGroup
              );

              var effectElements = [];
              var i;
              var len = data.ef.length;

              for (i = 0; i < len; i += 1) {
                if (data.ef[i].ty === 5) {
                  effectElements.push(
                    createGroupInterface(
                      data.ef[i],
                      elements.effectElements[i],
                      elements.effectElements[i].propertyGroup,
                      elem
                    )
                  );
                } else {
                  effectElements.push(
                    createValueInterface(
                      elements.effectElements[i],
                      data.ef[i].ty,
                      elem,
                      _propertyGroup
                    )
                  );
                }
              }

              if (data.mn === "ADBE Color Control") {
                Object.defineProperty(groupInterface, "color", {
                  get: function get() {
                    return effectElements[0]();
                  },
                });
              }

              Object.defineProperties(groupInterface, {
                numProperties: {
                  get: function get() {
                    return data.np;
                  },
                },
                _name: {
                  value: data.nm,
                },
                propertyGroup: {
                  value: _propertyGroup,
                },
              });
              groupInterface.enabled = data.en !== 0;
              groupInterface.active = groupInterface.enabled;
              return groupInterface;
            }

            function createValueInterface(element, type, elem, propertyGroup) {
              var expressionProperty = ExpressionPropertyInterface(element.p);

              function interfaceFunction() {
                if (type === 10) {
                  return elem.comp.compInterface(element.p.v);
                }

                return expressionProperty();
              }

              if (element.p.setGroupProperty) {
                element.p.setGroupProperty(
                  PropertyInterface("", propertyGroup)
                );
              }

              return interfaceFunction;
            }

            return ob;
          })();

          var CompExpressionInterface = (function () {
            return function (comp) {
              function _thisLayerFunction(name) {
                var i = 0;
                var len = comp.layers.length;

                while (i < len) {
                  if (
                    comp.layers[i].nm === name ||
                    comp.layers[i].ind === name
                  ) {
                    return comp.elements[i].layerInterface;
                  }

                  i += 1;
                }

                return null; // return {active:false};
              }

              Object.defineProperty(_thisLayerFunction, "_name", {
                value: comp.data.nm,
              });
              _thisLayerFunction.layer = _thisLayerFunction;
              _thisLayerFunction.pixelAspect = 1;
              _thisLayerFunction.height =
                comp.data.h || comp.globalData.compSize.h;
              _thisLayerFunction.width =
                comp.data.w || comp.globalData.compSize.w;
              _thisLayerFunction.pixelAspect = 1;
              _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
              _thisLayerFunction.displayStartTime = 0;
              _thisLayerFunction.numLayers = comp.layers.length;
              return _thisLayerFunction;
            };
          })();

          var ShapePathInterface = (function () {
            return function pathInterfaceFactory(shape, view, propertyGroup) {
              var prop = view.sh;

              function interfaceFunction(val) {
                if (
                  val === "Shape" ||
                  val === "shape" ||
                  val === "Path" ||
                  val === "path" ||
                  val === "ADBE Vector Shape" ||
                  val === 2
                ) {
                  return interfaceFunction.path;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
              Object.defineProperties(interfaceFunction, {
                path: {
                  get: function get() {
                    if (prop.k) {
                      prop.getValue();
                    }

                    return prop;
                  },
                },
                shape: {
                  get: function get() {
                    if (prop.k) {
                      prop.getValue();
                    }

                    return prop;
                  },
                },
                _name: {
                  value: shape.nm,
                },
                ix: {
                  value: shape.ix,
                },
                propertyIndex: {
                  value: shape.ix,
                },
                mn: {
                  value: shape.mn,
                },
                propertyGroup: {
                  value: propertyGroup,
                },
              });
              return interfaceFunction;
            };
          })();

          var ShapeExpressionInterface = (function () {
            function iterateElements(shapes, view, propertyGroup) {
              var arr = [];
              var i;
              var len = shapes ? shapes.length : 0;

              for (i = 0; i < len; i += 1) {
                if (shapes[i].ty === "gr") {
                  arr.push(
                    groupInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "fl") {
                  arr.push(
                    fillInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "st") {
                  arr.push(
                    strokeInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "tm") {
                  arr.push(
                    trimInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "tr") {
                  // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));
                } else if (shapes[i].ty === "el") {
                  arr.push(
                    ellipseInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "sr") {
                  arr.push(
                    starInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "sh") {
                  arr.push(
                    ShapePathInterface(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "rc") {
                  arr.push(
                    rectInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "rd") {
                  arr.push(
                    roundedInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "rp") {
                  arr.push(
                    repeaterInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                } else if (shapes[i].ty === "gf") {
                  arr.push(
                    gradientFillInterfaceFactory(
                      shapes[i],
                      view[i],
                      propertyGroup
                    )
                  );
                } else {
                  arr.push(
                    defaultInterfaceFactory(shapes[i], view[i], propertyGroup)
                  );
                }
              }

              return arr;
            }

            function contentsInterfaceFactory(shape, view, propertyGroup) {
              var interfaces;

              var interfaceFunction = function _interfaceFunction(value) {
                var i = 0;
                var len = interfaces.length;

                while (i < len) {
                  if (
                    interfaces[i]._name === value ||
                    interfaces[i].mn === value ||
                    interfaces[i].propertyIndex === value ||
                    interfaces[i].ix === value ||
                    interfaces[i].ind === value
                  ) {
                    return interfaces[i];
                  }

                  i += 1;
                }

                if (typeof value === "number") {
                  return interfaces[value - 1];
                }

                return null;
              };

              interfaceFunction.propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );
              interfaces = iterateElements(
                shape.it,
                view.it,
                interfaceFunction.propertyGroup
              );
              interfaceFunction.numProperties = interfaces.length;
              var transformInterface = transformInterfaceFactory(
                shape.it[shape.it.length - 1],
                view.it[view.it.length - 1],
                interfaceFunction.propertyGroup
              );
              interfaceFunction.transform = transformInterface;
              interfaceFunction.propertyIndex = shape.cix;
              interfaceFunction._name = shape.nm;
              return interfaceFunction;
            }

            function groupInterfaceFactory(shape, view, propertyGroup) {
              var interfaceFunction = function _interfaceFunction(value) {
                switch (value) {
                  case "ADBE Vectors Group":
                  case "Contents":
                  case 2:
                    return interfaceFunction.content;
                  // Not necessary for now. Keeping them here in case a new case appears
                  // case 'ADBE Vector Transform Group':
                  // case 3:

                  default:
                    return interfaceFunction.transform;
                }
              };

              interfaceFunction.propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );
              var content = contentsInterfaceFactory(
                shape,
                view,
                interfaceFunction.propertyGroup
              );
              var transformInterface = transformInterfaceFactory(
                shape.it[shape.it.length - 1],
                view.it[view.it.length - 1],
                interfaceFunction.propertyGroup
              );
              interfaceFunction.content = content;
              interfaceFunction.transform = transformInterface;
              Object.defineProperty(interfaceFunction, "_name", {
                get: function get() {
                  return shape.nm;
                },
              }); // interfaceFunction.content = interfaceFunction;

              interfaceFunction.numProperties = shape.np;
              interfaceFunction.propertyIndex = shape.ix;
              interfaceFunction.nm = shape.nm;
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            function fillInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(val) {
                if (val === "Color" || val === "color") {
                  return interfaceFunction.color;
                }

                if (val === "Opacity" || val === "opacity") {
                  return interfaceFunction.opacity;
                }

                return null;
              }

              Object.defineProperties(interfaceFunction, {
                color: {
                  get: ExpressionPropertyInterface(view.c),
                },
                opacity: {
                  get: ExpressionPropertyInterface(view.o),
                },
                _name: {
                  value: shape.nm,
                },
                mn: {
                  value: shape.mn,
                },
              });
              view.c.setGroupProperty(
                PropertyInterface("Color", propertyGroup)
              );
              view.o.setGroupProperty(
                PropertyInterface("Opacity", propertyGroup)
              );
              return interfaceFunction;
            }

            function gradientFillInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(val) {
                if (val === "Start Point" || val === "start point") {
                  return interfaceFunction.startPoint;
                }

                if (val === "End Point" || val === "end point") {
                  return interfaceFunction.endPoint;
                }

                if (val === "Opacity" || val === "opacity") {
                  return interfaceFunction.opacity;
                }

                return null;
              }

              Object.defineProperties(interfaceFunction, {
                startPoint: {
                  get: ExpressionPropertyInterface(view.s),
                },
                endPoint: {
                  get: ExpressionPropertyInterface(view.e),
                },
                opacity: {
                  get: ExpressionPropertyInterface(view.o),
                },
                type: {
                  get: function get() {
                    return "a";
                  },
                },
                _name: {
                  value: shape.nm,
                },
                mn: {
                  value: shape.mn,
                },
              });
              view.s.setGroupProperty(
                PropertyInterface("Start Point", propertyGroup)
              );
              view.e.setGroupProperty(
                PropertyInterface("End Point", propertyGroup)
              );
              view.o.setGroupProperty(
                PropertyInterface("Opacity", propertyGroup)
              );
              return interfaceFunction;
            }

            function defaultInterfaceFactory() {
              function interfaceFunction() {
                return null;
              }

              return interfaceFunction;
            }

            function strokeInterfaceFactory(shape, view, propertyGroup) {
              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              var _dashPropertyGroup = propertyGroupFactory(
                dashOb,
                _propertyGroup
              );

              function addPropertyToDashOb(i) {
                Object.defineProperty(dashOb, shape.d[i].nm, {
                  get: ExpressionPropertyInterface(view.d.dataProps[i].p),
                });
              }

              var i;
              var len = shape.d ? shape.d.length : 0;
              var dashOb = {};

              for (i = 0; i < len; i += 1) {
                addPropertyToDashOb(i);
                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
              }

              function interfaceFunction(val) {
                if (val === "Color" || val === "color") {
                  return interfaceFunction.color;
                }

                if (val === "Opacity" || val === "opacity") {
                  return interfaceFunction.opacity;
                }

                if (val === "Stroke Width" || val === "stroke width") {
                  return interfaceFunction.strokeWidth;
                }

                return null;
              }

              Object.defineProperties(interfaceFunction, {
                color: {
                  get: ExpressionPropertyInterface(view.c),
                },
                opacity: {
                  get: ExpressionPropertyInterface(view.o),
                },
                strokeWidth: {
                  get: ExpressionPropertyInterface(view.w),
                },
                dash: {
                  get: function get() {
                    return dashOb;
                  },
                },
                _name: {
                  value: shape.nm,
                },
                mn: {
                  value: shape.mn,
                },
              });
              view.c.setGroupProperty(
                PropertyInterface("Color", _propertyGroup)
              );
              view.o.setGroupProperty(
                PropertyInterface("Opacity", _propertyGroup)
              );
              view.w.setGroupProperty(
                PropertyInterface("Stroke Width", _propertyGroup)
              );
              return interfaceFunction;
            }

            function trimInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(val) {
                if (val === shape.e.ix || val === "End" || val === "end") {
                  return interfaceFunction.end;
                }

                if (val === shape.s.ix) {
                  return interfaceFunction.start;
                }

                if (val === shape.o.ix) {
                  return interfaceFunction.offset;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              interfaceFunction.propertyIndex = shape.ix;
              view.s.setGroupProperty(
                PropertyInterface("Start", _propertyGroup)
              );
              view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
              view.o.setGroupProperty(
                PropertyInterface("Offset", _propertyGroup)
              );
              interfaceFunction.propertyIndex = shape.ix;
              interfaceFunction.propertyGroup = propertyGroup;
              Object.defineProperties(interfaceFunction, {
                start: {
                  get: ExpressionPropertyInterface(view.s),
                },
                end: {
                  get: ExpressionPropertyInterface(view.e),
                },
                offset: {
                  get: ExpressionPropertyInterface(view.o),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            function transformInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(value) {
                if (shape.a.ix === value || value === "Anchor Point") {
                  return interfaceFunction.anchorPoint;
                }

                if (shape.o.ix === value || value === "Opacity") {
                  return interfaceFunction.opacity;
                }

                if (shape.p.ix === value || value === "Position") {
                  return interfaceFunction.position;
                }

                if (
                  shape.r.ix === value ||
                  value === "Rotation" ||
                  value === "ADBE Vector Rotation"
                ) {
                  return interfaceFunction.rotation;
                }

                if (shape.s.ix === value || value === "Scale") {
                  return interfaceFunction.scale;
                }

                if ((shape.sk && shape.sk.ix === value) || value === "Skew") {
                  return interfaceFunction.skew;
                }

                if (
                  (shape.sa && shape.sa.ix === value) ||
                  value === "Skew Axis"
                ) {
                  return interfaceFunction.skewAxis;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              view.transform.mProps.o.setGroupProperty(
                PropertyInterface("Opacity", _propertyGroup)
              );
              view.transform.mProps.p.setGroupProperty(
                PropertyInterface("Position", _propertyGroup)
              );
              view.transform.mProps.a.setGroupProperty(
                PropertyInterface("Anchor Point", _propertyGroup)
              );
              view.transform.mProps.s.setGroupProperty(
                PropertyInterface("Scale", _propertyGroup)
              );
              view.transform.mProps.r.setGroupProperty(
                PropertyInterface("Rotation", _propertyGroup)
              );

              if (view.transform.mProps.sk) {
                view.transform.mProps.sk.setGroupProperty(
                  PropertyInterface("Skew", _propertyGroup)
                );
                view.transform.mProps.sa.setGroupProperty(
                  PropertyInterface("Skew Angle", _propertyGroup)
                );
              }

              view.transform.op.setGroupProperty(
                PropertyInterface("Opacity", _propertyGroup)
              );
              Object.defineProperties(interfaceFunction, {
                opacity: {
                  get: ExpressionPropertyInterface(view.transform.mProps.o),
                },
                position: {
                  get: ExpressionPropertyInterface(view.transform.mProps.p),
                },
                anchorPoint: {
                  get: ExpressionPropertyInterface(view.transform.mProps.a),
                },
                scale: {
                  get: ExpressionPropertyInterface(view.transform.mProps.s),
                },
                rotation: {
                  get: ExpressionPropertyInterface(view.transform.mProps.r),
                },
                skew: {
                  get: ExpressionPropertyInterface(view.transform.mProps.sk),
                },
                skewAxis: {
                  get: ExpressionPropertyInterface(view.transform.mProps.sa),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.ty = "tr";
              interfaceFunction.mn = shape.mn;
              interfaceFunction.propertyGroup = propertyGroup;
              return interfaceFunction;
            }

            function ellipseInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(value) {
                if (shape.p.ix === value) {
                  return interfaceFunction.position;
                }

                if (shape.s.ix === value) {
                  return interfaceFunction.size;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              interfaceFunction.propertyIndex = shape.ix;
              var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
              prop.s.setGroupProperty(
                PropertyInterface("Size", _propertyGroup)
              );
              prop.p.setGroupProperty(
                PropertyInterface("Position", _propertyGroup)
              );
              Object.defineProperties(interfaceFunction, {
                size: {
                  get: ExpressionPropertyInterface(prop.s),
                },
                position: {
                  get: ExpressionPropertyInterface(prop.p),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            function starInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(value) {
                if (shape.p.ix === value) {
                  return interfaceFunction.position;
                }

                if (shape.r.ix === value) {
                  return interfaceFunction.rotation;
                }

                if (shape.pt.ix === value) {
                  return interfaceFunction.points;
                }

                if (
                  shape.or.ix === value ||
                  value === "ADBE Vector Star Outer Radius"
                ) {
                  return interfaceFunction.outerRadius;
                }

                if (shape.os.ix === value) {
                  return interfaceFunction.outerRoundness;
                }

                if (
                  shape.ir &&
                  (shape.ir.ix === value ||
                    value === "ADBE Vector Star Inner Radius")
                ) {
                  return interfaceFunction.innerRadius;
                }

                if (shape.is && shape.is.ix === value) {
                  return interfaceFunction.innerRoundness;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
              interfaceFunction.propertyIndex = shape.ix;
              prop.or.setGroupProperty(
                PropertyInterface("Outer Radius", _propertyGroup)
              );
              prop.os.setGroupProperty(
                PropertyInterface("Outer Roundness", _propertyGroup)
              );
              prop.pt.setGroupProperty(
                PropertyInterface("Points", _propertyGroup)
              );
              prop.p.setGroupProperty(
                PropertyInterface("Position", _propertyGroup)
              );
              prop.r.setGroupProperty(
                PropertyInterface("Rotation", _propertyGroup)
              );

              if (shape.ir) {
                prop.ir.setGroupProperty(
                  PropertyInterface("Inner Radius", _propertyGroup)
                );
                prop.is.setGroupProperty(
                  PropertyInterface("Inner Roundness", _propertyGroup)
                );
              }

              Object.defineProperties(interfaceFunction, {
                position: {
                  get: ExpressionPropertyInterface(prop.p),
                },
                rotation: {
                  get: ExpressionPropertyInterface(prop.r),
                },
                points: {
                  get: ExpressionPropertyInterface(prop.pt),
                },
                outerRadius: {
                  get: ExpressionPropertyInterface(prop.or),
                },
                outerRoundness: {
                  get: ExpressionPropertyInterface(prop.os),
                },
                innerRadius: {
                  get: ExpressionPropertyInterface(prop.ir),
                },
                innerRoundness: {
                  get: ExpressionPropertyInterface(prop.is),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            function rectInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(value) {
                if (shape.p.ix === value) {
                  return interfaceFunction.position;
                }

                if (shape.r.ix === value) {
                  return interfaceFunction.roundness;
                }

                if (
                  shape.s.ix === value ||
                  value === "Size" ||
                  value === "ADBE Vector Rect Size"
                ) {
                  return interfaceFunction.size;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
              interfaceFunction.propertyIndex = shape.ix;
              prop.p.setGroupProperty(
                PropertyInterface("Position", _propertyGroup)
              );
              prop.s.setGroupProperty(
                PropertyInterface("Size", _propertyGroup)
              );
              prop.r.setGroupProperty(
                PropertyInterface("Rotation", _propertyGroup)
              );
              Object.defineProperties(interfaceFunction, {
                position: {
                  get: ExpressionPropertyInterface(prop.p),
                },
                roundness: {
                  get: ExpressionPropertyInterface(prop.r),
                },
                size: {
                  get: ExpressionPropertyInterface(prop.s),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            function roundedInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(value) {
                if (shape.r.ix === value || value === "Round Corners 1") {
                  return interfaceFunction.radius;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              var prop = view;
              interfaceFunction.propertyIndex = shape.ix;
              prop.rd.setGroupProperty(
                PropertyInterface("Radius", _propertyGroup)
              );
              Object.defineProperties(interfaceFunction, {
                radius: {
                  get: ExpressionPropertyInterface(prop.rd),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            function repeaterInterfaceFactory(shape, view, propertyGroup) {
              function interfaceFunction(value) {
                if (shape.c.ix === value || value === "Copies") {
                  return interfaceFunction.copies;
                }

                if (shape.o.ix === value || value === "Offset") {
                  return interfaceFunction.offset;
                }

                return null;
              }

              var _propertyGroup = propertyGroupFactory(
                interfaceFunction,
                propertyGroup
              );

              var prop = view;
              interfaceFunction.propertyIndex = shape.ix;
              prop.c.setGroupProperty(
                PropertyInterface("Copies", _propertyGroup)
              );
              prop.o.setGroupProperty(
                PropertyInterface("Offset", _propertyGroup)
              );
              Object.defineProperties(interfaceFunction, {
                copies: {
                  get: ExpressionPropertyInterface(prop.c),
                },
                offset: {
                  get: ExpressionPropertyInterface(prop.o),
                },
                _name: {
                  value: shape.nm,
                },
              });
              interfaceFunction.mn = shape.mn;
              return interfaceFunction;
            }

            return function (shapes, view, propertyGroup) {
              var interfaces;

              function _interfaceFunction(value) {
                if (typeof value === "number") {
                  value = value === undefined ? 1 : value;

                  if (value === 0) {
                    return propertyGroup;
                  }

                  return interfaces[value - 1];
                }

                var i = 0;
                var len = interfaces.length;

                while (i < len) {
                  if (interfaces[i]._name === value) {
                    return interfaces[i];
                  }

                  i += 1;
                }

                return null;
              }

              function parentGroupWrapper() {
                return propertyGroup;
              }

              _interfaceFunction.propertyGroup = propertyGroupFactory(
                _interfaceFunction,
                parentGroupWrapper
              );
              interfaces = iterateElements(
                shapes,
                view,
                _interfaceFunction.propertyGroup
              );
              _interfaceFunction.numProperties = interfaces.length;
              _interfaceFunction._name = "Contents";
              return _interfaceFunction;
            };
          })();

          var TextExpressionInterface = (function () {
            return function (elem) {
              var _prevValue;

              var _sourceText;

              function _thisLayerFunction(name) {
                switch (name) {
                  case "ADBE Text Document":
                    return _thisLayerFunction.sourceText;

                  default:
                    return null;
                }
              }

              Object.defineProperty(_thisLayerFunction, "sourceText", {
                get: function get() {
                  elem.textProperty.getValue();
                  var stringValue = elem.textProperty.currentData.t;

                  if (stringValue !== _prevValue) {
                    elem.textProperty.currentData.t = _prevValue;
                    _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
                    // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive

                    _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
                  }

                  return _sourceText;
                },
              });
              return _thisLayerFunction;
            };
          })();

          var getBlendMode = (function () {
            var blendModeEnums = {
              0: "source-over",
              1: "multiply",
              2: "screen",
              3: "overlay",
              4: "darken",
              5: "lighten",
              6: "color-dodge",
              7: "color-burn",
              8: "hard-light",
              9: "soft-light",
              10: "difference",
              11: "exclusion",
              12: "hue",
              13: "saturation",
              14: "color",
              15: "luminosity",
            };
            return function (mode) {
              return blendModeEnums[mode] || "";
            };
          })();

          function SliderEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
          }

          function AngleEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
          }

          function ColorEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
          }

          function PointEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
          }

          function LayerIndexEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
          }

          function MaskIndexEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
          }

          function CheckboxEffect(data, elem, container) {
            this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
          }

          function NoValueEffect() {
            this.p = {};
          }

          function EffectsManager(data, element) {
            var effects = data.ef || [];
            this.effectElements = [];
            var i;
            var len = effects.length;
            var effectItem;

            for (i = 0; i < len; i += 1) {
              effectItem = new GroupEffect(effects[i], element);
              this.effectElements.push(effectItem);
            }
          }

          function GroupEffect(data, element) {
            this.init(data, element);
          }

          extendPrototype([DynamicPropertyContainer], GroupEffect);
          GroupEffect.prototype.getValue =
            GroupEffect.prototype.iterateDynamicProperties;

          GroupEffect.prototype.init = function (data, element) {
            this.data = data;
            this.effectElements = [];
            this.initDynamicPropertyContainer(element);
            var i;
            var len = this.data.ef.length;
            var eff;
            var effects = this.data.ef;

            for (i = 0; i < len; i += 1) {
              eff = null;

              switch (effects[i].ty) {
                case 0:
                  eff = new SliderEffect(effects[i], element, this);
                  break;

                case 1:
                  eff = new AngleEffect(effects[i], element, this);
                  break;

                case 2:
                  eff = new ColorEffect(effects[i], element, this);
                  break;

                case 3:
                  eff = new PointEffect(effects[i], element, this);
                  break;

                case 4:
                case 7:
                  eff = new CheckboxEffect(effects[i], element, this);
                  break;

                case 10:
                  eff = new LayerIndexEffect(effects[i], element, this);
                  break;

                case 11:
                  eff = new MaskIndexEffect(effects[i], element, this);
                  break;

                case 5:
                  eff = new EffectsManager(effects[i], element, this);
                  break;
                // case 6:

                default:
                  eff = new NoValueEffect(effects[i], element, this);
                  break;
              }

              if (eff) {
                this.effectElements.push(eff);
              }
            }
          };

          function BaseElement() {}

          BaseElement.prototype = {
            checkMasks: function checkMasks() {
              if (!this.data.hasMask) {
                return false;
              }

              var i = 0;
              var len = this.data.masksProperties.length;

              while (i < len) {
                if (
                  this.data.masksProperties[i].mode !== "n" &&
                  this.data.masksProperties[i].cl !== false
                ) {
                  return true;
                }

                i += 1;
              }

              return false;
            },
            initExpressions: function initExpressions() {
              this.layerInterface = LayerExpressionInterface(this);

              if (this.data.hasMask && this.maskManager) {
                this.layerInterface.registerMaskInterface(this.maskManager);
              }

              var effectsInterface =
                EffectsExpressionInterface.createEffectsInterface(
                  this,
                  this.layerInterface
                );
              this.layerInterface.registerEffectsInterface(effectsInterface);

              if (this.data.ty === 0 || this.data.xt) {
                this.compInterface = CompExpressionInterface(this);
              } else if (this.data.ty === 4) {
                this.layerInterface.shapeInterface = ShapeExpressionInterface(
                  this.shapesData,
                  this.itemsData,
                  this.layerInterface
                );
                this.layerInterface.content =
                  this.layerInterface.shapeInterface;
              } else if (this.data.ty === 5) {
                this.layerInterface.textInterface =
                  TextExpressionInterface(this);
                this.layerInterface.text = this.layerInterface.textInterface;
              }
            },
            setBlendMode: function setBlendMode() {
              var blendModeValue = getBlendMode(this.data.bm);
              var elem = this.baseElement || this.layerElement;
              elem.style["mix-blend-mode"] = blendModeValue;
            },
            initBaseData: function initBaseData(data, globalData, comp) {
              this.globalData = globalData;
              this.comp = comp;
              this.data = data;
              this.layerId = createElementID(); // Stretch factor for old animations missing this property.

              if (!this.data.sr) {
                this.data.sr = 1;
              } // effects manager

              this.effectsManager = new EffectsManager(
                this.data,
                this,
                this.dynamicProperties
              );
            },
            getType: function getType() {
              return this.type;
            },
            sourceRectAtTime: function sourceRectAtTime() {},
          };

          /**
           * @file
           * Handles element's layer frame update.
           * Checks layer in point and out point
           *
           */
          function FrameElement() {}

          FrameElement.prototype = {
            /**
             * @function
             * Initializes frame related properties.
             *
             */
            initFrame: function initFrame() {
              // set to true when inpoint is rendered
              this._isFirstFrame = false; // list of animated properties

              this.dynamicProperties = []; // If layer has been modified in current tick this will be true

              this._mdf = false;
            },

            /**
             * @function
             * Calculates all dynamic values
             *
             * @param {number} num
             * current frame number in Layer's time
             * @param {boolean} isVisible
             * if layers is currently in range
             *
             */
            prepareProperties: function prepareProperties(num, isVisible) {
              var i;
              var len = this.dynamicProperties.length;

              for (i = 0; i < len; i += 1) {
                if (
                  isVisible ||
                  (this._isParent &&
                    this.dynamicProperties[i].propType === "transform")
                ) {
                  this.dynamicProperties[i].getValue();

                  if (this.dynamicProperties[i]._mdf) {
                    this.globalData._mdf = true;
                    this._mdf = true;
                  }
                }
              }
            },
            addDynamicProperty: function addDynamicProperty(prop) {
              if (this.dynamicProperties.indexOf(prop) === -1) {
                this.dynamicProperties.push(prop);
              }
            },
          };

          function _typeof$2(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof$2 = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof$2 = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof$2(obj);
          }

          var FootageInterface = (function () {
            var outlineInterfaceFactory = function outlineInterfaceFactory(
              elem
            ) {
              var currentPropertyName = "";
              var currentProperty = elem.getFootageData();

              function init() {
                currentPropertyName = "";
                currentProperty = elem.getFootageData();
                return searchProperty;
              }

              function searchProperty(value) {
                if (currentProperty[value]) {
                  currentPropertyName = value;
                  currentProperty = currentProperty[value];

                  if (_typeof$2(currentProperty) === "object") {
                    return searchProperty;
                  }

                  return currentProperty;
                }

                var propertyNameIndex = value.indexOf(currentPropertyName);

                if (propertyNameIndex !== -1) {
                  var index = parseInt(
                    value.substr(
                      propertyNameIndex + currentPropertyName.length
                    ),
                    10
                  );
                  currentProperty = currentProperty[index];

                  if (_typeof$2(currentProperty) === "object") {
                    return searchProperty;
                  }

                  return currentProperty;
                }

                return "";
              }

              return init;
            };

            var dataInterfaceFactory = function dataInterfaceFactory(elem) {
              function interfaceFunction(value) {
                if (value === "Outline") {
                  return interfaceFunction.outlineInterface();
                }

                return null;
              }

              interfaceFunction._name = "Outline";
              interfaceFunction.outlineInterface =
                outlineInterfaceFactory(elem);
              return interfaceFunction;
            };

            return function (elem) {
              function _interfaceFunction(value) {
                if (value === "Data") {
                  return _interfaceFunction.dataInterface;
                }

                return null;
              }

              _interfaceFunction._name = "Data";
              _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
              return _interfaceFunction;
            };
          })();

          function FootageElement(data, globalData, comp) {
            this.initFrame();
            this.initRenderable();
            this.assetData = globalData.getAssetData(data.refId);
            this.footageData = globalData.imageLoader.getAsset(this.assetData);
            this.initBaseData(data, globalData, comp);
          }

          FootageElement.prototype.prepareFrame = function () {};

          extendPrototype(
            [RenderableElement, BaseElement, FrameElement],
            FootageElement
          );

          FootageElement.prototype.getBaseElement = function () {
            return null;
          };

          FootageElement.prototype.renderFrame = function () {};

          FootageElement.prototype.destroy = function () {};

          FootageElement.prototype.initExpressions = function () {
            this.layerInterface = FootageInterface(this);
          };

          FootageElement.prototype.getFootageData = function () {
            return this.footageData;
          };

          function AudioElement(data, globalData, comp) {
            this.initFrame();
            this.initRenderable();
            this.assetData = globalData.getAssetData(data.refId);
            this.initBaseData(data, globalData, comp);
            this._isPlaying = false;
            this._canPlay = false;
            var assetPath = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(assetPath);
            this._currentTime = 0;
            this.globalData.audioController.addAudio(this);
            this.tm = data.tm
              ? PropertyFactory.getProp(
                  this,
                  data.tm,
                  0,
                  globalData.frameRate,
                  this
                )
              : {
                  _placeholder: true,
                };
          }

          AudioElement.prototype.prepareFrame = function (num) {
            this.prepareRenderableFrame(num, true);
            this.prepareProperties(num, true);

            if (!this.tm._placeholder) {
              var timeRemapped = this.tm.v;
              this._currentTime = timeRemapped;
            } else {
              this._currentTime = num / this.data.sr;
            }
          };

          extendPrototype(
            [RenderableElement, BaseElement, FrameElement],
            AudioElement
          );

          AudioElement.prototype.renderFrame = function () {
            if (this.isInRange && this._canPlay) {
              if (!this._isPlaying) {
                this.audio.play();
                this.audio.seek(this._currentTime / this.globalData.frameRate);
                this._isPlaying = true;
              } else if (
                !this.audio.playing() ||
                Math.abs(
                  this._currentTime / this.globalData.frameRate -
                    this.audio.seek()
                ) > 0.1
              ) {
                this.audio.seek(this._currentTime / this.globalData.frameRate);
              }
            }
          };

          AudioElement.prototype.show = function () {
            // this.audio.play()
          };

          AudioElement.prototype.hide = function () {
            this.audio.pause();
            this._isPlaying = false;
          };

          AudioElement.prototype.pause = function () {
            this.audio.pause();
            this._isPlaying = false;
            this._canPlay = false;
          };

          AudioElement.prototype.resume = function () {
            this._canPlay = true;
          };

          AudioElement.prototype.setRate = function (rateValue) {
            this.audio.rate(rateValue);
          };

          AudioElement.prototype.volume = function (volumeValue) {
            this.audio.volume(volumeValue);
          };

          AudioElement.prototype.getBaseElement = function () {
            return null;
          };

          AudioElement.prototype.destroy = function () {};

          AudioElement.prototype.sourceRectAtTime = function () {};

          AudioElement.prototype.initExpressions = function () {};

          function BaseRenderer() {}

          BaseRenderer.prototype.checkLayers = function (num) {
            var i;
            var len = this.layers.length;
            var data;
            this.completeLayers = true;

            for (i = len - 1; i >= 0; i -= 1) {
              if (!this.elements[i]) {
                data = this.layers[i];

                if (
                  data.ip - data.st <= num - this.layers[i].st &&
                  data.op - data.st > num - this.layers[i].st
                ) {
                  this.buildItem(i);
                }
              }

              this.completeLayers = this.elements[i]
                ? this.completeLayers
                : false;
            }

            this.checkPendingElements();
          };

          BaseRenderer.prototype.createItem = function (layer) {
            switch (layer.ty) {
              case 2:
                return this.createImage(layer);

              case 0:
                return this.createComp(layer);

              case 1:
                return this.createSolid(layer);

              case 3:
                return this.createNull(layer);

              case 4:
                return this.createShape(layer);

              case 5:
                return this.createText(layer);

              case 6:
                return this.createAudio(layer);

              case 13:
                return this.createCamera(layer);

              case 15:
                return this.createFootage(layer);

              default:
                return this.createNull(layer);
            }
          };

          BaseRenderer.prototype.createCamera = function () {
            throw new Error("You're using a 3d camera. Try the html renderer.");
          };

          BaseRenderer.prototype.createAudio = function (data) {
            return new AudioElement(data, this.globalData, this);
          };

          BaseRenderer.prototype.createFootage = function (data) {
            return new FootageElement(data, this.globalData, this);
          };

          BaseRenderer.prototype.buildAllItems = function () {
            var i;
            var len = this.layers.length;

            for (i = 0; i < len; i += 1) {
              this.buildItem(i);
            }

            this.checkPendingElements();
          };

          BaseRenderer.prototype.includeLayers = function (newLayers) {
            this.completeLayers = false;
            var i;
            var len = newLayers.length;
            var j;
            var jLen = this.layers.length;

            for (i = 0; i < len; i += 1) {
              j = 0;

              while (j < jLen) {
                if (this.layers[j].id === newLayers[i].id) {
                  this.layers[j] = newLayers[i];
                  break;
                }

                j += 1;
              }
            }
          };

          BaseRenderer.prototype.setProjectInterface = function (pInterface) {
            this.globalData.projectInterface = pInterface;
          };

          BaseRenderer.prototype.initItems = function () {
            if (!this.globalData.progressiveLoad) {
              this.buildAllItems();
            }
          };

          BaseRenderer.prototype.buildElementParenting = function (
            element,
            parentName,
            hierarchy
          ) {
            var elements = this.elements;
            var layers = this.layers;
            var i = 0;
            var len = layers.length;

            while (i < len) {
              if (layers[i].ind == parentName) {
                // eslint-disable-line eqeqeq
                if (!elements[i] || elements[i] === true) {
                  this.buildItem(i);
                  this.addPendingElement(element);
                } else {
                  hierarchy.push(elements[i]);
                  elements[i].setAsParent();

                  if (layers[i].parent !== undefined) {
                    this.buildElementParenting(
                      element,
                      layers[i].parent,
                      hierarchy
                    );
                  } else {
                    element.setHierarchy(hierarchy);
                  }
                }
              }

              i += 1;
            }
          };

          BaseRenderer.prototype.addPendingElement = function (element) {
            this.pendingElements.push(element);
          };

          BaseRenderer.prototype.searchExtraCompositions = function (assets) {
            var i;
            var len = assets.length;

            for (i = 0; i < len; i += 1) {
              if (assets[i].xt) {
                var comp = this.createComp(assets[i]);
                comp.initExpressions();
                this.globalData.projectInterface.registerComposition(comp);
              }
            }
          };

          BaseRenderer.prototype.setupGlobalData = function (
            animData,
            fontsContainer
          ) {
            this.globalData.fontManager = new FontManager();
            this.globalData.fontManager.addChars(animData.chars);
            this.globalData.fontManager.addFonts(
              animData.fonts,
              fontsContainer
            );
            this.globalData.getAssetData = this.animationItem.getAssetData.bind(
              this.animationItem
            );
            this.globalData.getAssetsPath =
              this.animationItem.getAssetsPath.bind(this.animationItem);
            this.globalData.imageLoader = this.animationItem.imagePreloader;
            this.globalData.audioController =
              this.animationItem.audioController;
            this.globalData.frameId = 0;
            this.globalData.frameRate = animData.fr;
            this.globalData.nm = animData.nm;
            this.globalData.compSize = {
              w: animData.w,
              h: animData.h,
            };
          };

          function TransformElement() {}

          TransformElement.prototype = {
            initTransform: function initTransform() {
              this.finalTransform = {
                mProp: this.data.ks
                  ? TransformPropertyFactory.getTransformProperty(
                      this,
                      this.data.ks,
                      this
                    )
                  : {
                      o: 0,
                    },
                _matMdf: false,
                _opMdf: false,
                mat: new Matrix(),
              };

              if (this.data.ao) {
                this.finalTransform.mProp.autoOriented = true;
              } // TODO: check TYPE 11: Guided elements

              if (this.data.ty !== 11) {
                // this.createElements();
              }
            },
            renderTransform: function renderTransform() {
              this.finalTransform._opMdf =
                this.finalTransform.mProp.o._mdf || this._isFirstFrame;
              this.finalTransform._matMdf =
                this.finalTransform.mProp._mdf || this._isFirstFrame;

              if (this.hierarchy) {
                var mat;
                var finalMat = this.finalTransform.mat;
                var i = 0;
                var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.

                if (!this.finalTransform._matMdf) {
                  while (i < len) {
                    if (this.hierarchy[i].finalTransform.mProp._mdf) {
                      this.finalTransform._matMdf = true;
                      break;
                    }

                    i += 1;
                  }
                }

                if (this.finalTransform._matMdf) {
                  mat = this.finalTransform.mProp.v.props;
                  finalMat.cloneFromProps(mat);

                  for (i = 0; i < len; i += 1) {
                    mat = this.hierarchy[i].finalTransform.mProp.v.props;
                    finalMat.transform(
                      mat[0],
                      mat[1],
                      mat[2],
                      mat[3],
                      mat[4],
                      mat[5],
                      mat[6],
                      mat[7],
                      mat[8],
                      mat[9],
                      mat[10],
                      mat[11],
                      mat[12],
                      mat[13],
                      mat[14],
                      mat[15]
                    );
                  }
                }
              }
            },
            globalToLocal: function globalToLocal(pt) {
              var transforms = [];
              transforms.push(this.finalTransform);
              var flag = true;
              var comp = this.comp;

              while (flag) {
                if (comp.finalTransform) {
                  if (comp.data.hasMask) {
                    transforms.splice(0, 0, comp.finalTransform);
                  }

                  comp = comp.comp;
                } else {
                  flag = false;
                }
              }

              var i;
              var len = transforms.length;
              var ptNew;

              for (i = 0; i < len; i += 1) {
                ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);

                pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
              }

              return pt;
            },
            mHelper: new Matrix(),
          };

          function MaskElement(data, element, globalData) {
            this.data = data;
            this.element = element;
            this.globalData = globalData;
            this.storedData = [];
            this.masksProperties = this.data.masksProperties || [];
            this.maskElement = null;
            var defs = this.globalData.defs;
            var i;
            var len = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(len);
            this.solidPath = "";
            var path;
            var properties = this.masksProperties;
            var count = 0;
            var currentMasks = [];
            var j;
            var jLen;
            var layerId = createElementID();
            var rect;
            var expansor;
            var feMorph;
            var x;
            var maskType = "clipPath";
            var maskRef = "clip-path";

            for (i = 0; i < len; i += 1) {
              if (
                (properties[i].mode !== "a" && properties[i].mode !== "n") ||
                properties[i].inv ||
                properties[i].o.k !== 100 ||
                properties[i].o.x
              ) {
                maskType = "mask";
                maskRef = "mask";
              }

              if (
                (properties[i].mode === "s" || properties[i].mode === "i") &&
                count === 0
              ) {
                rect = createNS("rect");
                rect.setAttribute("fill", "#ffffff");
                rect.setAttribute("width", this.element.comp.data.w || 0);
                rect.setAttribute("height", this.element.comp.data.h || 0);
                currentMasks.push(rect);
              } else {
                rect = null;
              }

              path = createNS("path");

              if (properties[i].mode === "n") {
                // TODO move this to a factory or to a constructor
                this.viewData[i] = {
                  op: PropertyFactory.getProp(
                    this.element,
                    properties[i].o,
                    0,
                    0.01,
                    this.element
                  ),
                  prop: ShapePropertyFactory.getShapeProp(
                    this.element,
                    properties[i],
                    3
                  ),
                  elem: path,
                  lastPath: "",
                };
                defs.appendChild(path);
              } else {
                count += 1;
                path.setAttribute(
                  "fill",
                  properties[i].mode === "s" ? "#000000" : "#ffffff"
                );
                path.setAttribute("clip-rule", "nonzero");
                var filterID;

                if (properties[i].x.k !== 0) {
                  maskType = "mask";
                  maskRef = "mask";
                  x = PropertyFactory.getProp(
                    this.element,
                    properties[i].x,
                    0,
                    null,
                    this.element
                  );
                  filterID = createElementID();
                  expansor = createNS("filter");
                  expansor.setAttribute("id", filterID);
                  feMorph = createNS("feMorphology");
                  feMorph.setAttribute("operator", "erode");
                  feMorph.setAttribute("in", "SourceGraphic");
                  feMorph.setAttribute("radius", "0");
                  expansor.appendChild(feMorph);
                  defs.appendChild(expansor);
                  path.setAttribute(
                    "stroke",
                    properties[i].mode === "s" ? "#000000" : "#ffffff"
                  );
                } else {
                  feMorph = null;
                  x = null;
                } // TODO move this to a factory or to a constructor

                this.storedData[i] = {
                  elem: path,
                  x: x,
                  expan: feMorph,
                  lastPath: "",
                  lastOperator: "",
                  filterId: filterID,
                  lastRadius: 0,
                };

                if (properties[i].mode === "i") {
                  jLen = currentMasks.length;
                  var g = createNS("g");

                  for (j = 0; j < jLen; j += 1) {
                    g.appendChild(currentMasks[j]);
                  }

                  var mask = createNS("mask");
                  mask.setAttribute("mask-type", "alpha");
                  mask.setAttribute("id", layerId + "_" + count);
                  mask.appendChild(path);
                  defs.appendChild(mask);
                  g.setAttribute(
                    "mask",
                    "url(" +
                      getLocationHref() +
                      "#" +
                      layerId +
                      "_" +
                      count +
                      ")"
                  );
                  currentMasks.length = 0;
                  currentMasks.push(g);
                } else {
                  currentMasks.push(path);
                }

                if (properties[i].inv && !this.solidPath) {
                  this.solidPath = this.createLayerSolidPath();
                } // TODO move this to a factory or to a constructor

                this.viewData[i] = {
                  elem: path,
                  lastPath: "",
                  op: PropertyFactory.getProp(
                    this.element,
                    properties[i].o,
                    0,
                    0.01,
                    this.element
                  ),
                  prop: ShapePropertyFactory.getShapeProp(
                    this.element,
                    properties[i],
                    3
                  ),
                  invRect: rect,
                };

                if (!this.viewData[i].prop.k) {
                  this.drawPath(
                    properties[i],
                    this.viewData[i].prop.v,
                    this.viewData[i]
                  );
                }
              }
            }

            this.maskElement = createNS(maskType);
            len = currentMasks.length;

            for (i = 0; i < len; i += 1) {
              this.maskElement.appendChild(currentMasks[i]);
            }

            if (count > 0) {
              this.maskElement.setAttribute("id", layerId);
              this.element.maskedElement.setAttribute(
                maskRef,
                "url(" + getLocationHref() + "#" + layerId + ")"
              );
              defs.appendChild(this.maskElement);
            }

            if (this.viewData.length) {
              this.element.addRenderableComponent(this);
            }
          }

          MaskElement.prototype.getMaskProperty = function (pos) {
            return this.viewData[pos].prop;
          };

          MaskElement.prototype.renderFrame = function (isFirstFrame) {
            var finalMat = this.element.finalTransform.mat;
            var i;
            var len = this.masksProperties.length;

            for (i = 0; i < len; i += 1) {
              if (this.viewData[i].prop._mdf || isFirstFrame) {
                this.drawPath(
                  this.masksProperties[i],
                  this.viewData[i].prop.v,
                  this.viewData[i]
                );
              }

              if (this.viewData[i].op._mdf || isFirstFrame) {
                this.viewData[i].elem.setAttribute(
                  "fill-opacity",
                  this.viewData[i].op.v
                );
              }

              if (this.masksProperties[i].mode !== "n") {
                if (
                  this.viewData[i].invRect &&
                  (this.element.finalTransform.mProp._mdf || isFirstFrame)
                ) {
                  this.viewData[i].invRect.setAttribute(
                    "transform",
                    finalMat.getInverseMatrix().to2dCSS()
                  );
                }

                if (
                  this.storedData[i].x &&
                  (this.storedData[i].x._mdf || isFirstFrame)
                ) {
                  var feMorph = this.storedData[i].expan;

                  if (this.storedData[i].x.v < 0) {
                    if (this.storedData[i].lastOperator !== "erode") {
                      this.storedData[i].lastOperator = "erode";
                      this.storedData[i].elem.setAttribute(
                        "filter",
                        "url(" +
                          getLocationHref() +
                          "#" +
                          this.storedData[i].filterId +
                          ")"
                      );
                    }

                    feMorph.setAttribute("radius", -this.storedData[i].x.v);
                  } else {
                    if (this.storedData[i].lastOperator !== "dilate") {
                      this.storedData[i].lastOperator = "dilate";
                      this.storedData[i].elem.setAttribute("filter", null);
                    }

                    this.storedData[i].elem.setAttribute(
                      "stroke-width",
                      this.storedData[i].x.v * 2
                    );
                  }
                }
              }
            }
          };

          MaskElement.prototype.getMaskelement = function () {
            return this.maskElement;
          };

          MaskElement.prototype.createLayerSolidPath = function () {
            var path = "M0,0 ";
            path += " h" + this.globalData.compSize.w;
            path += " v" + this.globalData.compSize.h;
            path += " h-" + this.globalData.compSize.w;
            path += " v-" + this.globalData.compSize.h + " ";
            return path;
          };

          MaskElement.prototype.drawPath = function (
            pathData,
            pathNodes,
            viewData
          ) {
            var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
            var i;
            var len;
            len = pathNodes._length;

            for (i = 1; i < len; i += 1) {
              // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
              pathString +=
                " C" +
                pathNodes.o[i - 1][0] +
                "," +
                pathNodes.o[i - 1][1] +
                " " +
                pathNodes.i[i][0] +
                "," +
                pathNodes.i[i][1] +
                " " +
                pathNodes.v[i][0] +
                "," +
                pathNodes.v[i][1];
            } // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];

            if (pathNodes.c && len > 1) {
              pathString +=
                " C" +
                pathNodes.o[i - 1][0] +
                "," +
                pathNodes.o[i - 1][1] +
                " " +
                pathNodes.i[0][0] +
                "," +
                pathNodes.i[0][1] +
                " " +
                pathNodes.v[0][0] +
                "," +
                pathNodes.v[0][1];
            } // pathNodes.__renderedString = pathString;

            if (viewData.lastPath !== pathString) {
              var pathShapeValue = "";

              if (viewData.elem) {
                if (pathNodes.c) {
                  pathShapeValue = pathData.inv
                    ? this.solidPath + pathString
                    : pathString;
                }

                viewData.elem.setAttribute("d", pathShapeValue);
              }

              viewData.lastPath = pathString;
            }
          };

          MaskElement.prototype.destroy = function () {
            this.element = null;
            this.globalData = null;
            this.maskElement = null;
            this.data = null;
            this.masksProperties = null;
          };

          var filtersFactory = (function () {
            var ob = {};
            ob.createFilter = createFilter;
            ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

            function createFilter(filId, skipCoordinates) {
              var fil = createNS("filter");
              fil.setAttribute("id", filId);

              if (skipCoordinates !== true) {
                fil.setAttribute("filterUnits", "objectBoundingBox");
                fil.setAttribute("x", "0%");
                fil.setAttribute("y", "0%");
                fil.setAttribute("width", "100%");
                fil.setAttribute("height", "100%");
              }

              return fil;
            }

            function createAlphaToLuminanceFilter() {
              var feColorMatrix = createNS("feColorMatrix");
              feColorMatrix.setAttribute("type", "matrix");
              feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
              feColorMatrix.setAttribute(
                "values",
                "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"
              );
              return feColorMatrix;
            }

            return ob;
          })();

          var featureSupport = (function () {
            var ob = {
              maskType: true,
            };

            if (
              /MSIE 10/i.test(navigator.userAgent) ||
              /MSIE 9/i.test(navigator.userAgent) ||
              /rv:11.0/i.test(navigator.userAgent) ||
              /Edge\/\d./i.test(navigator.userAgent)
            ) {
              ob.maskType = false;
            }

            return ob;
          })();

          function SVGTintFilter(filter, filterManager) {
            this.filterManager = filterManager;
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute(
              "color-interpolation-filters",
              "linearRGB"
            );
            feColorMatrix.setAttribute(
              "values",
              "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
            );
            feColorMatrix.setAttribute("result", "f1");
            filter.appendChild(feColorMatrix);
            feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute(
              "values",
              "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"
            );
            feColorMatrix.setAttribute("result", "f2");
            filter.appendChild(feColorMatrix);
            this.matrixFilter = feColorMatrix;

            if (
              filterManager.effectElements[2].p.v !== 100 ||
              filterManager.effectElements[2].p.k
            ) {
              var feMerge = createNS("feMerge");
              filter.appendChild(feMerge);
              var feMergeNode;
              feMergeNode = createNS("feMergeNode");
              feMergeNode.setAttribute("in", "SourceGraphic");
              feMerge.appendChild(feMergeNode);
              feMergeNode = createNS("feMergeNode");
              feMergeNode.setAttribute("in", "f2");
              feMerge.appendChild(feMergeNode);
            }
          }

          SVGTintFilter.prototype.renderFrame = function (forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var colorBlack = this.filterManager.effectElements[0].p.v;
              var colorWhite = this.filterManager.effectElements[1].p.v;
              var opacity = this.filterManager.effectElements[2].p.v / 100;
              this.matrixFilter.setAttribute(
                "values",
                colorWhite[0] -
                  colorBlack[0] +
                  " 0 0 0 " +
                  colorBlack[0] +
                  " " +
                  (colorWhite[1] - colorBlack[1]) +
                  " 0 0 0 " +
                  colorBlack[1] +
                  " " +
                  (colorWhite[2] - colorBlack[2]) +
                  " 0 0 0 " +
                  colorBlack[2] +
                  " 0 0 0 " +
                  opacity +
                  " 0"
              );
            }
          };

          function SVGFillFilter(filter, filterManager) {
            this.filterManager = filterManager;
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute(
              "values",
              "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"
            );
            filter.appendChild(feColorMatrix);
            this.matrixFilter = feColorMatrix;
          }

          SVGFillFilter.prototype.renderFrame = function (forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var color = this.filterManager.effectElements[2].p.v;
              var opacity = this.filterManager.effectElements[6].p.v;
              this.matrixFilter.setAttribute(
                "values",
                "0 0 0 0 " +
                  color[0] +
                  " 0 0 0 0 " +
                  color[1] +
                  " 0 0 0 0 " +
                  color[2] +
                  " 0 0 0 " +
                  opacity +
                  " 0"
              );
            }
          };

          function SVGStrokeEffect(elem, filterManager) {
            this.initialized = false;
            this.filterManager = filterManager;
            this.elem = elem;
            this.paths = [];
          }

          SVGStrokeEffect.prototype.initialize = function () {
            var elemChildren =
              this.elem.layerElement.children ||
              this.elem.layerElement.childNodes;
            var path;
            var groupPath;
            var i;
            var len;

            if (this.filterManager.effectElements[1].p.v === 1) {
              len = this.elem.maskManager.masksProperties.length;
              i = 0;
            } else {
              i = this.filterManager.effectElements[0].p.v - 1;
              len = i + 1;
            }

            groupPath = createNS("g");
            groupPath.setAttribute("fill", "none");
            groupPath.setAttribute("stroke-linecap", "round");
            groupPath.setAttribute("stroke-dashoffset", 1);

            for (i; i < len; i += 1) {
              path = createNS("path");
              groupPath.appendChild(path);
              this.paths.push({
                p: path,
                m: i,
              });
            }

            if (this.filterManager.effectElements[10].p.v === 3) {
              var mask = createNS("mask");
              var id = createElementID();
              mask.setAttribute("id", id);
              mask.setAttribute("mask-type", "alpha");
              mask.appendChild(groupPath);
              this.elem.globalData.defs.appendChild(mask);
              var g = createNS("g");
              g.setAttribute(
                "mask",
                "url(" + getLocationHref() + "#" + id + ")"
              );

              while (elemChildren[0]) {
                g.appendChild(elemChildren[0]);
              }

              this.elem.layerElement.appendChild(g);
              this.masker = mask;
              groupPath.setAttribute("stroke", "#fff");
            } else if (
              this.filterManager.effectElements[10].p.v === 1 ||
              this.filterManager.effectElements[10].p.v === 2
            ) {
              if (this.filterManager.effectElements[10].p.v === 2) {
                elemChildren =
                  this.elem.layerElement.children ||
                  this.elem.layerElement.childNodes;

                while (elemChildren.length) {
                  this.elem.layerElement.removeChild(elemChildren[0]);
                }
              }

              this.elem.layerElement.appendChild(groupPath);
              this.elem.layerElement.removeAttribute("mask");
              groupPath.setAttribute("stroke", "#fff");
            }

            this.initialized = true;
            this.pathMasker = groupPath;
          };

          SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
            if (!this.initialized) {
              this.initialize();
            }

            var i;
            var len = this.paths.length;
            var mask;
            var path;

            for (i = 0; i < len; i += 1) {
              if (this.paths[i].m !== -1) {
                mask = this.elem.maskManager.viewData[this.paths[i].m];
                path = this.paths[i].p;

                if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
                  path.setAttribute("d", mask.lastPath);
                }

                if (
                  forceRender ||
                  this.filterManager.effectElements[9].p._mdf ||
                  this.filterManager.effectElements[4].p._mdf ||
                  this.filterManager.effectElements[7].p._mdf ||
                  this.filterManager.effectElements[8].p._mdf ||
                  mask.prop._mdf
                ) {
                  var dasharrayValue;

                  if (
                    this.filterManager.effectElements[7].p.v !== 0 ||
                    this.filterManager.effectElements[8].p.v !== 100
                  ) {
                    var s =
                      Math.min(
                        this.filterManager.effectElements[7].p.v,
                        this.filterManager.effectElements[8].p.v
                      ) * 0.01;
                    var e =
                      Math.max(
                        this.filterManager.effectElements[7].p.v,
                        this.filterManager.effectElements[8].p.v
                      ) * 0.01;
                    var l = path.getTotalLength();
                    dasharrayValue = "0 0 0 " + l * s + " ";
                    var lineLength = l * (e - s);
                    var segment =
                      1 +
                      this.filterManager.effectElements[4].p.v *
                        2 *
                        this.filterManager.effectElements[9].p.v *
                        0.01;
                    var units = Math.floor(lineLength / segment);
                    var j;

                    for (j = 0; j < units; j += 1) {
                      dasharrayValue +=
                        "1 " +
                        this.filterManager.effectElements[4].p.v *
                          2 *
                          this.filterManager.effectElements[9].p.v *
                          0.01 +
                        " ";
                    }

                    dasharrayValue += "0 " + l * 10 + " 0 0";
                  } else {
                    dasharrayValue =
                      "1 " +
                      this.filterManager.effectElements[4].p.v *
                        2 *
                        this.filterManager.effectElements[9].p.v *
                        0.01;
                  }

                  path.setAttribute("stroke-dasharray", dasharrayValue);
                }
              }
            }

            if (forceRender || this.filterManager.effectElements[4].p._mdf) {
              this.pathMasker.setAttribute(
                "stroke-width",
                this.filterManager.effectElements[4].p.v * 2
              );
            }

            if (forceRender || this.filterManager.effectElements[6].p._mdf) {
              this.pathMasker.setAttribute(
                "opacity",
                this.filterManager.effectElements[6].p.v
              );
            }

            if (
              this.filterManager.effectElements[10].p.v === 1 ||
              this.filterManager.effectElements[10].p.v === 2
            ) {
              if (forceRender || this.filterManager.effectElements[3].p._mdf) {
                var color = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute(
                  "stroke",
                  "rgb(" +
                    bmFloor(color[0] * 255) +
                    "," +
                    bmFloor(color[1] * 255) +
                    "," +
                    bmFloor(color[2] * 255) +
                    ")"
                );
              }
            }
          };

          function SVGTritoneFilter(filter, filterManager) {
            this.filterManager = filterManager;
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute(
              "color-interpolation-filters",
              "linearRGB"
            );
            feColorMatrix.setAttribute(
              "values",
              "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
            );
            feColorMatrix.setAttribute("result", "f1");
            filter.appendChild(feColorMatrix);
            var feComponentTransfer = createNS("feComponentTransfer");
            feComponentTransfer.setAttribute(
              "color-interpolation-filters",
              "sRGB"
            );
            filter.appendChild(feComponentTransfer);
            this.matrixFilter = feComponentTransfer;
            var feFuncR = createNS("feFuncR");
            feFuncR.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFuncR);
            this.feFuncR = feFuncR;
            var feFuncG = createNS("feFuncG");
            feFuncG.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFuncG);
            this.feFuncG = feFuncG;
            var feFuncB = createNS("feFuncB");
            feFuncB.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFuncB);
            this.feFuncB = feFuncB;
          }

          SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var color1 = this.filterManager.effectElements[0].p.v;
              var color2 = this.filterManager.effectElements[1].p.v;
              var color3 = this.filterManager.effectElements[2].p.v;
              var tableR = color3[0] + " " + color2[0] + " " + color1[0];
              var tableG = color3[1] + " " + color2[1] + " " + color1[1];
              var tableB = color3[2] + " " + color2[2] + " " + color1[2];
              this.feFuncR.setAttribute("tableValues", tableR);
              this.feFuncG.setAttribute("tableValues", tableG);
              this.feFuncB.setAttribute("tableValues", tableB); // var opacity = this.filterManager.effectElements[2].p.v/100;
              // this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
            }
          };

          function SVGProLevelsFilter(filter, filterManager) {
            this.filterManager = filterManager;
            var effectElements = this.filterManager.effectElements;
            var feComponentTransfer = createNS("feComponentTransfer");

            if (
              effectElements[10].p.k ||
              effectElements[10].p.v !== 0 ||
              effectElements[11].p.k ||
              effectElements[11].p.v !== 1 ||
              effectElements[12].p.k ||
              effectElements[12].p.v !== 1 ||
              effectElements[13].p.k ||
              effectElements[13].p.v !== 0 ||
              effectElements[14].p.k ||
              effectElements[14].p.v !== 1
            ) {
              this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
            }

            if (
              effectElements[17].p.k ||
              effectElements[17].p.v !== 0 ||
              effectElements[18].p.k ||
              effectElements[18].p.v !== 1 ||
              effectElements[19].p.k ||
              effectElements[19].p.v !== 1 ||
              effectElements[20].p.k ||
              effectElements[20].p.v !== 0 ||
              effectElements[21].p.k ||
              effectElements[21].p.v !== 1
            ) {
              this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
            }

            if (
              effectElements[24].p.k ||
              effectElements[24].p.v !== 0 ||
              effectElements[25].p.k ||
              effectElements[25].p.v !== 1 ||
              effectElements[26].p.k ||
              effectElements[26].p.v !== 1 ||
              effectElements[27].p.k ||
              effectElements[27].p.v !== 0 ||
              effectElements[28].p.k ||
              effectElements[28].p.v !== 1
            ) {
              this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
            }

            if (
              effectElements[31].p.k ||
              effectElements[31].p.v !== 0 ||
              effectElements[32].p.k ||
              effectElements[32].p.v !== 1 ||
              effectElements[33].p.k ||
              effectElements[33].p.v !== 1 ||
              effectElements[34].p.k ||
              effectElements[34].p.v !== 0 ||
              effectElements[35].p.k ||
              effectElements[35].p.v !== 1
            ) {
              this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
            }

            if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
              feComponentTransfer.setAttribute(
                "color-interpolation-filters",
                "sRGB"
              );
              filter.appendChild(feComponentTransfer);
              feComponentTransfer = createNS("feComponentTransfer");
            }

            if (
              effectElements[3].p.k ||
              effectElements[3].p.v !== 0 ||
              effectElements[4].p.k ||
              effectElements[4].p.v !== 1 ||
              effectElements[5].p.k ||
              effectElements[5].p.v !== 1 ||
              effectElements[6].p.k ||
              effectElements[6].p.v !== 0 ||
              effectElements[7].p.k ||
              effectElements[7].p.v !== 1
            ) {
              feComponentTransfer.setAttribute(
                "color-interpolation-filters",
                "sRGB"
              );
              filter.appendChild(feComponentTransfer);
              this.feFuncRComposed = this.createFeFunc(
                "feFuncR",
                feComponentTransfer
              );
              this.feFuncGComposed = this.createFeFunc(
                "feFuncG",
                feComponentTransfer
              );
              this.feFuncBComposed = this.createFeFunc(
                "feFuncB",
                feComponentTransfer
              );
            }
          }

          SVGProLevelsFilter.prototype.createFeFunc = function (
            type,
            feComponentTransfer
          ) {
            var feFunc = createNS(type);
            feFunc.setAttribute("type", "table");
            feComponentTransfer.appendChild(feFunc);
            return feFunc;
          };

          SVGProLevelsFilter.prototype.getTableValue = function (
            inputBlack,
            inputWhite,
            gamma,
            outputBlack,
            outputWhite
          ) {
            var cnt = 0;
            var segments = 256;
            var perc;
            var min = Math.min(inputBlack, inputWhite);
            var max = Math.max(inputBlack, inputWhite);
            var table = Array.call(null, {
              length: segments,
            });
            var colorValue;
            var pos = 0;
            var outputDelta = outputWhite - outputBlack;
            var inputDelta = inputWhite - inputBlack;

            while (cnt <= 256) {
              perc = cnt / 256;

              if (perc <= min) {
                colorValue = inputDelta < 0 ? outputWhite : outputBlack;
              } else if (perc >= max) {
                colorValue = inputDelta < 0 ? outputBlack : outputWhite;
              } else {
                colorValue =
                  outputBlack +
                  outputDelta *
                    Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
              }

              table[pos] = colorValue;
              pos += 1;
              cnt += 256 / (segments - 1);
            }

            return table.join(" ");
          };

          SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
            if (forceRender || this.filterManager._mdf) {
              var val;
              var effectElements = this.filterManager.effectElements;

              if (
                this.feFuncRComposed &&
                (forceRender ||
                  effectElements[3].p._mdf ||
                  effectElements[4].p._mdf ||
                  effectElements[5].p._mdf ||
                  effectElements[6].p._mdf ||
                  effectElements[7].p._mdf)
              ) {
                val = this.getTableValue(
                  effectElements[3].p.v,
                  effectElements[4].p.v,
                  effectElements[5].p.v,
                  effectElements[6].p.v,
                  effectElements[7].p.v
                );
                this.feFuncRComposed.setAttribute("tableValues", val);
                this.feFuncGComposed.setAttribute("tableValues", val);
                this.feFuncBComposed.setAttribute("tableValues", val);
              }

              if (
                this.feFuncR &&
                (forceRender ||
                  effectElements[10].p._mdf ||
                  effectElements[11].p._mdf ||
                  effectElements[12].p._mdf ||
                  effectElements[13].p._mdf ||
                  effectElements[14].p._mdf)
              ) {
                val = this.getTableValue(
                  effectElements[10].p.v,
                  effectElements[11].p.v,
                  effectElements[12].p.v,
                  effectElements[13].p.v,
                  effectElements[14].p.v
                );
                this.feFuncR.setAttribute("tableValues", val);
              }

              if (
                this.feFuncG &&
                (forceRender ||
                  effectElements[17].p._mdf ||
                  effectElements[18].p._mdf ||
                  effectElements[19].p._mdf ||
                  effectElements[20].p._mdf ||
                  effectElements[21].p._mdf)
              ) {
                val = this.getTableValue(
                  effectElements[17].p.v,
                  effectElements[18].p.v,
                  effectElements[19].p.v,
                  effectElements[20].p.v,
                  effectElements[21].p.v
                );
                this.feFuncG.setAttribute("tableValues", val);
              }

              if (
                this.feFuncB &&
                (forceRender ||
                  effectElements[24].p._mdf ||
                  effectElements[25].p._mdf ||
                  effectElements[26].p._mdf ||
                  effectElements[27].p._mdf ||
                  effectElements[28].p._mdf)
              ) {
                val = this.getTableValue(
                  effectElements[24].p.v,
                  effectElements[25].p.v,
                  effectElements[26].p.v,
                  effectElements[27].p.v,
                  effectElements[28].p.v
                );
                this.feFuncB.setAttribute("tableValues", val);
              }

              if (
                this.feFuncA &&
                (forceRender ||
                  effectElements[31].p._mdf ||
                  effectElements[32].p._mdf ||
                  effectElements[33].p._mdf ||
                  effectElements[34].p._mdf ||
                  effectElements[35].p._mdf)
              ) {
                val = this.getTableValue(
                  effectElements[31].p.v,
                  effectElements[32].p.v,
                  effectElements[33].p.v,
                  effectElements[34].p.v,
                  effectElements[35].p.v
                );
                this.feFuncA.setAttribute("tableValues", val);
              }
            }
          };

          function SVGDropShadowEffect(filter, filterManager) {
            var filterSize =
              filterManager.container.globalData.renderConfig.filterSize;
            filter.setAttribute("x", filterSize.x);
            filter.setAttribute("y", filterSize.y);
            filter.setAttribute("width", filterSize.width);
            filter.setAttribute("height", filterSize.height);
            this.filterManager = filterManager;
            var feGaussianBlur = createNS("feGaussianBlur");
            feGaussianBlur.setAttribute("in", "SourceAlpha");
            feGaussianBlur.setAttribute("result", "drop_shadow_1");
            feGaussianBlur.setAttribute("stdDeviation", "0");
            this.feGaussianBlur = feGaussianBlur;
            filter.appendChild(feGaussianBlur);
            var feOffset = createNS("feOffset");
            feOffset.setAttribute("dx", "25");
            feOffset.setAttribute("dy", "0");
            feOffset.setAttribute("in", "drop_shadow_1");
            feOffset.setAttribute("result", "drop_shadow_2");
            this.feOffset = feOffset;
            filter.appendChild(feOffset);
            var feFlood = createNS("feFlood");
            feFlood.setAttribute("flood-color", "#00ff00");
            feFlood.setAttribute("flood-opacity", "1");
            feFlood.setAttribute("result", "drop_shadow_3");
            this.feFlood = feFlood;
            filter.appendChild(feFlood);
            var feComposite = createNS("feComposite");
            feComposite.setAttribute("in", "drop_shadow_3");
            feComposite.setAttribute("in2", "drop_shadow_2");
            feComposite.setAttribute("operator", "in");
            feComposite.setAttribute("result", "drop_shadow_4");
            filter.appendChild(feComposite);
            var feMerge = createNS("feMerge");
            filter.appendChild(feMerge);
            var feMergeNode;
            feMergeNode = createNS("feMergeNode");
            feMerge.appendChild(feMergeNode);
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", "SourceGraphic");
            this.feMergeNode = feMergeNode;
            this.feMerge = feMerge;
            this.originalNodeAdded = false;
            feMerge.appendChild(feMergeNode);
          }

          SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
            if (forceRender || this.filterManager._mdf) {
              if (forceRender || this.filterManager.effectElements[4].p._mdf) {
                this.feGaussianBlur.setAttribute(
                  "stdDeviation",
                  this.filterManager.effectElements[4].p.v / 4
                );
              }

              if (forceRender || this.filterManager.effectElements[0].p._mdf) {
                var col = this.filterManager.effectElements[0].p.v;
                this.feFlood.setAttribute(
                  "flood-color",
                  rgbToHex(
                    Math.round(col[0] * 255),
                    Math.round(col[1] * 255),
                    Math.round(col[2] * 255)
                  )
                );
              }

              if (forceRender || this.filterManager.effectElements[1].p._mdf) {
                this.feFlood.setAttribute(
                  "flood-opacity",
                  this.filterManager.effectElements[1].p.v / 255
                );
              }

              if (
                forceRender ||
                this.filterManager.effectElements[2].p._mdf ||
                this.filterManager.effectElements[3].p._mdf
              ) {
                var distance = this.filterManager.effectElements[3].p.v;
                var angle =
                  (this.filterManager.effectElements[2].p.v - 90) * degToRads;
                var x = distance * Math.cos(angle);
                var y = distance * Math.sin(angle);
                this.feOffset.setAttribute("dx", x);
                this.feOffset.setAttribute("dy", y);
              }
              /* if(forceRender || this.filterManager.effectElements[5].p._mdf){
              if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
                  this.feMerge.removeChild(this.feMergeNode);
                  this.originalNodeAdded = false;
              } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
                  this.feMerge.appendChild(this.feMergeNode);
                  this.originalNodeAdded = true;
              }
          } */
            }
          };

          var _svgMatteSymbols = [];

          function SVGMatte3Effect(filterElem, filterManager, elem) {
            this.initialized = false;
            this.filterManager = filterManager;
            this.filterElem = filterElem;
            this.elem = elem;
            elem.matteElement = createNS("g");
            elem.matteElement.appendChild(elem.layerElement);
            elem.matteElement.appendChild(elem.transformedElement);
            elem.baseElement = elem.matteElement;
          }

          SVGMatte3Effect.prototype.findSymbol = function (mask) {
            var i = 0;
            var len = _svgMatteSymbols.length;

            while (i < len) {
              if (_svgMatteSymbols[i] === mask) {
                return _svgMatteSymbols[i];
              }

              i += 1;
            }

            return null;
          };

          SVGMatte3Effect.prototype.replaceInParent = function (
            mask,
            symbolId
          ) {
            var parentNode = mask.layerElement.parentNode;

            if (!parentNode) {
              return;
            }

            var children = parentNode.children;
            var i = 0;
            var len = children.length;

            while (i < len) {
              if (children[i] === mask.layerElement) {
                break;
              }

              i += 1;
            }

            var nextChild;

            if (i <= len - 2) {
              nextChild = children[i + 1];
            }

            var useElem = createNS("use");
            useElem.setAttribute("href", "#" + symbolId);

            if (nextChild) {
              parentNode.insertBefore(useElem, nextChild);
            } else {
              parentNode.appendChild(useElem);
            }
          };

          SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
            if (!this.findSymbol(mask)) {
              var symbolId = createElementID();
              var masker = createNS("mask");
              masker.setAttribute("id", mask.layerId);
              masker.setAttribute("mask-type", "alpha");

              _svgMatteSymbols.push(mask);

              var defs = elem.globalData.defs;
              defs.appendChild(masker);
              var symbol = createNS("symbol");
              symbol.setAttribute("id", symbolId);
              this.replaceInParent(mask, symbolId);
              symbol.appendChild(mask.layerElement);
              defs.appendChild(symbol);
              var useElem = createNS("use");
              useElem.setAttribute("href", "#" + symbolId);
              masker.appendChild(useElem);
              mask.data.hd = false;
              mask.show();
            }

            elem.setMatte(mask.layerId);
          };

          SVGMatte3Effect.prototype.initialize = function () {
            var ind = this.filterManager.effectElements[0].p.v;
            var elements = this.elem.comp.elements;
            var i = 0;
            var len = elements.length;

            while (i < len) {
              if (elements[i] && elements[i].data.ind === ind) {
                this.setElementAsMask(this.elem, elements[i]);
              }

              i += 1;
            }

            this.initialized = true;
          };

          SVGMatte3Effect.prototype.renderFrame = function () {
            if (!this.initialized) {
              this.initialize();
            }
          };

          function SVGGaussianBlurEffect(filter, filterManager) {
            // Outset the filter region by 100% on all sides to accommodate blur expansion.
            filter.setAttribute("x", "-100%");
            filter.setAttribute("y", "-100%");
            filter.setAttribute("width", "300%");
            filter.setAttribute("height", "300%");
            this.filterManager = filterManager;
            var feGaussianBlur = createNS("feGaussianBlur");
            filter.appendChild(feGaussianBlur);
            this.feGaussianBlur = feGaussianBlur;
          }

          SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
            if (forceRender || this.filterManager._mdf) {
              // Empirical value, matching AE's blur appearance.
              var kBlurrinessToSigma = 0.3;
              var sigma =
                this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:
              //
              //   1 -> horizontal & vertical
              //   2 -> horizontal only
              //   3 -> vertical only
              //

              var dimensions = this.filterManager.effectElements[1].p.v;
              var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq

              var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq

              this.feGaussianBlur.setAttribute(
                "stdDeviation",
                sigmaX + " " + sigmaY
              ); // Repeat edges mapping:
              //
              //   0 -> off -> duplicate
              //   1 -> on  -> wrap

              var edgeMode =
                this.filterManager.effectElements[2].p.v == 1
                  ? "wrap"
                  : "duplicate"; // eslint-disable-line eqeqeq

              this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
            }
          };

          var registeredEffects = {};

          function SVGEffects(elem) {
            var i;
            var len = elem.data.ef ? elem.data.ef.length : 0;
            var filId = createElementID();
            var fil = filtersFactory.createFilter(filId, true);
            var count = 0;
            this.filters = [];
            var filterManager;

            for (i = 0; i < len; i += 1) {
              filterManager = null;
              var type = elem.data.ef[i].ty;

              if (registeredEffects[type]) {
                var Effect = registeredEffects[type].effect;
                filterManager = new Effect(
                  fil,
                  elem.effectsManager.effectElements[i],
                  elem
                );

                if (registeredEffects[type].countsAsEffect) {
                  count += 1;
                }
              }

              if (elem.data.ef[i].ty === 20) {
                count += 1;
                filterManager = new SVGTintFilter(
                  fil,
                  elem.effectsManager.effectElements[i]
                );
              } else if (elem.data.ef[i].ty === 21) {
                count += 1;
                filterManager = new SVGFillFilter(
                  fil,
                  elem.effectsManager.effectElements[i]
                );
              } else if (elem.data.ef[i].ty === 22) {
                filterManager = new SVGStrokeEffect(
                  elem,
                  elem.effectsManager.effectElements[i]
                );
              } else if (elem.data.ef[i].ty === 23) {
                count += 1;
                filterManager = new SVGTritoneFilter(
                  fil,
                  elem.effectsManager.effectElements[i]
                );
              } else if (elem.data.ef[i].ty === 24) {
                count += 1;
                filterManager = new SVGProLevelsFilter(
                  fil,
                  elem.effectsManager.effectElements[i]
                );
              } else if (elem.data.ef[i].ty === 25) {
                count += 1;
                filterManager = new SVGDropShadowEffect(
                  fil,
                  elem.effectsManager.effectElements[i]
                );
              } else if (elem.data.ef[i].ty === 28) {
                // count += 1;
                filterManager = new SVGMatte3Effect(
                  fil,
                  elem.effectsManager.effectElements[i],
                  elem
                );
              } else if (elem.data.ef[i].ty === 29) {
                count += 1;
                filterManager = new SVGGaussianBlurEffect(
                  fil,
                  elem.effectsManager.effectElements[i]
                );
              }

              if (filterManager) {
                this.filters.push(filterManager);
              }
            }

            if (count) {
              elem.globalData.defs.appendChild(fil);
              elem.layerElement.setAttribute(
                "filter",
                "url(" + getLocationHref() + "#" + filId + ")"
              );
            }

            if (this.filters.length) {
              elem.addRenderableComponent(this);
            }
          }

          SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
            var i;
            var len = this.filters.length;

            for (i = 0; i < len; i += 1) {
              this.filters[i].renderFrame(_isFirstFrame);
            }
          };

          function registerEffect(id, effect, countsAsEffect) {
            registeredEffects[id] = {
              effect: effect,
              countsAsEffect: countsAsEffect,
            };
          }

          function SVGBaseElement() {}

          SVGBaseElement.prototype = {
            initRendererElement: function initRendererElement() {
              this.layerElement = createNS("g");
            },
            createContainerElements: function createContainerElements() {
              this.matteElement = createNS("g");
              this.transformedElement = this.layerElement;
              this.maskedElement = this.layerElement;
              this._sizeChanged = false;
              var layerElementParent = null; // If this layer acts as a mask for the following layer

              var filId;
              var fil;
              var gg;

              if (this.data.td) {
                if (this.data.td == 3 || this.data.td == 1) {
                  // eslint-disable-line eqeqeq
                  var masker = createNS("mask");
                  masker.setAttribute("id", this.layerId);
                  masker.setAttribute(
                    "mask-type",
                    this.data.td == 3 ? "luminance" : "alpha"
                  ); // eslint-disable-line eqeqeq

                  masker.appendChild(this.layerElement);
                  layerElementParent = masker;
                  this.globalData.defs.appendChild(masker); // This is only for IE and Edge when mask if of type alpha

                  if (!featureSupport.maskType && this.data.td == 1) {
                    // eslint-disable-line eqeqeq
                    masker.setAttribute("mask-type", "luminance");
                    filId = createElementID();
                    fil = filtersFactory.createFilter(filId);
                    this.globalData.defs.appendChild(fil);
                    fil.appendChild(
                      filtersFactory.createAlphaToLuminanceFilter()
                    );
                    gg = createNS("g");
                    gg.appendChild(this.layerElement);
                    layerElementParent = gg;
                    masker.appendChild(gg);
                    gg.setAttribute(
                      "filter",
                      "url(" + getLocationHref() + "#" + filId + ")"
                    );
                  }
                } else if (this.data.td == 2) {
                  // eslint-disable-line eqeqeq
                  var maskGroup = createNS("mask");
                  maskGroup.setAttribute("id", this.layerId);
                  maskGroup.setAttribute("mask-type", "alpha");
                  var maskGrouper = createNS("g");
                  maskGroup.appendChild(maskGrouper);
                  filId = createElementID();
                  fil = filtersFactory.createFilter(filId); /// /
                  // This solution doesn't work on Android when meta tag with viewport attribute is set

                  /* var feColorMatrix = createNS('feColorMatrix');
                  feColorMatrix.setAttribute('type', 'matrix');
                  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                  feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                  fil.appendChild(feColorMatrix); */
                  /// /

                  var feCTr = createNS("feComponentTransfer");
                  feCTr.setAttribute("in", "SourceGraphic");
                  fil.appendChild(feCTr);
                  var feFunc = createNS("feFuncA");
                  feFunc.setAttribute("type", "table");
                  feFunc.setAttribute("tableValues", "1.0 0.0");
                  feCTr.appendChild(feFunc); /// /

                  this.globalData.defs.appendChild(fil);
                  var alphaRect = createNS("rect");
                  alphaRect.setAttribute("width", this.comp.data.w);
                  alphaRect.setAttribute("height", this.comp.data.h);
                  alphaRect.setAttribute("x", "0");
                  alphaRect.setAttribute("y", "0");
                  alphaRect.setAttribute("fill", "#ffffff");
                  alphaRect.setAttribute("opacity", "0");
                  maskGrouper.setAttribute(
                    "filter",
                    "url(" + getLocationHref() + "#" + filId + ")"
                  );
                  maskGrouper.appendChild(alphaRect);
                  maskGrouper.appendChild(this.layerElement);
                  layerElementParent = maskGrouper;

                  if (!featureSupport.maskType) {
                    maskGroup.setAttribute("mask-type", "luminance");
                    fil.appendChild(
                      filtersFactory.createAlphaToLuminanceFilter()
                    );
                    gg = createNS("g");
                    maskGrouper.appendChild(alphaRect);
                    gg.appendChild(this.layerElement);
                    layerElementParent = gg;
                    maskGrouper.appendChild(gg);
                  }

                  this.globalData.defs.appendChild(maskGroup);
                }
              } else if (this.data.tt) {
                this.matteElement.appendChild(this.layerElement);
                layerElementParent = this.matteElement;
                this.baseElement = this.matteElement;
              } else {
                this.baseElement = this.layerElement;
              }

              if (this.data.ln) {
                this.layerElement.setAttribute("id", this.data.ln);
              }

              if (this.data.cl) {
                this.layerElement.setAttribute("class", this.data.cl);
              } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped

              if (this.data.ty === 0 && !this.data.hd) {
                var cp = createNS("clipPath");
                var pt = createNS("path");
                pt.setAttribute(
                  "d",
                  "M0,0 L" +
                    this.data.w +
                    ",0 L" +
                    this.data.w +
                    "," +
                    this.data.h +
                    " L0," +
                    this.data.h +
                    "z"
                );
                var clipId = createElementID();
                cp.setAttribute("id", clipId);
                cp.appendChild(pt);
                this.globalData.defs.appendChild(cp);

                if (this.checkMasks()) {
                  var cpGroup = createNS("g");
                  cpGroup.setAttribute(
                    "clip-path",
                    "url(" + getLocationHref() + "#" + clipId + ")"
                  );
                  cpGroup.appendChild(this.layerElement);
                  this.transformedElement = cpGroup;

                  if (layerElementParent) {
                    layerElementParent.appendChild(this.transformedElement);
                  } else {
                    this.baseElement = this.transformedElement;
                  }
                } else {
                  this.layerElement.setAttribute(
                    "clip-path",
                    "url(" + getLocationHref() + "#" + clipId + ")"
                  );
                }
              }

              if (this.data.bm !== 0) {
                this.setBlendMode();
              }
            },
            renderElement: function renderElement() {
              if (this.finalTransform._matMdf) {
                this.transformedElement.setAttribute(
                  "transform",
                  this.finalTransform.mat.to2dCSS()
                );
              }

              if (this.finalTransform._opMdf) {
                this.transformedElement.setAttribute(
                  "opacity",
                  this.finalTransform.mProp.o.v
                );
              }
            },
            destroyBaseElement: function destroyBaseElement() {
              this.layerElement = null;
              this.matteElement = null;
              this.maskManager.destroy();
            },
            getBaseElement: function getBaseElement() {
              if (this.data.hd) {
                return null;
              }

              return this.baseElement;
            },
            createRenderableComponents: function createRenderableComponents() {
              this.maskManager = new MaskElement(
                this.data,
                this,
                this.globalData
              );
              this.renderableEffectsManager = new SVGEffects(this);
            },
            setMatte: function setMatte(id) {
              if (!this.matteElement) {
                return;
              }

              this.matteElement.setAttribute(
                "mask",
                "url(" + getLocationHref() + "#" + id + ")"
              );
            },
          };

          /**
           * @file
           * Handles AE's layer parenting property.
           *
           */
          function HierarchyElement() {}

          HierarchyElement.prototype = {
            /**
             * @function
             * Initializes hierarchy properties
             *
             */
            initHierarchy: function initHierarchy() {
              // element's parent list
              this.hierarchy = []; // if element is parent of another layer _isParent will be true

              this._isParent = false;
              this.checkParenting();
            },

            /**
             * @function
             * Sets layer's hierarchy.
             * @param {array} hierarch
             * layer's parent list
             *
             */
            setHierarchy: function setHierarchy(hierarchy) {
              this.hierarchy = hierarchy;
            },

            /**
             * @function
             * Sets layer as parent.
             *
             */
            setAsParent: function setAsParent() {
              this._isParent = true;
            },

            /**
             * @function
             * Searches layer's parenting chain
             *
             */
            checkParenting: function checkParenting() {
              if (this.data.parent !== undefined) {
                this.comp.buildElementParenting(this, this.data.parent, []);
              }
            },
          };

          function RenderableDOMElement() {}

          (function () {
            var _prototype = {
              initElement: function initElement(data, globalData, comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initTransform(data, globalData, comp);
                this.initHierarchy();
                this.initRenderable();
                this.initRendererElement();
                this.createContainerElements();
                this.createRenderableComponents();
                this.createContent();
                this.hide();
              },
              hide: function hide() {
                // console.log('HIDE', this);
                if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                  var elem = this.baseElement || this.layerElement;
                  elem.style.display = "none";
                  this.hidden = true;
                }
              },
              show: function show() {
                // console.log('SHOW', this);
                if (this.isInRange && !this.isTransparent) {
                  if (!this.data.hd) {
                    var elem = this.baseElement || this.layerElement;
                    elem.style.display = "block";
                  }

                  this.hidden = false;
                  this._isFirstFrame = true;
                }
              },
              renderFrame: function renderFrame() {
                // If it is exported as hidden (data.hd === true) no need to render
                // If it is not visible no need to render
                if (this.data.hd || this.hidden) {
                  return;
                }

                this.renderTransform();
                this.renderRenderable();
                this.renderElement();
                this.renderInnerContent();

                if (this._isFirstFrame) {
                  this._isFirstFrame = false;
                }
              },
              renderInnerContent: function renderInnerContent() {},
              prepareFrame: function prepareFrame(num) {
                this._mdf = false;
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
                this.checkTransparency();
              },
              destroy: function destroy() {
                this.innerElem = null;
                this.destroyBaseElement();
              },
            };
            extendPrototype(
              [RenderableElement, createProxyFunction(_prototype)],
              RenderableDOMElement
            );
          })();

          function IImageElement(data, globalData, comp) {
            this.assetData = globalData.getAssetData(data.refId);
            this.initElement(data, globalData, comp);
            this.sourceRect = {
              top: 0,
              left: 0,
              width: this.assetData.w,
              height: this.assetData.h,
            };
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              SVGBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
            ],
            IImageElement
          );

          IImageElement.prototype.createContent = function () {
            var assetPath = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image");
            this.innerElem.setAttribute("width", this.assetData.w + "px");
            this.innerElem.setAttribute("height", this.assetData.h + "px");
            this.innerElem.setAttribute(
              "preserveAspectRatio",
              this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio
            );
            this.innerElem.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "href",
              assetPath
            );
            this.layerElement.appendChild(this.innerElem);
          };

          IImageElement.prototype.sourceRectAtTime = function () {
            return this.sourceRect;
          };

          function ProcessedElement(element, position) {
            this.elem = element;
            this.pos = position;
          }

          function IShapeElement() {}

          IShapeElement.prototype = {
            addShapeToModifiers: function addShapeToModifiers(data) {
              var i;
              var len = this.shapeModifiers.length;

              for (i = 0; i < len; i += 1) {
                this.shapeModifiers[i].addShape(data);
              }
            },
            isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(
              data
            ) {
              var i = 0;
              var len = this.shapeModifiers.length;

              while (i < len) {
                if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
                  return true;
                }
              }

              return false;
            },
            renderModifiers: function renderModifiers() {
              if (!this.shapeModifiers.length) {
                return;
              }

              var i;
              var len = this.shapes.length;

              for (i = 0; i < len; i += 1) {
                this.shapes[i].sh.reset();
              }

              len = this.shapeModifiers.length;
              var shouldBreakProcess;

              for (i = len - 1; i >= 0; i -= 1) {
                shouldBreakProcess = this.shapeModifiers[i].processShapes(
                  this._isFirstFrame
                ); // workaround to fix cases where a repeater resets the shape so the following processes get called twice
                // TODO: find a better solution for this

                if (shouldBreakProcess) {
                  break;
                }
              }
            },
            searchProcessedElement: function searchProcessedElement(elem) {
              var elements = this.processedElements;
              var i = 0;
              var len = elements.length;

              while (i < len) {
                if (elements[i].elem === elem) {
                  return elements[i].pos;
                }

                i += 1;
              }

              return 0;
            },
            addProcessedElement: function addProcessedElement(elem, pos) {
              var elements = this.processedElements;
              var i = elements.length;

              while (i) {
                i -= 1;

                if (elements[i].elem === elem) {
                  elements[i].pos = pos;
                  return;
                }
              }

              elements.push(new ProcessedElement(elem, pos));
            },
            prepareFrame: function prepareFrame(num) {
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
            },
          };

          var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square",
          };
          var lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel",
          };

          function SVGShapeData(transformers, level, shape) {
            this.caches = [];
            this.styles = [];
            this.transformers = transformers;
            this.lStr = "";
            this.sh = shape;
            this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.
            // For now, since shapes add up with other shapes. They have to be calculated every time.
            // One way of finding out is checking if all styles associated to this shape depend only of this shape

            this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated

            var i = 0;
            var len = transformers.length;

            while (i < len) {
              if (transformers[i].mProps.dynamicProperties.length) {
                this._isAnimated = true;
                break;
              }

              i += 1;
            }
          }

          SVGShapeData.prototype.setAsAnimated = function () {
            this._isAnimated = true;
          };

          function SVGStyleData(data, level) {
            this.data = data;
            this.type = data.ty;
            this.d = "";
            this.lvl = level;
            this._mdf = false;
            this.closed = data.hd === true;
            this.pElem = createNS("path");
            this.msElem = null;
          }

          SVGStyleData.prototype.reset = function () {
            this.d = "";
            this._mdf = false;
          };

          function DashProperty(elem, data, renderer, container) {
            this.elem = elem;
            this.frameId = -1;
            this.dataProps = createSizedArray(data.length);
            this.renderer = renderer;
            this.k = false;
            this.dashStr = "";
            this.dashArray = createTypedArray(
              "float32",
              data.length ? data.length - 1 : 0
            );
            this.dashoffset = createTypedArray("float32", 1);
            this.initDynamicPropertyContainer(container);
            var i;
            var len = data.length || 0;
            var prop;

            for (i = 0; i < len; i += 1) {
              prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
              this.k = prop.k || this.k;
              this.dataProps[i] = {
                n: data[i].n,
                p: prop,
              };
            }

            if (!this.k) {
              this.getValue(true);
            }

            this._isAnimated = this.k;
          }

          DashProperty.prototype.getValue = function (forceRender) {
            if (this.elem.globalData.frameId === this.frameId && !forceRender) {
              return;
            }

            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || forceRender;

            if (this._mdf) {
              var i = 0;
              var len = this.dataProps.length;

              if (this.renderer === "svg") {
                this.dashStr = "";
              }

              for (i = 0; i < len; i += 1) {
                if (this.dataProps[i].n !== "o") {
                  if (this.renderer === "svg") {
                    this.dashStr += " " + this.dataProps[i].p.v;
                  } else {
                    this.dashArray[i] = this.dataProps[i].p.v;
                  }
                } else {
                  this.dashoffset[0] = this.dataProps[i].p.v;
                }
              }
            }
          };

          extendPrototype([DynamicPropertyContainer], DashProperty);

          function SVGStrokeStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
            this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
            this.d = new DashProperty(elem, data.d || {}, "svg", this);
            this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
            this.style = styleOb;
            this._isAnimated = !!this._isAnimated;
          }

          extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

          function SVGFillStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
            this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
            this.style = styleOb;
          }

          extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

          function SVGNoStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.style = styleOb;
          }

          extendPrototype([DynamicPropertyContainer], SVGNoStyleData);

          function GradientProperty(elem, data, container) {
            this.data = data;
            this.c = createTypedArray("uint8c", data.p * 4);
            var cLength = data.k.k[0].s
              ? data.k.k[0].s.length - data.p * 4
              : data.k.k.length - data.p * 4;
            this.o = createTypedArray("float32", cLength);
            this._cmdf = false;
            this._omdf = false;
            this._collapsable = this.checkCollapsable();
            this._hasOpacity = cLength;
            this.initDynamicPropertyContainer(container);
            this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
            this.k = this.prop.k;
            this.getValue(true);
          }

          GradientProperty.prototype.comparePoints = function (values, points) {
            var i = 0;
            var len = this.o.length / 2;
            var diff;

            while (i < len) {
              diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);

              if (diff > 0.01) {
                return false;
              }

              i += 1;
            }

            return true;
          };

          GradientProperty.prototype.checkCollapsable = function () {
            if (this.o.length / 2 !== this.c.length / 4) {
              return false;
            }

            if (this.data.k.k[0].s) {
              var i = 0;
              var len = this.data.k.k.length;

              while (i < len) {
                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
                  return false;
                }

                i += 1;
              }
            } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
              return false;
            }

            return true;
          };

          GradientProperty.prototype.getValue = function (forceRender) {
            this.prop.getValue();
            this._mdf = false;
            this._cmdf = false;
            this._omdf = false;

            if (this.prop._mdf || forceRender) {
              var i;
              var len = this.data.p * 4;
              var mult;
              var val;

              for (i = 0; i < len; i += 1) {
                mult = i % 4 === 0 ? 100 : 255;
                val = Math.round(this.prop.v[i] * mult);

                if (this.c[i] !== val) {
                  this.c[i] = val;
                  this._cmdf = !forceRender;
                }
              }

              if (this.o.length) {
                len = this.prop.v.length;

                for (i = this.data.p * 4; i < len; i += 1) {
                  mult = i % 2 === 0 ? 100 : 1;
                  val =
                    i % 2 === 0
                      ? Math.round(this.prop.v[i] * 100)
                      : this.prop.v[i];

                  if (this.o[i - this.data.p * 4] !== val) {
                    this.o[i - this.data.p * 4] = val;
                    this._omdf = !forceRender;
                  }
                }
              }

              this._mdf = !forceRender;
            }
          };

          extendPrototype([DynamicPropertyContainer], GradientProperty);

          function SVGGradientFillStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.initGradientData(elem, data, styleOb);
          }

          SVGGradientFillStyleData.prototype.initGradientData = function (
            elem,
            data,
            styleOb
          ) {
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
            this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
            this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
            this.h = PropertyFactory.getProp(
              elem,
              data.h || {
                k: 0,
              },
              0,
              0.01,
              this
            );
            this.a = PropertyFactory.getProp(
              elem,
              data.a || {
                k: 0,
              },
              0,
              degToRads,
              this
            );
            this.g = new GradientProperty(elem, data.g, this);
            this.style = styleOb;
            this.stops = [];
            this.setGradientData(styleOb.pElem, data);
            this.setGradientOpacity(data, styleOb);
            this._isAnimated = !!this._isAnimated;
          };

          SVGGradientFillStyleData.prototype.setGradientData = function (
            pathElement,
            data
          ) {
            var gradientId = createElementID();
            var gfill = createNS(
              data.t === 1 ? "linearGradient" : "radialGradient"
            );
            gfill.setAttribute("id", gradientId);
            gfill.setAttribute("spreadMethod", "pad");
            gfill.setAttribute("gradientUnits", "userSpaceOnUse");
            var stops = [];
            var stop;
            var j;
            var jLen;
            jLen = data.g.p * 4;

            for (j = 0; j < jLen; j += 4) {
              stop = createNS("stop");
              gfill.appendChild(stop);
              stops.push(stop);
            }

            pathElement.setAttribute(
              data.ty === "gf" ? "fill" : "stroke",
              "url(" + getLocationHref() + "#" + gradientId + ")"
            );
            this.gf = gfill;
            this.cst = stops;
          };

          SVGGradientFillStyleData.prototype.setGradientOpacity = function (
            data,
            styleOb
          ) {
            if (this.g._hasOpacity && !this.g._collapsable) {
              var stop;
              var j;
              var jLen;
              var mask = createNS("mask");
              var maskElement = createNS("path");
              mask.appendChild(maskElement);
              var opacityId = createElementID();
              var maskId = createElementID();
              mask.setAttribute("id", maskId);
              var opFill = createNS(
                data.t === 1 ? "linearGradient" : "radialGradient"
              );
              opFill.setAttribute("id", opacityId);
              opFill.setAttribute("spreadMethod", "pad");
              opFill.setAttribute("gradientUnits", "userSpaceOnUse");
              jLen = data.g.k.k[0].s
                ? data.g.k.k[0].s.length
                : data.g.k.k.length;
              var stops = this.stops;

              for (j = data.g.p * 4; j < jLen; j += 2) {
                stop = createNS("stop");
                stop.setAttribute("stop-color", "rgb(255,255,255)");
                opFill.appendChild(stop);
                stops.push(stop);
              }

              maskElement.setAttribute(
                data.ty === "gf" ? "fill" : "stroke",
                "url(" + getLocationHref() + "#" + opacityId + ")"
              );

              if (data.ty === "gs") {
                maskElement.setAttribute(
                  "stroke-linecap",
                  lineCapEnum[data.lc || 2]
                );
                maskElement.setAttribute(
                  "stroke-linejoin",
                  lineJoinEnum[data.lj || 2]
                );

                if (data.lj === 1) {
                  maskElement.setAttribute("stroke-miterlimit", data.ml);
                }
              }

              this.of = opFill;
              this.ms = mask;
              this.ost = stops;
              this.maskId = maskId;
              styleOb.msElem = maskElement;
            }
          };

          extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

          function SVGGradientStrokeStyleData(elem, data, styleOb) {
            this.initDynamicPropertyContainer(elem);
            this.getValue = this.iterateDynamicProperties;
            this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
            this.d = new DashProperty(elem, data.d || {}, "svg", this);
            this.initGradientData(elem, data, styleOb);
            this._isAnimated = !!this._isAnimated;
          }

          extendPrototype(
            [SVGGradientFillStyleData, DynamicPropertyContainer],
            SVGGradientStrokeStyleData
          );

          function ShapeGroupData() {
            this.it = [];
            this.prevViewData = [];
            this.gr = createNS("g");
          }

          function SVGTransformData(mProps, op, container) {
            this.transform = {
              mProps: mProps,
              op: op,
              container: container,
            };
            this.elements = [];
            this._isAnimated =
              this.transform.mProps.dynamicProperties.length ||
              this.transform.op.effectsSequence.length;
          }

          var buildShapeString = function buildShapeString(
            pathNodes,
            length,
            closed,
            mat
          ) {
            if (length === 0) {
              return "";
            }

            var _o = pathNodes.o;
            var _i = pathNodes.i;
            var _v = pathNodes.v;
            var i;
            var shapeString =
              " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);

            for (i = 1; i < length; i += 1) {
              shapeString +=
                " C" +
                mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) +
                " " +
                mat.applyToPointStringified(_i[i][0], _i[i][1]) +
                " " +
                mat.applyToPointStringified(_v[i][0], _v[i][1]);
            }

            if (closed && length) {
              shapeString +=
                " C" +
                mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) +
                " " +
                mat.applyToPointStringified(_i[0][0], _i[0][1]) +
                " " +
                mat.applyToPointStringified(_v[0][0], _v[0][1]);
              shapeString += "z";
            }

            return shapeString;
          };

          var SVGElementsRenderer = (function () {
            var _identityMatrix = new Matrix();

            var _matrixHelper = new Matrix();

            var ob = {
              createRenderFunction: createRenderFunction,
            };

            function createRenderFunction(data) {
              switch (data.ty) {
                case "fl":
                  return renderFill;

                case "gf":
                  return renderGradient;

                case "gs":
                  return renderGradientStroke;

                case "st":
                  return renderStroke;

                case "sh":
                case "el":
                case "rc":
                case "sr":
                  return renderPath;

                case "tr":
                  return renderContentTransform;

                case "no":
                  return renderNoop;

                default:
                  return null;
              }
            }

            function renderContentTransform(styleData, itemData, isFirstFrame) {
              if (isFirstFrame || itemData.transform.op._mdf) {
                itemData.transform.container.setAttribute(
                  "opacity",
                  itemData.transform.op.v
                );
              }

              if (isFirstFrame || itemData.transform.mProps._mdf) {
                itemData.transform.container.setAttribute(
                  "transform",
                  itemData.transform.mProps.v.to2dCSS()
                );
              }
            }

            function renderNoop() {}

            function renderPath(styleData, itemData, isFirstFrame) {
              var j;
              var jLen;
              var pathStringTransformed;
              var redraw;
              var pathNodes;
              var l;
              var lLen = itemData.styles.length;
              var lvl = itemData.lvl;
              var paths;
              var mat;
              var props;
              var iterations;
              var k;

              for (l = 0; l < lLen; l += 1) {
                redraw = itemData.sh._mdf || isFirstFrame;

                if (itemData.styles[l].lvl < lvl) {
                  mat = _matrixHelper.reset();
                  iterations = lvl - itemData.styles[l].lvl;
                  k = itemData.transformers.length - 1;

                  while (!redraw && iterations > 0) {
                    redraw = itemData.transformers[k].mProps._mdf || redraw;
                    iterations -= 1;
                    k -= 1;
                  }

                  if (redraw) {
                    iterations = lvl - itemData.styles[l].lvl;
                    k = itemData.transformers.length - 1;

                    while (iterations > 0) {
                      props = itemData.transformers[k].mProps.v.props;
                      mat.transform(
                        props[0],
                        props[1],
                        props[2],
                        props[3],
                        props[4],
                        props[5],
                        props[6],
                        props[7],
                        props[8],
                        props[9],
                        props[10],
                        props[11],
                        props[12],
                        props[13],
                        props[14],
                        props[15]
                      );
                      iterations -= 1;
                      k -= 1;
                    }
                  }
                } else {
                  mat = _identityMatrix;
                }

                paths = itemData.sh.paths;
                jLen = paths._length;

                if (redraw) {
                  pathStringTransformed = "";

                  for (j = 0; j < jLen; j += 1) {
                    pathNodes = paths.shapes[j];

                    if (pathNodes && pathNodes._length) {
                      pathStringTransformed += buildShapeString(
                        pathNodes,
                        pathNodes._length,
                        pathNodes.c,
                        mat
                      );
                    }
                  }

                  itemData.caches[l] = pathStringTransformed;
                } else {
                  pathStringTransformed = itemData.caches[l];
                }

                itemData.styles[l].d +=
                  styleData.hd === true ? "" : pathStringTransformed;
                itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
              }
            }

            function renderFill(styleData, itemData, isFirstFrame) {
              var styleElem = itemData.style;

              if (itemData.c._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute(
                  "fill",
                  "rgb(" +
                    bmFloor(itemData.c.v[0]) +
                    "," +
                    bmFloor(itemData.c.v[1]) +
                    "," +
                    bmFloor(itemData.c.v[2]) +
                    ")"
                );
              }

              if (itemData.o._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
              }
            }

            function renderGradientStroke(styleData, itemData, isFirstFrame) {
              renderGradient(styleData, itemData, isFirstFrame);
              renderStroke(styleData, itemData, isFirstFrame);
            }

            function renderGradient(styleData, itemData, isFirstFrame) {
              var gfill = itemData.gf;
              var hasOpacity = itemData.g._hasOpacity;
              var pt1 = itemData.s.v;
              var pt2 = itemData.e.v;

              if (itemData.o._mdf || isFirstFrame) {
                var attr =
                  styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                itemData.style.pElem.setAttribute(attr, itemData.o.v);
              }

              if (itemData.s._mdf || isFirstFrame) {
                var attr1 = styleData.t === 1 ? "x1" : "cx";
                var attr2 = attr1 === "x1" ? "y1" : "cy";
                gfill.setAttribute(attr1, pt1[0]);
                gfill.setAttribute(attr2, pt1[1]);

                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute(attr1, pt1[0]);
                  itemData.of.setAttribute(attr2, pt1[1]);
                }
              }

              var stops;
              var i;
              var len;
              var stop;

              if (itemData.g._cmdf || isFirstFrame) {
                stops = itemData.cst;
                var cValues = itemData.g.c;
                len = stops.length;

                for (i = 0; i < len; i += 1) {
                  stop = stops[i];
                  stop.setAttribute("offset", cValues[i * 4] + "%");
                  stop.setAttribute(
                    "stop-color",
                    "rgb(" +
                      cValues[i * 4 + 1] +
                      "," +
                      cValues[i * 4 + 2] +
                      "," +
                      cValues[i * 4 + 3] +
                      ")"
                  );
                }
              }

              if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
                var oValues = itemData.g.o;

                if (itemData.g._collapsable) {
                  stops = itemData.cst;
                } else {
                  stops = itemData.ost;
                }

                len = stops.length;

                for (i = 0; i < len; i += 1) {
                  stop = stops[i];

                  if (!itemData.g._collapsable) {
                    stop.setAttribute("offset", oValues[i * 2] + "%");
                  }

                  stop.setAttribute("stop-opacity", oValues[i * 2 + 1]);
                }
              }

              if (styleData.t === 1) {
                if (itemData.e._mdf || isFirstFrame) {
                  gfill.setAttribute("x2", pt2[0]);
                  gfill.setAttribute("y2", pt2[1]);

                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute("x2", pt2[0]);
                    itemData.of.setAttribute("y2", pt2[1]);
                  }
                }
              } else {
                var rad;

                if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                  rad = Math.sqrt(
                    Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2)
                  );
                  gfill.setAttribute("r", rad);

                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute("r", rad);
                  }
                }

                if (
                  itemData.e._mdf ||
                  itemData.h._mdf ||
                  itemData.a._mdf ||
                  isFirstFrame
                ) {
                  if (!rad) {
                    rad = Math.sqrt(
                      Math.pow(pt1[0] - pt2[0], 2) +
                        Math.pow(pt1[1] - pt2[1], 2)
                    );
                  }

                  var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                  var percent = itemData.h.v;

                  if (percent >= 1) {
                    percent = 0.99;
                  } else if (percent <= -1) {
                    percent = -0.99;
                  }

                  var dist = rad * percent;
                  var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                  var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                  gfill.setAttribute("fx", x);
                  gfill.setAttribute("fy", y);

                  if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute("fx", x);
                    itemData.of.setAttribute("fy", y);
                  }
                } // gfill.setAttribute('fy','200');
              }
            }

            function renderStroke(styleData, itemData, isFirstFrame) {
              var styleElem = itemData.style;
              var d = itemData.d;

              if (d && (d._mdf || isFirstFrame) && d.dashStr) {
                styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
                styleElem.pElem.setAttribute(
                  "stroke-dashoffset",
                  d.dashoffset[0]
                );
              }

              if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
                styleElem.pElem.setAttribute(
                  "stroke",
                  "rgb(" +
                    bmFloor(itemData.c.v[0]) +
                    "," +
                    bmFloor(itemData.c.v[1]) +
                    "," +
                    bmFloor(itemData.c.v[2]) +
                    ")"
                );
              }

              if (itemData.o._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
              }

              if (itemData.w._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("stroke-width", itemData.w.v);

                if (styleElem.msElem) {
                  styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
                }
              }
            }

            return ob;
          })();

          function SVGShapeElement(data, globalData, comp) {
            // List of drawable elements
            this.shapes = []; // Full shape data

            this.shapesData = data.shapes; // List of styles that will be applied to shapes

            this.stylesList = []; // List of modifiers that will be applied to shapes

            this.shapeModifiers = []; // List of items in shape tree

            this.itemsData = []; // List of items in previous shape tree

            this.processedElements = []; // List of animated components

            this.animatedContents = [];
            this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
            // List of elements that have been created

            this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              SVGBaseElement,
              IShapeElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
            ],
            SVGShapeElement
          );

          SVGShapeElement.prototype.initSecondaryElement = function () {};

          SVGShapeElement.prototype.identityMatrix = new Matrix();

          SVGShapeElement.prototype.buildExpressionInterface = function () {};

          SVGShapeElement.prototype.createContent = function () {
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              true
            );
            this.filterUniqueShapes();
          };
          /*
  This method searches for multiple shapes that affect a single element and one of them is animated
  */

          SVGShapeElement.prototype.filterUniqueShapes = function () {
            var i;
            var len = this.shapes.length;
            var shape;
            var j;
            var jLen = this.stylesList.length;
            var style;
            var tempShapes = [];
            var areAnimated = false;

            for (j = 0; j < jLen; j += 1) {
              style = this.stylesList[j];
              areAnimated = false;
              tempShapes.length = 0;

              for (i = 0; i < len; i += 1) {
                shape = this.shapes[i];

                if (shape.styles.indexOf(style) !== -1) {
                  tempShapes.push(shape);
                  areAnimated = shape._isAnimated || areAnimated;
                }
              }

              if (tempShapes.length > 1 && areAnimated) {
                this.setShapesAsAnimated(tempShapes);
              }
            }
          };

          SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
            var i;
            var len = shapes.length;

            for (i = 0; i < len; i += 1) {
              shapes[i].setAsAnimated();
            }
          };

          SVGShapeElement.prototype.createStyleElement = function (
            data,
            level
          ) {
            // TODO: prevent drawing of hidden styles
            var elementData;
            var styleOb = new SVGStyleData(data, level);
            var pathElement = styleOb.pElem;

            if (data.ty === "st") {
              elementData = new SVGStrokeStyleData(this, data, styleOb);
            } else if (data.ty === "fl") {
              elementData = new SVGFillStyleData(this, data, styleOb);
            } else if (data.ty === "gf" || data.ty === "gs") {
              var GradientConstructor =
                data.ty === "gf"
                  ? SVGGradientFillStyleData
                  : SVGGradientStrokeStyleData;
              elementData = new GradientConstructor(this, data, styleOb);
              this.globalData.defs.appendChild(elementData.gf);

              if (elementData.maskId) {
                this.globalData.defs.appendChild(elementData.ms);
                this.globalData.defs.appendChild(elementData.of);
                pathElement.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + elementData.maskId + ")"
                );
              }
            } else if (data.ty === "no") {
              elementData = new SVGNoStyleData(this, data, styleOb);
            }

            if (data.ty === "st" || data.ty === "gs") {
              pathElement.setAttribute(
                "stroke-linecap",
                lineCapEnum[data.lc || 2]
              );
              pathElement.setAttribute(
                "stroke-linejoin",
                lineJoinEnum[data.lj || 2]
              );
              pathElement.setAttribute("fill-opacity", "0");

              if (data.lj === 1) {
                pathElement.setAttribute("stroke-miterlimit", data.ml);
              }
            }

            if (data.r === 2) {
              pathElement.setAttribute("fill-rule", "evenodd");
            }

            if (data.ln) {
              pathElement.setAttribute("id", data.ln);
            }

            if (data.cl) {
              pathElement.setAttribute("class", data.cl);
            }

            if (data.bm) {
              pathElement.style["mix-blend-mode"] = getBlendMode(data.bm);
            }

            this.stylesList.push(styleOb);
            this.addToAnimatedContents(data, elementData);
            return elementData;
          };

          SVGShapeElement.prototype.createGroupElement = function (data) {
            var elementData = new ShapeGroupData();

            if (data.ln) {
              elementData.gr.setAttribute("id", data.ln);
            }

            if (data.cl) {
              elementData.gr.setAttribute("class", data.cl);
            }

            if (data.bm) {
              elementData.gr.style["mix-blend-mode"] = getBlendMode(data.bm);
            }

            return elementData;
          };

          SVGShapeElement.prototype.createTransformElement = function (
            data,
            container
          ) {
            var transformProperty =
              TransformPropertyFactory.getTransformProperty(this, data, this);
            var elementData = new SVGTransformData(
              transformProperty,
              transformProperty.o,
              container
            );
            this.addToAnimatedContents(data, elementData);
            return elementData;
          };

          SVGShapeElement.prototype.createShapeElement = function (
            data,
            ownTransformers,
            level
          ) {
            var ty = 4;

            if (data.ty === "rc") {
              ty = 5;
            } else if (data.ty === "el") {
              ty = 6;
            } else if (data.ty === "sr") {
              ty = 7;
            }

            var shapeProperty = ShapePropertyFactory.getShapeProp(
              this,
              data,
              ty,
              this
            );
            var elementData = new SVGShapeData(
              ownTransformers,
              level,
              shapeProperty
            );
            this.shapes.push(elementData);
            this.addShapeToModifiers(elementData);
            this.addToAnimatedContents(data, elementData);
            return elementData;
          };

          SVGShapeElement.prototype.addToAnimatedContents = function (
            data,
            element
          ) {
            var i = 0;
            var len = this.animatedContents.length;

            while (i < len) {
              if (this.animatedContents[i].element === element) {
                return;
              }

              i += 1;
            }

            this.animatedContents.push({
              fn: SVGElementsRenderer.createRenderFunction(data),
              element: element,
              data: data,
            });
          };

          SVGShapeElement.prototype.setElementStyles = function (elementData) {
            var arr = elementData.styles;
            var j;
            var jLen = this.stylesList.length;

            for (j = 0; j < jLen; j += 1) {
              if (!this.stylesList[j].closed) {
                arr.push(this.stylesList[j]);
              }
            }
          };

          SVGShapeElement.prototype.reloadShapes = function () {
            this._isFirstFrame = true;
            var i;
            var len = this.itemsData.length;

            for (i = 0; i < len; i += 1) {
              this.prevViewData[i] = this.itemsData[i];
            }

            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              true
            );
            this.filterUniqueShapes();
            len = this.dynamicProperties.length;

            for (i = 0; i < len; i += 1) {
              this.dynamicProperties[i].getValue();
            }

            this.renderModifiers();
          };

          SVGShapeElement.prototype.searchShapes = function (
            arr,
            itemsData,
            prevViewData,
            container,
            level,
            transformers,
            render
          ) {
            var ownTransformers = [].concat(transformers);
            var i;
            var len = arr.length - 1;
            var j;
            var jLen;
            var ownStyles = [];
            var ownModifiers = [];
            var currentTransform;
            var modifier;
            var processedPos;

            for (i = len; i >= 0; i -= 1) {
              processedPos = this.searchProcessedElement(arr[i]);

              if (!processedPos) {
                arr[i]._render = render;
              } else {
                itemsData[i] = prevViewData[processedPos - 1];
              }

              if (
                arr[i].ty === "fl" ||
                arr[i].ty === "st" ||
                arr[i].ty === "gf" ||
                arr[i].ty === "gs" ||
                arr[i].ty === "no"
              ) {
                if (!processedPos) {
                  itemsData[i] = this.createStyleElement(arr[i], level);
                } else {
                  itemsData[i].style.closed = false;
                }

                if (arr[i]._render) {
                  if (itemsData[i].style.pElem.parentNode !== container) {
                    container.appendChild(itemsData[i].style.pElem);
                  }
                }

                ownStyles.push(itemsData[i].style);
              } else if (arr[i].ty === "gr") {
                if (!processedPos) {
                  itemsData[i] = this.createGroupElement(arr[i]);
                } else {
                  jLen = itemsData[i].it.length;

                  for (j = 0; j < jLen; j += 1) {
                    itemsData[i].prevViewData[j] = itemsData[i].it[j];
                  }
                }

                this.searchShapes(
                  arr[i].it,
                  itemsData[i].it,
                  itemsData[i].prevViewData,
                  itemsData[i].gr,
                  level + 1,
                  ownTransformers,
                  render
                );

                if (arr[i]._render) {
                  if (itemsData[i].gr.parentNode !== container) {
                    container.appendChild(itemsData[i].gr);
                  }
                }
              } else if (arr[i].ty === "tr") {
                if (!processedPos) {
                  itemsData[i] = this.createTransformElement(arr[i], container);
                }

                currentTransform = itemsData[i].transform;
                ownTransformers.push(currentTransform);
              } else if (
                arr[i].ty === "sh" ||
                arr[i].ty === "rc" ||
                arr[i].ty === "el" ||
                arr[i].ty === "sr"
              ) {
                if (!processedPos) {
                  itemsData[i] = this.createShapeElement(
                    arr[i],
                    ownTransformers,
                    level
                  );
                }

                this.setElementStyles(itemsData[i]);
              } else if (
                arr[i].ty === "tm" ||
                arr[i].ty === "rd" ||
                arr[i].ty === "ms" ||
                arr[i].ty === "pb"
              ) {
                if (!processedPos) {
                  modifier = ShapeModifiers.getModifier(arr[i].ty);
                  modifier.init(this, arr[i]);
                  itemsData[i] = modifier;
                  this.shapeModifiers.push(modifier);
                } else {
                  modifier = itemsData[i];
                  modifier.closed = false;
                }

                ownModifiers.push(modifier);
              } else if (arr[i].ty === "rp") {
                if (!processedPos) {
                  modifier = ShapeModifiers.getModifier(arr[i].ty);
                  itemsData[i] = modifier;
                  modifier.init(this, arr, i, itemsData);
                  this.shapeModifiers.push(modifier);
                  render = false;
                } else {
                  modifier = itemsData[i];
                  modifier.closed = true;
                }

                ownModifiers.push(modifier);
              }

              this.addProcessedElement(arr[i], i + 1);
            }

            len = ownStyles.length;

            for (i = 0; i < len; i += 1) {
              ownStyles[i].closed = true;
            }

            len = ownModifiers.length;

            for (i = 0; i < len; i += 1) {
              ownModifiers[i].closed = true;
            }
          };

          SVGShapeElement.prototype.renderInnerContent = function () {
            this.renderModifiers();
            var i;
            var len = this.stylesList.length;

            for (i = 0; i < len; i += 1) {
              this.stylesList[i].reset();
            }

            this.renderShape();

            for (i = 0; i < len; i += 1) {
              if (this.stylesList[i]._mdf || this._isFirstFrame) {
                if (this.stylesList[i].msElem) {
                  this.stylesList[i].msElem.setAttribute(
                    "d",
                    this.stylesList[i].d
                  ); // Adding M0 0 fixes same mask bug on all browsers

                  this.stylesList[i].d = "M0 0" + this.stylesList[i].d;
                }

                this.stylesList[i].pElem.setAttribute(
                  "d",
                  this.stylesList[i].d || "M0 0"
                );
              }
            }
          };

          SVGShapeElement.prototype.renderShape = function () {
            var i;
            var len = this.animatedContents.length;
            var animatedContent;

            for (i = 0; i < len; i += 1) {
              animatedContent = this.animatedContents[i];

              if (
                (this._isFirstFrame || animatedContent.element._isAnimated) &&
                animatedContent.data !== true
              ) {
                animatedContent.fn(
                  animatedContent.data,
                  animatedContent.element,
                  this._isFirstFrame
                );
              }
            }
          };

          SVGShapeElement.prototype.destroy = function () {
            this.destroyBaseElement();
            this.shapesData = null;
            this.itemsData = null;
          };

          function LetterProps(o, sw, sc, fc, m, p) {
            this.o = o;
            this.sw = sw;
            this.sc = sc;
            this.fc = fc;
            this.m = m;
            this.p = p;
            this._mdf = {
              o: true,
              sw: !!sw,
              sc: !!sc,
              fc: !!fc,
              m: true,
              p: true,
            };
          }

          LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
            this._mdf.o = false;
            this._mdf.sw = false;
            this._mdf.sc = false;
            this._mdf.fc = false;
            this._mdf.m = false;
            this._mdf.p = false;
            var updated = false;

            if (this.o !== o) {
              this.o = o;
              this._mdf.o = true;
              updated = true;
            }

            if (this.sw !== sw) {
              this.sw = sw;
              this._mdf.sw = true;
              updated = true;
            }

            if (this.sc !== sc) {
              this.sc = sc;
              this._mdf.sc = true;
              updated = true;
            }

            if (this.fc !== fc) {
              this.fc = fc;
              this._mdf.fc = true;
              updated = true;
            }

            if (this.m !== m) {
              this.m = m;
              this._mdf.m = true;
              updated = true;
            }

            if (
              p.length &&
              (this.p[0] !== p[0] ||
                this.p[1] !== p[1] ||
                this.p[4] !== p[4] ||
                this.p[5] !== p[5] ||
                this.p[12] !== p[12] ||
                this.p[13] !== p[13])
            ) {
              this.p = p;
              this._mdf.p = true;
              updated = true;
            }

            return updated;
          };

          function TextProperty(elem, data) {
            this._frameId = initialDefaultFrame;
            this.pv = "";
            this.v = "";
            this.kf = false;
            this._isFirstFrame = true;
            this._mdf = false;
            this.data = data;
            this.elem = elem;
            this.comp = this.elem.comp;
            this.keysIndex = 0;
            this.canResize = false;
            this.minimumFontSize = 1;
            this.effectsSequence = [];
            this.currentData = {
              ascent: 0,
              boxWidth: this.defaultBoxWidth,
              f: "",
              fStyle: "",
              fWeight: "",
              fc: "",
              j: "",
              justifyOffset: "",
              l: [],
              lh: 0,
              lineWidths: [],
              ls: "",
              of: "",
              s: "",
              sc: "",
              sw: 0,
              t: 0,
              tr: 0,
              sz: 0,
              ps: null,
              fillColorAnim: false,
              strokeColorAnim: false,
              strokeWidthAnim: false,
              yOffset: 0,
              finalSize: 0,
              finalText: [],
              finalLineHeight: 0,
              __complete: false,
            };
            this.copyData(this.currentData, this.data.d.k[0].s);

            if (!this.searchProperty()) {
              this.completeTextData(this.currentData);
            }
          }

          TextProperty.prototype.defaultBoxWidth = [0, 0];

          TextProperty.prototype.copyData = function (obj, data) {
            for (var s in data) {
              if (Object.prototype.hasOwnProperty.call(data, s)) {
                obj[s] = data[s];
              }
            }

            return obj;
          };

          TextProperty.prototype.setCurrentData = function (data) {
            if (!data.__complete) {
              this.completeTextData(data);
            }

            this.currentData = data;
            this.currentData.boxWidth =
              this.currentData.boxWidth || this.defaultBoxWidth;
            this._mdf = true;
          };

          TextProperty.prototype.searchProperty = function () {
            return this.searchKeyframes();
          };

          TextProperty.prototype.searchKeyframes = function () {
            this.kf = this.data.d.k.length > 1;

            if (this.kf) {
              this.addEffect(this.getKeyframeValue.bind(this));
            }

            return this.kf;
          };

          TextProperty.prototype.addEffect = function (effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.elem.addDynamicProperty(this);
          };

          TextProperty.prototype.getValue = function (_finalValue) {
            if (
              (this.elem.globalData.frameId === this.frameId ||
                !this.effectsSequence.length) &&
              !_finalValue
            ) {
              return;
            }

            this.currentData.t = this.data.d.k[this.keysIndex].s.t;
            var currentValue = this.currentData;
            var currentIndex = this.keysIndex;

            if (this.lock) {
              this.setCurrentData(this.currentData);
              return;
            }

            this.lock = true;
            this._mdf = false;
            var i;
            var len = this.effectsSequence.length;
            var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;

            for (i = 0; i < len; i += 1) {
              // Checking if index changed to prevent creating a new object every time the expression updates.
              if (currentIndex !== this.keysIndex) {
                finalValue = this.effectsSequence[i](finalValue, finalValue.t);
              } else {
                finalValue = this.effectsSequence[i](
                  this.currentData,
                  finalValue.t
                );
              }
            }

            if (currentValue !== finalValue) {
              this.setCurrentData(finalValue);
            }

            this.v = this.currentData;
            this.pv = this.v;
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
          };

          TextProperty.prototype.getKeyframeValue = function () {
            var textKeys = this.data.d.k;
            var frameNum = this.elem.comp.renderedFrame;
            var i = 0;
            var len = textKeys.length;

            while (i <= len - 1) {
              if (i === len - 1 || textKeys[i + 1].t > frameNum) {
                break;
              }

              i += 1;
            }

            if (this.keysIndex !== i) {
              this.keysIndex = i;
            }

            return this.data.d.k[this.keysIndex].s;
          };

          TextProperty.prototype.buildFinalText = function (text) {
            var charactersArray = [];
            var i = 0;
            var len = text.length;
            var charCode;
            var secondCharCode;
            var shouldCombine = false;

            while (i < len) {
              charCode = text.charCodeAt(i);

              if (FontManager.isCombinedCharacter(charCode)) {
                charactersArray[charactersArray.length - 1] += text.charAt(i);
              } else if (charCode >= 0xd800 && charCode <= 0xdbff) {
                secondCharCode = text.charCodeAt(i + 1);

                if (secondCharCode >= 0xdc00 && secondCharCode <= 0xdfff) {
                  if (
                    shouldCombine ||
                    FontManager.isModifier(charCode, secondCharCode)
                  ) {
                    charactersArray[charactersArray.length - 1] += text.substr(
                      i,
                      2
                    );
                    shouldCombine = false;
                  } else {
                    charactersArray.push(text.substr(i, 2));
                  }

                  i += 1;
                } else {
                  charactersArray.push(text.charAt(i));
                }
              } else if (charCode > 0xdbff) {
                secondCharCode = text.charCodeAt(i + 1);

                if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
                  shouldCombine = true;
                  charactersArray[charactersArray.length - 1] += text.substr(
                    i,
                    2
                  );
                  i += 1;
                } else {
                  charactersArray.push(text.charAt(i));
                }
              } else if (FontManager.isZeroWidthJoiner(charCode)) {
                charactersArray[charactersArray.length - 1] += text.charAt(i);
                shouldCombine = true;
              } else {
                charactersArray.push(text.charAt(i));
              }

              i += 1;
            }

            return charactersArray;
          };

          TextProperty.prototype.completeTextData = function (documentData) {
            documentData.__complete = true;
            var fontManager = this.elem.globalData.fontManager;
            var data = this.data;
            var letters = [];
            var i;
            var len;
            var newLineFlag;
            var index = 0;
            var val;
            var anchorGrouping = data.m.g;
            var currentSize = 0;
            var currentPos = 0;
            var currentLine = 0;
            var lineWidths = [];
            var lineWidth = 0;
            var maxLineWidth = 0;
            var j;
            var jLen;
            var fontData = fontManager.getFontByName(documentData.f);
            var charData;
            var cLength = 0;
            var fontProps = getFontProperties(fontData);
            documentData.fWeight = fontProps.weight;
            documentData.fStyle = fontProps.style;
            documentData.finalSize = documentData.s;
            documentData.finalText = this.buildFinalText(documentData.t);
            len = documentData.finalText.length;
            documentData.finalLineHeight = documentData.lh;
            var trackingOffset =
              (documentData.tr / 1000) * documentData.finalSize;
            var charCode;

            if (documentData.sz) {
              var flag = true;
              var boxWidth = documentData.sz[0];
              var boxHeight = documentData.sz[1];
              var currentHeight;
              var finalText;

              while (flag) {
                finalText = this.buildFinalText(documentData.t);
                currentHeight = 0;
                lineWidth = 0;
                len = finalText.length;
                trackingOffset =
                  (documentData.tr / 1000) * documentData.finalSize;
                var lastSpaceIndex = -1;

                for (i = 0; i < len; i += 1) {
                  charCode = finalText[i].charCodeAt(0);
                  newLineFlag = false;

                  if (finalText[i] === " ") {
                    lastSpaceIndex = i;
                  } else if (charCode === 13 || charCode === 3) {
                    lineWidth = 0;
                    newLineFlag = true;
                    currentHeight +=
                      documentData.finalLineHeight ||
                      documentData.finalSize * 1.2;
                  }

                  if (fontManager.chars) {
                    charData = fontManager.getCharData(
                      finalText[i],
                      fontData.fStyle,
                      fontData.fFamily
                    );
                    cLength = newLineFlag
                      ? 0
                      : (charData.w * documentData.finalSize) / 100;
                  } else {
                    // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
                    cLength = fontManager.measureText(
                      finalText[i],
                      documentData.f,
                      documentData.finalSize
                    );
                  }

                  if (lineWidth + cLength > boxWidth && finalText[i] !== " ") {
                    if (lastSpaceIndex === -1) {
                      len += 1;
                    } else {
                      i = lastSpaceIndex;
                    }

                    currentHeight +=
                      documentData.finalLineHeight ||
                      documentData.finalSize * 1.2;
                    finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r"); // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);

                    lastSpaceIndex = -1;
                    lineWidth = 0;
                  } else {
                    lineWidth += cLength;
                    lineWidth += trackingOffset;
                  }
                }

                currentHeight +=
                  (fontData.ascent * documentData.finalSize) / 100;

                if (
                  this.canResize &&
                  documentData.finalSize > this.minimumFontSize &&
                  boxHeight < currentHeight
                ) {
                  documentData.finalSize -= 1;
                  documentData.finalLineHeight =
                    (documentData.finalSize * documentData.lh) / documentData.s;
                } else {
                  documentData.finalText = finalText;
                  len = documentData.finalText.length;
                  flag = false;
                }
              }
            }

            lineWidth = -trackingOffset;
            cLength = 0;
            var uncollapsedSpaces = 0;
            var currentChar;

            for (i = 0; i < len; i += 1) {
              newLineFlag = false;
              currentChar = documentData.finalText[i];
              charCode = currentChar.charCodeAt(0);

              if (charCode === 13 || charCode === 3) {
                uncollapsedSpaces = 0;
                lineWidths.push(lineWidth);
                maxLineWidth =
                  lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                lineWidth = -2 * trackingOffset;
                val = "";
                newLineFlag = true;
                currentLine += 1;
              } else {
                val = currentChar;
              }

              if (fontManager.chars) {
                charData = fontManager.getCharData(
                  currentChar,
                  fontData.fStyle,
                  fontManager.getFontByName(documentData.f).fFamily
                );
                cLength = newLineFlag
                  ? 0
                  : (charData.w * documentData.finalSize) / 100;
              } else {
                // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
                // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
                cLength = fontManager.measureText(
                  val,
                  documentData.f,
                  documentData.finalSize
                );
              } //

              if (currentChar === " ") {
                uncollapsedSpaces += cLength + trackingOffset;
              } else {
                lineWidth += cLength + trackingOffset + uncollapsedSpaces;
                uncollapsedSpaces = 0;
              }

              letters.push({
                l: cLength,
                an: cLength,
                add: currentSize,
                n: newLineFlag,
                anIndexes: [],
                val: val,
                line: currentLine,
                animatorJustifyOffset: 0,
              });

              if (anchorGrouping == 2) {
                // eslint-disable-line eqeqeq
                currentSize += cLength;

                if (val === "" || val === " " || i === len - 1) {
                  if (val === "" || val === " ") {
                    currentSize -= cLength;
                  }

                  while (currentPos <= i) {
                    letters[currentPos].an = currentSize;
                    letters[currentPos].ind = index;
                    letters[currentPos].extra = cLength;
                    currentPos += 1;
                  }

                  index += 1;
                  currentSize = 0;
                }
              } else if (anchorGrouping == 3) {
                // eslint-disable-line eqeqeq
                currentSize += cLength;

                if (val === "" || i === len - 1) {
                  if (val === "") {
                    currentSize -= cLength;
                  }

                  while (currentPos <= i) {
                    letters[currentPos].an = currentSize;
                    letters[currentPos].ind = index;
                    letters[currentPos].extra = cLength;
                    currentPos += 1;
                  }

                  currentSize = 0;
                  index += 1;
                }
              } else {
                letters[index].ind = index;
                letters[index].extra = 0;
                index += 1;
              }
            }

            documentData.l = letters;
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidths.push(lineWidth);

            if (documentData.sz) {
              documentData.boxWidth = documentData.sz[0];
              documentData.justifyOffset = 0;
            } else {
              documentData.boxWidth = maxLineWidth;

              switch (documentData.j) {
                case 1:
                  documentData.justifyOffset = -documentData.boxWidth;
                  break;

                case 2:
                  documentData.justifyOffset = -documentData.boxWidth / 2;
                  break;

                default:
                  documentData.justifyOffset = 0;
              }
            }

            documentData.lineWidths = lineWidths;
            var animators = data.a;
            var animatorData;
            var letterData;
            jLen = animators.length;
            var based;
            var ind;
            var indexes = [];

            for (j = 0; j < jLen; j += 1) {
              animatorData = animators[j];

              if (animatorData.a.sc) {
                documentData.strokeColorAnim = true;
              }

              if (animatorData.a.sw) {
                documentData.strokeWidthAnim = true;
              }

              if (
                animatorData.a.fc ||
                animatorData.a.fh ||
                animatorData.a.fs ||
                animatorData.a.fb
              ) {
                documentData.fillColorAnim = true;
              }

              ind = 0;
              based = animatorData.s.b;

              for (i = 0; i < len; i += 1) {
                letterData = letters[i];
                letterData.anIndexes[j] = ind;

                if (
                  (based == 1 && letterData.val !== "") ||
                  (based == 2 &&
                    letterData.val !== "" &&
                    letterData.val !== " ") ||
                  (based == 3 &&
                    (letterData.n || letterData.val == " " || i == len - 1)) ||
                  (based == 4 && (letterData.n || i == len - 1))
                ) {
                  // eslint-disable-line eqeqeq
                  if (animatorData.s.rn === 1) {
                    indexes.push(ind);
                  }

                  ind += 1;
                }
              }

              data.a[j].s.totalChars = ind;
              var currentInd = -1;
              var newInd;

              if (animatorData.s.rn === 1) {
                for (i = 0; i < len; i += 1) {
                  letterData = letters[i];

                  if (currentInd != letterData.anIndexes[j]) {
                    // eslint-disable-line eqeqeq
                    currentInd = letterData.anIndexes[j];
                    newInd = indexes.splice(
                      Math.floor(Math.random() * indexes.length),
                      1
                    )[0];
                  }

                  letterData.anIndexes[j] = newInd;
                }
              }
            }

            documentData.yOffset =
              documentData.finalLineHeight || documentData.finalSize * 1.2;
            documentData.ls = documentData.ls || 0;
            documentData.ascent =
              (fontData.ascent * documentData.finalSize) / 100;
          };

          TextProperty.prototype.updateDocumentData = function (
            newData,
            index
          ) {
            index = index === undefined ? this.keysIndex : index;
            var dData = this.copyData({}, this.data.d.k[index].s);
            dData = this.copyData(dData, newData);
            this.data.d.k[index].s = dData;
            this.recalculate(index);
            this.elem.addDynamicProperty(this);
          };

          TextProperty.prototype.recalculate = function (index) {
            var dData = this.data.d.k[index].s;
            dData.__complete = false;
            this.keysIndex = 0;
            this._isFirstFrame = true;
            this.getValue(dData);
          };

          TextProperty.prototype.canResizeFont = function (_canResize) {
            this.canResize = _canResize;
            this.recalculate(this.keysIndex);
            this.elem.addDynamicProperty(this);
          };

          TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
            this.minimumFontSize = Math.floor(_fontValue) || 1;
            this.recalculate(this.keysIndex);
            this.elem.addDynamicProperty(this);
          };

          var TextSelectorProp = (function () {
            var max = Math.max;
            var min = Math.min;
            var floor = Math.floor;

            function TextSelectorPropFactory(elem, data) {
              this._currentTextLength = -1;
              this.k = false;
              this.data = data;
              this.elem = elem;
              this.comp = elem.comp;
              this.finalS = 0;
              this.finalE = 0;
              this.initDynamicPropertyContainer(elem);
              this.s = PropertyFactory.getProp(
                elem,
                data.s || {
                  k: 0,
                },
                0,
                0,
                this
              );

              if ("e" in data) {
                this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
              } else {
                this.e = {
                  v: 100,
                };
              }

              this.o = PropertyFactory.getProp(
                elem,
                data.o || {
                  k: 0,
                },
                0,
                0,
                this
              );
              this.xe = PropertyFactory.getProp(
                elem,
                data.xe || {
                  k: 0,
                },
                0,
                0,
                this
              );
              this.ne = PropertyFactory.getProp(
                elem,
                data.ne || {
                  k: 0,
                },
                0,
                0,
                this
              );
              this.sm = PropertyFactory.getProp(
                elem,
                data.sm || {
                  k: 100,
                },
                0,
                0,
                this
              );
              this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);

              if (!this.dynamicProperties.length) {
                this.getValue();
              }
            }

            TextSelectorPropFactory.prototype = {
              getMult: function getMult(ind) {
                if (
                  this._currentTextLength !==
                  this.elem.textProperty.currentData.l.length
                ) {
                  this.getValue();
                }

                var x1 = 0;
                var y1 = 0;
                var x2 = 1;
                var y2 = 1;

                if (this.ne.v > 0) {
                  x1 = this.ne.v / 100.0;
                } else {
                  y1 = -this.ne.v / 100.0;
                }

                if (this.xe.v > 0) {
                  x2 = 1.0 - this.xe.v / 100.0;
                } else {
                  y2 = 1.0 + this.xe.v / 100.0;
                }

                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
                var mult = 0;
                var s = this.finalS;
                var e = this.finalE;
                var type = this.data.sh;

                if (type === 2) {
                  if (e === s) {
                    mult = ind >= e ? 1 : 0;
                  } else {
                    mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                  }

                  mult = easer(mult);
                } else if (type === 3) {
                  if (e === s) {
                    mult = ind >= e ? 0 : 1;
                  } else {
                    mult =
                      1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                  }

                  mult = easer(mult);
                } else if (type === 4) {
                  if (e === s) {
                    mult = 0;
                  } else {
                    mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));

                    if (mult < 0.5) {
                      mult *= 2;
                    } else {
                      mult = 1 - 2 * (mult - 0.5);
                    }
                  }

                  mult = easer(mult);
                } else if (type === 5) {
                  if (e === s) {
                    mult = 0;
                  } else {
                    var tot = e - s;
                    /* ind += 0.5;
                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */

                    ind = min(max(0, ind + 0.5 - s), e - s);
                    var x = -tot / 2 + ind;
                    var a = tot / 2;
                    mult = Math.sqrt(1 - (x * x) / (a * a));
                  }

                  mult = easer(mult);
                } else if (type === 6) {
                  if (e === s) {
                    mult = 0;
                  } else {
                    ind = min(max(0, ind + 0.5 - s), e - s);
                    mult =
                      (1 + Math.cos(Math.PI + (Math.PI * 2 * ind) / (e - s))) /
                      2; // eslint-disable-line
                  }

                  mult = easer(mult);
                } else {
                  if (ind >= floor(s)) {
                    if (ind - s < 0) {
                      mult = max(0, min(min(e, 1) - (s - ind), 1));
                    } else {
                      mult = max(0, min(e - ind, 1));
                    }
                  }

                  mult = easer(mult);
                } // Smoothness implementation.
                // The smoothness represents a reduced range of the original [0; 1] range.
                // if smoothness is 25%, the new range will be [0.375; 0.625]
                // Steps are:
                // - find the lower value of the new range (threshold)
                // - if multiplier is smaller than that value, floor it to 0
                // - if it is larger,
                //     - subtract the threshold
                //     - divide it by the smoothness (this will return the range to [0; 1])
                // Note: If it doesn't work on some scenarios, consider applying it before the easer.

                if (this.sm.v !== 100) {
                  var smoothness = this.sm.v * 0.01;

                  if (smoothness === 0) {
                    smoothness = 0.00000001;
                  }

                  var threshold = 0.5 - smoothness * 0.5;

                  if (mult < threshold) {
                    mult = 0;
                  } else {
                    mult = (mult - threshold) / smoothness;

                    if (mult > 1) {
                      mult = 1;
                    }
                  }
                }

                return mult * this.a.v;
              },
              getValue: function getValue(newCharsFlag) {
                this.iterateDynamicProperties();
                this._mdf = newCharsFlag || this._mdf;
                this._currentTextLength =
                  this.elem.textProperty.currentData.l.length || 0;

                if (newCharsFlag && this.data.r === 2) {
                  this.e.v = this._currentTextLength;
                }

                var divisor =
                  this.data.r === 2 ? 1 : 100 / this.data.totalChars;
                var o = this.o.v / divisor;
                var s = this.s.v / divisor + o;
                var e = this.e.v / divisor + o;

                if (s > e) {
                  var _s = s;
                  s = e;
                  e = _s;
                }

                this.finalS = s;
                this.finalE = e;
              },
            };
            extendPrototype(
              [DynamicPropertyContainer],
              TextSelectorPropFactory
            );

            function getTextSelectorProp(elem, data, arr) {
              return new TextSelectorPropFactory(elem, data, arr);
            }

            return {
              getTextSelectorProp: getTextSelectorProp,
            };
          })();

          function TextAnimatorDataProperty(elem, animatorProps, container) {
            var defaultData = {
              propType: false,
            };
            var getProp = PropertyFactory.getProp;
            var textAnimatorAnimatables = animatorProps.a;
            this.a = {
              r: textAnimatorAnimatables.r
                ? getProp(
                    elem,
                    textAnimatorAnimatables.r,
                    0,
                    degToRads,
                    container
                  )
                : defaultData,
              rx: textAnimatorAnimatables.rx
                ? getProp(
                    elem,
                    textAnimatorAnimatables.rx,
                    0,
                    degToRads,
                    container
                  )
                : defaultData,
              ry: textAnimatorAnimatables.ry
                ? getProp(
                    elem,
                    textAnimatorAnimatables.ry,
                    0,
                    degToRads,
                    container
                  )
                : defaultData,
              sk: textAnimatorAnimatables.sk
                ? getProp(
                    elem,
                    textAnimatorAnimatables.sk,
                    0,
                    degToRads,
                    container
                  )
                : defaultData,
              sa: textAnimatorAnimatables.sa
                ? getProp(
                    elem,
                    textAnimatorAnimatables.sa,
                    0,
                    degToRads,
                    container
                  )
                : defaultData,
              s: textAnimatorAnimatables.s
                ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container)
                : defaultData,
              a: textAnimatorAnimatables.a
                ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container)
                : defaultData,
              o: textAnimatorAnimatables.o
                ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container)
                : defaultData,
              p: textAnimatorAnimatables.p
                ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container)
                : defaultData,
              sw: textAnimatorAnimatables.sw
                ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container)
                : defaultData,
              sc: textAnimatorAnimatables.sc
                ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container)
                : defaultData,
              fc: textAnimatorAnimatables.fc
                ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container)
                : defaultData,
              fh: textAnimatorAnimatables.fh
                ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container)
                : defaultData,
              fs: textAnimatorAnimatables.fs
                ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container)
                : defaultData,
              fb: textAnimatorAnimatables.fb
                ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container)
                : defaultData,
              t: textAnimatorAnimatables.t
                ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container)
                : defaultData,
            };
            this.s = TextSelectorProp.getTextSelectorProp(
              elem,
              animatorProps.s,
              container
            );
            this.s.t = animatorProps.s.t;
          }

          function TextAnimatorProperty(textData, renderType, elem) {
            this._isFirstFrame = true;
            this._hasMaskedPath = false;
            this._frameId = -1;
            this._textData = textData;
            this._renderType = renderType;
            this._elem = elem;
            this._animatorsData = createSizedArray(this._textData.a.length);
            this._pathData = {};
            this._moreOptions = {
              alignment: {},
            };
            this.renderedLetters = [];
            this.lettersChangedFlag = false;
            this.initDynamicPropertyContainer(elem);
          }

          TextAnimatorProperty.prototype.searchProperties = function () {
            var i;
            var len = this._textData.a.length;
            var animatorProps;
            var getProp = PropertyFactory.getProp;

            for (i = 0; i < len; i += 1) {
              animatorProps = this._textData.a[i];
              this._animatorsData[i] = new TextAnimatorDataProperty(
                this._elem,
                animatorProps,
                this
              );
            }

            if (this._textData.p && "m" in this._textData.p) {
              this._pathData = {
                a: getProp(this._elem, this._textData.p.a, 0, 0, this),
                f: getProp(this._elem, this._textData.p.f, 0, 0, this),
                l: getProp(this._elem, this._textData.p.l, 0, 0, this),
                r: getProp(this._elem, this._textData.p.r, 0, 0, this),
                p: getProp(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
              };
              this._hasMaskedPath = true;
            } else {
              this._hasMaskedPath = false;
            }

            this._moreOptions.alignment = getProp(
              this._elem,
              this._textData.m.a,
              1,
              0,
              this
            );
          };

          TextAnimatorProperty.prototype.getMeasures = function (
            documentData,
            lettersChangedFlag
          ) {
            this.lettersChangedFlag = lettersChangedFlag;

            if (
              !this._mdf &&
              !this._isFirstFrame &&
              !lettersChangedFlag &&
              (!this._hasMaskedPath || !this._pathData.m._mdf)
            ) {
              return;
            }

            this._isFirstFrame = false;
            var alignment = this._moreOptions.alignment.v;
            var animators = this._animatorsData;
            var textData = this._textData;
            var matrixHelper = this.mHelper;
            var renderType = this._renderType;
            var renderedLettersCount = this.renderedLetters.length;
            var xPos;
            var yPos;
            var i;
            var len;
            var letters = documentData.l;
            var pathInfo;
            var currentLength;
            var currentPoint;
            var segmentLength;
            var flag;
            var pointInd;
            var segmentInd;
            var prevPoint;
            var points;
            var segments;
            var partialLength;
            var totalLength;
            var perc;
            var tanAngle;
            var mask;

            if (this._hasMaskedPath) {
              mask = this._pathData.m;

              if (!this._pathData.n || this._pathData._mdf) {
                var paths = mask.v;

                if (this._pathData.r.v) {
                  paths = paths.reverse();
                } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi

                pathInfo = {
                  tLength: 0,
                  segments: [],
                };
                len = paths._length - 1;
                var bezierData;
                totalLength = 0;

                for (i = 0; i < len; i += 1) {
                  bezierData = bez.buildBezierData(
                    paths.v[i],
                    paths.v[i + 1],
                    [
                      paths.o[i][0] - paths.v[i][0],
                      paths.o[i][1] - paths.v[i][1],
                    ],
                    [
                      paths.i[i + 1][0] - paths.v[i + 1][0],
                      paths.i[i + 1][1] - paths.v[i + 1][1],
                    ]
                  );
                  pathInfo.tLength += bezierData.segmentLength;
                  pathInfo.segments.push(bezierData);
                  totalLength += bezierData.segmentLength;
                }

                i = len;

                if (mask.v.c) {
                  bezierData = bez.buildBezierData(
                    paths.v[i],
                    paths.v[0],
                    [
                      paths.o[i][0] - paths.v[i][0],
                      paths.o[i][1] - paths.v[i][1],
                    ],
                    [
                      paths.i[0][0] - paths.v[0][0],
                      paths.i[0][1] - paths.v[0][1],
                    ]
                  );
                  pathInfo.tLength += bezierData.segmentLength;
                  pathInfo.segments.push(bezierData);
                  totalLength += bezierData.segmentLength;
                }

                this._pathData.pi = pathInfo;
              }

              pathInfo = this._pathData.pi;
              currentLength = this._pathData.f.v;
              segmentInd = 0;
              pointInd = 1;
              segmentLength = 0;
              flag = true;
              segments = pathInfo.segments;

              if (currentLength < 0 && mask.v.c) {
                if (pathInfo.tLength < Math.abs(currentLength)) {
                  currentLength = -Math.abs(currentLength) % pathInfo.tLength;
                }

                segmentInd = segments.length - 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;

                while (currentLength < 0) {
                  currentLength += points[pointInd].partialLength;
                  pointInd -= 1;

                  if (pointInd < 0) {
                    segmentInd -= 1;
                    points = segments[segmentInd].points;
                    pointInd = points.length - 1;
                  }
                }
              }

              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
            }

            len = letters.length;
            xPos = 0;
            yPos = 0;
            var yOff = documentData.finalSize * 1.2 * 0.714;
            var firstLine = true;
            var animatorProps;
            var animatorSelector;
            var j;
            var jLen;
            var letterValue;
            jLen = animators.length;
            var mult;
            var ind = -1;
            var offf;
            var xPathPos;
            var yPathPos;
            var initPathPos = currentLength;
            var initSegmentInd = segmentInd;
            var initPointInd = pointInd;
            var currentLine = -1;
            var elemOpacity;
            var sc;
            var sw;
            var fc;
            var k;
            var letterSw;
            var letterSc;
            var letterFc;
            var letterM = "";
            var letterP = this.defaultPropsArray;
            var letterO; //

            if (documentData.j === 2 || documentData.j === 1) {
              var animatorJustifyOffset = 0;
              var animatorFirstCharOffset = 0;
              var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
              var lastIndex = 0;
              var isNewLine = true;

              for (i = 0; i < len; i += 1) {
                if (letters[i].n) {
                  if (animatorJustifyOffset) {
                    animatorJustifyOffset += animatorFirstCharOffset;
                  }

                  while (lastIndex < i) {
                    letters[lastIndex].animatorJustifyOffset =
                      animatorJustifyOffset;
                    lastIndex += 1;
                  }

                  animatorJustifyOffset = 0;
                  isNewLine = true;
                } else {
                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;

                    if (animatorProps.t.propType) {
                      if (isNewLine && documentData.j === 2) {
                        animatorFirstCharOffset +=
                          animatorProps.t.v * justifyOffsetMult;
                      }

                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(
                        letters[i].anIndexes[j],
                        textData.a[j].s.totalChars
                      );

                      if (mult.length) {
                        animatorJustifyOffset +=
                          animatorProps.t.v * mult[0] * justifyOffsetMult;
                      } else {
                        animatorJustifyOffset +=
                          animatorProps.t.v * mult * justifyOffsetMult;
                      }
                    }
                  }

                  isNewLine = false;
                }
              }

              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }

              while (lastIndex < i) {
                letters[lastIndex].animatorJustifyOffset =
                  animatorJustifyOffset;
                lastIndex += 1;
              }
            } //

            for (i = 0; i < len; i += 1) {
              matrixHelper.reset();
              elemOpacity = 1;

              if (letters[i].n) {
                xPos = 0;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                currentLength = initPathPos;
                firstLine = false;

                if (this._hasMaskedPath) {
                  segmentInd = initSegmentInd;
                  pointInd = initPointInd;
                  points = segments[segmentInd].points;
                  prevPoint = points[pointInd - 1];
                  currentPoint = points[pointInd];
                  partialLength = currentPoint.partialLength;
                  segmentLength = 0;
                }

                letterM = "";
                letterFc = "";
                letterSw = "";
                letterO = "";
                letterP = this.defaultPropsArray;
              } else {
                if (this._hasMaskedPath) {
                  if (currentLine !== letters[i].line) {
                    switch (documentData.j) {
                      case 1:
                        currentLength +=
                          totalLength -
                          documentData.lineWidths[letters[i].line];
                        break;

                      case 2:
                        currentLength +=
                          (totalLength -
                            documentData.lineWidths[letters[i].line]) /
                          2;
                        break;

                      default:
                        break;
                    }

                    currentLine = letters[i].line;
                  }

                  if (ind !== letters[i].ind) {
                    if (letters[ind]) {
                      currentLength += letters[ind].extra;
                    }

                    currentLength += letters[i].an / 2;
                    ind = letters[i].ind;
                  }

                  currentLength += alignment[0] * letters[i].an * 0.005;
                  var animatorOffset = 0;

                  for (j = 0; j < jLen; j += 1) {
                    animatorProps = animators[j].a;

                    if (animatorProps.p.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(
                        letters[i].anIndexes[j],
                        textData.a[j].s.totalChars
                      );

                      if (mult.length) {
                        animatorOffset += animatorProps.p.v[0] * mult[0];
                      } else {
                        animatorOffset += animatorProps.p.v[0] * mult;
                      }
                    }

                    if (animatorProps.a.propType) {
                      animatorSelector = animators[j].s;
                      mult = animatorSelector.getMult(
                        letters[i].anIndexes[j],
                        textData.a[j].s.totalChars
                      );

                      if (mult.length) {
                        animatorOffset += animatorProps.a.v[0] * mult[0];
                      } else {
                        animatorOffset += animatorProps.a.v[0] * mult;
                      }
                    }
                  }

                  flag = true; // Force alignment only works with a single line for now

                  if (this._pathData.a.v) {
                    currentLength =
                      letters[0].an * 0.5 +
                      ((totalLength -
                        this._pathData.f.v -
                        letters[0].an * 0.5 -
                        letters[letters.length - 1].an * 0.5) *
                        ind) /
                        (len - 1);
                    currentLength += this._pathData.f.v;
                  }

                  while (flag) {
                    if (
                      segmentLength + partialLength >=
                        currentLength + animatorOffset ||
                      !points
                    ) {
                      perc =
                        (currentLength + animatorOffset - segmentLength) /
                        currentPoint.partialLength;
                      xPathPos =
                        prevPoint.point[0] +
                        (currentPoint.point[0] - prevPoint.point[0]) * perc;
                      yPathPos =
                        prevPoint.point[1] +
                        (currentPoint.point[1] - prevPoint.point[1]) * perc;
                      matrixHelper.translate(
                        -alignment[0] * letters[i].an * 0.005,
                        -(alignment[1] * yOff) * 0.01
                      );
                      flag = false;
                    } else if (points) {
                      segmentLength += currentPoint.partialLength;
                      pointInd += 1;

                      if (pointInd >= points.length) {
                        pointInd = 0;
                        segmentInd += 1;

                        if (!segments[segmentInd]) {
                          if (mask.v.c) {
                            pointInd = 0;
                            segmentInd = 0;
                            points = segments[segmentInd].points;
                          } else {
                            segmentLength -= currentPoint.partialLength;
                            points = null;
                          }
                        } else {
                          points = segments[segmentInd].points;
                        }
                      }

                      if (points) {
                        prevPoint = currentPoint;
                        currentPoint = points[pointInd];
                        partialLength = currentPoint.partialLength;
                      }
                    }
                  }

                  offf = letters[i].an / 2 - letters[i].add;
                  matrixHelper.translate(-offf, 0, 0);
                } else {
                  offf = letters[i].an / 2 - letters[i].add;
                  matrixHelper.translate(-offf, 0, 0); // Grouping alignment

                  matrixHelper.translate(
                    -alignment[0] * letters[i].an * 0.005,
                    -alignment[1] * yOff * 0.01,
                    0
                  );
                }

                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;

                  if (animatorProps.t.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(
                      letters[i].anIndexes[j],
                      textData.a[j].s.totalChars
                    ); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"

                    if (xPos !== 0 || documentData.j !== 0) {
                      if (this._hasMaskedPath) {
                        if (mult.length) {
                          currentLength += animatorProps.t.v * mult[0];
                        } else {
                          currentLength += animatorProps.t.v * mult;
                        }
                      } else if (mult.length) {
                        xPos += animatorProps.t.v * mult[0];
                      } else {
                        xPos += animatorProps.t.v * mult;
                      }
                    }
                  }
                }

                if (documentData.strokeWidthAnim) {
                  sw = documentData.sw || 0;
                }

                if (documentData.strokeColorAnim) {
                  if (documentData.sc) {
                    sc = [
                      documentData.sc[0],
                      documentData.sc[1],
                      documentData.sc[2],
                    ];
                  } else {
                    sc = [0, 0, 0];
                  }
                }

                if (documentData.fillColorAnim && documentData.fc) {
                  fc = [
                    documentData.fc[0],
                    documentData.fc[1],
                    documentData.fc[2],
                  ];
                }

                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;

                  if (animatorProps.a.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(
                      letters[i].anIndexes[j],
                      textData.a[j].s.totalChars
                    );

                    if (mult.length) {
                      matrixHelper.translate(
                        -animatorProps.a.v[0] * mult[0],
                        -animatorProps.a.v[1] * mult[1],
                        animatorProps.a.v[2] * mult[2]
                      );
                    } else {
                      matrixHelper.translate(
                        -animatorProps.a.v[0] * mult,
                        -animatorProps.a.v[1] * mult,
                        animatorProps.a.v[2] * mult
                      );
                    }
                  }
                }

                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;

                  if (animatorProps.s.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(
                      letters[i].anIndexes[j],
                      textData.a[j].s.totalChars
                    );

                    if (mult.length) {
                      matrixHelper.scale(
                        1 + (animatorProps.s.v[0] - 1) * mult[0],
                        1 + (animatorProps.s.v[1] - 1) * mult[1],
                        1
                      );
                    } else {
                      matrixHelper.scale(
                        1 + (animatorProps.s.v[0] - 1) * mult,
                        1 + (animatorProps.s.v[1] - 1) * mult,
                        1
                      );
                    }
                  }
                }

                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(
                    letters[i].anIndexes[j],
                    textData.a[j].s.totalChars
                  );

                  if (animatorProps.sk.propType) {
                    if (mult.length) {
                      matrixHelper.skewFromAxis(
                        -animatorProps.sk.v * mult[0],
                        animatorProps.sa.v * mult[1]
                      );
                    } else {
                      matrixHelper.skewFromAxis(
                        -animatorProps.sk.v * mult,
                        animatorProps.sa.v * mult
                      );
                    }
                  }

                  if (animatorProps.r.propType) {
                    if (mult.length) {
                      matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                    } else {
                      matrixHelper.rotateZ(-animatorProps.r.v * mult);
                    }
                  }

                  if (animatorProps.ry.propType) {
                    if (mult.length) {
                      matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                    } else {
                      matrixHelper.rotateY(animatorProps.ry.v * mult);
                    }
                  }

                  if (animatorProps.rx.propType) {
                    if (mult.length) {
                      matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                    } else {
                      matrixHelper.rotateX(animatorProps.rx.v * mult);
                    }
                  }

                  if (animatorProps.o.propType) {
                    if (mult.length) {
                      elemOpacity +=
                        (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                    } else {
                      elemOpacity +=
                        (animatorProps.o.v * mult - elemOpacity) * mult;
                    }
                  }

                  if (
                    documentData.strokeWidthAnim &&
                    animatorProps.sw.propType
                  ) {
                    if (mult.length) {
                      sw += animatorProps.sw.v * mult[0];
                    } else {
                      sw += animatorProps.sw.v * mult;
                    }
                  }

                  if (
                    documentData.strokeColorAnim &&
                    animatorProps.sc.propType
                  ) {
                    for (k = 0; k < 3; k += 1) {
                      if (mult.length) {
                        sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                      } else {
                        sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                      }
                    }
                  }

                  if (documentData.fillColorAnim && documentData.fc) {
                    if (animatorProps.fc.propType) {
                      for (k = 0; k < 3; k += 1) {
                        if (mult.length) {
                          fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                        } else {
                          fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                        }
                      }
                    }

                    if (animatorProps.fh.propType) {
                      if (mult.length) {
                        fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                      } else {
                        fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                      }
                    }

                    if (animatorProps.fs.propType) {
                      if (mult.length) {
                        fc = addSaturationToRGB(
                          fc,
                          animatorProps.fs.v * mult[0]
                        );
                      } else {
                        fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                      }
                    }

                    if (animatorProps.fb.propType) {
                      if (mult.length) {
                        fc = addBrightnessToRGB(
                          fc,
                          animatorProps.fb.v * mult[0]
                        );
                      } else {
                        fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                      }
                    }
                  }
                }

                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;

                  if (animatorProps.p.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(
                      letters[i].anIndexes[j],
                      textData.a[j].s.totalChars
                    );

                    if (this._hasMaskedPath) {
                      if (mult.length) {
                        matrixHelper.translate(
                          0,
                          animatorProps.p.v[1] * mult[0],
                          -animatorProps.p.v[2] * mult[1]
                        );
                      } else {
                        matrixHelper.translate(
                          0,
                          animatorProps.p.v[1] * mult,
                          -animatorProps.p.v[2] * mult
                        );
                      }
                    } else if (mult.length) {
                      matrixHelper.translate(
                        animatorProps.p.v[0] * mult[0],
                        animatorProps.p.v[1] * mult[1],
                        -animatorProps.p.v[2] * mult[2]
                      );
                    } else {
                      matrixHelper.translate(
                        animatorProps.p.v[0] * mult,
                        animatorProps.p.v[1] * mult,
                        -animatorProps.p.v[2] * mult
                      );
                    }
                  }
                }

                if (documentData.strokeWidthAnim) {
                  letterSw = sw < 0 ? 0 : sw;
                }

                if (documentData.strokeColorAnim) {
                  letterSc =
                    "rgb(" +
                    Math.round(sc[0] * 255) +
                    "," +
                    Math.round(sc[1] * 255) +
                    "," +
                    Math.round(sc[2] * 255) +
                    ")";
                }

                if (documentData.fillColorAnim && documentData.fc) {
                  letterFc =
                    "rgb(" +
                    Math.round(fc[0] * 255) +
                    "," +
                    Math.round(fc[1] * 255) +
                    "," +
                    Math.round(fc[2] * 255) +
                    ")";
                }

                if (this._hasMaskedPath) {
                  matrixHelper.translate(0, -documentData.ls);
                  matrixHelper.translate(
                    0,
                    alignment[1] * yOff * 0.01 + yPos,
                    0
                  );

                  if (this._pathData.p.v) {
                    tanAngle =
                      (currentPoint.point[1] - prevPoint.point[1]) /
                      (currentPoint.point[0] - prevPoint.point[0]);
                    var rot = (Math.atan(tanAngle) * 180) / Math.PI;

                    if (currentPoint.point[0] < prevPoint.point[0]) {
                      rot += 180;
                    }

                    matrixHelper.rotate((-rot * Math.PI) / 180);
                  }

                  matrixHelper.translate(xPathPos, yPathPos, 0);
                  currentLength -= alignment[0] * letters[i].an * 0.005;

                  if (letters[i + 1] && ind !== letters[i + 1].ind) {
                    currentLength += letters[i].an / 2;
                    currentLength +=
                      documentData.tr * 0.001 * documentData.finalSize;
                  }
                } else {
                  matrixHelper.translate(xPos, yPos, 0);

                  if (documentData.ps) {
                    // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
                    matrixHelper.translate(
                      documentData.ps[0],
                      documentData.ps[1] + documentData.ascent,
                      0
                    );
                  }

                  switch (documentData.j) {
                    case 1:
                      matrixHelper.translate(
                        letters[i].animatorJustifyOffset +
                          documentData.justifyOffset +
                          (documentData.boxWidth -
                            documentData.lineWidths[letters[i].line]),
                        0,
                        0
                      );
                      break;

                    case 2:
                      matrixHelper.translate(
                        letters[i].animatorJustifyOffset +
                          documentData.justifyOffset +
                          (documentData.boxWidth -
                            documentData.lineWidths[letters[i].line]) /
                            2,
                        0,
                        0
                      );
                      break;

                    default:
                      break;
                  }

                  matrixHelper.translate(0, -documentData.ls);
                  matrixHelper.translate(offf, 0, 0);
                  matrixHelper.translate(
                    alignment[0] * letters[i].an * 0.005,
                    alignment[1] * yOff * 0.01,
                    0
                  );
                  xPos +=
                    letters[i].l +
                    documentData.tr * 0.001 * documentData.finalSize;
                }

                if (renderType === "html") {
                  letterM = matrixHelper.toCSS();
                } else if (renderType === "svg") {
                  letterM = matrixHelper.to2dCSS();
                } else {
                  letterP = [
                    matrixHelper.props[0],
                    matrixHelper.props[1],
                    matrixHelper.props[2],
                    matrixHelper.props[3],
                    matrixHelper.props[4],
                    matrixHelper.props[5],
                    matrixHelper.props[6],
                    matrixHelper.props[7],
                    matrixHelper.props[8],
                    matrixHelper.props[9],
                    matrixHelper.props[10],
                    matrixHelper.props[11],
                    matrixHelper.props[12],
                    matrixHelper.props[13],
                    matrixHelper.props[14],
                    matrixHelper.props[15],
                  ];
                }

                letterO = elemOpacity;
              }

              if (renderedLettersCount <= i) {
                letterValue = new LetterProps(
                  letterO,
                  letterSw,
                  letterSc,
                  letterFc,
                  letterM,
                  letterP
                );
                this.renderedLetters.push(letterValue);
                renderedLettersCount += 1;
                this.lettersChangedFlag = true;
              } else {
                letterValue = this.renderedLetters[i];
                this.lettersChangedFlag =
                  letterValue.update(
                    letterO,
                    letterSw,
                    letterSc,
                    letterFc,
                    letterM,
                    letterP
                  ) || this.lettersChangedFlag;
              }
            }
          };

          TextAnimatorProperty.prototype.getValue = function () {
            if (this._elem.globalData.frameId === this._frameId) {
              return;
            }

            this._frameId = this._elem.globalData.frameId;
            this.iterateDynamicProperties();
          };

          TextAnimatorProperty.prototype.mHelper = new Matrix();
          TextAnimatorProperty.prototype.defaultPropsArray = [];
          extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

          function ITextElement() {}

          ITextElement.prototype.initElement = function (
            data,
            globalData,
            comp
          ) {
            this.lettersChangedFlag = true;
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.textProperty = new TextProperty(
              this,
              data.t,
              this.dynamicProperties
            );
            this.textAnimator = new TextAnimatorProperty(
              data.t,
              this.renderType,
              this
            );
            this.initTransform(data, globalData, comp);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
            this.textAnimator.searchProperties(this.dynamicProperties);
          };

          ITextElement.prototype.prepareFrame = function (num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);

            if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
              this.buildNewText();
              this.textProperty._isFirstFrame = false;
              this.textProperty._mdf = false;
            }
          };

          ITextElement.prototype.createPathShape = function (
            matrixHelper,
            shapes
          ) {
            var j;
            var jLen = shapes.length;
            var pathNodes;
            var shapeStr = "";

            for (j = 0; j < jLen; j += 1) {
              if (shapes[j].ty === "sh") {
                pathNodes = shapes[j].ks.k;
                shapeStr += buildShapeString(
                  pathNodes,
                  pathNodes.i.length,
                  true,
                  matrixHelper
                );
              }
            }

            return shapeStr;
          };

          ITextElement.prototype.updateDocumentData = function (
            newData,
            index
          ) {
            this.textProperty.updateDocumentData(newData, index);
          };

          ITextElement.prototype.canResizeFont = function (_canResize) {
            this.textProperty.canResizeFont(_canResize);
          };

          ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
            this.textProperty.setMinimumFontSize(_fontSize);
          };

          ITextElement.prototype.applyTextPropertiesToMatrix = function (
            documentData,
            matrixHelper,
            lineNumber,
            xPos,
            yPos
          ) {
            if (documentData.ps) {
              matrixHelper.translate(
                documentData.ps[0],
                documentData.ps[1] + documentData.ascent,
                0
              );
            }

            matrixHelper.translate(0, -documentData.ls, 0);

            switch (documentData.j) {
              case 1:
                matrixHelper.translate(
                  documentData.justifyOffset +
                    (documentData.boxWidth -
                      documentData.lineWidths[lineNumber]),
                  0,
                  0
                );
                break;

              case 2:
                matrixHelper.translate(
                  documentData.justifyOffset +
                    (documentData.boxWidth -
                      documentData.lineWidths[lineNumber]) /
                      2,
                  0,
                  0
                );
                break;

              default:
                break;
            }

            matrixHelper.translate(xPos, yPos, 0);
          };

          ITextElement.prototype.buildColor = function (colorData) {
            return (
              "rgb(" +
              Math.round(colorData[0] * 255) +
              "," +
              Math.round(colorData[1] * 255) +
              "," +
              Math.round(colorData[2] * 255) +
              ")"
            );
          };

          ITextElement.prototype.emptyProp = new LetterProps();

          ITextElement.prototype.destroy = function () {};

          var emptyShapeData = {
            shapes: [],
          };

          function SVGTextLottieElement(data, globalData, comp) {
            this.textSpans = [];
            this.renderType = "svg";
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              SVGBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
              ITextElement,
            ],
            SVGTextLottieElement
          );

          SVGTextLottieElement.prototype.createContent = function () {
            if (this.data.singleShape && !this.globalData.fontManager.chars) {
              this.textContainer = createNS("text");
            }
          };

          SVGTextLottieElement.prototype.buildTextContents = function (
            textArray
          ) {
            var i = 0;
            var len = textArray.length;
            var textContents = [];
            var currentTextContent = "";

            while (i < len) {
              if (
                textArray[i] === String.fromCharCode(13) ||
                textArray[i] === String.fromCharCode(3)
              ) {
                textContents.push(currentTextContent);
                currentTextContent = "";
              } else {
                currentTextContent += textArray[i];
              }

              i += 1;
            }

            textContents.push(currentTextContent);
            return textContents;
          };

          SVGTextLottieElement.prototype.buildNewText = function () {
            this.addDynamicProperty(this);
            var i;
            var len;
            var documentData = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(
              documentData ? documentData.l.length : 0
            );

            if (documentData.fc) {
              this.layerElement.setAttribute(
                "fill",
                this.buildColor(documentData.fc)
              );
            } else {
              this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
            }

            if (documentData.sc) {
              this.layerElement.setAttribute(
                "stroke",
                this.buildColor(documentData.sc)
              );
              this.layerElement.setAttribute("stroke-width", documentData.sw);
            }

            this.layerElement.setAttribute("font-size", documentData.finalSize);
            var fontData = this.globalData.fontManager.getFontByName(
              documentData.f
            );

            if (fontData.fClass) {
              this.layerElement.setAttribute("class", fontData.fClass);
            } else {
              this.layerElement.setAttribute("font-family", fontData.fFamily);
              var fWeight = documentData.fWeight;
              var fStyle = documentData.fStyle;
              this.layerElement.setAttribute("font-style", fStyle);
              this.layerElement.setAttribute("font-weight", fWeight);
            }

            this.layerElement.setAttribute("aria-label", documentData.t);
            var letters = documentData.l || [];
            var usesGlyphs = !!this.globalData.fontManager.chars;
            len = letters.length;
            var tSpan;
            var matrixHelper = this.mHelper;
            var shapeStr = "";
            var singleShape = this.data.singleShape;
            var xPos = 0;
            var yPos = 0;
            var firstLine = true;
            var trackingOffset =
              documentData.tr * 0.001 * documentData.finalSize;

            if (singleShape && !usesGlyphs && !documentData.sz) {
              var tElement = this.textContainer;
              var justify = "start";

              switch (documentData.j) {
                case 1:
                  justify = "end";
                  break;

                case 2:
                  justify = "middle";
                  break;

                default:
                  justify = "start";
                  break;
              }

              tElement.setAttribute("text-anchor", justify);
              tElement.setAttribute("letter-spacing", trackingOffset);
              var textContent = this.buildTextContents(documentData.finalText);
              len = textContent.length;
              yPos = documentData.ps
                ? documentData.ps[1] + documentData.ascent
                : 0;

              for (i = 0; i < len; i += 1) {
                tSpan = this.textSpans[i].span || createNS("tspan");
                tSpan.textContent = textContent[i];
                tSpan.setAttribute("x", 0);
                tSpan.setAttribute("y", yPos);
                tSpan.style.display = "inherit";
                tElement.appendChild(tSpan);

                if (!this.textSpans[i]) {
                  this.textSpans[i] = {
                    span: null,
                    glyph: null,
                  };
                }

                this.textSpans[i].span = tSpan;
                yPos += documentData.finalLineHeight;
              }

              this.layerElement.appendChild(tElement);
            } else {
              var cachedSpansLength = this.textSpans.length;
              var charData;

              for (i = 0; i < len; i += 1) {
                if (!this.textSpans[i]) {
                  this.textSpans[i] = {
                    span: null,
                    childSpan: null,
                    glyph: null,
                  };
                }

                if (!usesGlyphs || !singleShape || i === 0) {
                  tSpan =
                    cachedSpansLength > i
                      ? this.textSpans[i].span
                      : createNS(usesGlyphs ? "g" : "text");

                  if (cachedSpansLength <= i) {
                    tSpan.setAttribute("stroke-linecap", "butt");
                    tSpan.setAttribute("stroke-linejoin", "round");
                    tSpan.setAttribute("stroke-miterlimit", "4");
                    this.textSpans[i].span = tSpan;

                    if (usesGlyphs) {
                      var childSpan = createNS("g");
                      tSpan.appendChild(childSpan);
                      this.textSpans[i].childSpan = childSpan;
                    }

                    this.textSpans[i].span = tSpan;
                    this.layerElement.appendChild(tSpan);
                  }

                  tSpan.style.display = "inherit";
                }

                matrixHelper.reset();
                matrixHelper.scale(
                  documentData.finalSize / 100,
                  documentData.finalSize / 100
                );

                if (singleShape) {
                  if (letters[i].n) {
                    xPos = -trackingOffset;
                    yPos += documentData.yOffset;
                    yPos += firstLine ? 1 : 0;
                    firstLine = false;
                  }

                  this.applyTextPropertiesToMatrix(
                    documentData,
                    matrixHelper,
                    letters[i].line,
                    xPos,
                    yPos
                  );
                  xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;

                  xPos += trackingOffset;
                }

                if (usesGlyphs) {
                  charData = this.globalData.fontManager.getCharData(
                    documentData.finalText[i],
                    fontData.fStyle,
                    this.globalData.fontManager.getFontByName(documentData.f)
                      .fFamily
                  );
                  var glyphElement;

                  if (charData.t === 1) {
                    glyphElement = new SVGCompElement(
                      charData.data,
                      this.globalData,
                      this
                    );
                  } else {
                    var data = emptyShapeData;

                    if (charData.data && charData.data.shapes) {
                      data = charData.data;
                    }

                    glyphElement = new SVGShapeElement(
                      data,
                      this.globalData,
                      this
                    );
                  }

                  if (this.textSpans[i].glyph) {
                    var glyph = this.textSpans[i].glyph;
                    this.textSpans[i].childSpan.removeChild(glyph.layerElement);
                    glyph.destroy();
                  }

                  this.textSpans[i].glyph = glyphElement;
                  glyphElement._debug = true;
                  glyphElement.prepareFrame(0);
                  glyphElement.renderFrame();
                  this.textSpans[i].childSpan.appendChild(
                    glyphElement.layerElement
                  );
                  this.textSpans[i].childSpan.setAttribute(
                    "transform",
                    "scale(" +
                      documentData.finalSize / 100 +
                      "," +
                      documentData.finalSize / 100 +
                      ")"
                  );
                } else {
                  if (singleShape) {
                    tSpan.setAttribute(
                      "transform",
                      "translate(" +
                        matrixHelper.props[12] +
                        "," +
                        matrixHelper.props[13] +
                        ")"
                    );
                  }

                  tSpan.textContent = letters[i].val;
                  tSpan.setAttributeNS(
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:space",
                    "preserve"
                  );
                } //
              }

              if (singleShape && tSpan) {
                tSpan.setAttribute("d", shapeStr);
              }
            }

            while (i < this.textSpans.length) {
              this.textSpans[i].span.style.display = "none";
              i += 1;
            }

            this._sizeChanged = true;
          };

          SVGTextLottieElement.prototype.sourceRectAtTime = function () {
            this.prepareFrame(this.comp.renderedFrame - this.data.st);
            this.renderInnerContent();

            if (this._sizeChanged) {
              this._sizeChanged = false;
              var textBox = this.layerElement.getBBox();
              this.bbox = {
                top: textBox.y,
                left: textBox.x,
                width: textBox.width,
                height: textBox.height,
              };
            }

            return this.bbox;
          };

          SVGTextLottieElement.prototype.getValue = function () {
            var i;
            var len = this.textSpans.length;
            var glyphElement;
            this.renderedFrame = this.comp.renderedFrame;

            for (i = 0; i < len; i += 1) {
              glyphElement = this.textSpans[i].glyph;

              if (glyphElement) {
                glyphElement.prepareFrame(
                  this.comp.renderedFrame - this.data.st
                );

                if (glyphElement._mdf) {
                  this._mdf = true;
                }
              }
            }
          };

          SVGTextLottieElement.prototype.renderInnerContent = function () {
            if (!this.data.singleShape || this._mdf) {
              this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              );

              if (
                this.lettersChangedFlag ||
                this.textAnimator.lettersChangedFlag
              ) {
                this._sizeChanged = true;
                var i;
                var len;
                var renderedLetters = this.textAnimator.renderedLetters;
                var letters = this.textProperty.currentData.l;
                len = letters.length;
                var renderedLetter;
                var textSpan;
                var glyphElement;

                for (i = 0; i < len; i += 1) {
                  if (!letters[i].n) {
                    renderedLetter = renderedLetters[i];
                    textSpan = this.textSpans[i].span;
                    glyphElement = this.textSpans[i].glyph;

                    if (glyphElement) {
                      glyphElement.renderFrame();
                    }

                    if (renderedLetter._mdf.m) {
                      textSpan.setAttribute("transform", renderedLetter.m);
                    }

                    if (renderedLetter._mdf.o) {
                      textSpan.setAttribute("opacity", renderedLetter.o);
                    }

                    if (renderedLetter._mdf.sw) {
                      textSpan.setAttribute("stroke-width", renderedLetter.sw);
                    }

                    if (renderedLetter._mdf.sc) {
                      textSpan.setAttribute("stroke", renderedLetter.sc);
                    }

                    if (renderedLetter._mdf.fc) {
                      textSpan.setAttribute("fill", renderedLetter.fc);
                    }
                  }
                }
              }
            }
          };

          function ISolidElement(data, globalData, comp) {
            this.initElement(data, globalData, comp);
          }

          extendPrototype([IImageElement], ISolidElement);

          ISolidElement.prototype.createContent = function () {
            var rect = createNS("rect"); /// /rect.style.width = this.data.sw;
            /// /rect.style.height = this.data.sh;
            /// /rect.style.fill = this.data.sc;

            rect.setAttribute("width", this.data.sw);
            rect.setAttribute("height", this.data.sh);
            rect.setAttribute("fill", this.data.sc);
            this.layerElement.appendChild(rect);
          };

          function NullElement(data, globalData, comp) {
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.initFrame();
            this.initTransform(data, globalData, comp);
            this.initHierarchy();
          }

          NullElement.prototype.prepareFrame = function (num) {
            this.prepareProperties(num, true);
          };

          NullElement.prototype.renderFrame = function () {};

          NullElement.prototype.getBaseElement = function () {
            return null;
          };

          NullElement.prototype.destroy = function () {};

          NullElement.prototype.sourceRectAtTime = function () {};

          NullElement.prototype.hide = function () {};

          extendPrototype(
            [BaseElement, TransformElement, HierarchyElement, FrameElement],
            NullElement
          );

          function SVGRendererBase() {}

          extendPrototype([BaseRenderer], SVGRendererBase);

          SVGRendererBase.prototype.createNull = function (data) {
            return new NullElement(data, this.globalData, this);
          };

          SVGRendererBase.prototype.createShape = function (data) {
            return new SVGShapeElement(data, this.globalData, this);
          };

          SVGRendererBase.prototype.createText = function (data) {
            return new SVGTextLottieElement(data, this.globalData, this);
          };

          SVGRendererBase.prototype.createImage = function (data) {
            return new IImageElement(data, this.globalData, this);
          };

          SVGRendererBase.prototype.createSolid = function (data) {
            return new ISolidElement(data, this.globalData, this);
          };

          SVGRendererBase.prototype.configAnimation = function (animData) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            if (this.renderConfig.viewBoxSize) {
              this.svgElement.setAttribute(
                "viewBox",
                this.renderConfig.viewBoxSize
              );
            } else {
              this.svgElement.setAttribute(
                "viewBox",
                "0 0 " + animData.w + " " + animData.h
              );
            }

            if (!this.renderConfig.viewBoxOnly) {
              this.svgElement.setAttribute("width", animData.w);
              this.svgElement.setAttribute("height", animData.h);
              this.svgElement.style.width = "100%";
              this.svgElement.style.height = "100%";
              this.svgElement.style.transform = "translate3d(0,0,0)";
              this.svgElement.style.contentVisibility =
                this.renderConfig.contentVisibility;
            }

            if (this.renderConfig.width) {
              this.svgElement.setAttribute("width", this.renderConfig.width);
            }

            if (this.renderConfig.height) {
              this.svgElement.setAttribute("height", this.renderConfig.height);
            }

            if (this.renderConfig.className) {
              this.svgElement.setAttribute(
                "class",
                this.renderConfig.className
              );
            }

            if (this.renderConfig.id) {
              this.svgElement.setAttribute("id", this.renderConfig.id);
            }

            if (this.renderConfig.focusable !== undefined) {
              this.svgElement.setAttribute(
                "focusable",
                this.renderConfig.focusable
              );
            }

            this.svgElement.setAttribute(
              "preserveAspectRatio",
              this.renderConfig.preserveAspectRatio
            ); // this.layerElement.style.transform = 'translate3d(0,0,0)';
            // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";

            this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation

            var defs = this.globalData.defs;
            this.setupGlobalData(animData, defs);
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
            this.data = animData;
            var maskElement = createNS("clipPath");
            var rect = createNS("rect");
            rect.setAttribute("width", animData.w);
            rect.setAttribute("height", animData.h);
            rect.setAttribute("x", 0);
            rect.setAttribute("y", 0);
            var maskId = createElementID();
            maskElement.setAttribute("id", maskId);
            maskElement.appendChild(rect);
            this.layerElement.setAttribute(
              "clip-path",
              "url(" + getLocationHref() + "#" + maskId + ")"
            );
            defs.appendChild(maskElement);
            this.layers = animData.layers;
            this.elements = createSizedArray(animData.layers.length);
          };

          SVGRendererBase.prototype.destroy = function () {
            if (this.animationItem.wrapper) {
              this.animationItem.wrapper.innerText = "";
            }

            this.layerElement = null;
            this.globalData.defs = null;
            var i;
            var len = this.layers ? this.layers.length : 0;

            for (i = 0; i < len; i += 1) {
              if (this.elements[i]) {
                this.elements[i].destroy();
              }
            }

            this.elements.length = 0;
            this.destroyed = true;
            this.animationItem = null;
          };

          SVGRendererBase.prototype.updateContainerSize = function () {};

          SVGRendererBase.prototype.buildItem = function (pos) {
            var elements = this.elements;

            if (elements[pos] || this.layers[pos].ty === 99) {
              return;
            }

            elements[pos] = true;
            var element = this.createItem(this.layers[pos]);
            elements[pos] = element;

            if (getExpressionsPlugin()) {
              if (this.layers[pos].ty === 0) {
                this.globalData.projectInterface.registerComposition(element);
              }

              element.initExpressions();
            }

            this.appendElementInPos(element, pos);

            if (this.layers[pos].tt) {
              if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
                this.buildItem(pos - 1);
                this.addPendingElement(element);
              } else {
                element.setMatte(elements[pos - 1].layerId);
              }
            }
          };

          SVGRendererBase.prototype.checkPendingElements = function () {
            while (this.pendingElements.length) {
              var element = this.pendingElements.pop();
              element.checkParenting();

              if (element.data.tt) {
                var i = 0;
                var len = this.elements.length;

                while (i < len) {
                  if (this.elements[i] === element) {
                    element.setMatte(this.elements[i - 1].layerId);
                    break;
                  }

                  i += 1;
                }
              }
            }
          };

          SVGRendererBase.prototype.renderFrame = function (num) {
            if (this.renderedFrame === num || this.destroyed) {
              return;
            }

            if (num === null) {
              num = this.renderedFrame;
            } else {
              this.renderedFrame = num;
            } // console.log('-------');
            // console.log('FRAME ',num);

            this.globalData.frameNum = num;
            this.globalData.frameId += 1;
            this.globalData.projectInterface.currentFrame = num;
            this.globalData._mdf = false;
            var i;
            var len = this.layers.length;

            if (!this.completeLayers) {
              this.checkLayers(num);
            }

            for (i = len - 1; i >= 0; i -= 1) {
              if (this.completeLayers || this.elements[i]) {
                this.elements[i].prepareFrame(num - this.layers[i].st);
              }
            }

            if (this.globalData._mdf) {
              for (i = 0; i < len; i += 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].renderFrame();
                }
              }
            }
          };

          SVGRendererBase.prototype.appendElementInPos = function (
            element,
            pos
          ) {
            var newElement = element.getBaseElement();

            if (!newElement) {
              return;
            }

            var i = 0;
            var nextElement;

            while (i < pos) {
              if (
                this.elements[i] &&
                this.elements[i] !== true &&
                this.elements[i].getBaseElement()
              ) {
                nextElement = this.elements[i].getBaseElement();
              }

              i += 1;
            }

            if (nextElement) {
              this.layerElement.insertBefore(newElement, nextElement);
            } else {
              this.layerElement.appendChild(newElement);
            }
          };

          SVGRendererBase.prototype.hide = function () {
            this.layerElement.style.display = "none";
          };

          SVGRendererBase.prototype.show = function () {
            this.layerElement.style.display = "block";
          };

          function ICompElement() {}

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
            ],
            ICompElement
          );

          ICompElement.prototype.initElement = function (
            data,
            globalData,
            comp
          ) {
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.initTransform(data, globalData, comp);
            this.initRenderable();
            this.initHierarchy();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();

            if (this.data.xt || !globalData.progressiveLoad) {
              this.buildAllItems();
            }

            this.hide();
          };
          /* ICompElement.prototype.hide = function(){
      if(!this.hidden){
          this.hideElement();
          var i,len = this.elements.length;
          for( i = 0; i < len; i+=1 ){
              if(this.elements[i]){
                  this.elements[i].hide();
              }
          }
      }
  }; */

          ICompElement.prototype.prepareFrame = function (num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);

            if (!this.isInRange && !this.data.xt) {
              return;
            }

            if (!this.tm._placeholder) {
              var timeRemapped = this.tm.v;

              if (timeRemapped === this.data.op) {
                timeRemapped = this.data.op - 1;
              }

              this.renderedFrame = timeRemapped;
            } else {
              this.renderedFrame = num / this.data.sr;
            }

            var i;
            var len = this.elements.length;

            if (!this.completeLayers) {
              this.checkLayers(this.renderedFrame);
            } // This iteration needs to be backwards because of how expressions connect between each other

            for (i = len - 1; i >= 0; i -= 1) {
              if (this.completeLayers || this.elements[i]) {
                this.elements[i].prepareFrame(
                  this.renderedFrame - this.layers[i].st
                );

                if (this.elements[i]._mdf) {
                  this._mdf = true;
                }
              }
            }
          };

          ICompElement.prototype.renderInnerContent = function () {
            var i;
            var len = this.layers.length;

            for (i = 0; i < len; i += 1) {
              if (this.completeLayers || this.elements[i]) {
                this.elements[i].renderFrame();
              }
            }
          };

          ICompElement.prototype.setElements = function (elems) {
            this.elements = elems;
          };

          ICompElement.prototype.getElements = function () {
            return this.elements;
          };

          ICompElement.prototype.destroyElements = function () {
            var i;
            var len = this.layers.length;

            for (i = 0; i < len; i += 1) {
              if (this.elements[i]) {
                this.elements[i].destroy();
              }
            }
          };

          ICompElement.prototype.destroy = function () {
            this.destroyElements();
            this.destroyBaseElement();
          };

          function SVGCompElement(data, globalData, comp) {
            this.layers = data.layers;
            this.supports3d = true;
            this.completeLayers = false;
            this.pendingElements = [];
            this.elements = this.layers
              ? createSizedArray(this.layers.length)
              : [];
            this.initElement(data, globalData, comp);
            this.tm = data.tm
              ? PropertyFactory.getProp(
                  this,
                  data.tm,
                  0,
                  globalData.frameRate,
                  this
                )
              : {
                  _placeholder: true,
                };
          }

          extendPrototype(
            [SVGRendererBase, ICompElement, SVGBaseElement],
            SVGCompElement
          );

          SVGCompElement.prototype.createComp = function (data) {
            return new SVGCompElement(data, this.globalData, this);
          };

          function SVGRenderer(animationItem, config) {
            this.animationItem = animationItem;
            this.layers = null;
            this.renderedFrame = -1;
            this.svgElement = createNS("svg");
            var ariaLabel = "";

            if (config && config.title) {
              var titleElement = createNS("title");
              var titleId = createElementID();
              titleElement.setAttribute("id", titleId);
              titleElement.textContent = config.title;
              this.svgElement.appendChild(titleElement);
              ariaLabel += titleId;
            }

            if (config && config.description) {
              var descElement = createNS("desc");
              var descId = createElementID();
              descElement.setAttribute("id", descId);
              descElement.textContent = config.description;
              this.svgElement.appendChild(descElement);
              ariaLabel += " " + descId;
            }

            if (ariaLabel) {
              this.svgElement.setAttribute("aria-labelledby", ariaLabel);
            }

            var defs = createNS("defs");
            this.svgElement.appendChild(defs);
            var maskElement = createNS("g");
            this.svgElement.appendChild(maskElement);
            this.layerElement = maskElement;
            this.renderConfig = {
              preserveAspectRatio:
                (config && config.preserveAspectRatio) || "xMidYMid meet",
              imagePreserveAspectRatio:
                (config && config.imagePreserveAspectRatio) || "xMidYMid slice",
              contentVisibility:
                (config && config.contentVisibility) || "visible",
              progressiveLoad: (config && config.progressiveLoad) || false,
              hideOnTransparent: !(
                config && config.hideOnTransparent === false
              ),
              viewBoxOnly: (config && config.viewBoxOnly) || false,
              viewBoxSize: (config && config.viewBoxSize) || false,
              className: (config && config.className) || "",
              id: (config && config.id) || "",
              focusable: config && config.focusable,
              filterSize: {
                width:
                  (config && config.filterSize && config.filterSize.width) ||
                  "100%",
                height:
                  (config && config.filterSize && config.filterSize.height) ||
                  "100%",
                x: (config && config.filterSize && config.filterSize.x) || "0%",
                y: (config && config.filterSize && config.filterSize.y) || "0%",
              },
              width: config && config.width,
              height: config && config.height,
            };
            this.globalData = {
              _mdf: false,
              frameNum: -1,
              defs: defs,
              renderConfig: this.renderConfig,
            };
            this.elements = [];
            this.pendingElements = [];
            this.destroyed = false;
            this.rendererType = "svg";
          }

          extendPrototype([SVGRendererBase], SVGRenderer);

          SVGRenderer.prototype.createComp = function (data) {
            return new SVGCompElement(data, this.globalData, this);
          };

          function CVContextData() {
            this.saved = [];
            this.cArrPos = 0;
            this.cTr = new Matrix();
            this.cO = 1;
            var i;
            var len = 15;
            this.savedOp = createTypedArray("float32", len);

            for (i = 0; i < len; i += 1) {
              this.saved[i] = createTypedArray("float32", 16);
            }

            this._length = len;
          }

          CVContextData.prototype.duplicate = function () {
            var newLength = this._length * 2;
            var currentSavedOp = this.savedOp;
            this.savedOp = createTypedArray("float32", newLength);
            this.savedOp.set(currentSavedOp);
            var i = 0;

            for (i = this._length; i < newLength; i += 1) {
              this.saved[i] = createTypedArray("float32", 16);
            }

            this._length = newLength;
          };

          CVContextData.prototype.reset = function () {
            this.cArrPos = 0;
            this.cTr.reset();
            this.cO = 1;
          };

          function ShapeTransformManager() {
            this.sequences = {};
            this.sequenceList = [];
            this.transform_key_count = 0;
          }

          ShapeTransformManager.prototype = {
            addTransformSequence: function addTransformSequence(transforms) {
              var i;
              var len = transforms.length;
              var key = "_";

              for (i = 0; i < len; i += 1) {
                key += transforms[i].transform.key + "_";
              }

              var sequence = this.sequences[key];

              if (!sequence) {
                sequence = {
                  transforms: [].concat(transforms),
                  finalTransform: new Matrix(),
                  _mdf: false,
                };
                this.sequences[key] = sequence;
                this.sequenceList.push(sequence);
              }

              return sequence;
            },
            processSequence: function processSequence(sequence, isFirstFrame) {
              var i = 0;
              var len = sequence.transforms.length;
              var _mdf = isFirstFrame;

              while (i < len && !isFirstFrame) {
                if (sequence.transforms[i].transform.mProps._mdf) {
                  _mdf = true;
                  break;
                }

                i += 1;
              }

              if (_mdf) {
                var props;
                sequence.finalTransform.reset();

                for (i = len - 1; i >= 0; i -= 1) {
                  props = sequence.transforms[i].transform.mProps.v.props;
                  sequence.finalTransform.transform(
                    props[0],
                    props[1],
                    props[2],
                    props[3],
                    props[4],
                    props[5],
                    props[6],
                    props[7],
                    props[8],
                    props[9],
                    props[10],
                    props[11],
                    props[12],
                    props[13],
                    props[14],
                    props[15]
                  );
                }
              }

              sequence._mdf = _mdf;
            },
            processSequences: function processSequences(isFirstFrame) {
              var i;
              var len = this.sequenceList.length;

              for (i = 0; i < len; i += 1) {
                this.processSequence(this.sequenceList[i], isFirstFrame);
              }
            },
            getNewKey: function getNewKey() {
              this.transform_key_count += 1;
              return "_" + this.transform_key_count;
            },
          };

          function CVEffects() {}

          CVEffects.prototype.renderFrame = function () {};

          function CVMaskElement(data, element) {
            this.data = data;
            this.element = element;
            this.masksProperties = this.data.masksProperties || [];
            this.viewData = createSizedArray(this.masksProperties.length);
            var i;
            var len = this.masksProperties.length;
            var hasMasks = false;

            for (i = 0; i < len; i += 1) {
              if (this.masksProperties[i].mode !== "n") {
                hasMasks = true;
              }

              this.viewData[i] = ShapePropertyFactory.getShapeProp(
                this.element,
                this.masksProperties[i],
                3
              );
            }

            this.hasMasks = hasMasks;

            if (hasMasks) {
              this.element.addRenderableComponent(this);
            }
          }

          CVMaskElement.prototype.renderFrame = function () {
            if (!this.hasMasks) {
              return;
            }

            var transform = this.element.finalTransform.mat;
            var ctx = this.element.canvasContext;
            var i;
            var len = this.masksProperties.length;
            var pt;
            var pts;
            var data;
            ctx.beginPath();

            for (i = 0; i < len; i += 1) {
              if (this.masksProperties[i].mode !== "n") {
                if (this.masksProperties[i].inv) {
                  ctx.moveTo(0, 0);
                  ctx.lineTo(this.element.globalData.compSize.w, 0);
                  ctx.lineTo(
                    this.element.globalData.compSize.w,
                    this.element.globalData.compSize.h
                  );
                  ctx.lineTo(0, this.element.globalData.compSize.h);
                  ctx.lineTo(0, 0);
                }

                data = this.viewData[i].v;
                pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
                ctx.moveTo(pt[0], pt[1]);
                var j;
                var jLen = data._length;

                for (j = 1; j < jLen; j += 1) {
                  pts = transform.applyToTriplePoints(
                    data.o[j - 1],
                    data.i[j],
                    data.v[j]
                  );
                  ctx.bezierCurveTo(
                    pts[0],
                    pts[1],
                    pts[2],
                    pts[3],
                    pts[4],
                    pts[5]
                  );
                }

                pts = transform.applyToTriplePoints(
                  data.o[j - 1],
                  data.i[0],
                  data.v[0]
                );
                ctx.bezierCurveTo(
                  pts[0],
                  pts[1],
                  pts[2],
                  pts[3],
                  pts[4],
                  pts[5]
                );
              }
            }

            this.element.globalData.renderer.save(true);
            ctx.clip();
          };

          CVMaskElement.prototype.getMaskProperty =
            MaskElement.prototype.getMaskProperty;

          CVMaskElement.prototype.destroy = function () {
            this.element = null;
          };

          function CVBaseElement() {}

          CVBaseElement.prototype = {
            createElements: function createElements() {},
            initRendererElement: function initRendererElement() {},
            createContainerElements: function createContainerElements() {
              this.canvasContext = this.globalData.canvasContext;
              this.renderableEffectsManager = new CVEffects(this);
            },
            createContent: function createContent() {},
            setBlendMode: function setBlendMode() {
              var globalData = this.globalData;

              if (globalData.blendMode !== this.data.bm) {
                globalData.blendMode = this.data.bm;
                var blendModeValue = getBlendMode(this.data.bm);
                globalData.canvasContext.globalCompositeOperation =
                  blendModeValue;
              }
            },
            createRenderableComponents: function createRenderableComponents() {
              this.maskManager = new CVMaskElement(this.data, this);
            },
            hideElement: function hideElement() {
              if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                this.hidden = true;
              }
            },
            showElement: function showElement() {
              if (this.isInRange && !this.isTransparent) {
                this.hidden = false;
                this._isFirstFrame = true;
                this.maskManager._isFirstFrame = true;
              }
            },
            renderFrame: function renderFrame() {
              if (this.hidden || this.data.hd) {
                return;
              }

              this.renderTransform();
              this.renderRenderable();
              this.setBlendMode();
              var forceRealStack = this.data.ty === 0;
              this.globalData.renderer.save(forceRealStack);
              this.globalData.renderer.ctxTransform(
                this.finalTransform.mat.props
              );
              this.globalData.renderer.ctxOpacity(
                this.finalTransform.mProp.o.v
              );
              this.renderInnerContent();
              this.globalData.renderer.restore(forceRealStack);

              if (this.maskManager.hasMasks) {
                this.globalData.renderer.restore(true);
              }

              if (this._isFirstFrame) {
                this._isFirstFrame = false;
              }
            },
            destroy: function destroy() {
              this.canvasContext = null;
              this.data = null;
              this.globalData = null;
              this.maskManager.destroy();
            },
            mHelper: new Matrix(),
          };
          CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
          CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

          function CVShapeData(element, data, styles, transformsManager) {
            this.styledShapes = [];
            this.tr = [0, 0, 0, 0, 0, 0];
            var ty = 4;

            if (data.ty === "rc") {
              ty = 5;
            } else if (data.ty === "el") {
              ty = 6;
            } else if (data.ty === "sr") {
              ty = 7;
            }

            this.sh = ShapePropertyFactory.getShapeProp(
              element,
              data,
              ty,
              element
            );
            var i;
            var len = styles.length;
            var styledShape;

            for (i = 0; i < len; i += 1) {
              if (!styles[i].closed) {
                styledShape = {
                  transforms: transformsManager.addTransformSequence(
                    styles[i].transforms
                  ),
                  trNodes: [],
                };
                this.styledShapes.push(styledShape);
                styles[i].elements.push(styledShape);
              }
            }
          }

          CVShapeData.prototype.setAsAnimated =
            SVGShapeData.prototype.setAsAnimated;

          function CVShapeElement(data, globalData, comp) {
            this.shapes = [];
            this.shapesData = data.shapes;
            this.stylesList = [];
            this.itemsData = [];
            this.prevViewData = [];
            this.shapeModifiers = [];
            this.processedElements = [];
            this.transformsManager = new ShapeTransformManager();
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              IShapeElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
            ],
            CVShapeElement
          );
          CVShapeElement.prototype.initElement =
            RenderableDOMElement.prototype.initElement;
          CVShapeElement.prototype.transformHelper = {
            opacity: 1,
            _opMdf: false,
          };
          CVShapeElement.prototype.dashResetter = [];

          CVShapeElement.prototype.createContent = function () {
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              true,
              []
            );
          };

          CVShapeElement.prototype.createStyleElement = function (
            data,
            transforms
          ) {
            var styleElem = {
              data: data,
              type: data.ty,
              preTransforms:
                this.transformsManager.addTransformSequence(transforms),
              transforms: [],
              elements: [],
              closed: data.hd === true,
            };
            var elementData = {};

            if (data.ty === "fl" || data.ty === "st") {
              elementData.c = PropertyFactory.getProp(
                this,
                data.c,
                1,
                255,
                this
              );

              if (!elementData.c.k) {
                styleElem.co =
                  "rgb(" +
                  bmFloor(elementData.c.v[0]) +
                  "," +
                  bmFloor(elementData.c.v[1]) +
                  "," +
                  bmFloor(elementData.c.v[2]) +
                  ")";
              }
            } else if (data.ty === "gf" || data.ty === "gs") {
              elementData.s = PropertyFactory.getProp(
                this,
                data.s,
                1,
                null,
                this
              );
              elementData.e = PropertyFactory.getProp(
                this,
                data.e,
                1,
                null,
                this
              );
              elementData.h = PropertyFactory.getProp(
                this,
                data.h || {
                  k: 0,
                },
                0,
                0.01,
                this
              );
              elementData.a = PropertyFactory.getProp(
                this,
                data.a || {
                  k: 0,
                },
                0,
                degToRads,
                this
              );
              elementData.g = new GradientProperty(this, data.g, this);
            }

            elementData.o = PropertyFactory.getProp(
              this,
              data.o,
              0,
              0.01,
              this
            );

            if (data.ty === "st" || data.ty === "gs") {
              styleElem.lc = lineCapEnum[data.lc || 2];
              styleElem.lj = lineJoinEnum[data.lj || 2];

              if (data.lj == 1) {
                // eslint-disable-line eqeqeq
                styleElem.ml = data.ml;
              }

              elementData.w = PropertyFactory.getProp(
                this,
                data.w,
                0,
                null,
                this
              );

              if (!elementData.w.k) {
                styleElem.wi = elementData.w.v;
              }

              if (data.d) {
                var d = new DashProperty(this, data.d, "canvas", this);
                elementData.d = d;

                if (!elementData.d.k) {
                  styleElem.da = elementData.d.dashArray;
                  styleElem["do"] = elementData.d.dashoffset[0];
                }
              }
            } else {
              styleElem.r = data.r === 2 ? "evenodd" : "nonzero";
            }

            this.stylesList.push(styleElem);
            elementData.style = styleElem;
            return elementData;
          };

          CVShapeElement.prototype.createGroupElement = function () {
            var elementData = {
              it: [],
              prevViewData: [],
            };
            return elementData;
          };

          CVShapeElement.prototype.createTransformElement = function (data) {
            var elementData = {
              transform: {
                opacity: 1,
                _opMdf: false,
                key: this.transformsManager.getNewKey(),
                op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
                mProps: TransformPropertyFactory.getTransformProperty(
                  this,
                  data,
                  this
                ),
              },
            };
            return elementData;
          };

          CVShapeElement.prototype.createShapeElement = function (data) {
            var elementData = new CVShapeData(
              this,
              data,
              this.stylesList,
              this.transformsManager
            );
            this.shapes.push(elementData);
            this.addShapeToModifiers(elementData);
            return elementData;
          };

          CVShapeElement.prototype.reloadShapes = function () {
            this._isFirstFrame = true;
            var i;
            var len = this.itemsData.length;

            for (i = 0; i < len; i += 1) {
              this.prevViewData[i] = this.itemsData[i];
            }

            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              true,
              []
            );
            len = this.dynamicProperties.length;

            for (i = 0; i < len; i += 1) {
              this.dynamicProperties[i].getValue();
            }

            this.renderModifiers();
            this.transformsManager.processSequences(this._isFirstFrame);
          };

          CVShapeElement.prototype.addTransformToStyleList = function (
            transform
          ) {
            var i;
            var len = this.stylesList.length;

            for (i = 0; i < len; i += 1) {
              if (!this.stylesList[i].closed) {
                this.stylesList[i].transforms.push(transform);
              }
            }
          };

          CVShapeElement.prototype.removeTransformFromStyleList = function () {
            var i;
            var len = this.stylesList.length;

            for (i = 0; i < len; i += 1) {
              if (!this.stylesList[i].closed) {
                this.stylesList[i].transforms.pop();
              }
            }
          };

          CVShapeElement.prototype.closeStyles = function (styles) {
            var i;
            var len = styles.length;

            for (i = 0; i < len; i += 1) {
              styles[i].closed = true;
            }
          };

          CVShapeElement.prototype.searchShapes = function (
            arr,
            itemsData,
            prevViewData,
            shouldRender,
            transforms
          ) {
            var i;
            var len = arr.length - 1;
            var j;
            var jLen;
            var ownStyles = [];
            var ownModifiers = [];
            var processedPos;
            var modifier;
            var currentTransform;
            var ownTransforms = [].concat(transforms);

            for (i = len; i >= 0; i -= 1) {
              processedPos = this.searchProcessedElement(arr[i]);

              if (!processedPos) {
                arr[i]._shouldRender = shouldRender;
              } else {
                itemsData[i] = prevViewData[processedPos - 1];
              }

              if (
                arr[i].ty === "fl" ||
                arr[i].ty === "st" ||
                arr[i].ty === "gf" ||
                arr[i].ty === "gs"
              ) {
                if (!processedPos) {
                  itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
                } else {
                  itemsData[i].style.closed = false;
                }

                ownStyles.push(itemsData[i].style);
              } else if (arr[i].ty === "gr") {
                if (!processedPos) {
                  itemsData[i] = this.createGroupElement(arr[i]);
                } else {
                  jLen = itemsData[i].it.length;

                  for (j = 0; j < jLen; j += 1) {
                    itemsData[i].prevViewData[j] = itemsData[i].it[j];
                  }
                }

                this.searchShapes(
                  arr[i].it,
                  itemsData[i].it,
                  itemsData[i].prevViewData,
                  shouldRender,
                  ownTransforms
                );
              } else if (arr[i].ty === "tr") {
                if (!processedPos) {
                  currentTransform = this.createTransformElement(arr[i]);
                  itemsData[i] = currentTransform;
                }

                ownTransforms.push(itemsData[i]);
                this.addTransformToStyleList(itemsData[i]);
              } else if (
                arr[i].ty === "sh" ||
                arr[i].ty === "rc" ||
                arr[i].ty === "el" ||
                arr[i].ty === "sr"
              ) {
                if (!processedPos) {
                  itemsData[i] = this.createShapeElement(arr[i]);
                }
              } else if (
                arr[i].ty === "tm" ||
                arr[i].ty === "rd" ||
                arr[i].ty === "pb"
              ) {
                if (!processedPos) {
                  modifier = ShapeModifiers.getModifier(arr[i].ty);
                  modifier.init(this, arr[i]);
                  itemsData[i] = modifier;
                  this.shapeModifiers.push(modifier);
                } else {
                  modifier = itemsData[i];
                  modifier.closed = false;
                }

                ownModifiers.push(modifier);
              } else if (arr[i].ty === "rp") {
                if (!processedPos) {
                  modifier = ShapeModifiers.getModifier(arr[i].ty);
                  itemsData[i] = modifier;
                  modifier.init(this, arr, i, itemsData);
                  this.shapeModifiers.push(modifier);
                  shouldRender = false;
                } else {
                  modifier = itemsData[i];
                  modifier.closed = true;
                }

                ownModifiers.push(modifier);
              }

              this.addProcessedElement(arr[i], i + 1);
            }

            this.removeTransformFromStyleList();
            this.closeStyles(ownStyles);
            len = ownModifiers.length;

            for (i = 0; i < len; i += 1) {
              ownModifiers[i].closed = true;
            }
          };

          CVShapeElement.prototype.renderInnerContent = function () {
            this.transformHelper.opacity = 1;
            this.transformHelper._opMdf = false;
            this.renderModifiers();
            this.transformsManager.processSequences(this._isFirstFrame);
            this.renderShape(
              this.transformHelper,
              this.shapesData,
              this.itemsData,
              true
            );
          };

          CVShapeElement.prototype.renderShapeTransform = function (
            parentTransform,
            groupTransform
          ) {
            if (
              parentTransform._opMdf ||
              groupTransform.op._mdf ||
              this._isFirstFrame
            ) {
              groupTransform.opacity = parentTransform.opacity;
              groupTransform.opacity *= groupTransform.op.v;
              groupTransform._opMdf = true;
            }
          };

          CVShapeElement.prototype.drawLayer = function () {
            var i;
            var len = this.stylesList.length;
            var j;
            var jLen;
            var k;
            var kLen;
            var elems;
            var nodes;
            var renderer = this.globalData.renderer;
            var ctx = this.globalData.canvasContext;
            var type;
            var currentStyle;

            for (i = 0; i < len; i += 1) {
              currentStyle = this.stylesList[i];
              type = currentStyle.type; // Skipping style when
              // Stroke width equals 0
              // style should not be rendered (extra unused repeaters)
              // current opacity equals 0
              // global opacity equals 0

              if (
                !(
                  ((type === "st" || type === "gs") && currentStyle.wi === 0) ||
                  !currentStyle.data._shouldRender ||
                  currentStyle.coOp === 0 ||
                  this.globalData.currentGlobalAlpha === 0
                )
              ) {
                renderer.save();
                elems = currentStyle.elements;

                if (type === "st" || type === "gs") {
                  ctx.strokeStyle =
                    type === "st" ? currentStyle.co : currentStyle.grd;
                  ctx.lineWidth = currentStyle.wi;
                  ctx.lineCap = currentStyle.lc;
                  ctx.lineJoin = currentStyle.lj;
                  ctx.miterLimit = currentStyle.ml || 0;
                } else {
                  ctx.fillStyle =
                    type === "fl" ? currentStyle.co : currentStyle.grd;
                }

                renderer.ctxOpacity(currentStyle.coOp);

                if (type !== "st" && type !== "gs") {
                  ctx.beginPath();
                }

                renderer.ctxTransform(
                  currentStyle.preTransforms.finalTransform.props
                );
                jLen = elems.length;

                for (j = 0; j < jLen; j += 1) {
                  if (type === "st" || type === "gs") {
                    ctx.beginPath();

                    if (currentStyle.da) {
                      ctx.setLineDash(currentStyle.da);
                      ctx.lineDashOffset = currentStyle["do"];
                    }
                  }

                  nodes = elems[j].trNodes;
                  kLen = nodes.length;

                  for (k = 0; k < kLen; k += 1) {
                    if (nodes[k].t === "m") {
                      ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
                    } else if (nodes[k].t === "c") {
                      ctx.bezierCurveTo(
                        nodes[k].pts[0],
                        nodes[k].pts[1],
                        nodes[k].pts[2],
                        nodes[k].pts[3],
                        nodes[k].pts[4],
                        nodes[k].pts[5]
                      );
                    } else {
                      ctx.closePath();
                    }
                  }

                  if (type === "st" || type === "gs") {
                    ctx.stroke();

                    if (currentStyle.da) {
                      ctx.setLineDash(this.dashResetter);
                    }
                  }
                }

                if (type !== "st" && type !== "gs") {
                  ctx.fill(currentStyle.r);
                }

                renderer.restore();
              }
            }
          };

          CVShapeElement.prototype.renderShape = function (
            parentTransform,
            items,
            data,
            isMain
          ) {
            var i;
            var len = items.length - 1;
            var groupTransform;
            groupTransform = parentTransform;

            for (i = len; i >= 0; i -= 1) {
              if (items[i].ty === "tr") {
                groupTransform = data[i].transform;
                this.renderShapeTransform(parentTransform, groupTransform);
              } else if (
                items[i].ty === "sh" ||
                items[i].ty === "el" ||
                items[i].ty === "rc" ||
                items[i].ty === "sr"
              ) {
                this.renderPath(items[i], data[i]);
              } else if (items[i].ty === "fl") {
                this.renderFill(items[i], data[i], groupTransform);
              } else if (items[i].ty === "st") {
                this.renderStroke(items[i], data[i], groupTransform);
              } else if (items[i].ty === "gf" || items[i].ty === "gs") {
                this.renderGradientFill(items[i], data[i], groupTransform);
              } else if (items[i].ty === "gr") {
                this.renderShape(groupTransform, items[i].it, data[i].it);
              } else if (items[i].ty === "tm") {
                //
              }
            }

            if (isMain) {
              this.drawLayer();
            }
          };

          CVShapeElement.prototype.renderStyledShape = function (
            styledShape,
            shape
          ) {
            if (
              this._isFirstFrame ||
              shape._mdf ||
              styledShape.transforms._mdf
            ) {
              var shapeNodes = styledShape.trNodes;
              var paths = shape.paths;
              var i;
              var len;
              var j;
              var jLen = paths._length;
              shapeNodes.length = 0;
              var groupTransformMat = styledShape.transforms.finalTransform;

              for (j = 0; j < jLen; j += 1) {
                var pathNodes = paths.shapes[j];

                if (pathNodes && pathNodes.v) {
                  len = pathNodes._length;

                  for (i = 1; i < len; i += 1) {
                    if (i === 1) {
                      shapeNodes.push({
                        t: "m",
                        p: groupTransformMat.applyToPointArray(
                          pathNodes.v[0][0],
                          pathNodes.v[0][1],
                          0
                        ),
                      });
                    }

                    shapeNodes.push({
                      t: "c",
                      pts: groupTransformMat.applyToTriplePoints(
                        pathNodes.o[i - 1],
                        pathNodes.i[i],
                        pathNodes.v[i]
                      ),
                    });
                  }

                  if (len === 1) {
                    shapeNodes.push({
                      t: "m",
                      p: groupTransformMat.applyToPointArray(
                        pathNodes.v[0][0],
                        pathNodes.v[0][1],
                        0
                      ),
                    });
                  }

                  if (pathNodes.c && len) {
                    shapeNodes.push({
                      t: "c",
                      pts: groupTransformMat.applyToTriplePoints(
                        pathNodes.o[i - 1],
                        pathNodes.i[0],
                        pathNodes.v[0]
                      ),
                    });
                    shapeNodes.push({
                      t: "z",
                    });
                  }
                }
              }

              styledShape.trNodes = shapeNodes;
            }
          };

          CVShapeElement.prototype.renderPath = function (pathData, itemData) {
            if (pathData.hd !== true && pathData._shouldRender) {
              var i;
              var len = itemData.styledShapes.length;

              for (i = 0; i < len; i += 1) {
                this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
              }
            }
          };

          CVShapeElement.prototype.renderFill = function (
            styleData,
            itemData,
            groupTransform
          ) {
            var styleElem = itemData.style;

            if (itemData.c._mdf || this._isFirstFrame) {
              styleElem.co =
                "rgb(" +
                bmFloor(itemData.c.v[0]) +
                "," +
                bmFloor(itemData.c.v[1]) +
                "," +
                bmFloor(itemData.c.v[2]) +
                ")";
            }

            if (
              itemData.o._mdf ||
              groupTransform._opMdf ||
              this._isFirstFrame
            ) {
              styleElem.coOp = itemData.o.v * groupTransform.opacity;
            }
          };

          CVShapeElement.prototype.renderGradientFill = function (
            styleData,
            itemData,
            groupTransform
          ) {
            var styleElem = itemData.style;
            var grd;

            if (
              !styleElem.grd ||
              itemData.g._mdf ||
              itemData.s._mdf ||
              itemData.e._mdf ||
              (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))
            ) {
              var ctx = this.globalData.canvasContext;
              var pt1 = itemData.s.v;
              var pt2 = itemData.e.v;

              if (styleData.t === 1) {
                grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
              } else {
                var rad = Math.sqrt(
                  Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2)
                );
                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                var percent = itemData.h.v;

                if (percent >= 1) {
                  percent = 0.99;
                } else if (percent <= -1) {
                  percent = -0.99;
                }

                var dist = rad * percent;
                var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
              }

              var i;
              var len = styleData.g.p;
              var cValues = itemData.g.c;
              var opacity = 1;

              for (i = 0; i < len; i += 1) {
                if (itemData.g._hasOpacity && itemData.g._collapsable) {
                  opacity = itemData.g.o[i * 2 + 1];
                }

                grd.addColorStop(
                  cValues[i * 4] / 100,
                  "rgba(" +
                    cValues[i * 4 + 1] +
                    "," +
                    cValues[i * 4 + 2] +
                    "," +
                    cValues[i * 4 + 3] +
                    "," +
                    opacity +
                    ")"
                );
              }

              styleElem.grd = grd;
            }

            styleElem.coOp = itemData.o.v * groupTransform.opacity;
          };

          CVShapeElement.prototype.renderStroke = function (
            styleData,
            itemData,
            groupTransform
          ) {
            var styleElem = itemData.style;
            var d = itemData.d;

            if (d && (d._mdf || this._isFirstFrame)) {
              styleElem.da = d.dashArray;
              styleElem["do"] = d.dashoffset[0];
            }

            if (itemData.c._mdf || this._isFirstFrame) {
              styleElem.co =
                "rgb(" +
                bmFloor(itemData.c.v[0]) +
                "," +
                bmFloor(itemData.c.v[1]) +
                "," +
                bmFloor(itemData.c.v[2]) +
                ")";
            }

            if (
              itemData.o._mdf ||
              groupTransform._opMdf ||
              this._isFirstFrame
            ) {
              styleElem.coOp = itemData.o.v * groupTransform.opacity;
            }

            if (itemData.w._mdf || this._isFirstFrame) {
              styleElem.wi = itemData.w.v;
            }
          };

          CVShapeElement.prototype.destroy = function () {
            this.shapesData = null;
            this.globalData = null;
            this.canvasContext = null;
            this.stylesList.length = 0;
            this.itemsData.length = 0;
          };

          function CVTextElement(data, globalData, comp) {
            this.textSpans = [];
            this.yOffset = 0;
            this.fillColorAnim = false;
            this.strokeColorAnim = false;
            this.strokeWidthAnim = false;
            this.stroke = false;
            this.fill = false;
            this.justifyOffset = 0;
            this.currentRender = null;
            this.renderType = "canvas";
            this.values = {
              fill: "rgba(0,0,0,0)",
              stroke: "rgba(0,0,0,0)",
              sWidth: 0,
              fValue: "",
            };
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
              ITextElement,
            ],
            CVTextElement
          );
          CVTextElement.prototype.tHelper =
            createTag("canvas").getContext("2d");

          CVTextElement.prototype.buildNewText = function () {
            var documentData = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(
              documentData.l ? documentData.l.length : 0
            );
            var hasFill = false;

            if (documentData.fc) {
              hasFill = true;
              this.values.fill = this.buildColor(documentData.fc);
            } else {
              this.values.fill = "rgba(0,0,0,0)";
            }

            this.fill = hasFill;
            var hasStroke = false;

            if (documentData.sc) {
              hasStroke = true;
              this.values.stroke = this.buildColor(documentData.sc);
              this.values.sWidth = documentData.sw;
            }

            var fontData = this.globalData.fontManager.getFontByName(
              documentData.f
            );
            var i;
            var len;
            var letters = documentData.l;
            var matrixHelper = this.mHelper;
            this.stroke = hasStroke;
            this.values.fValue =
              documentData.finalSize +
              "px " +
              this.globalData.fontManager.getFontByName(documentData.f).fFamily;
            len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;

            var charData;
            var shapeData;
            var k;
            var kLen;
            var shapes;
            var j;
            var jLen;
            var pathNodes;
            var commands;
            var pathArr;
            var singleShape = this.data.singleShape;
            var trackingOffset =
              documentData.tr * 0.001 * documentData.finalSize;
            var xPos = 0;
            var yPos = 0;
            var firstLine = true;
            var cnt = 0;

            for (i = 0; i < len; i += 1) {
              charData = this.globalData.fontManager.getCharData(
                documentData.finalText[i],
                fontData.fStyle,
                this.globalData.fontManager.getFontByName(documentData.f)
                  .fFamily
              );
              shapeData = (charData && charData.data) || {};
              matrixHelper.reset();

              if (singleShape && letters[i].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
              }

              shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
              jLen = shapes.length;
              matrixHelper.scale(
                documentData.finalSize / 100,
                documentData.finalSize / 100
              );

              if (singleShape) {
                this.applyTextPropertiesToMatrix(
                  documentData,
                  matrixHelper,
                  letters[i].line,
                  xPos,
                  yPos
                );
              }

              commands = createSizedArray(jLen - 1);
              var commandsCounter = 0;

              for (j = 0; j < jLen; j += 1) {
                if (shapes[j].ty === "sh") {
                  kLen = shapes[j].ks.k.i.length;
                  pathNodes = shapes[j].ks.k;
                  pathArr = [];

                  for (k = 1; k < kLen; k += 1) {
                    if (k === 1) {
                      pathArr.push(
                        matrixHelper.applyToX(
                          pathNodes.v[0][0],
                          pathNodes.v[0][1],
                          0
                        ),
                        matrixHelper.applyToY(
                          pathNodes.v[0][0],
                          pathNodes.v[0][1],
                          0
                        )
                      );
                    }

                    pathArr.push(
                      matrixHelper.applyToX(
                        pathNodes.o[k - 1][0],
                        pathNodes.o[k - 1][1],
                        0
                      ),
                      matrixHelper.applyToY(
                        pathNodes.o[k - 1][0],
                        pathNodes.o[k - 1][1],
                        0
                      ),
                      matrixHelper.applyToX(
                        pathNodes.i[k][0],
                        pathNodes.i[k][1],
                        0
                      ),
                      matrixHelper.applyToY(
                        pathNodes.i[k][0],
                        pathNodes.i[k][1],
                        0
                      ),
                      matrixHelper.applyToX(
                        pathNodes.v[k][0],
                        pathNodes.v[k][1],
                        0
                      ),
                      matrixHelper.applyToY(
                        pathNodes.v[k][0],
                        pathNodes.v[k][1],
                        0
                      )
                    );
                  }

                  pathArr.push(
                    matrixHelper.applyToX(
                      pathNodes.o[k - 1][0],
                      pathNodes.o[k - 1][1],
                      0
                    ),
                    matrixHelper.applyToY(
                      pathNodes.o[k - 1][0],
                      pathNodes.o[k - 1][1],
                      0
                    ),
                    matrixHelper.applyToX(
                      pathNodes.i[0][0],
                      pathNodes.i[0][1],
                      0
                    ),
                    matrixHelper.applyToY(
                      pathNodes.i[0][0],
                      pathNodes.i[0][1],
                      0
                    ),
                    matrixHelper.applyToX(
                      pathNodes.v[0][0],
                      pathNodes.v[0][1],
                      0
                    ),
                    matrixHelper.applyToY(
                      pathNodes.v[0][0],
                      pathNodes.v[0][1],
                      0
                    )
                  );
                  commands[commandsCounter] = pathArr;
                  commandsCounter += 1;
                }
              }

              if (singleShape) {
                xPos += letters[i].l;
                xPos += trackingOffset;
              }

              if (this.textSpans[cnt]) {
                this.textSpans[cnt].elem = commands;
              } else {
                this.textSpans[cnt] = {
                  elem: commands,
                };
              }

              cnt += 1;
            }
          };

          CVTextElement.prototype.renderInnerContent = function () {
            var ctx = this.canvasContext;
            ctx.font = this.values.fValue;
            ctx.lineCap = "butt";
            ctx.lineJoin = "miter";
            ctx.miterLimit = 4;

            if (!this.data.singleShape) {
              this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              );
            }

            var i;
            var len;
            var j;
            var jLen;
            var k;
            var kLen;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var lastFill = null;
            var lastStroke = null;
            var lastStrokeW = null;
            var commands;
            var pathArr;

            for (i = 0; i < len; i += 1) {
              if (!letters[i].n) {
                renderedLetter = renderedLetters[i];

                if (renderedLetter) {
                  this.globalData.renderer.save();
                  this.globalData.renderer.ctxTransform(renderedLetter.p);
                  this.globalData.renderer.ctxOpacity(renderedLetter.o);
                }

                if (this.fill) {
                  if (renderedLetter && renderedLetter.fc) {
                    if (lastFill !== renderedLetter.fc) {
                      lastFill = renderedLetter.fc;
                      ctx.fillStyle = renderedLetter.fc;
                    }
                  } else if (lastFill !== this.values.fill) {
                    lastFill = this.values.fill;
                    ctx.fillStyle = this.values.fill;
                  }

                  commands = this.textSpans[i].elem;
                  jLen = commands.length;
                  this.globalData.canvasContext.beginPath();

                  for (j = 0; j < jLen; j += 1) {
                    pathArr = commands[j];
                    kLen = pathArr.length;
                    this.globalData.canvasContext.moveTo(
                      pathArr[0],
                      pathArr[1]
                    );

                    for (k = 2; k < kLen; k += 6) {
                      this.globalData.canvasContext.bezierCurveTo(
                        pathArr[k],
                        pathArr[k + 1],
                        pathArr[k + 2],
                        pathArr[k + 3],
                        pathArr[k + 4],
                        pathArr[k + 5]
                      );
                    }
                  }

                  this.globalData.canvasContext.closePath();
                  this.globalData.canvasContext.fill(); /// ctx.fillText(this.textSpans[i].val,0,0);
                }

                if (this.stroke) {
                  if (renderedLetter && renderedLetter.sw) {
                    if (lastStrokeW !== renderedLetter.sw) {
                      lastStrokeW = renderedLetter.sw;
                      ctx.lineWidth = renderedLetter.sw;
                    }
                  } else if (lastStrokeW !== this.values.sWidth) {
                    lastStrokeW = this.values.sWidth;
                    ctx.lineWidth = this.values.sWidth;
                  }

                  if (renderedLetter && renderedLetter.sc) {
                    if (lastStroke !== renderedLetter.sc) {
                      lastStroke = renderedLetter.sc;
                      ctx.strokeStyle = renderedLetter.sc;
                    }
                  } else if (lastStroke !== this.values.stroke) {
                    lastStroke = this.values.stroke;
                    ctx.strokeStyle = this.values.stroke;
                  }

                  commands = this.textSpans[i].elem;
                  jLen = commands.length;
                  this.globalData.canvasContext.beginPath();

                  for (j = 0; j < jLen; j += 1) {
                    pathArr = commands[j];
                    kLen = pathArr.length;
                    this.globalData.canvasContext.moveTo(
                      pathArr[0],
                      pathArr[1]
                    );

                    for (k = 2; k < kLen; k += 6) {
                      this.globalData.canvasContext.bezierCurveTo(
                        pathArr[k],
                        pathArr[k + 1],
                        pathArr[k + 2],
                        pathArr[k + 3],
                        pathArr[k + 4],
                        pathArr[k + 5]
                      );
                    }
                  }

                  this.globalData.canvasContext.closePath();
                  this.globalData.canvasContext.stroke(); /// ctx.strokeText(letters[i].val,0,0);
                }

                if (renderedLetter) {
                  this.globalData.renderer.restore();
                }
              }
            }
          };

          function CVImageElement(data, globalData, comp) {
            this.assetData = globalData.getAssetData(data.refId);
            this.img = globalData.imageLoader.getAsset(this.assetData);
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
            ],
            CVImageElement
          );
          CVImageElement.prototype.initElement =
            SVGShapeElement.prototype.initElement;
          CVImageElement.prototype.prepareFrame =
            IImageElement.prototype.prepareFrame;

          CVImageElement.prototype.createContent = function () {
            if (
              this.img.width &&
              (this.assetData.w !== this.img.width ||
                this.assetData.h !== this.img.height)
            ) {
              var canvas = createTag("canvas");
              canvas.width = this.assetData.w;
              canvas.height = this.assetData.h;
              var ctx = canvas.getContext("2d");
              var imgW = this.img.width;
              var imgH = this.img.height;
              var imgRel = imgW / imgH;
              var canvasRel = this.assetData.w / this.assetData.h;
              var widthCrop;
              var heightCrop;
              var par =
                this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio;

              if (
                (imgRel > canvasRel && par === "xMidYMid slice") ||
                (imgRel < canvasRel && par !== "xMidYMid slice")
              ) {
                heightCrop = imgH;
                widthCrop = heightCrop * canvasRel;
              } else {
                widthCrop = imgW;
                heightCrop = widthCrop / canvasRel;
              }

              ctx.drawImage(
                this.img,
                (imgW - widthCrop) / 2,
                (imgH - heightCrop) / 2,
                widthCrop,
                heightCrop,
                0,
                0,
                this.assetData.w,
                this.assetData.h
              );
              this.img = canvas;
            }
          };

          CVImageElement.prototype.renderInnerContent = function () {
            this.canvasContext.drawImage(this.img, 0, 0);
          };

          CVImageElement.prototype.destroy = function () {
            this.img = null;
          };

          function CVSolidElement(data, globalData, comp) {
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
            ],
            CVSolidElement
          );
          CVSolidElement.prototype.initElement =
            SVGShapeElement.prototype.initElement;
          CVSolidElement.prototype.prepareFrame =
            IImageElement.prototype.prepareFrame;

          CVSolidElement.prototype.renderInnerContent = function () {
            var ctx = this.canvasContext;
            ctx.fillStyle = this.data.sc;
            ctx.fillRect(0, 0, this.data.sw, this.data.sh); //
          };

          function CanvasRendererBase(animationItem, config) {
            this.animationItem = animationItem;
            this.renderConfig = {
              clearCanvas:
                config && config.clearCanvas !== undefined
                  ? config.clearCanvas
                  : true,
              context: (config && config.context) || null,
              progressiveLoad: (config && config.progressiveLoad) || false,
              preserveAspectRatio:
                (config && config.preserveAspectRatio) || "xMidYMid meet",
              imagePreserveAspectRatio:
                (config && config.imagePreserveAspectRatio) || "xMidYMid slice",
              contentVisibility:
                (config && config.contentVisibility) || "visible",
              className: (config && config.className) || "",
              id: (config && config.id) || "",
            };
            this.renderConfig.dpr = (config && config.dpr) || 1;

            if (this.animationItem.wrapper) {
              this.renderConfig.dpr =
                (config && config.dpr) || window.devicePixelRatio || 1;
            }

            this.renderedFrame = -1;
            this.globalData = {
              frameNum: -1,
              _mdf: false,
              renderConfig: this.renderConfig,
              currentGlobalAlpha: -1,
            };
            this.contextData = new CVContextData();
            this.elements = [];
            this.pendingElements = [];
            this.transformMat = new Matrix();
            this.completeLayers = false;
            this.rendererType = "canvas";
          }

          extendPrototype([BaseRenderer], CanvasRendererBase);

          CanvasRendererBase.prototype.createShape = function (data) {
            return new CVShapeElement(data, this.globalData, this);
          };

          CanvasRendererBase.prototype.createText = function (data) {
            return new CVTextElement(data, this.globalData, this);
          };

          CanvasRendererBase.prototype.createImage = function (data) {
            return new CVImageElement(data, this.globalData, this);
          };

          CanvasRendererBase.prototype.createSolid = function (data) {
            return new CVSolidElement(data, this.globalData, this);
          };

          CanvasRendererBase.prototype.createNull =
            SVGRenderer.prototype.createNull;

          CanvasRendererBase.prototype.ctxTransform = function (props) {
            if (
              props[0] === 1 &&
              props[1] === 0 &&
              props[4] === 0 &&
              props[5] === 1 &&
              props[12] === 0 &&
              props[13] === 0
            ) {
              return;
            }

            if (!this.renderConfig.clearCanvas) {
              this.canvasContext.transform(
                props[0],
                props[1],
                props[4],
                props[5],
                props[12],
                props[13]
              );
              return;
            }

            this.transformMat.cloneFromProps(props);
            var cProps = this.contextData.cTr.props;
            this.transformMat.transform(
              cProps[0],
              cProps[1],
              cProps[2],
              cProps[3],
              cProps[4],
              cProps[5],
              cProps[6],
              cProps[7],
              cProps[8],
              cProps[9],
              cProps[10],
              cProps[11],
              cProps[12],
              cProps[13],
              cProps[14],
              cProps[15]
            ); // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);

            this.contextData.cTr.cloneFromProps(this.transformMat.props);
            var trProps = this.contextData.cTr.props;
            this.canvasContext.setTransform(
              trProps[0],
              trProps[1],
              trProps[4],
              trProps[5],
              trProps[12],
              trProps[13]
            );
          };

          CanvasRendererBase.prototype.ctxOpacity = function (op) {
            /* if(op === 1){
          return;
      } */
            if (!this.renderConfig.clearCanvas) {
              this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
              this.globalData.currentGlobalAlpha = this.contextData.cO;
              return;
            }

            this.contextData.cO *= op < 0 ? 0 : op;

            if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
              this.canvasContext.globalAlpha = this.contextData.cO;
              this.globalData.currentGlobalAlpha = this.contextData.cO;
            }
          };

          CanvasRendererBase.prototype.reset = function () {
            if (!this.renderConfig.clearCanvas) {
              this.canvasContext.restore();
              return;
            }

            this.contextData.reset();
          };

          CanvasRendererBase.prototype.save = function (actionFlag) {
            if (!this.renderConfig.clearCanvas) {
              this.canvasContext.save();
              return;
            }

            if (actionFlag) {
              this.canvasContext.save();
            }

            var props = this.contextData.cTr.props;

            if (this.contextData._length <= this.contextData.cArrPos) {
              this.contextData.duplicate();
            }

            var i;
            var arr = this.contextData.saved[this.contextData.cArrPos];

            for (i = 0; i < 16; i += 1) {
              arr[i] = props[i];
            }

            this.contextData.savedOp[this.contextData.cArrPos] =
              this.contextData.cO;
            this.contextData.cArrPos += 1;
          };

          CanvasRendererBase.prototype.restore = function (actionFlag) {
            if (!this.renderConfig.clearCanvas) {
              this.canvasContext.restore();
              return;
            }

            if (actionFlag) {
              this.canvasContext.restore();
              this.globalData.blendMode = "source-over";
            }

            this.contextData.cArrPos -= 1;
            var popped = this.contextData.saved[this.contextData.cArrPos];
            var i;
            var arr = this.contextData.cTr.props;

            for (i = 0; i < 16; i += 1) {
              arr[i] = popped[i];
            }

            this.canvasContext.setTransform(
              popped[0],
              popped[1],
              popped[4],
              popped[5],
              popped[12],
              popped[13]
            );
            popped = this.contextData.savedOp[this.contextData.cArrPos];
            this.contextData.cO = popped;

            if (this.globalData.currentGlobalAlpha !== popped) {
              this.canvasContext.globalAlpha = popped;
              this.globalData.currentGlobalAlpha = popped;
            }
          };

          CanvasRendererBase.prototype.configAnimation = function (animData) {
            if (this.animationItem.wrapper) {
              this.animationItem.container = createTag("canvas");
              var containerStyle = this.animationItem.container.style;
              containerStyle.width = "100%";
              containerStyle.height = "100%";
              var origin = "0px 0px 0px";
              containerStyle.transformOrigin = origin;
              containerStyle.mozTransformOrigin = origin;
              containerStyle.webkitTransformOrigin = origin;
              containerStyle["-webkit-transform"] = origin;
              containerStyle.contentVisibility =
                this.renderConfig.contentVisibility;
              this.animationItem.wrapper.appendChild(
                this.animationItem.container
              );
              this.canvasContext =
                this.animationItem.container.getContext("2d");

              if (this.renderConfig.className) {
                this.animationItem.container.setAttribute(
                  "class",
                  this.renderConfig.className
                );
              }

              if (this.renderConfig.id) {
                this.animationItem.container.setAttribute(
                  "id",
                  this.renderConfig.id
                );
              }
            } else {
              this.canvasContext = this.renderConfig.context;
            }

            this.data = animData;
            this.layers = animData.layers;
            this.transformCanvas = {
              w: animData.w,
              h: animData.h,
              sx: 0,
              sy: 0,
              tx: 0,
              ty: 0,
            };
            this.setupGlobalData(animData, document.body);
            this.globalData.canvasContext = this.canvasContext;
            this.globalData.renderer = this;
            this.globalData.isDashed = false;
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
            this.globalData.transformCanvas = this.transformCanvas;
            this.elements = createSizedArray(animData.layers.length);
            this.updateContainerSize();
          };

          CanvasRendererBase.prototype.updateContainerSize = function () {
            this.reset();
            var elementWidth;
            var elementHeight;

            if (this.animationItem.wrapper && this.animationItem.container) {
              elementWidth = this.animationItem.wrapper.offsetWidth;
              elementHeight = this.animationItem.wrapper.offsetHeight;
              this.animationItem.container.setAttribute(
                "width",
                elementWidth * this.renderConfig.dpr
              );
              this.animationItem.container.setAttribute(
                "height",
                elementHeight * this.renderConfig.dpr
              );
            } else {
              elementWidth =
                this.canvasContext.canvas.width * this.renderConfig.dpr;
              elementHeight =
                this.canvasContext.canvas.height * this.renderConfig.dpr;
            }

            var elementRel;
            var animationRel;

            if (
              this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 ||
              this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1
            ) {
              var par = this.renderConfig.preserveAspectRatio.split(" ");
              var fillType = par[1] || "meet";
              var pos = par[0] || "xMidYMid";
              var xPos = pos.substr(0, 4);
              var yPos = pos.substr(4);
              elementRel = elementWidth / elementHeight;
              animationRel = this.transformCanvas.w / this.transformCanvas.h;

              if (
                (animationRel > elementRel && fillType === "meet") ||
                (animationRel < elementRel && fillType === "slice")
              ) {
                this.transformCanvas.sx =
                  elementWidth /
                  (this.transformCanvas.w / this.renderConfig.dpr);
                this.transformCanvas.sy =
                  elementWidth /
                  (this.transformCanvas.w / this.renderConfig.dpr);
              } else {
                this.transformCanvas.sx =
                  elementHeight /
                  (this.transformCanvas.h / this.renderConfig.dpr);
                this.transformCanvas.sy =
                  elementHeight /
                  (this.transformCanvas.h / this.renderConfig.dpr);
              }

              if (
                xPos === "xMid" &&
                ((animationRel < elementRel && fillType === "meet") ||
                  (animationRel > elementRel && fillType === "slice"))
              ) {
                this.transformCanvas.tx =
                  ((elementWidth -
                    this.transformCanvas.w *
                      (elementHeight / this.transformCanvas.h)) /
                    2) *
                  this.renderConfig.dpr;
              } else if (
                xPos === "xMax" &&
                ((animationRel < elementRel && fillType === "meet") ||
                  (animationRel > elementRel && fillType === "slice"))
              ) {
                this.transformCanvas.tx =
                  (elementWidth -
                    this.transformCanvas.w *
                      (elementHeight / this.transformCanvas.h)) *
                  this.renderConfig.dpr;
              } else {
                this.transformCanvas.tx = 0;
              }

              if (
                yPos === "YMid" &&
                ((animationRel > elementRel && fillType === "meet") ||
                  (animationRel < elementRel && fillType === "slice"))
              ) {
                this.transformCanvas.ty =
                  ((elementHeight -
                    this.transformCanvas.h *
                      (elementWidth / this.transformCanvas.w)) /
                    2) *
                  this.renderConfig.dpr;
              } else if (
                yPos === "YMax" &&
                ((animationRel > elementRel && fillType === "meet") ||
                  (animationRel < elementRel && fillType === "slice"))
              ) {
                this.transformCanvas.ty =
                  (elementHeight -
                    this.transformCanvas.h *
                      (elementWidth / this.transformCanvas.w)) *
                  this.renderConfig.dpr;
              } else {
                this.transformCanvas.ty = 0;
              }
            } else if (this.renderConfig.preserveAspectRatio === "none") {
              this.transformCanvas.sx =
                elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
              this.transformCanvas.sy =
                elementHeight /
                (this.transformCanvas.h / this.renderConfig.dpr);
              this.transformCanvas.tx = 0;
              this.transformCanvas.ty = 0;
            } else {
              this.transformCanvas.sx = this.renderConfig.dpr;
              this.transformCanvas.sy = this.renderConfig.dpr;
              this.transformCanvas.tx = 0;
              this.transformCanvas.ty = 0;
            }

            this.transformCanvas.props = [
              this.transformCanvas.sx,
              0,
              0,
              0,
              0,
              this.transformCanvas.sy,
              0,
              0,
              0,
              0,
              1,
              0,
              this.transformCanvas.tx,
              this.transformCanvas.ty,
              0,
              1,
            ];
            /* var i, len = this.elements.length;
      for(i=0;i<len;i+=1){
          if(this.elements[i] && this.elements[i].data.ty === 0){
              this.elements[i].resize(this.globalData.transformCanvas);
          }
      } */

            this.ctxTransform(this.transformCanvas.props);
            this.canvasContext.beginPath();
            this.canvasContext.rect(
              0,
              0,
              this.transformCanvas.w,
              this.transformCanvas.h
            );
            this.canvasContext.closePath();
            this.canvasContext.clip();
            this.renderFrame(this.renderedFrame, true);
          };

          CanvasRendererBase.prototype.destroy = function () {
            if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
              this.animationItem.wrapper.innerText = "";
            }

            var i;
            var len = this.layers ? this.layers.length : 0;

            for (i = len - 1; i >= 0; i -= 1) {
              if (this.elements[i]) {
                this.elements[i].destroy();
              }
            }

            this.elements.length = 0;
            this.globalData.canvasContext = null;
            this.animationItem.container = null;
            this.destroyed = true;
          };

          CanvasRendererBase.prototype.renderFrame = function (
            num,
            forceRender
          ) {
            if (
              (this.renderedFrame === num &&
                this.renderConfig.clearCanvas === true &&
                !forceRender) ||
              this.destroyed ||
              num === -1
            ) {
              return;
            }

            this.renderedFrame = num;
            this.globalData.frameNum = num - this.animationItem._isFirstFrame;
            this.globalData.frameId += 1;
            this.globalData._mdf =
              !this.renderConfig.clearCanvas || forceRender;
            this.globalData.projectInterface.currentFrame = num; // console.log('--------');
            // console.log('NEW: ',num);

            var i;
            var len = this.layers.length;

            if (!this.completeLayers) {
              this.checkLayers(num);
            }

            for (i = 0; i < len; i += 1) {
              if (this.completeLayers || this.elements[i]) {
                this.elements[i].prepareFrame(num - this.layers[i].st);
              }
            }

            if (this.globalData._mdf) {
              if (this.renderConfig.clearCanvas === true) {
                this.canvasContext.clearRect(
                  0,
                  0,
                  this.transformCanvas.w,
                  this.transformCanvas.h
                );
              } else {
                this.save();
              }

              for (i = len - 1; i >= 0; i -= 1) {
                if (this.completeLayers || this.elements[i]) {
                  this.elements[i].renderFrame();
                }
              }

              if (this.renderConfig.clearCanvas !== true) {
                this.restore();
              }
            }
          };

          CanvasRendererBase.prototype.buildItem = function (pos) {
            var elements = this.elements;

            if (elements[pos] || this.layers[pos].ty === 99) {
              return;
            }

            var element = this.createItem(
              this.layers[pos],
              this,
              this.globalData
            );
            elements[pos] = element;
            element.initExpressions();
            /* if(this.layers[pos].ty === 0){
          element.resize(this.globalData.transformCanvas);
      } */
          };

          CanvasRendererBase.prototype.checkPendingElements = function () {
            while (this.pendingElements.length) {
              var element = this.pendingElements.pop();
              element.checkParenting();
            }
          };

          CanvasRendererBase.prototype.hide = function () {
            this.animationItem.container.style.display = "none";
          };

          CanvasRendererBase.prototype.show = function () {
            this.animationItem.container.style.display = "block";
          };

          function CVCompElement(data, globalData, comp) {
            this.completeLayers = false;
            this.layers = data.layers;
            this.pendingElements = [];
            this.elements = createSizedArray(this.layers.length);
            this.initElement(data, globalData, comp);
            this.tm = data.tm
              ? PropertyFactory.getProp(
                  this,
                  data.tm,
                  0,
                  globalData.frameRate,
                  this
                )
              : {
                  _placeholder: true,
                };
          }

          extendPrototype(
            [CanvasRendererBase, ICompElement, CVBaseElement],
            CVCompElement
          );

          CVCompElement.prototype.renderInnerContent = function () {
            var ctx = this.canvasContext;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(this.data.w, 0);
            ctx.lineTo(this.data.w, this.data.h);
            ctx.lineTo(0, this.data.h);
            ctx.lineTo(0, 0);
            ctx.clip();
            var i;
            var len = this.layers.length;

            for (i = len - 1; i >= 0; i -= 1) {
              if (this.completeLayers || this.elements[i]) {
                this.elements[i].renderFrame();
              }
            }
          };

          CVCompElement.prototype.destroy = function () {
            var i;
            var len = this.layers.length;

            for (i = len - 1; i >= 0; i -= 1) {
              if (this.elements[i]) {
                this.elements[i].destroy();
              }
            }

            this.layers = null;
            this.elements = null;
          };

          CVCompElement.prototype.createComp = function (data) {
            return new CVCompElement(data, this.globalData, this);
          };

          function CanvasRenderer(animationItem, config) {
            this.animationItem = animationItem;
            this.renderConfig = {
              clearCanvas:
                config && config.clearCanvas !== undefined
                  ? config.clearCanvas
                  : true,
              context: (config && config.context) || null,
              progressiveLoad: (config && config.progressiveLoad) || false,
              preserveAspectRatio:
                (config && config.preserveAspectRatio) || "xMidYMid meet",
              imagePreserveAspectRatio:
                (config && config.imagePreserveAspectRatio) || "xMidYMid slice",
              contentVisibility:
                (config && config.contentVisibility) || "visible",
              className: (config && config.className) || "",
              id: (config && config.id) || "",
            };
            this.renderConfig.dpr = (config && config.dpr) || 1;

            if (this.animationItem.wrapper) {
              this.renderConfig.dpr =
                (config && config.dpr) || window.devicePixelRatio || 1;
            }

            this.renderedFrame = -1;
            this.globalData = {
              frameNum: -1,
              _mdf: false,
              renderConfig: this.renderConfig,
              currentGlobalAlpha: -1,
            };
            this.contextData = new CVContextData();
            this.elements = [];
            this.pendingElements = [];
            this.transformMat = new Matrix();
            this.completeLayers = false;
            this.rendererType = "canvas";
          }

          extendPrototype([CanvasRendererBase], CanvasRenderer);

          CanvasRenderer.prototype.createComp = function (data) {
            return new CVCompElement(data, this.globalData, this);
          };

          function HBaseElement() {}

          HBaseElement.prototype = {
            checkBlendMode: function checkBlendMode() {},
            initRendererElement: function initRendererElement() {
              this.baseElement = createTag(this.data.tg || "div");

              if (this.data.hasMask) {
                this.svgElement = createNS("svg");
                this.layerElement = createNS("g");
                this.maskedElement = this.layerElement;
                this.svgElement.appendChild(this.layerElement);
                this.baseElement.appendChild(this.svgElement);
              } else {
                this.layerElement = this.baseElement;
              }

              styleDiv(this.baseElement);
            },
            createContainerElements: function createContainerElements() {
              this.renderableEffectsManager = new CVEffects(this);
              this.transformedElement = this.baseElement;
              this.maskedElement = this.layerElement;

              if (this.data.ln) {
                this.layerElement.setAttribute("id", this.data.ln);
              }

              if (this.data.cl) {
                this.layerElement.setAttribute("class", this.data.cl);
              }

              if (this.data.bm !== 0) {
                this.setBlendMode();
              }
            },
            renderElement: function renderElement() {
              var transformedElementStyle = this.transformedElement
                ? this.transformedElement.style
                : {};

              if (this.finalTransform._matMdf) {
                var matrixValue = this.finalTransform.mat.toCSS();
                transformedElementStyle.transform = matrixValue;
                transformedElementStyle.webkitTransform = matrixValue;
              }

              if (this.finalTransform._opMdf) {
                transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
              }
            },
            renderFrame: function renderFrame() {
              // If it is exported as hidden (data.hd === true) no need to render
              // If it is not visible no need to render
              if (this.data.hd || this.hidden) {
                return;
              }

              this.renderTransform();
              this.renderRenderable();
              this.renderElement();
              this.renderInnerContent();

              if (this._isFirstFrame) {
                this._isFirstFrame = false;
              }
            },
            destroy: function destroy() {
              this.layerElement = null;
              this.transformedElement = null;

              if (this.matteElement) {
                this.matteElement = null;
              }

              if (this.maskManager) {
                this.maskManager.destroy();
                this.maskManager = null;
              }
            },
            createRenderableComponents: function createRenderableComponents() {
              this.maskManager = new MaskElement(
                this.data,
                this,
                this.globalData
              );
            },
            addEffects: function addEffects() {},
            setMatte: function setMatte() {},
          };
          HBaseElement.prototype.getBaseElement =
            SVGBaseElement.prototype.getBaseElement;
          HBaseElement.prototype.destroyBaseElement =
            HBaseElement.prototype.destroy;
          HBaseElement.prototype.buildElementParenting =
            BaseRenderer.prototype.buildElementParenting;

          function HSolidElement(data, globalData, comp) {
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
            ],
            HSolidElement
          );

          HSolidElement.prototype.createContent = function () {
            var rect;

            if (this.data.hasMask) {
              rect = createNS("rect");
              rect.setAttribute("width", this.data.sw);
              rect.setAttribute("height", this.data.sh);
              rect.setAttribute("fill", this.data.sc);
              this.svgElement.setAttribute("width", this.data.sw);
              this.svgElement.setAttribute("height", this.data.sh);
            } else {
              rect = createTag("div");
              rect.style.width = this.data.sw + "px";
              rect.style.height = this.data.sh + "px";
              rect.style.backgroundColor = this.data.sc;
            }

            this.layerElement.appendChild(rect);
          };

          function HShapeElement(data, globalData, comp) {
            // List of drawable elements
            this.shapes = []; // Full shape data

            this.shapesData = data.shapes; // List of styles that will be applied to shapes

            this.stylesList = []; // List of modifiers that will be applied to shapes

            this.shapeModifiers = []; // List of items in shape tree

            this.itemsData = []; // List of items in previous shape tree

            this.processedElements = []; // List of animated components

            this.animatedContents = [];
            this.shapesContainer = createNS("g");
            this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
            // List of elements that have been created

            this.prevViewData = [];
            this.currentBBox = {
              x: 999999,
              y: -999999,
              h: 0,
              w: 0,
            };
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HSolidElement,
              SVGShapeElement,
              HBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
            ],
            HShapeElement
          );
          HShapeElement.prototype._renderShapeFrame =
            HShapeElement.prototype.renderInnerContent;

          HShapeElement.prototype.createContent = function () {
            var cont;
            this.baseElement.style.fontSize = 0;

            if (this.data.hasMask) {
              this.layerElement.appendChild(this.shapesContainer);
              cont = this.svgElement;
            } else {
              cont = createNS("svg");
              var size = this.comp.data
                ? this.comp.data
                : this.globalData.compSize;
              cont.setAttribute("width", size.w);
              cont.setAttribute("height", size.h);
              cont.appendChild(this.shapesContainer);
              this.layerElement.appendChild(cont);
            }

            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.shapesContainer,
              0,
              [],
              true
            );
            this.filterUniqueShapes();
            this.shapeCont = cont;
          };

          HShapeElement.prototype.getTransformedPoint = function (
            transformers,
            point
          ) {
            var i;
            var len = transformers.length;

            for (i = 0; i < len; i += 1) {
              point = transformers[i].mProps.v.applyToPointArray(
                point[0],
                point[1],
                0
              );
            }

            return point;
          };

          HShapeElement.prototype.calculateShapeBoundingBox = function (
            item,
            boundingBox
          ) {
            var shape = item.sh.v;
            var transformers = item.transformers;
            var i;
            var len = shape._length;
            var vPoint;
            var oPoint;
            var nextIPoint;
            var nextVPoint;

            if (len <= 1) {
              return;
            }

            for (i = 0; i < len - 1; i += 1) {
              vPoint = this.getTransformedPoint(transformers, shape.v[i]);
              oPoint = this.getTransformedPoint(transformers, shape.o[i]);
              nextIPoint = this.getTransformedPoint(
                transformers,
                shape.i[i + 1]
              );
              nextVPoint = this.getTransformedPoint(
                transformers,
                shape.v[i + 1]
              );
              this.checkBounds(
                vPoint,
                oPoint,
                nextIPoint,
                nextVPoint,
                boundingBox
              );
            }

            if (shape.c) {
              vPoint = this.getTransformedPoint(transformers, shape.v[i]);
              oPoint = this.getTransformedPoint(transformers, shape.o[i]);
              nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
              nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
              this.checkBounds(
                vPoint,
                oPoint,
                nextIPoint,
                nextVPoint,
                boundingBox
              );
            }
          };

          HShapeElement.prototype.checkBounds = function (
            vPoint,
            oPoint,
            nextIPoint,
            nextVPoint,
            boundingBox
          ) {
            this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
            var bounds = this.shapeBoundingBox;
            boundingBox.x = bmMin(bounds.left, boundingBox.x);
            boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
            boundingBox.y = bmMin(bounds.top, boundingBox.y);
            boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
          };

          HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
          };
          HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0,
          };

          HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
            var bounds = [
              [p0[0], p3[0]],
              [p0[1], p3[1]],
            ];

            for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
              // eslint-disable-line no-plusplus
              b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
              a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
              c = 3 * p1[i] - 3 * p0[i];
              b |= 0; // eslint-disable-line no-bitwise

              a |= 0; // eslint-disable-line no-bitwise

              c |= 0; // eslint-disable-line no-bitwise

              if (a === 0 && b === 0) {
                //
              } else if (a === 0) {
                t = -c / b;

                if (t > 0 && t < 1) {
                  bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
                }
              } else {
                b2ac = b * b - 4 * c * a;

                if (b2ac >= 0) {
                  t1 = (-b + bmSqrt(b2ac)) / (2 * a);
                  if (t1 > 0 && t1 < 1)
                    bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
                  t2 = (-b - bmSqrt(b2ac)) / (2 * a);
                  if (t2 > 0 && t2 < 1)
                    bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
                }
              }
            }

            this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
            this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
            this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
            this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
          };

          HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
            return (
              bmPow(1 - t, 3) * p0[i] +
              3 * bmPow(1 - t, 2) * t * p1[i] +
              3 * (1 - t) * bmPow(t, 2) * p2[i] +
              bmPow(t, 3) * p3[i]
            );
          };

          HShapeElement.prototype.calculateBoundingBox = function (
            itemsData,
            boundingBox
          ) {
            var i;
            var len = itemsData.length;

            for (i = 0; i < len; i += 1) {
              if (itemsData[i] && itemsData[i].sh) {
                this.calculateShapeBoundingBox(itemsData[i], boundingBox);
              } else if (itemsData[i] && itemsData[i].it) {
                this.calculateBoundingBox(itemsData[i].it, boundingBox);
              }
            }
          };

          HShapeElement.prototype.currentBoxContains = function (box) {
            return (
              this.currentBBox.x <= box.x &&
              this.currentBBox.y <= box.y &&
              this.currentBBox.width + this.currentBBox.x >=
                box.x + box.width &&
              this.currentBBox.height + this.currentBBox.y >= box.y + box.height
            );
          };

          HShapeElement.prototype.renderInnerContent = function () {
            this._renderShapeFrame();

            if (!this.hidden && (this._isFirstFrame || this._mdf)) {
              var tempBoundingBox = this.tempBoundingBox;
              var max = 999999;
              tempBoundingBox.x = max;
              tempBoundingBox.xMax = -max;
              tempBoundingBox.y = max;
              tempBoundingBox.yMax = -max;
              this.calculateBoundingBox(this.itemsData, tempBoundingBox);
              tempBoundingBox.width =
                tempBoundingBox.xMax < tempBoundingBox.x
                  ? 0
                  : tempBoundingBox.xMax - tempBoundingBox.x;
              tempBoundingBox.height =
                tempBoundingBox.yMax < tempBoundingBox.y
                  ? 0
                  : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();

              if (this.currentBoxContains(tempBoundingBox)) {
                return;
              }

              var changed = false;

              if (this.currentBBox.w !== tempBoundingBox.width) {
                this.currentBBox.w = tempBoundingBox.width;
                this.shapeCont.setAttribute("width", tempBoundingBox.width);
                changed = true;
              }

              if (this.currentBBox.h !== tempBoundingBox.height) {
                this.currentBBox.h = tempBoundingBox.height;
                this.shapeCont.setAttribute("height", tempBoundingBox.height);
                changed = true;
              }

              if (
                changed ||
                this.currentBBox.x !== tempBoundingBox.x ||
                this.currentBBox.y !== tempBoundingBox.y
              ) {
                this.currentBBox.w = tempBoundingBox.width;
                this.currentBBox.h = tempBoundingBox.height;
                this.currentBBox.x = tempBoundingBox.x;
                this.currentBBox.y = tempBoundingBox.y;
                this.shapeCont.setAttribute(
                  "viewBox",
                  this.currentBBox.x +
                    " " +
                    this.currentBBox.y +
                    " " +
                    this.currentBBox.w +
                    " " +
                    this.currentBBox.h
                );
                var shapeStyle = this.shapeCont.style;
                var shapeTransform =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
                shapeStyle.transform = shapeTransform;
                shapeStyle.webkitTransform = shapeTransform;
              }
            }
          };

          function HTextElement(data, globalData, comp) {
            this.textSpans = [];
            this.textPaths = [];
            this.currentBBox = {
              x: 999999,
              y: -999999,
              h: 0,
              w: 0,
            };
            this.renderType = "svg";
            this.isMasked = false;
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
              ITextElement,
            ],
            HTextElement
          );

          HTextElement.prototype.createContent = function () {
            this.isMasked = this.checkMasks();

            if (this.isMasked) {
              this.renderType = "svg";
              this.compW = this.comp.data.w;
              this.compH = this.comp.data.h;
              this.svgElement.setAttribute("width", this.compW);
              this.svgElement.setAttribute("height", this.compH);
              var g = createNS("g");
              this.maskedElement.appendChild(g);
              this.innerElem = g;
            } else {
              this.renderType = "html";
              this.innerElem = this.layerElement;
            }

            this.checkParenting();
          };

          HTextElement.prototype.buildNewText = function () {
            var documentData = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(
              documentData.l ? documentData.l.length : 0
            );
            var innerElemStyle = this.innerElem.style;
            var textColor = documentData.fc
              ? this.buildColor(documentData.fc)
              : "rgba(0,0,0,0)";
            innerElemStyle.fill = textColor;
            innerElemStyle.color = textColor;

            if (documentData.sc) {
              innerElemStyle.stroke = this.buildColor(documentData.sc);
              innerElemStyle.strokeWidth = documentData.sw + "px";
            }

            var fontData = this.globalData.fontManager.getFontByName(
              documentData.f
            );

            if (!this.globalData.fontManager.chars) {
              innerElemStyle.fontSize = documentData.finalSize + "px";
              innerElemStyle.lineHeight = documentData.finalSize + "px";

              if (fontData.fClass) {
                this.innerElem.className = fontData.fClass;
              } else {
                innerElemStyle.fontFamily = fontData.fFamily;
                var fWeight = documentData.fWeight;
                var fStyle = documentData.fStyle;
                innerElemStyle.fontStyle = fStyle;
                innerElemStyle.fontWeight = fWeight;
              }
            }

            var i;
            var len;
            var letters = documentData.l;
            len = letters.length;
            var tSpan;
            var tParent;
            var tCont;
            var matrixHelper = this.mHelper;
            var shapes;
            var shapeStr = "";
            var cnt = 0;

            for (i = 0; i < len; i += 1) {
              if (this.globalData.fontManager.chars) {
                if (!this.textPaths[cnt]) {
                  tSpan = createNS("path");
                  tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
                  tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
                  tSpan.setAttribute("stroke-miterlimit", "4");
                } else {
                  tSpan = this.textPaths[cnt];
                }

                if (!this.isMasked) {
                  if (this.textSpans[cnt]) {
                    tParent = this.textSpans[cnt];
                    tCont = tParent.children[0];
                  } else {
                    tParent = createTag("div");
                    tParent.style.lineHeight = 0;
                    tCont = createNS("svg");
                    tCont.appendChild(tSpan);
                    styleDiv(tParent);
                  }
                }
              } else if (!this.isMasked) {
                if (this.textSpans[cnt]) {
                  tParent = this.textSpans[cnt];
                  tSpan = this.textPaths[cnt];
                } else {
                  tParent = createTag("span");
                  styleDiv(tParent);
                  tSpan = createTag("span");
                  styleDiv(tSpan);
                  tParent.appendChild(tSpan);
                }
              } else {
                tSpan = this.textPaths[cnt]
                  ? this.textPaths[cnt]
                  : createNS("text");
              } // tSpan.setAttribute('visibility', 'hidden');

              if (this.globalData.fontManager.chars) {
                var charData = this.globalData.fontManager.getCharData(
                  documentData.finalText[i],
                  fontData.fStyle,
                  this.globalData.fontManager.getFontByName(documentData.f)
                    .fFamily
                );
                var shapeData;

                if (charData) {
                  shapeData = charData.data;
                } else {
                  shapeData = null;
                }

                matrixHelper.reset();

                if (shapeData && shapeData.shapes && shapeData.shapes.length) {
                  shapes = shapeData.shapes[0].it;
                  matrixHelper.scale(
                    documentData.finalSize / 100,
                    documentData.finalSize / 100
                  );
                  shapeStr = this.createPathShape(matrixHelper, shapes);
                  tSpan.setAttribute("d", shapeStr);
                }

                if (!this.isMasked) {
                  this.innerElem.appendChild(tParent);

                  if (shapeData && shapeData.shapes) {
                    // document.body.appendChild is needed to get exact measure of shape
                    document.body.appendChild(tCont);
                    var boundingBox = tCont.getBBox();
                    tCont.setAttribute("width", boundingBox.width + 2);
                    tCont.setAttribute("height", boundingBox.height + 2);
                    tCont.setAttribute(
                      "viewBox",
                      boundingBox.x -
                        1 +
                        " " +
                        (boundingBox.y - 1) +
                        " " +
                        (boundingBox.width + 2) +
                        " " +
                        (boundingBox.height + 2)
                    );
                    var tContStyle = tCont.style;
                    var tContTranslation =
                      "translate(" +
                      (boundingBox.x - 1) +
                      "px," +
                      (boundingBox.y - 1) +
                      "px)";
                    tContStyle.transform = tContTranslation;
                    tContStyle.webkitTransform = tContTranslation;
                    letters[i].yOffset = boundingBox.y - 1;
                  } else {
                    tCont.setAttribute("width", 1);
                    tCont.setAttribute("height", 1);
                  }

                  tParent.appendChild(tCont);
                } else {
                  this.innerElem.appendChild(tSpan);
                }
              } else {
                tSpan.textContent = letters[i].val;
                tSpan.setAttributeNS(
                  "http://www.w3.org/XML/1998/namespace",
                  "xml:space",
                  "preserve"
                );

                if (!this.isMasked) {
                  this.innerElem.appendChild(tParent); //

                  var tStyle = tSpan.style;
                  var tSpanTranslation =
                    "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
                  tStyle.transform = tSpanTranslation;
                  tStyle.webkitTransform = tSpanTranslation;
                } else {
                  this.innerElem.appendChild(tSpan);
                }
              } //

              if (!this.isMasked) {
                this.textSpans[cnt] = tParent;
              } else {
                this.textSpans[cnt] = tSpan;
              }

              this.textSpans[cnt].style.display = "block";
              this.textPaths[cnt] = tSpan;
              cnt += 1;
            }

            while (cnt < this.textSpans.length) {
              this.textSpans[cnt].style.display = "none";
              cnt += 1;
            }
          };

          HTextElement.prototype.renderInnerContent = function () {
            var svgStyle;

            if (this.data.singleShape) {
              if (!this._isFirstFrame && !this.lettersChangedFlag) {
                return;
              }

              if (this.isMasked && this.finalTransform._matMdf) {
                // Todo Benchmark if using this is better than getBBox
                this.svgElement.setAttribute(
                  "viewBox",
                  -this.finalTransform.mProp.p.v[0] +
                    " " +
                    -this.finalTransform.mProp.p.v[1] +
                    " " +
                    this.compW +
                    " " +
                    this.compH
                );
                svgStyle = this.svgElement.style;
                var translation =
                  "translate(" +
                  -this.finalTransform.mProp.p.v[0] +
                  "px," +
                  -this.finalTransform.mProp.p.v[1] +
                  "px)";
                svgStyle.transform = translation;
                svgStyle.webkitTransform = translation;
              }
            }

            this.textAnimator.getMeasures(
              this.textProperty.currentData,
              this.lettersChangedFlag
            );

            if (
              !this.lettersChangedFlag &&
              !this.textAnimator.lettersChangedFlag
            ) {
              return;
            }

            var i;
            var len;
            var count = 0;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var textSpan;
            var textPath;

            for (i = 0; i < len; i += 1) {
              if (letters[i].n) {
                count += 1;
              } else {
                textSpan = this.textSpans[i];
                textPath = this.textPaths[i];
                renderedLetter = renderedLetters[count];
                count += 1;

                if (renderedLetter._mdf.m) {
                  if (!this.isMasked) {
                    textSpan.style.webkitTransform = renderedLetter.m;
                    textSpan.style.transform = renderedLetter.m;
                  } else {
                    textSpan.setAttribute("transform", renderedLetter.m);
                  }
                } /// /textSpan.setAttribute('opacity',renderedLetter.o);

                textSpan.style.opacity = renderedLetter.o;

                if (renderedLetter.sw && renderedLetter._mdf.sw) {
                  textPath.setAttribute("stroke-width", renderedLetter.sw);
                }

                if (renderedLetter.sc && renderedLetter._mdf.sc) {
                  textPath.setAttribute("stroke", renderedLetter.sc);
                }

                if (renderedLetter.fc && renderedLetter._mdf.fc) {
                  textPath.setAttribute("fill", renderedLetter.fc);
                  textPath.style.color = renderedLetter.fc;
                }
              }
            }

            if (
              this.innerElem.getBBox &&
              !this.hidden &&
              (this._isFirstFrame || this._mdf)
            ) {
              var boundingBox = this.innerElem.getBBox();

              if (this.currentBBox.w !== boundingBox.width) {
                this.currentBBox.w = boundingBox.width;
                this.svgElement.setAttribute("width", boundingBox.width);
              }

              if (this.currentBBox.h !== boundingBox.height) {
                this.currentBBox.h = boundingBox.height;
                this.svgElement.setAttribute("height", boundingBox.height);
              }

              var margin = 1;

              if (
                this.currentBBox.w !== boundingBox.width + margin * 2 ||
                this.currentBBox.h !== boundingBox.height + margin * 2 ||
                this.currentBBox.x !== boundingBox.x - margin ||
                this.currentBBox.y !== boundingBox.y - margin
              ) {
                this.currentBBox.w = boundingBox.width + margin * 2;
                this.currentBBox.h = boundingBox.height + margin * 2;
                this.currentBBox.x = boundingBox.x - margin;
                this.currentBBox.y = boundingBox.y - margin;
                this.svgElement.setAttribute(
                  "viewBox",
                  this.currentBBox.x +
                    " " +
                    this.currentBBox.y +
                    " " +
                    this.currentBBox.w +
                    " " +
                    this.currentBBox.h
                );
                svgStyle = this.svgElement.style;
                var svgTransform =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)";
                svgStyle.transform = svgTransform;
                svgStyle.webkitTransform = svgTransform;
              }
            }
          };

          function HCameraElement(data, globalData, comp) {
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.initHierarchy();
            var getProp = PropertyFactory.getProp;
            this.pe = getProp(this, data.pe, 0, 0, this);

            if (data.ks.p.s) {
              this.px = getProp(this, data.ks.p.x, 1, 0, this);
              this.py = getProp(this, data.ks.p.y, 1, 0, this);
              this.pz = getProp(this, data.ks.p.z, 1, 0, this);
            } else {
              this.p = getProp(this, data.ks.p, 1, 0, this);
            }

            if (data.ks.a) {
              this.a = getProp(this, data.ks.a, 1, 0, this);
            }

            if (data.ks.or.k.length && data.ks.or.k[0].to) {
              var i;
              var len = data.ks.or.k.length;

              for (i = 0; i < len; i += 1) {
                data.ks.or.k[i].to = null;
                data.ks.or.k[i].ti = null;
              }
            }

            this.or = getProp(this, data.ks.or, 1, degToRads, this);
            this.or.sh = true;
            this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
            this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
            this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
            this.mat = new Matrix();
            this._prevMat = new Matrix();
            this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.

            this.finalTransform = {
              mProp: this,
            };
          }

          extendPrototype(
            [BaseElement, FrameElement, HierarchyElement],
            HCameraElement
          );

          HCameraElement.prototype.setup = function () {
            var i;
            var len = this.comp.threeDElements.length;
            var comp;
            var perspectiveStyle;
            var containerStyle;

            for (i = 0; i < len; i += 1) {
              // [perspectiveElem,container]
              comp = this.comp.threeDElements[i];

              if (comp.type === "3d") {
                perspectiveStyle = comp.perspectiveElem.style;
                containerStyle = comp.container.style;
                var perspective = this.pe.v + "px";
                var origin = "0px 0px 0px";
                var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                perspectiveStyle.perspective = perspective;
                perspectiveStyle.webkitPerspective = perspective;
                containerStyle.transformOrigin = origin;
                containerStyle.mozTransformOrigin = origin;
                containerStyle.webkitTransformOrigin = origin;
                perspectiveStyle.transform = matrix;
                perspectiveStyle.webkitTransform = matrix;
              }
            }
          };

          HCameraElement.prototype.createElements = function () {};

          HCameraElement.prototype.hide = function () {};

          HCameraElement.prototype.renderFrame = function () {
            var _mdf = this._isFirstFrame;
            var i;
            var len;

            if (this.hierarchy) {
              len = this.hierarchy.length;

              for (i = 0; i < len; i += 1) {
                _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
              }
            }

            if (
              _mdf ||
              this.pe._mdf ||
              (this.p && this.p._mdf) ||
              (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
              this.rx._mdf ||
              this.ry._mdf ||
              this.rz._mdf ||
              this.or._mdf ||
              (this.a && this.a._mdf)
            ) {
              this.mat.reset();

              if (this.hierarchy) {
                len = this.hierarchy.length - 1;

                for (i = len; i >= 0; i -= 1) {
                  var mTransf = this.hierarchy[i].finalTransform.mProp;
                  this.mat.translate(
                    -mTransf.p.v[0],
                    -mTransf.p.v[1],
                    mTransf.p.v[2]
                  );
                  this.mat
                    .rotateX(-mTransf.or.v[0])
                    .rotateY(-mTransf.or.v[1])
                    .rotateZ(mTransf.or.v[2]);
                  this.mat
                    .rotateX(-mTransf.rx.v)
                    .rotateY(-mTransf.ry.v)
                    .rotateZ(mTransf.rz.v);
                  this.mat.scale(
                    1 / mTransf.s.v[0],
                    1 / mTransf.s.v[1],
                    1 / mTransf.s.v[2]
                  );
                  this.mat.translate(
                    mTransf.a.v[0],
                    mTransf.a.v[1],
                    mTransf.a.v[2]
                  );
                }
              }

              if (this.p) {
                this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
              } else {
                this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
              }

              if (this.a) {
                var diffVector;

                if (this.p) {
                  diffVector = [
                    this.p.v[0] - this.a.v[0],
                    this.p.v[1] - this.a.v[1],
                    this.p.v[2] - this.a.v[2],
                  ];
                } else {
                  diffVector = [
                    this.px.v - this.a.v[0],
                    this.py.v - this.a.v[1],
                    this.pz.v - this.a.v[2],
                  ];
                }

                var mag = Math.sqrt(
                  Math.pow(diffVector[0], 2) +
                    Math.pow(diffVector[1], 2) +
                    Math.pow(diffVector[2], 2)
                ); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));

                var lookDir = [
                  diffVector[0] / mag,
                  diffVector[1] / mag,
                  diffVector[2] / mag,
                ];
                var lookLengthOnXZ = Math.sqrt(
                  lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]
                );
                var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
                var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
                this.mat.rotateY(mRotationY).rotateX(-mRotationX);
              }

              this.mat
                .rotateX(-this.rx.v)
                .rotateY(-this.ry.v)
                .rotateZ(this.rz.v);
              this.mat
                .rotateX(-this.or.v[0])
                .rotateY(-this.or.v[1])
                .rotateZ(this.or.v[2]);
              this.mat.translate(
                this.globalData.compSize.w / 2,
                this.globalData.compSize.h / 2,
                0
              );
              this.mat.translate(0, 0, this.pe.v);
              var hasMatrixChanged = !this._prevMat.equals(this.mat);

              if (
                (hasMatrixChanged || this.pe._mdf) &&
                this.comp.threeDElements
              ) {
                len = this.comp.threeDElements.length;
                var comp;
                var perspectiveStyle;
                var containerStyle;

                for (i = 0; i < len; i += 1) {
                  comp = this.comp.threeDElements[i];

                  if (comp.type === "3d") {
                    if (hasMatrixChanged) {
                      var matValue = this.mat.toCSS();
                      containerStyle = comp.container.style;
                      containerStyle.transform = matValue;
                      containerStyle.webkitTransform = matValue;
                    }

                    if (this.pe._mdf) {
                      perspectiveStyle = comp.perspectiveElem.style;
                      perspectiveStyle.perspective = this.pe.v + "px";
                      perspectiveStyle.webkitPerspective = this.pe.v + "px";
                    }
                  }
                }

                this.mat.clone(this._prevMat);
              }
            }

            this._isFirstFrame = false;
          };

          HCameraElement.prototype.prepareFrame = function (num) {
            this.prepareProperties(num, true);
          };

          HCameraElement.prototype.destroy = function () {};

          HCameraElement.prototype.getBaseElement = function () {
            return null;
          };

          function HImageElement(data, globalData, comp) {
            this.assetData = globalData.getAssetData(data.refId);
            this.initElement(data, globalData, comp);
          }

          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HBaseElement,
              HSolidElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
            ],
            HImageElement
          );

          HImageElement.prototype.createContent = function () {
            var assetPath = this.globalData.getAssetsPath(this.assetData);
            var img = new Image();

            if (this.data.hasMask) {
              this.imageElem = createNS("image");
              this.imageElem.setAttribute("width", this.assetData.w + "px");
              this.imageElem.setAttribute("height", this.assetData.h + "px");
              this.imageElem.setAttributeNS(
                "http://www.w3.org/1999/xlink",
                "href",
                assetPath
              );
              this.layerElement.appendChild(this.imageElem);
              this.baseElement.setAttribute("width", this.assetData.w);
              this.baseElement.setAttribute("height", this.assetData.h);
            } else {
              this.layerElement.appendChild(img);
            }

            img.crossOrigin = "anonymous";
            img.src = assetPath;

            if (this.data.ln) {
              this.baseElement.setAttribute("id", this.data.ln);
            }
          };

          function HybridRendererBase(animationItem, config) {
            this.animationItem = animationItem;
            this.layers = null;
            this.renderedFrame = -1;
            this.renderConfig = {
              className: (config && config.className) || "",
              imagePreserveAspectRatio:
                (config && config.imagePreserveAspectRatio) || "xMidYMid slice",
              hideOnTransparent: !(
                config && config.hideOnTransparent === false
              ),
              filterSize: {
                width:
                  (config && config.filterSize && config.filterSize.width) ||
                  "400%",
                height:
                  (config && config.filterSize && config.filterSize.height) ||
                  "400%",
                x:
                  (config && config.filterSize && config.filterSize.x) ||
                  "-100%",
                y:
                  (config && config.filterSize && config.filterSize.y) ||
                  "-100%",
              },
            };
            this.globalData = {
              _mdf: false,
              frameNum: -1,
              renderConfig: this.renderConfig,
            };
            this.pendingElements = [];
            this.elements = [];
            this.threeDElements = [];
            this.destroyed = false;
            this.camera = null;
            this.supports3d = true;
            this.rendererType = "html";
          }

          extendPrototype([BaseRenderer], HybridRendererBase);
          HybridRendererBase.prototype.buildItem =
            SVGRenderer.prototype.buildItem;

          HybridRendererBase.prototype.checkPendingElements = function () {
            while (this.pendingElements.length) {
              var element = this.pendingElements.pop();
              element.checkParenting();
            }
          };

          HybridRendererBase.prototype.appendElementInPos = function (
            element,
            pos
          ) {
            var newDOMElement = element.getBaseElement();

            if (!newDOMElement) {
              return;
            }

            var layer = this.layers[pos];

            if (!layer.ddd || !this.supports3d) {
              if (this.threeDElements) {
                this.addTo3dContainer(newDOMElement, pos);
              } else {
                var i = 0;
                var nextDOMElement;
                var nextLayer;
                var tmpDOMElement;

                while (i < pos) {
                  if (
                    this.elements[i] &&
                    this.elements[i] !== true &&
                    this.elements[i].getBaseElement
                  ) {
                    nextLayer = this.elements[i];
                    tmpDOMElement = this.layers[i].ddd
                      ? this.getThreeDContainerByPos(i)
                      : nextLayer.getBaseElement();
                    nextDOMElement = tmpDOMElement || nextDOMElement;
                  }

                  i += 1;
                }

                if (nextDOMElement) {
                  if (!layer.ddd || !this.supports3d) {
                    this.layerElement.insertBefore(
                      newDOMElement,
                      nextDOMElement
                    );
                  }
                } else if (!layer.ddd || !this.supports3d) {
                  this.layerElement.appendChild(newDOMElement);
                }
              }
            } else {
              this.addTo3dContainer(newDOMElement, pos);
            }
          };

          HybridRendererBase.prototype.createShape = function (data) {
            if (!this.supports3d) {
              return new SVGShapeElement(data, this.globalData, this);
            }

            return new HShapeElement(data, this.globalData, this);
          };

          HybridRendererBase.prototype.createText = function (data) {
            if (!this.supports3d) {
              return new SVGTextLottieElement(data, this.globalData, this);
            }

            return new HTextElement(data, this.globalData, this);
          };

          HybridRendererBase.prototype.createCamera = function (data) {
            this.camera = new HCameraElement(data, this.globalData, this);
            return this.camera;
          };

          HybridRendererBase.prototype.createImage = function (data) {
            if (!this.supports3d) {
              return new IImageElement(data, this.globalData, this);
            }

            return new HImageElement(data, this.globalData, this);
          };

          HybridRendererBase.prototype.createSolid = function (data) {
            if (!this.supports3d) {
              return new ISolidElement(data, this.globalData, this);
            }

            return new HSolidElement(data, this.globalData, this);
          };

          HybridRendererBase.prototype.createNull =
            SVGRenderer.prototype.createNull;

          HybridRendererBase.prototype.getThreeDContainerByPos = function (
            pos
          ) {
            var i = 0;
            var len = this.threeDElements.length;

            while (i < len) {
              if (
                this.threeDElements[i].startPos <= pos &&
                this.threeDElements[i].endPos >= pos
              ) {
                return this.threeDElements[i].perspectiveElem;
              }

              i += 1;
            }

            return null;
          };

          HybridRendererBase.prototype.createThreeDContainer = function (
            pos,
            type
          ) {
            var perspectiveElem = createTag("div");
            var style;
            var containerStyle;
            styleDiv(perspectiveElem);
            var container = createTag("div");
            styleDiv(container);

            if (type === "3d") {
              style = perspectiveElem.style;
              style.width = this.globalData.compSize.w + "px";
              style.height = this.globalData.compSize.h + "px";
              var center = "50% 50%";
              style.webkitTransformOrigin = center;
              style.mozTransformOrigin = center;
              style.transformOrigin = center;
              containerStyle = container.style;
              var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              containerStyle.transform = matrix;
              containerStyle.webkitTransform = matrix;
            }

            perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);

            var threeDContainerData = {
              container: container,
              perspectiveElem: perspectiveElem,
              startPos: pos,
              endPos: pos,
              type: type,
            };
            this.threeDElements.push(threeDContainerData);
            return threeDContainerData;
          };

          HybridRendererBase.prototype.build3dContainers = function () {
            var i;
            var len = this.layers.length;
            var lastThreeDContainerData;
            var currentContainer = "";

            for (i = 0; i < len; i += 1) {
              if (this.layers[i].ddd && this.layers[i].ty !== 3) {
                if (currentContainer !== "3d") {
                  currentContainer = "3d";
                  lastThreeDContainerData = this.createThreeDContainer(i, "3d");
                }

                lastThreeDContainerData.endPos = Math.max(
                  lastThreeDContainerData.endPos,
                  i
                );
              } else {
                if (currentContainer !== "2d") {
                  currentContainer = "2d";
                  lastThreeDContainerData = this.createThreeDContainer(i, "2d");
                }

                lastThreeDContainerData.endPos = Math.max(
                  lastThreeDContainerData.endPos,
                  i
                );
              }
            }

            len = this.threeDElements.length;

            for (i = len - 1; i >= 0; i -= 1) {
              this.resizerElem.appendChild(
                this.threeDElements[i].perspectiveElem
              );
            }
          };

          HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
            var i = 0;
            var len = this.threeDElements.length;

            while (i < len) {
              if (pos <= this.threeDElements[i].endPos) {
                var j = this.threeDElements[i].startPos;
                var nextElement;

                while (j < pos) {
                  if (this.elements[j] && this.elements[j].getBaseElement) {
                    nextElement = this.elements[j].getBaseElement();
                  }

                  j += 1;
                }

                if (nextElement) {
                  this.threeDElements[i].container.insertBefore(
                    elem,
                    nextElement
                  );
                } else {
                  this.threeDElements[i].container.appendChild(elem);
                }

                break;
              }

              i += 1;
            }
          };

          HybridRendererBase.prototype.configAnimation = function (animData) {
            var resizerElem = createTag("div");
            var wrapper = this.animationItem.wrapper;
            var style = resizerElem.style;
            style.width = animData.w + "px";
            style.height = animData.h + "px";
            this.resizerElem = resizerElem;
            styleDiv(resizerElem);
            style.transformStyle = "flat";
            style.mozTransformStyle = "flat";
            style.webkitTransformStyle = "flat";

            if (this.renderConfig.className) {
              resizerElem.setAttribute("class", this.renderConfig.className);
            }

            wrapper.appendChild(resizerElem);
            style.overflow = "hidden";
            var svg = createNS("svg");
            svg.setAttribute("width", "1");
            svg.setAttribute("height", "1");
            styleDiv(svg);
            this.resizerElem.appendChild(svg);
            var defs = createNS("defs");
            svg.appendChild(defs);
            this.data = animData; // Mask animation

            this.setupGlobalData(animData, svg);
            this.globalData.defs = defs;
            this.layers = animData.layers;
            this.layerElement = this.resizerElem;
            this.build3dContainers();
            this.updateContainerSize();
          };

          HybridRendererBase.prototype.destroy = function () {
            if (this.animationItem.wrapper) {
              this.animationItem.wrapper.innerText = "";
            }

            this.animationItem.container = null;
            this.globalData.defs = null;
            var i;
            var len = this.layers ? this.layers.length : 0;

            for (i = 0; i < len; i += 1) {
              this.elements[i].destroy();
            }

            this.elements.length = 0;
            this.destroyed = true;
            this.animationItem = null;
          };

          HybridRendererBase.prototype.updateContainerSize = function () {
            var elementWidth = this.animationItem.wrapper.offsetWidth;
            var elementHeight = this.animationItem.wrapper.offsetHeight;
            var elementRel = elementWidth / elementHeight;
            var animationRel =
              this.globalData.compSize.w / this.globalData.compSize.h;
            var sx;
            var sy;
            var tx;
            var ty;

            if (animationRel > elementRel) {
              sx = elementWidth / this.globalData.compSize.w;
              sy = elementWidth / this.globalData.compSize.w;
              tx = 0;
              ty =
                (elementHeight -
                  this.globalData.compSize.h *
                    (elementWidth / this.globalData.compSize.w)) /
                2;
            } else {
              sx = elementHeight / this.globalData.compSize.h;
              sy = elementHeight / this.globalData.compSize.h;
              tx =
                (elementWidth -
                  this.globalData.compSize.w *
                    (elementHeight / this.globalData.compSize.h)) /
                2;
              ty = 0;
            }

            var style = this.resizerElem.style;
            style.webkitTransform =
              "matrix3d(" +
              sx +
              ",0,0,0,0," +
              sy +
              ",0,0,0,0,1,0," +
              tx +
              "," +
              ty +
              ",0,1)";
            style.transform = style.webkitTransform;
          };

          HybridRendererBase.prototype.renderFrame =
            SVGRenderer.prototype.renderFrame;

          HybridRendererBase.prototype.hide = function () {
            this.resizerElem.style.display = "none";
          };

          HybridRendererBase.prototype.show = function () {
            this.resizerElem.style.display = "block";
          };

          HybridRendererBase.prototype.initItems = function () {
            this.buildAllItems();

            if (this.camera) {
              this.camera.setup();
            } else {
              var cWidth = this.globalData.compSize.w;
              var cHeight = this.globalData.compSize.h;
              var i;
              var len = this.threeDElements.length;

              for (i = 0; i < len; i += 1) {
                var style = this.threeDElements[i].perspectiveElem.style;
                style.webkitPerspective =
                  Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
                style.perspective = style.webkitPerspective;
              }
            }
          };

          HybridRendererBase.prototype.searchExtraCompositions = function (
            assets
          ) {
            var i;
            var len = assets.length;
            var floatingContainer = createTag("div");

            for (i = 0; i < len; i += 1) {
              if (assets[i].xt) {
                var comp = this.createComp(
                  assets[i],
                  floatingContainer,
                  this.globalData.comp,
                  null
                );
                comp.initExpressions();
                this.globalData.projectInterface.registerComposition(comp);
              }
            }
          };

          function HCompElement(data, globalData, comp) {
            this.layers = data.layers;
            this.supports3d = !data.hasMask;
            this.completeLayers = false;
            this.pendingElements = [];
            this.elements = this.layers
              ? createSizedArray(this.layers.length)
              : [];
            this.initElement(data, globalData, comp);
            this.tm = data.tm
              ? PropertyFactory.getProp(
                  this,
                  data.tm,
                  0,
                  globalData.frameRate,
                  this
                )
              : {
                  _placeholder: true,
                };
          }

          extendPrototype(
            [HybridRendererBase, ICompElement, HBaseElement],
            HCompElement
          );
          HCompElement.prototype._createBaseContainerElements =
            HCompElement.prototype.createContainerElements;

          HCompElement.prototype.createContainerElements = function () {
            this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';

            if (this.data.hasMask) {
              this.svgElement.setAttribute("width", this.data.w);
              this.svgElement.setAttribute("height", this.data.h);
              this.transformedElement = this.baseElement;
            } else {
              this.transformedElement = this.layerElement;
            }
          };

          HCompElement.prototype.addTo3dContainer = function (elem, pos) {
            var j = 0;
            var nextElement;

            while (j < pos) {
              if (this.elements[j] && this.elements[j].getBaseElement) {
                nextElement = this.elements[j].getBaseElement();
              }

              j += 1;
            }

            if (nextElement) {
              this.layerElement.insertBefore(elem, nextElement);
            } else {
              this.layerElement.appendChild(elem);
            }
          };

          HCompElement.prototype.createComp = function (data) {
            if (!this.supports3d) {
              return new SVGCompElement(data, this.globalData, this);
            }

            return new HCompElement(data, this.globalData, this);
          };

          function HybridRenderer(animationItem, config) {
            this.animationItem = animationItem;
            this.layers = null;
            this.renderedFrame = -1;
            this.renderConfig = {
              className: (config && config.className) || "",
              imagePreserveAspectRatio:
                (config && config.imagePreserveAspectRatio) || "xMidYMid slice",
              hideOnTransparent: !(
                config && config.hideOnTransparent === false
              ),
              filterSize: {
                width:
                  (config && config.filterSize && config.filterSize.width) ||
                  "400%",
                height:
                  (config && config.filterSize && config.filterSize.height) ||
                  "400%",
                x:
                  (config && config.filterSize && config.filterSize.x) ||
                  "-100%",
                y:
                  (config && config.filterSize && config.filterSize.y) ||
                  "-100%",
              },
            };
            this.globalData = {
              _mdf: false,
              frameNum: -1,
              renderConfig: this.renderConfig,
            };
            this.pendingElements = [];
            this.elements = [];
            this.threeDElements = [];
            this.destroyed = false;
            this.camera = null;
            this.supports3d = true;
            this.rendererType = "html";
          }

          extendPrototype([HybridRendererBase], HybridRenderer);

          HybridRenderer.prototype.createComp = function (data) {
            if (!this.supports3d) {
              return new SVGCompElement(data, this.globalData, this);
            }

            return new HCompElement(data, this.globalData, this);
          };

          var Expressions = (function () {
            var ob = {};
            ob.initExpressions = initExpressions;

            function initExpressions(animation) {
              var stackCount = 0;
              var registers = [];

              function pushExpression() {
                stackCount += 1;
              }

              function popExpression() {
                stackCount -= 1;

                if (stackCount === 0) {
                  releaseInstances();
                }
              }

              function registerExpressionProperty(expression) {
                if (registers.indexOf(expression) === -1) {
                  registers.push(expression);
                }
              }

              function releaseInstances() {
                var i;
                var len = registers.length;

                for (i = 0; i < len; i += 1) {
                  registers[i].release();
                }

                registers.length = 0;
              }

              animation.renderer.compInterface = CompExpressionInterface(
                animation.renderer
              );
              animation.renderer.globalData.projectInterface.registerComposition(
                animation.renderer
              );
              animation.renderer.globalData.pushExpression = pushExpression;
              animation.renderer.globalData.popExpression = popExpression;
              animation.renderer.globalData.registerExpressionProperty =
                registerExpressionProperty;
            }

            return ob;
          })();

          function _typeof$1(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof$1 = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof$1 = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof$1(obj);
          }

          /* eslint-disable */

          /*
   Copyright 2014 David Bau.
     Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:
     The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
          function seedRandom(pool, math) {
            //
            // The following constants are related to IEEE 754 limits.
            //
            var global = this,
              width = 256,
              // each RC4 output is 0 <= x < 256
              chunks = 6,
              // at least six RC4 outputs for each double
              digits = 52,
              // there are 52 significant digits in a double
              rngname = "random",
              // rngname: name for Math.random and Math.seedrandom
              startdenom = math.pow(width, chunks),
              significance = math.pow(2, digits),
              overflow = significance * 2,
              mask = width - 1,
              nodecrypto; // node.js crypto module, initialized at the bottom.
            //
            // seedrandom()
            // This is the seedrandom function described above.
            //

            function seedrandom(seed, options, callback) {
              var key = [];
              options =
                options === true
                  ? {
                      entropy: true,
                    }
                  : options || {}; // Flatten the seed string or build one from local entropy if needed.

              var shortseed = mixkey(
                flatten(
                  options.entropy
                    ? [seed, tostring(pool)]
                    : seed === null
                    ? autoseed()
                    : seed,
                  3
                ),
                key
              ); // Use the seed to initialize an ARC4 generator.

              var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains
              // randomness in every bit of the mantissa of the IEEE 754 value.

              var prng = function prng() {
                var n = arc4.g(chunks),
                  // Start with a numerator n < 2 ^ 48
                  d = startdenom,
                  //   and denominator d = 2 ^ 48.
                  x = 0; //   and no 'extra last byte'.

                while (n < significance) {
                  // Fill up all significant digits by
                  n = (n + x) * width; //   shifting numerator and

                  d *= width; //   denominator and generating a

                  x = arc4.g(1); //   new least-significant-byte.
                }

                while (n >= overflow) {
                  // To avoid rounding up, before adding
                  n /= 2; //   last byte, shift everything

                  d /= 2; //   right using integer math until

                  x >>>= 1; //   we have exactly the desired bits.
                }

                return (n + x) / d; // Form the number within [0, 1).
              };

              prng.int32 = function () {
                return arc4.g(4) | 0;
              };

              prng.quick = function () {
                return arc4.g(4) / 0x100000000;
              };

              prng["double"] = prng; // Mix the randomness into accumulated entropy.

              mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.

              return (
                options.pass ||
                callback ||
                function (prng, seed, is_math_call, state) {
                  if (state) {
                    // Load the arc4 state from the given state if it has an S array.
                    if (state.S) {
                      copy(state, arc4);
                    } // Only provide the .state method if requested via options.state.

                    prng.state = function () {
                      return copy(arc4, {});
                    };
                  } // If called as a method of Math (Math.seedrandom()), mutate
                  // Math.random because that is how seedrandom.js has worked since v1.0.

                  if (is_math_call) {
                    math[rngname] = prng;
                    return seed;
                  } // Otherwise, it is a newer calling convention, so return the
                  // prng directly.
                  else return prng;
                }
              )(prng, shortseed, "global" in options ? options.global : this == math, options.state);
            }

            math["seed" + rngname] = seedrandom; //
            // ARC4
            //
            // An ARC4 implementation.  The constructor takes a key in the form of
            // an array of at most (width) integers that should be 0 <= x < (width).
            //
            // The g(count) method returns a pseudorandom integer that concatenates
            // the next (count) outputs from ARC4.  Its return value is a number x
            // that is in the range 0 <= x < (width ^ count).
            //

            function ARC4(key) {
              var t,
                keylen = key.length,
                me = this,
                i = 0,
                j = (me.i = me.j = 0),
                s = (me.S = []); // The empty key [] is treated as [0].

              if (!keylen) {
                key = [keylen++];
              } // Set up S using the standard key scheduling algorithm.

              while (i < width) {
                s[i] = i++;
              }

              for (i = 0; i < width; i++) {
                s[i] = s[(j = mask & (j + key[i % keylen] + (t = s[i])))];
                s[j] = t;
              } // The "g" method returns the next (count) outputs as one number.

              me.g = function (count) {
                // Using instance members instead of closure state nearly doubles speed.
                var t,
                  r = 0,
                  i = me.i,
                  j = me.j,
                  s = me.S;

                while (count--) {
                  t = s[(i = mask & (i + 1))];
                  r =
                    r * width +
                    s[mask & ((s[i] = s[(j = mask & (j + t))]) + (s[j] = t))];
                }

                me.i = i;
                me.j = j;
                return r; // For robust unpredictability, the function call below automatically
                // discards an initial batch of values.  This is called RC4-drop[256].
                // See http://google.com/search?q=rsa+fluhrer+response&btnI
              };
            } //
            // copy()
            // Copies internal state of ARC4 to or from a plain object.
            //

            function copy(f, t) {
              t.i = f.i;
              t.j = f.j;
              t.S = f.S.slice();
              return t;
            } //
            // flatten()
            // Converts an object tree to nested arrays of strings.
            //

            function flatten(obj, depth) {
              var result = [],
                typ = _typeof$1(obj),
                prop;

              if (depth && typ == "object") {
                for (prop in obj) {
                  try {
                    result.push(flatten(obj[prop], depth - 1));
                  } catch (e) {}
                }
              }

              return result.length
                ? result
                : typ == "string"
                ? obj
                : obj + "\0";
            } //
            // mixkey()
            // Mixes a string seed into a key that is an array of integers, and
            // returns a shortened string seed that is equivalent to the result key.
            //

            function mixkey(seed, key) {
              var stringseed = seed + "",
                smear,
                j = 0;

              while (j < stringseed.length) {
                key[mask & j] =
                  mask &
                  ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
              }

              return tostring(key);
            } //
            // autoseed()
            // Returns an object for autoseeding, using window.crypto and Node crypto
            // module if available.
            //

            function autoseed() {
              try {
                if (nodecrypto) {
                  return tostring(nodecrypto.randomBytes(width));
                }

                var out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
                return tostring(out);
              } catch (e) {
                var browser = global.navigator,
                  plugins = browser && browser.plugins;
                return [
                  +new Date(),
                  global,
                  plugins,
                  global.screen,
                  tostring(pool),
                ];
              }
            } //
            // tostring()
            // Converts an array of charcodes to a string
            //

            function tostring(a) {
              return String.fromCharCode.apply(0, a);
            } //
            // When seedrandom.js is loaded, we immediately mix a few bits
            // from the built-in RNG into the entropy pool.  Because we do
            // not want to interfere with deterministic PRNG state later,
            // seedrandom will not call math.random on its own again after
            // initialization.
            //

            mixkey(math.random(), pool); //
            // Nodejs and AMD support: export the implementation as a module using
            // either convention.
            //
            // End anonymous scope, and pass initial values.
          }

          function initialize$2(BMMath) {
            seedRandom([], BMMath);
          }

          var propTypes = {
            SHAPE: "shape",
          };

          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (
              typeof Symbol === "function" &&
              _typeof2(Symbol.iterator) === "symbol"
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof2(obj);
              };
            }
            return _typeof(obj);
          }

          var ExpressionManager = (function () {
            "use strict";

            var ob = {};
            var Math = BMMath;
            var window = null;
            var document = null;
            var XMLHttpRequest = null;
            var fetch = null;
            var frames = null;
            initialize$2(BMMath);

            function $bm_isInstanceOfArray(arr) {
              return (
                arr.constructor === Array || arr.constructor === Float32Array
              );
            }

            function isNumerable(tOfV, v) {
              return (
                tOfV === "number" ||
                tOfV === "boolean" ||
                tOfV === "string" ||
                v instanceof Number
              );
            }

            function $bm_neg(a) {
              var tOfA = _typeof(a);

              if (
                tOfA === "number" ||
                tOfA === "boolean" ||
                a instanceof Number
              ) {
                return -a;
              }

              if ($bm_isInstanceOfArray(a)) {
                var i;
                var lenA = a.length;
                var retArr = [];

                for (i = 0; i < lenA; i += 1) {
                  retArr[i] = -a[i];
                }

                return retArr;
              }

              if (a.propType) {
                return a.v;
              }

              return -a;
            }

            var easeInBez = BezierFactory.getBezierEasing(
              0.333,
              0,
              0.833,
              0.833,
              "easeIn"
            ).get;
            var easeOutBez = BezierFactory.getBezierEasing(
              0.167,
              0.167,
              0.667,
              1,
              "easeOut"
            ).get;
            var easeInOutBez = BezierFactory.getBezierEasing(
              0.33,
              0,
              0.667,
              1,
              "easeInOut"
            ).get;

            function sum(a, b) {
              var tOfA = _typeof(a);

              var tOfB = _typeof(b);

              if (tOfA === "string" || tOfB === "string") {
                return a + b;
              }

              if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                return a + b;
              }

              if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                a = a.slice(0);
                a[0] += b;
                return a;
              }

              if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                b = b.slice(0);
                b[0] = a + b[0];
                return b;
              }

              if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                var i = 0;
                var lenA = a.length;
                var lenB = b.length;
                var retArr = [];

                while (i < lenA || i < lenB) {
                  if (
                    (typeof a[i] === "number" || a[i] instanceof Number) &&
                    (typeof b[i] === "number" || b[i] instanceof Number)
                  ) {
                    retArr[i] = a[i] + b[i];
                  } else {
                    retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
                  }

                  i += 1;
                }

                return retArr;
              }

              return 0;
            }

            var add = sum;

            function sub(a, b) {
              var tOfA = _typeof(a);

              var tOfB = _typeof(b);

              if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                if (tOfA === "string") {
                  a = parseInt(a, 10);
                }

                if (tOfB === "string") {
                  b = parseInt(b, 10);
                }

                return a - b;
              }

              if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                a = a.slice(0);
                a[0] -= b;
                return a;
              }

              if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                b = b.slice(0);
                b[0] = a - b[0];
                return b;
              }

              if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                var i = 0;
                var lenA = a.length;
                var lenB = b.length;
                var retArr = [];

                while (i < lenA || i < lenB) {
                  if (
                    (typeof a[i] === "number" || a[i] instanceof Number) &&
                    (typeof b[i] === "number" || b[i] instanceof Number)
                  ) {
                    retArr[i] = a[i] - b[i];
                  } else {
                    retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
                  }

                  i += 1;
                }

                return retArr;
              }

              return 0;
            }

            function mul(a, b) {
              var tOfA = _typeof(a);

              var tOfB = _typeof(b);

              var arr;

              if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                return a * b;
              }

              var i;
              var len;

              if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                len = a.length;
                arr = createTypedArray("float32", len);

                for (i = 0; i < len; i += 1) {
                  arr[i] = a[i] * b;
                }

                return arr;
              }

              if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                len = b.length;
                arr = createTypedArray("float32", len);

                for (i = 0; i < len; i += 1) {
                  arr[i] = a * b[i];
                }

                return arr;
              }

              return 0;
            }

            function div(a, b) {
              var tOfA = _typeof(a);

              var tOfB = _typeof(b);

              var arr;

              if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                return a / b;
              }

              var i;
              var len;

              if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                len = a.length;
                arr = createTypedArray("float32", len);

                for (i = 0; i < len; i += 1) {
                  arr[i] = a[i] / b;
                }

                return arr;
              }

              if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                len = b.length;
                arr = createTypedArray("float32", len);

                for (i = 0; i < len; i += 1) {
                  arr[i] = a / b[i];
                }

                return arr;
              }

              return 0;
            }

            function mod(a, b) {
              if (typeof a === "string") {
                a = parseInt(a, 10);
              }

              if (typeof b === "string") {
                b = parseInt(b, 10);
              }

              return a % b;
            }

            var $bm_sum = sum;
            var $bm_sub = sub;
            var $bm_mul = mul;
            var $bm_div = div;
            var $bm_mod = mod;

            function clamp(num, min, max) {
              if (min > max) {
                var mm = max;
                max = min;
                min = mm;
              }

              return Math.min(Math.max(num, min), max);
            }

            function radiansToDegrees(val) {
              return val / degToRads;
            }

            var radians_to_degrees = radiansToDegrees;

            function degreesToRadians(val) {
              return val * degToRads;
            }

            var degrees_to_radians = radiansToDegrees;
            var helperLengthArray = [0, 0, 0, 0, 0, 0];

            function length(arr1, arr2) {
              if (typeof arr1 === "number" || arr1 instanceof Number) {
                arr2 = arr2 || 0;
                return Math.abs(arr1 - arr2);
              }

              if (!arr2) {
                arr2 = helperLengthArray;
              }

              var i;
              var len = Math.min(arr1.length, arr2.length);
              var addedLength = 0;

              for (i = 0; i < len; i += 1) {
                addedLength += Math.pow(arr2[i] - arr1[i], 2);
              }

              return Math.sqrt(addedLength);
            }

            function normalize(vec) {
              return div(vec, length(vec));
            }

            function rgbToHsl(val) {
              var r = val[0];
              var g = val[1];
              var b = val[2];
              var max = Math.max(r, g, b);
              var min = Math.min(r, g, b);
              var h;
              var s;
              var l = (max + min) / 2;

              if (max === min) {
                h = 0; // achromatic

                s = 0; // achromatic
              } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                  case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;

                  case g:
                    h = (b - r) / d + 2;
                    break;

                  case b:
                    h = (r - g) / d + 4;
                    break;

                  default:
                    break;
                }

                h /= 6;
              }

              return [h, s, l, val[3]];
            }

            function hue2rgb(p, q, t) {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1 / 6) return p + (q - p) * 6 * t;
              if (t < 1 / 2) return q;
              if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
              return p;
            }

            function hslToRgb(val) {
              var h = val[0];
              var s = val[1];
              var l = val[2];
              var r;
              var g;
              var b;

              if (s === 0) {
                r = l; // achromatic

                b = l; // achromatic

                g = l; // achromatic
              } else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
              }

              return [r, g, b, val[3]];
            }

            function linear(t, tMin, tMax, value1, value2) {
              if (value1 === undefined || value2 === undefined) {
                value1 = tMin;
                value2 = tMax;
                tMin = 0;
                tMax = 1;
              }

              if (tMax < tMin) {
                var _tMin = tMax;
                tMax = tMin;
                tMin = _tMin;
              }

              if (t <= tMin) {
                return value1;
              }

              if (t >= tMax) {
                return value2;
              }

              var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);

              if (!value1.length) {
                return value1 + (value2 - value1) * perc;
              }

              var i;
              var len = value1.length;
              var arr = createTypedArray("float32", len);

              for (i = 0; i < len; i += 1) {
                arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
              }

              return arr;
            }

            function random(min, max) {
              if (max === undefined) {
                if (min === undefined) {
                  min = 0;
                  max = 1;
                } else {
                  max = min;
                  min = undefined;
                }
              }

              if (max.length) {
                var i;
                var len = max.length;

                if (!min) {
                  min = createTypedArray("float32", len);
                }

                var arr = createTypedArray("float32", len);
                var rnd = BMMath.random();

                for (i = 0; i < len; i += 1) {
                  arr[i] = min[i] + rnd * (max[i] - min[i]);
                }

                return arr;
              }

              if (min === undefined) {
                min = 0;
              }

              var rndm = BMMath.random();
              return min + rndm * (max - min);
            }

            function createPath(points, inTangents, outTangents, closed) {
              var i;
              var len = points.length;
              var path = shapePool.newElement();
              path.setPathData(!!closed, len);
              var arrPlaceholder = [0, 0];
              var inVertexPoint;
              var outVertexPoint;

              for (i = 0; i < len; i += 1) {
                inVertexPoint =
                  inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
                outVertexPoint =
                  outTangents && outTangents[i]
                    ? outTangents[i]
                    : arrPlaceholder;
                path.setTripleAt(
                  points[i][0],
                  points[i][1],
                  outVertexPoint[0] + points[i][0],
                  outVertexPoint[1] + points[i][1],
                  inVertexPoint[0] + points[i][0],
                  inVertexPoint[1] + points[i][1],
                  i,
                  true
                );
              }

              return path;
            }

            function initiateExpression(elem, data, property) {
              var val = data.x;
              var needsVelocity = /velocity(?![\w\d])/.test(val);

              var _needsRandom = val.indexOf("random") !== -1;

              var elemType = elem.data.ty;
              var transform;
              var $bm_transform;
              var content;
              var effect;
              var thisProperty = property;
              thisProperty.valueAtTime = thisProperty.getValueAtTime;
              Object.defineProperty(thisProperty, "value", {
                get: function get() {
                  return thisProperty.v;
                },
              });
              elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
              elem.comp.displayStartTime = 0;
              var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
              var outPoint = elem.data.op / elem.comp.globalData.frameRate;
              var width = elem.data.sw ? elem.data.sw : 0;
              var height = elem.data.sh ? elem.data.sh : 0;
              var name = elem.data.nm;
              var loopIn;
              var loop_in;
              var loopOut;
              var loop_out;
              var smooth;
              var toWorld;
              var fromWorld;
              var fromComp;
              var toComp;
              var fromCompToSurface;
              var position;
              var rotation;
              var anchorPoint;
              var scale;
              var thisLayer;
              var thisComp;
              var mask;
              var valueAtTime;
              var velocityAtTime;
              var scoped_bm_rt; // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls

              var expression_function = eval(
                "[function _expression_function(){" +
                  val +
                  ";scoped_bm_rt=$bm_rt}]"
              )[0]; // eslint-disable-line no-eval

              var numKeys = property.kf ? data.k.length : 0;
              var active = !this.data || this.data.hd !== true;

              var wiggle = function wiggle(freq, amp) {
                var iWiggle;
                var j;
                var lenWiggle = this.pv.length ? this.pv.length : 1;
                var addedAmps = createTypedArray("float32", lenWiggle);
                freq = 5;
                var iterations = Math.floor(time * freq);
                iWiggle = 0;
                j = 0;

                while (iWiggle < iterations) {
                  // var rnd = BMMath.random();
                  for (j = 0; j < lenWiggle; j += 1) {
                    addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;
                  }

                  iWiggle += 1;
                } // var rnd2 = BMMath.random();

                var periods = time * freq;
                var perc = periods - Math.floor(periods);
                var arr = createTypedArray("float32", lenWiggle);

                if (lenWiggle > 1) {
                  for (j = 0; j < lenWiggle; j += 1) {
                    arr[j] =
                      this.pv[j] +
                      addedAmps[j] +
                      (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
                    // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
                  }

                  return arr;
                }

                return (
                  this.pv +
                  addedAmps[0] +
                  (-amp + amp * 2 * BMMath.random()) * perc
                );
              }.bind(this);

              if (thisProperty.loopIn) {
                loopIn = thisProperty.loopIn.bind(thisProperty);
                loop_in = loopIn;
              }

              if (thisProperty.loopOut) {
                loopOut = thisProperty.loopOut.bind(thisProperty);
                loop_out = loopOut;
              }

              if (thisProperty.smooth) {
                smooth = thisProperty.smooth.bind(thisProperty);
              }

              function loopInDuration(type, duration) {
                return loopIn(type, duration, true);
              }

              function loopOutDuration(type, duration) {
                return loopOut(type, duration, true);
              }

              if (this.getValueAtTime) {
                valueAtTime = this.getValueAtTime.bind(this);
              }

              if (this.getVelocityAtTime) {
                velocityAtTime = this.getVelocityAtTime.bind(this);
              }

              var comp = elem.comp.globalData.projectInterface.bind(
                elem.comp.globalData.projectInterface
              );

              function lookAt(elem1, elem2) {
                var fVec = [
                  elem2[0] - elem1[0],
                  elem2[1] - elem1[1],
                  elem2[2] - elem1[2],
                ];
                var pitch =
                  Math.atan2(
                    fVec[0],
                    Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])
                  ) / degToRads;
                var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
                return [yaw, pitch, 0];
              }

              function easeOut(t, tMin, tMax, val1, val2) {
                return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
              }

              function easeIn(t, tMin, tMax, val1, val2) {
                return applyEase(easeInBez, t, tMin, tMax, val1, val2);
              }

              function ease(t, tMin, tMax, val1, val2) {
                return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
              }

              function applyEase(fn, t, tMin, tMax, val1, val2) {
                if (val1 === undefined) {
                  val1 = tMin;
                  val2 = tMax;
                } else {
                  t = (t - tMin) / (tMax - tMin);
                }

                if (t > 1) {
                  t = 1;
                } else if (t < 0) {
                  t = 0;
                }

                var mult = fn(t);

                if ($bm_isInstanceOfArray(val1)) {
                  var iKey;
                  var lenKey = val1.length;
                  var arr = createTypedArray("float32", lenKey);

                  for (iKey = 0; iKey < lenKey; iKey += 1) {
                    arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                  }

                  return arr;
                }

                return (val2 - val1) * mult + val1;
              }

              function nearestKey(time) {
                var iKey;
                var lenKey = data.k.length;
                var index;
                var keyTime;

                if (!data.k.length || typeof data.k[0] === "number") {
                  index = 0;
                  keyTime = 0;
                } else {
                  index = -1;
                  time *= elem.comp.globalData.frameRate;

                  if (time < data.k[0].t) {
                    index = 1;
                    keyTime = data.k[0].t;
                  } else {
                    for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                      if (time === data.k[iKey].t) {
                        index = iKey + 1;
                        keyTime = data.k[iKey].t;
                        break;
                      } else if (
                        time > data.k[iKey].t &&
                        time < data.k[iKey + 1].t
                      ) {
                        if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                          index = iKey + 2;
                          keyTime = data.k[iKey + 1].t;
                        } else {
                          index = iKey + 1;
                          keyTime = data.k[iKey].t;
                        }

                        break;
                      }
                    }

                    if (index === -1) {
                      index = iKey + 1;
                      keyTime = data.k[iKey].t;
                    }
                  }
                }

                var obKey = {};
                obKey.index = index;
                obKey.time = keyTime / elem.comp.globalData.frameRate;
                return obKey;
              }

              function key(ind) {
                var obKey;
                var iKey;
                var lenKey;

                if (!data.k.length || typeof data.k[0] === "number") {
                  throw new Error(
                    "The property has no keyframe at index " + ind
                  );
                }

                ind -= 1;
                obKey = {
                  time: data.k[ind].t / elem.comp.globalData.frameRate,
                  value: [],
                };
                var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s")
                  ? data.k[ind].s
                  : data.k[ind - 1].e;
                lenKey = arr.length;

                for (iKey = 0; iKey < lenKey; iKey += 1) {
                  obKey[iKey] = arr[iKey];
                  obKey.value[iKey] = arr[iKey];
                }

                return obKey;
              }

              function framesToTime(fr, fps) {
                if (!fps) {
                  fps = elem.comp.globalData.frameRate;
                }

                return fr / fps;
              }

              function timeToFrames(t, fps) {
                if (!t && t !== 0) {
                  t = time;
                }

                if (!fps) {
                  fps = elem.comp.globalData.frameRate;
                }

                return t * fps;
              }

              function seedRandom(seed) {
                BMMath.seedrandom(randSeed + seed);
              }

              function sourceRectAtTime() {
                return elem.sourceRectAtTime();
              }

              function substring(init, end) {
                if (typeof value === "string") {
                  if (end === undefined) {
                    return value.substring(init);
                  }

                  return value.substring(init, end);
                }

                return "";
              }

              function substr(init, end) {
                if (typeof value === "string") {
                  if (end === undefined) {
                    return value.substr(init);
                  }

                  return value.substr(init, end);
                }

                return "";
              }

              function posterizeTime(framesPerSecond) {
                time =
                  framesPerSecond === 0
                    ? 0
                    : Math.floor(time * framesPerSecond) / framesPerSecond;
                value = valueAtTime(time);
              }

              var time;
              var velocity;
              var value;
              var text;
              var textIndex;
              var textTotal;
              var selectorValue;
              var index = elem.data.ind;
              var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
              var parent;
              var randSeed = Math.floor(Math.random() * 1000000);
              var globalData = elem.globalData;

              function executeExpression(_value) {
                // globalData.pushExpression();
                value = _value;

                if (
                  this.frameExpressionId === elem.globalData.frameId &&
                  this.propType !== "textSelector"
                ) {
                  return value;
                }

                if (this.propType === "textSelector") {
                  textIndex = this.textIndex;
                  textTotal = this.textTotal;
                  selectorValue = this.selectorValue;
                }

                if (!thisLayer) {
                  text = elem.layerInterface.text;
                  thisLayer = elem.layerInterface;
                  thisComp = elem.comp.compInterface;
                  toWorld = thisLayer.toWorld.bind(thisLayer);
                  fromWorld = thisLayer.fromWorld.bind(thisLayer);
                  fromComp = thisLayer.fromComp.bind(thisLayer);
                  toComp = thisLayer.toComp.bind(thisLayer);
                  mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                  fromCompToSurface = fromComp;
                }

                if (!transform) {
                  transform = elem.layerInterface("ADBE Transform Group");
                  $bm_transform = transform;

                  if (transform) {
                    anchorPoint = transform.anchorPoint;
                    /* position = transform.position;
                      rotation = transform.rotation;
                      scale = transform.scale; */
                  }
                }

                if (elemType === 4 && !content) {
                  content = thisLayer("ADBE Root Vectors Group");
                }

                if (!effect) {
                  effect = thisLayer(4);
                }

                hasParent = !!(elem.hierarchy && elem.hierarchy.length);

                if (hasParent && !parent) {
                  parent = elem.hierarchy[0].layerInterface;
                }

                time = this.comp.renderedFrame / this.comp.globalData.frameRate;

                if (_needsRandom) {
                  seedRandom(randSeed + time);
                }

                if (needsVelocity) {
                  velocity = velocityAtTime(time);
                }

                expression_function();
                this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value
                // Changed this to a ternary operation because Rollup failed compiling it correctly

                scoped_bm_rt =
                  scoped_bm_rt.propType === propTypes.SHAPE
                    ? scoped_bm_rt.v
                    : scoped_bm_rt;
                return scoped_bm_rt;
              } // Bundlers will see these as dead code and unless we reference them

              executeExpression.__preventDeadCodeRemoval = [
                $bm_transform,
                anchorPoint,
                time,
                velocity,
                inPoint,
                outPoint,
                width,
                height,
                name,
                loop_in,
                loop_out,
                smooth,
                toComp,
                fromCompToSurface,
                toWorld,
                fromWorld,
                mask,
                position,
                rotation,
                scale,
                thisComp,
                numKeys,
                active,
                wiggle,
                loopInDuration,
                loopOutDuration,
                comp,
                lookAt,
                easeOut,
                easeIn,
                ease,
                nearestKey,
                key,
                text,
                textIndex,
                textTotal,
                selectorValue,
                framesToTime,
                timeToFrames,
                sourceRectAtTime,
                substring,
                substr,
                posterizeTime,
                index,
                globalData,
              ];
              return executeExpression;
            }

            ob.initiateExpression = initiateExpression;
            ob.__preventDeadCodeRemoval = [
              window,
              document,
              XMLHttpRequest,
              fetch,
              frames,
              $bm_neg,
              add,
              $bm_sum,
              $bm_sub,
              $bm_mul,
              $bm_div,
              $bm_mod,
              clamp,
              radians_to_degrees,
              degreesToRadians,
              degrees_to_radians,
              normalize,
              rgbToHsl,
              hslToRgb,
              linear,
              random,
              createPath,
            ];
            return ob;
          })();

          var expressionHelpers = (function () {
            function searchExpressions(elem, data, prop) {
              if (data.x) {
                prop.k = true;
                prop.x = true;
                prop.initiateExpression = ExpressionManager.initiateExpression;
                prop.effectsSequence.push(
                  prop.initiateExpression(elem, data, prop).bind(prop)
                );
              }
            }

            function getValueAtTime(frameNum) {
              frameNum *= this.elem.globalData.frameRate;
              frameNum -= this.offsetTime;

              if (frameNum !== this._cachingAtTime.lastFrame) {
                this._cachingAtTime.lastIndex =
                  this._cachingAtTime.lastFrame < frameNum
                    ? this._cachingAtTime.lastIndex
                    : 0;
                this._cachingAtTime.value = this.interpolateValue(
                  frameNum,
                  this._cachingAtTime
                );
                this._cachingAtTime.lastFrame = frameNum;
              }

              return this._cachingAtTime.value;
            }

            function getSpeedAtTime(frameNum) {
              var delta = -0.01;
              var v1 = this.getValueAtTime(frameNum);
              var v2 = this.getValueAtTime(frameNum + delta);
              var speed = 0;

              if (v1.length) {
                var i;

                for (i = 0; i < v1.length; i += 1) {
                  speed += Math.pow(v2[i] - v1[i], 2);
                }

                speed = Math.sqrt(speed) * 100;
              } else {
                speed = 0;
              }

              return speed;
            }

            function getVelocityAtTime(frameNum) {
              if (this.vel !== undefined) {
                return this.vel;
              }

              var delta = -0.001; // frameNum += this.elem.data.st;

              var v1 = this.getValueAtTime(frameNum);
              var v2 = this.getValueAtTime(frameNum + delta);
              var velocity;

              if (v1.length) {
                velocity = createTypedArray("float32", v1.length);
                var i;

                for (i = 0; i < v1.length; i += 1) {
                  // removing frameRate
                  // if needed, don't add it here
                  // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
                  velocity[i] = (v2[i] - v1[i]) / delta;
                }
              } else {
                velocity = (v2 - v1) / delta;
              }

              return velocity;
            }

            function getStaticValueAtTime() {
              return this.pv;
            }

            function setGroupProperty(propertyGroup) {
              this.propertyGroup = propertyGroup;
            }

            return {
              searchExpressions: searchExpressions,
              getSpeedAtTime: getSpeedAtTime,
              getVelocityAtTime: getVelocityAtTime,
              getValueAtTime: getValueAtTime,
              getStaticValueAtTime: getStaticValueAtTime,
              setGroupProperty: setGroupProperty,
            };
          })();

          function addPropertyDecorator() {
            function loopOut(type, duration, durationFlag) {
              if (!this.k || !this.keyframes) {
                return this.pv;
              }

              type = type ? type.toLowerCase() : "";
              var currentFrame = this.comp.renderedFrame;
              var keyframes = this.keyframes;
              var lastKeyFrame = keyframes[keyframes.length - 1].t;

              if (currentFrame <= lastKeyFrame) {
                return this.pv;
              }

              var cycleDuration;
              var firstKeyFrame;

              if (!durationFlag) {
                if (!duration || duration > keyframes.length - 1) {
                  duration = keyframes.length - 1;
                }

                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
                cycleDuration = lastKeyFrame - firstKeyFrame;
              } else {
                if (!duration) {
                  cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
                } else {
                  cycleDuration = Math.abs(
                    lastKeyFrame -
                      this.elem.comp.globalData.frameRate * duration
                  );
                }

                firstKeyFrame = lastKeyFrame - cycleDuration;
              }

              var i;
              var len;
              var ret;

              if (type === "pingpong") {
                var iterations = Math.floor(
                  (currentFrame - firstKeyFrame) / cycleDuration
                );

                if (iterations % 2 !== 0) {
                  return this.getValueAtTime(
                    (cycleDuration -
                      ((currentFrame - firstKeyFrame) % cycleDuration) +
                      firstKeyFrame) /
                      this.comp.globalData.frameRate,
                    0
                  ); // eslint-disable-line
                }
              } else if (type === "offset") {
                var initV = this.getValueAtTime(
                  firstKeyFrame / this.comp.globalData.frameRate,
                  0
                );
                var endV = this.getValueAtTime(
                  lastKeyFrame / this.comp.globalData.frameRate,
                  0
                );
                var current = this.getValueAtTime(
                  (((currentFrame - firstKeyFrame) % cycleDuration) +
                    firstKeyFrame) /
                    this.comp.globalData.frameRate,
                  0
                ); // eslint-disable-line

                var repeats = Math.floor(
                  (currentFrame - firstKeyFrame) / cycleDuration
                );

                if (this.pv.length) {
                  ret = new Array(initV.length);
                  len = ret.length;

                  for (i = 0; i < len; i += 1) {
                    ret[i] = (endV[i] - initV[i]) * repeats + current[i];
                  }

                  return ret;
                }

                return (endV - initV) * repeats + current;
              } else if (type === "continue") {
                var lastValue = this.getValueAtTime(
                  lastKeyFrame / this.comp.globalData.frameRate,
                  0
                );
                var nextLastValue = this.getValueAtTime(
                  (lastKeyFrame - 0.001) / this.comp.globalData.frameRate,
                  0
                );

                if (this.pv.length) {
                  ret = new Array(lastValue.length);
                  len = ret.length;

                  for (i = 0; i < len; i += 1) {
                    ret[i] =
                      lastValue[i] +
                      ((lastValue[i] - nextLastValue[i]) *
                        ((currentFrame - lastKeyFrame) /
                          this.comp.globalData.frameRate)) /
                        0.0005; // eslint-disable-line
                  }

                  return ret;
                }

                return (
                  lastValue +
                  (lastValue - nextLastValue) *
                    ((currentFrame - lastKeyFrame) / 0.001)
                );
              }

              return this.getValueAtTime(
                (((currentFrame - firstKeyFrame) % cycleDuration) +
                  firstKeyFrame) /
                  this.comp.globalData.frameRate,
                0
              ); // eslint-disable-line
            }

            function loopIn(type, duration, durationFlag) {
              if (!this.k) {
                return this.pv;
              }

              type = type ? type.toLowerCase() : "";
              var currentFrame = this.comp.renderedFrame;
              var keyframes = this.keyframes;
              var firstKeyFrame = keyframes[0].t;

              if (currentFrame >= firstKeyFrame) {
                return this.pv;
              }

              var cycleDuration;
              var lastKeyFrame;

              if (!durationFlag) {
                if (!duration || duration > keyframes.length - 1) {
                  duration = keyframes.length - 1;
                }

                lastKeyFrame = keyframes[duration].t;
                cycleDuration = lastKeyFrame - firstKeyFrame;
              } else {
                if (!duration) {
                  cycleDuration = Math.max(
                    0,
                    this.elem.data.op - firstKeyFrame
                  );
                } else {
                  cycleDuration = Math.abs(
                    this.elem.comp.globalData.frameRate * duration
                  );
                }

                lastKeyFrame = firstKeyFrame + cycleDuration;
              }

              var i;
              var len;
              var ret;

              if (type === "pingpong") {
                var iterations = Math.floor(
                  (firstKeyFrame - currentFrame) / cycleDuration
                );

                if (iterations % 2 === 0) {
                  return this.getValueAtTime(
                    (((firstKeyFrame - currentFrame) % cycleDuration) +
                      firstKeyFrame) /
                      this.comp.globalData.frameRate,
                    0
                  ); // eslint-disable-line
                }
              } else if (type === "offset") {
                var initV = this.getValueAtTime(
                  firstKeyFrame / this.comp.globalData.frameRate,
                  0
                );
                var endV = this.getValueAtTime(
                  lastKeyFrame / this.comp.globalData.frameRate,
                  0
                );
                var current = this.getValueAtTime(
                  (cycleDuration -
                    ((firstKeyFrame - currentFrame) % cycleDuration) +
                    firstKeyFrame) /
                    this.comp.globalData.frameRate,
                  0
                );
                var repeats =
                  Math.floor((firstKeyFrame - currentFrame) / cycleDuration) +
                  1;

                if (this.pv.length) {
                  ret = new Array(initV.length);
                  len = ret.length;

                  for (i = 0; i < len; i += 1) {
                    ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
                  }

                  return ret;
                }

                return current - (endV - initV) * repeats;
              } else if (type === "continue") {
                var firstValue = this.getValueAtTime(
                  firstKeyFrame / this.comp.globalData.frameRate,
                  0
                );
                var nextFirstValue = this.getValueAtTime(
                  (firstKeyFrame + 0.001) / this.comp.globalData.frameRate,
                  0
                );

                if (this.pv.length) {
                  ret = new Array(firstValue.length);
                  len = ret.length;

                  for (i = 0; i < len; i += 1) {
                    ret[i] =
                      firstValue[i] +
                      ((firstValue[i] - nextFirstValue[i]) *
                        (firstKeyFrame - currentFrame)) /
                        0.001;
                  }

                  return ret;
                }

                return (
                  firstValue +
                  ((firstValue - nextFirstValue) *
                    (firstKeyFrame - currentFrame)) /
                    0.001
                );
              }

              return this.getValueAtTime(
                (cycleDuration -
                  (((firstKeyFrame - currentFrame) % cycleDuration) +
                    firstKeyFrame)) /
                  this.comp.globalData.frameRate,
                0
              ); // eslint-disable-line
            }

            function smooth(width, samples) {
              if (!this.k) {
                return this.pv;
              }

              width = (width || 0.4) * 0.5;
              samples = Math.floor(samples || 5);

              if (samples <= 1) {
                return this.pv;
              }

              var currentTime =
                this.comp.renderedFrame / this.comp.globalData.frameRate;
              var initFrame = currentTime - width;
              var endFrame = currentTime + width;
              var sampleFrequency =
                samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
              var i = 0;
              var j = 0;
              var value;

              if (this.pv.length) {
                value = createTypedArray("float32", this.pv.length);
              } else {
                value = 0;
              }

              var sampleValue;

              while (i < samples) {
                sampleValue = this.getValueAtTime(
                  initFrame + i * sampleFrequency
                );

                if (this.pv.length) {
                  for (j = 0; j < this.pv.length; j += 1) {
                    value[j] += sampleValue[j];
                  }
                } else {
                  value += sampleValue;
                }

                i += 1;
              }

              if (this.pv.length) {
                for (j = 0; j < this.pv.length; j += 1) {
                  value[j] /= samples;
                }
              } else {
                value /= samples;
              }

              return value;
            }

            function getTransformValueAtTime(time) {
              if (!this._transformCachingAtTime) {
                this._transformCachingAtTime = {
                  v: new Matrix(),
                };
              } /// /

              var matrix = this._transformCachingAtTime.v;
              matrix.cloneFromProps(this.pre.props);

              if (this.appliedTransformations < 1) {
                var anchor = this.a.getValueAtTime(time);
                matrix.translate(
                  -anchor[0] * this.a.mult,
                  -anchor[1] * this.a.mult,
                  anchor[2] * this.a.mult
                );
              }

              if (this.appliedTransformations < 2) {
                var scale = this.s.getValueAtTime(time);
                matrix.scale(
                  scale[0] * this.s.mult,
                  scale[1] * this.s.mult,
                  scale[2] * this.s.mult
                );
              }

              if (this.sk && this.appliedTransformations < 3) {
                var skew = this.sk.getValueAtTime(time);
                var skewAxis = this.sa.getValueAtTime(time);
                matrix.skewFromAxis(
                  -skew * this.sk.mult,
                  skewAxis * this.sa.mult
                );
              }

              if (this.r && this.appliedTransformations < 4) {
                var rotation = this.r.getValueAtTime(time);
                matrix.rotate(-rotation * this.r.mult);
              } else if (!this.r && this.appliedTransformations < 4) {
                var rotationZ = this.rz.getValueAtTime(time);
                var rotationY = this.ry.getValueAtTime(time);
                var rotationX = this.rx.getValueAtTime(time);
                var orientation = this.or.getValueAtTime(time);
                matrix
                  .rotateZ(-rotationZ * this.rz.mult)
                  .rotateY(rotationY * this.ry.mult)
                  .rotateX(rotationX * this.rx.mult)
                  .rotateZ(-orientation[2] * this.or.mult)
                  .rotateY(orientation[1] * this.or.mult)
                  .rotateX(orientation[0] * this.or.mult);
              }

              if (this.data.p && this.data.p.s) {
                var positionX = this.px.getValueAtTime(time);
                var positionY = this.py.getValueAtTime(time);

                if (this.data.p.z) {
                  var positionZ = this.pz.getValueAtTime(time);
                  matrix.translate(
                    positionX * this.px.mult,
                    positionY * this.py.mult,
                    -positionZ * this.pz.mult
                  );
                } else {
                  matrix.translate(
                    positionX * this.px.mult,
                    positionY * this.py.mult,
                    0
                  );
                }
              } else {
                var position = this.p.getValueAtTime(time);
                matrix.translate(
                  position[0] * this.p.mult,
                  position[1] * this.p.mult,
                  -position[2] * this.p.mult
                );
              }

              return matrix; /// /
            }

            function getTransformStaticValueAtTime() {
              return this.v.clone(new Matrix());
            }

            var getTransformProperty =
              TransformPropertyFactory.getTransformProperty;

            TransformPropertyFactory.getTransformProperty = function (
              elem,
              data,
              container
            ) {
              var prop = getTransformProperty(elem, data, container);

              if (prop.dynamicProperties.length) {
                prop.getValueAtTime = getTransformValueAtTime.bind(prop);
              } else {
                prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
              }

              prop.setGroupProperty = expressionHelpers.setGroupProperty;
              return prop;
            };

            var propertyGetProp = PropertyFactory.getProp;

            PropertyFactory.getProp = function (
              elem,
              data,
              type,
              mult,
              container
            ) {
              var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;
              // prop.loopOut = loopOut;
              // prop.loopIn = loopIn;

              if (prop.kf) {
                prop.getValueAtTime =
                  expressionHelpers.getValueAtTime.bind(prop);
              } else {
                prop.getValueAtTime =
                  expressionHelpers.getStaticValueAtTime.bind(prop);
              }

              prop.setGroupProperty = expressionHelpers.setGroupProperty;
              prop.loopOut = loopOut;
              prop.loopIn = loopIn;
              prop.smooth = smooth;
              prop.getVelocityAtTime =
                expressionHelpers.getVelocityAtTime.bind(prop);
              prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
              prop.numKeys = data.a === 1 ? data.k.length : 0;
              prop.propertyIndex = data.ix;
              var value = 0;

              if (type !== 0) {
                value = createTypedArray(
                  "float32",
                  data.a === 1 ? data.k[0].s.length : data.k.length
                );
              }

              prop._cachingAtTime = {
                lastFrame: initialDefaultFrame,
                lastIndex: 0,
                value: value,
              };
              expressionHelpers.searchExpressions(elem, data, prop);

              if (prop.k) {
                container.addDynamicProperty(prop);
              }

              return prop;
            };

            function getShapeValueAtTime(frameNum) {
              // For now this caching object is created only when needed instead of creating it when the shape is initialized.
              if (!this._cachingAtTime) {
                this._cachingAtTime = {
                  shapeValue: shapePool.clone(this.pv),
                  lastIndex: 0,
                  lastTime: initialDefaultFrame,
                };
              }

              frameNum *= this.elem.globalData.frameRate;
              frameNum -= this.offsetTime;

              if (frameNum !== this._cachingAtTime.lastTime) {
                this._cachingAtTime.lastIndex =
                  this._cachingAtTime.lastTime < frameNum
                    ? this._caching.lastIndex
                    : 0;
                this._cachingAtTime.lastTime = frameNum;
                this.interpolateShape(
                  frameNum,
                  this._cachingAtTime.shapeValue,
                  this._cachingAtTime
                );
              }

              return this._cachingAtTime.shapeValue;
            }

            var ShapePropertyConstructorFunction =
              ShapePropertyFactory.getConstructorFunction();
            var KeyframedShapePropertyConstructorFunction =
              ShapePropertyFactory.getKeyframedConstructorFunction();

            function ShapeExpressions() {}

            ShapeExpressions.prototype = {
              vertices: function vertices(prop, time) {
                if (this.k) {
                  this.getValue();
                }

                var shapePath = this.v;

                if (time !== undefined) {
                  shapePath = this.getValueAtTime(time, 0);
                }

                var i;
                var len = shapePath._length;
                var vertices = shapePath[prop];
                var points = shapePath.v;
                var arr = createSizedArray(len);

                for (i = 0; i < len; i += 1) {
                  if (prop === "i" || prop === "o") {
                    arr[i] = [
                      vertices[i][0] - points[i][0],
                      vertices[i][1] - points[i][1],
                    ];
                  } else {
                    arr[i] = [vertices[i][0], vertices[i][1]];
                  }
                }

                return arr;
              },
              points: function points(time) {
                return this.vertices("v", time);
              },
              inTangents: function inTangents(time) {
                return this.vertices("i", time);
              },
              outTangents: function outTangents(time) {
                return this.vertices("o", time);
              },
              isClosed: function isClosed() {
                return this.v.c;
              },
              pointOnPath: function pointOnPath(perc, time) {
                var shapePath = this.v;

                if (time !== undefined) {
                  shapePath = this.getValueAtTime(time, 0);
                }

                if (!this._segmentsLength) {
                  this._segmentsLength = bez.getSegmentsLength(shapePath);
                }

                var segmentsLength = this._segmentsLength;
                var lengths = segmentsLength.lengths;
                var lengthPos = segmentsLength.totalLength * perc;
                var i = 0;
                var len = lengths.length;
                var accumulatedLength = 0;
                var pt;

                while (i < len) {
                  if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                    var initIndex = i;
                    var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
                    var segmentPerc =
                      (lengthPos - accumulatedLength) / lengths[i].addedLength;
                    pt = bez.getPointInSegment(
                      shapePath.v[initIndex],
                      shapePath.v[endIndex],
                      shapePath.o[initIndex],
                      shapePath.i[endIndex],
                      segmentPerc,
                      lengths[i]
                    );
                    break;
                  } else {
                    accumulatedLength += lengths[i].addedLength;
                  }

                  i += 1;
                }

                if (!pt) {
                  pt = shapePath.c
                    ? [shapePath.v[0][0], shapePath.v[0][1]]
                    : [
                        shapePath.v[shapePath._length - 1][0],
                        shapePath.v[shapePath._length - 1][1],
                      ];
                }

                return pt;
              },
              vectorOnPath: function vectorOnPath(perc, time, vectorType) {
                // perc doesn't use triple equality because it can be a Number object as well as a primitive.
                if (perc == 1) {
                  // eslint-disable-line eqeqeq
                  perc = this.v.c;
                } else if (perc == 0) {
                  // eslint-disable-line eqeqeq
                  perc = 0.999;
                }

                var pt1 = this.pointOnPath(perc, time);
                var pt2 = this.pointOnPath(perc + 0.001, time);
                var xLength = pt2[0] - pt1[0];
                var yLength = pt2[1] - pt1[1];
                var magnitude = Math.sqrt(
                  Math.pow(xLength, 2) + Math.pow(yLength, 2)
                );

                if (magnitude === 0) {
                  return [0, 0];
                }

                var unitVector =
                  vectorType === "tangent"
                    ? [xLength / magnitude, yLength / magnitude]
                    : [-yLength / magnitude, xLength / magnitude];
                return unitVector;
              },
              tangentOnPath: function tangentOnPath(perc, time) {
                return this.vectorOnPath(perc, time, "tangent");
              },
              normalOnPath: function normalOnPath(perc, time) {
                return this.vectorOnPath(perc, time, "normal");
              },
              setGroupProperty: expressionHelpers.setGroupProperty,
              getValueAtTime: expressionHelpers.getStaticValueAtTime,
            };
            extendPrototype(
              [ShapeExpressions],
              ShapePropertyConstructorFunction
            );
            extendPrototype(
              [ShapeExpressions],
              KeyframedShapePropertyConstructorFunction
            );
            KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime =
              getShapeValueAtTime;
            KeyframedShapePropertyConstructorFunction.prototype.initiateExpression =
              ExpressionManager.initiateExpression;
            var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;

            ShapePropertyFactory.getShapeProp = function (
              elem,
              data,
              type,
              arr,
              trims
            ) {
              var prop = propertyGetShapeProp(elem, data, type, arr, trims);
              prop.propertyIndex = data.ix;
              prop.lock = false;

              if (type === 3) {
                expressionHelpers.searchExpressions(elem, data.pt, prop);
              } else if (type === 4) {
                expressionHelpers.searchExpressions(elem, data.ks, prop);
              }

              if (prop.k) {
                elem.addDynamicProperty(prop);
              }

              return prop;
            };
          }

          function initialize$1() {
            addPropertyDecorator();
          }

          function addDecorator() {
            function searchExpressions() {
              if (this.data.d.x) {
                this.calculateExpression =
                  ExpressionManager.initiateExpression.bind(this)(
                    this.elem,
                    this.data.d,
                    this
                  );
                this.addEffect(this.getExpressionValue.bind(this));
                return true;
              }

              return null;
            }

            TextProperty.prototype.getExpressionValue = function (
              currentValue,
              text
            ) {
              var newValue = this.calculateExpression(text);

              if (currentValue.t !== newValue) {
                var newData = {};
                this.copyData(newData, currentValue);
                newData.t = newValue.toString();
                newData.__complete = false;
                return newData;
              }

              return currentValue;
            };

            TextProperty.prototype.searchProperty = function () {
              var isKeyframed = this.searchKeyframes();
              var hasExpressions = this.searchExpressions();
              this.kf = isKeyframed || hasExpressions;
              return this.kf;
            };

            TextProperty.prototype.searchExpressions = searchExpressions;
          }

          function initialize() {
            addDecorator();
          }

          registerRenderer("canvas", CanvasRenderer);
          registerRenderer("html", HybridRenderer);
          registerRenderer("svg", SVGRenderer); // Registering shape modifiers

          ShapeModifiers.registerModifier("tm", TrimModifier);
          ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
          ShapeModifiers.registerModifier("rp", RepeaterModifier);
          ShapeModifiers.registerModifier("rd", RoundCornersModifier); // Registering expression plugin

          setExpressionsPlugin(Expressions);
          initialize$1();
          initialize(); // Registering svg effects

          registerEffect(20, SVGTintFilter, true);
          registerEffect(21, SVGFillFilter, true);
          registerEffect(22, SVGStrokeEffect, false);
          registerEffect(23, SVGTritoneFilter, true);
          registerEffect(24, SVGProLevelsFilter, true);
          registerEffect(25, SVGDropShadowEffect, true);
          registerEffect(28, SVGMatte3Effect, false);
          registerEffect(29, SVGGaussianBlurEffect, true);

          return lottie;
        });

      /***/
    },

    /***/ 26: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);
      var settle = __webpack_require__(61);
      var cookies = __webpack_require__(62);
      var buildURL = __webpack_require__(23);
      var buildFullPath = __webpack_require__(27);
      var parseHeaders = __webpack_require__(65);
      var isURLSameOrigin = __webpack_require__(66);
      var transitionalDefaults = __webpack_require__(24);
      var AxiosError = __webpack_require__(2);
      var CanceledError = __webpack_require__(8);
      var parseProtocol = __webpack_require__(67);

      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }

            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }

          if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
            delete requestHeaders["Content-Type"]; // Let the browser set it
          }

          var request = new XMLHttpRequest();

          // HTTP basic authentication
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password
              ? unescape(encodeURIComponent(config.auth.password))
              : "";
            requestHeaders.Authorization =
              "Basic " + btoa(username + ":" + password);
          }

          var fullPath = buildFullPath(config.baseURL, config.url);

          request.open(
            config.method.toUpperCase(),
            buildURL(fullPath, config.params, config.paramsSerializer),
            true
          );

          // Set the request timeout in MS
          request.timeout = config.timeout;

          function onloadend() {
            if (!request) {
              return;
            }
            // Prepare the response
            var responseHeaders =
              "getAllResponseHeaders" in request
                ? parseHeaders(request.getAllResponseHeaders())
                : null;
            var responseData =
              !responseType ||
              responseType === "text" ||
              responseType === "json"
                ? request.responseText
                : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config,
              request: request,
            };

            settle(
              function _resolve(value) {
                resolve(value);
                done();
              },
              function _reject(err) {
                reject(err);
                done();
              },
              response
            );

            // Clean up request
            request = null;
          }

          if ("onloadend" in request) {
            // Use onloadend if available
            request.onloadend = onloadend;
          } else {
            // Listen for ready state to emulate onloadend
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }

              // The request errored out and we didn't get a response, this will be
              // handled by onerror instead
              // With one exception: request that using file: protocol, most browsers
              // will return status as 0 even though it's a successful request
              if (
                request.status === 0 &&
                !(
                  request.responseURL &&
                  request.responseURL.indexOf("file:") === 0
                )
              ) {
                return;
              }
              // readystate handler is calling before onerror or ontimeout handlers,
              // so we should call onloadend on the next 'tick'
              setTimeout(onloadend);
            };
          }

          // Handle browser request cancellation (as opposed to a manual cancellation)
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }

            reject(
              new AxiosError(
                "Request aborted",
                AxiosError.ECONNABORTED,
                config,
                request
              )
            );

            // Clean up request
            request = null;
          };

          // Handle low level network errors
          request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(
              new AxiosError(
                "Network Error",
                AxiosError.ERR_NETWORK,
                config,
                request,
                request
              )
            );

            // Clean up request
            request = null;
          };

          // Handle timeout
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout
              ? "timeout of " + config.timeout + "ms exceeded"
              : "timeout exceeded";
            var transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(
              new AxiosError(
                timeoutErrorMessage,
                transitional.clarifyTimeoutError
                  ? AxiosError.ETIMEDOUT
                  : AxiosError.ECONNABORTED,
                config,
                request
              )
            );

            // Clean up request
            request = null;
          };

          // Add xsrf header
          // This is only done if running in a standard browser environment.
          // Specifically not if we're in a web worker, or react-native.
          if (utils.isStandardBrowserEnv()) {
            // Add xsrf header
            var xsrfValue =
              (config.withCredentials || isURLSameOrigin(fullPath)) &&
              config.xsrfCookieName
                ? cookies.read(config.xsrfCookieName)
                : undefined;

            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }

          // Add headers to the request
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (
                typeof requestData === "undefined" &&
                key.toLowerCase() === "content-type"
              ) {
                // Remove Content-Type if data is undefined
                delete requestHeaders[key];
              } else {
                // Otherwise add header to the request
                request.setRequestHeader(key, val);
              }
            });
          }

          // Add withCredentials to request if needed
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }

          // Add responseType to request if needed
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }

          // Handle progress if needed
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }

          // Not all browsers support upload events
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener(
              "progress",
              config.onUploadProgress
            );
          }

          if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = function onCanceled(cancel) {
              if (!request) {
                return;
              }
              reject(
                !cancel || (cancel && cancel.type)
                  ? new CanceledError()
                  : cancel
              );
              request.abort();
              request = null;
            };

            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted
                ? onCanceled()
                : config.signal.addEventListener("abort", onCanceled);
            }
          }

          if (!requestData) {
            requestData = null;
          }

          var protocol = parseProtocol(fullPath);

          if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
            reject(
              new AxiosError(
                "Unsupported protocol " + protocol + ":",
                AxiosError.ERR_BAD_REQUEST,
                config
              )
            );
            return;
          }

          // Send the request
          request.send(requestData);
        });
      };

      /***/
    },

    /***/ 264: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _createClass = (function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      })();

      var _lottieWeb = __webpack_require__(250);

      var _lottieWeb2 = _interopRequireDefault(_lottieWeb);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var LottieLoad = (function () {
        function LottieLoad() {
          _classCallCheck(this, LottieLoad);

          this.container = null;
          this.renderer = "canvas";
          this.animationData = null;
          this.loop = true;
          this.autoplay = true;
          this.lottie = null;
        }

        _createClass(LottieLoad, [
          {
            key: "load",
            value: function load() {
              if (!this.container) throw new Error("There is no container!");

              if (!this.animationData)
                throw new Error("There is no animation data!");

              this.lottie = _lottieWeb2.default.loadAnimation({
                container: this.container, // the dom element that will contain the animation
                renderer: this.renderer,
                loop: this.loop,
                autoplay: this.autoplay,
                animationData: this.animationData, // the path to the animation json
              });
            },
          },
          {
            key: "destroy",
            value: function destroy() {
              this.lottie.destroy();
            },
          },
          {
            key: "stop",
            value: function stop() {
              this.lottie.stop();
            },
          },
          {
            key: "setDirectionForward",
            value: function setDirectionForward() {
              this.lottie.setDirection(1);
            },
          },
          {
            key: "setDirectionBack",
            value: function setDirectionBack() {
              this.lottie.setDirection(-1);
            },
          },
          {
            key: "play",
            value: function play() {
              this.lottie.play();
            },
          },
          {
            key: "playSegments",
            value: function playSegments(segments, forceFlag) {
              this.lottie.playSegments(segments, forceFlag);
            },
          },
        ]);

        return LottieLoad;
      })();

      exports.default = LottieLoad;

      /***/
    },

    /***/ 27: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var isAbsoluteURL = __webpack_require__(63);
      var combineURLs = __webpack_require__(64);

      /**
       * Creates a new URL by combining the baseURL with the requestedURL,
       * only when the requestedURL is not already an absolute URL.
       * If the requestURL is absolute, this function returns the requestedURL untouched.
       *
       * @param {string} baseURL The base URL
       * @param {string} requestedURL Absolute or relative URL to combine
       * @returns {string} The combined full path
       */
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };

      /***/
    },

    /***/ 28: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };

      /***/
    },

    /***/ 29: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      /**
       * Config-specific merge-function which creates a new config-object
       * by merging two configuration objects together.
       *
       * @param {Object} config1
       * @param {Object} config2
       * @returns {Object} New object resulting from merging config2 to config1
       */
      module.exports = function mergeConfig(config1, config2) {
        // eslint-disable-next-line no-param-reassign
        config2 = config2 || {};
        var config = {};

        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }

        // eslint-disable-next-line consistent-return
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(undefined, config1[prop]);
          }
        }

        // eslint-disable-next-line consistent-return
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(undefined, config2[prop]);
          }
        }

        // eslint-disable-next-line consistent-return
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(undefined, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(undefined, config1[prop]);
          }
        }

        // eslint-disable-next-line consistent-return
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(undefined, config1[prop]);
          }
        }

        var mergeMap = {
          url: valueFromConfig2,
          method: valueFromConfig2,
          data: valueFromConfig2,
          baseURL: defaultToConfig2,
          transformRequest: defaultToConfig2,
          transformResponse: defaultToConfig2,
          paramsSerializer: defaultToConfig2,
          timeout: defaultToConfig2,
          timeoutMessage: defaultToConfig2,
          withCredentials: defaultToConfig2,
          adapter: defaultToConfig2,
          responseType: defaultToConfig2,
          xsrfCookieName: defaultToConfig2,
          xsrfHeaderName: defaultToConfig2,
          onUploadProgress: defaultToConfig2,
          onDownloadProgress: defaultToConfig2,
          decompress: defaultToConfig2,
          maxContentLength: defaultToConfig2,
          maxBodyLength: defaultToConfig2,
          beforeRedirect: defaultToConfig2,
          transport: defaultToConfig2,
          httpAgent: defaultToConfig2,
          httpsAgent: defaultToConfig2,
          cancelToken: defaultToConfig2,
          socketPath: defaultToConfig2,
          responseEncoding: defaultToConfig2,
          validateStatus: mergeDirectKeys,
        };

        utils.forEach(
          Object.keys(config1).concat(Object.keys(config2)),
          function computeConfigValue(prop) {
            var merge = mergeMap[prop] || mergeDeepProperties;
            var configValue = merge(prop);
            (utils.isUndefined(configValue) && merge !== mergeDirectKeys) ||
              (config[prop] = configValue);
          }
        );

        return config;
      };

      /***/
    },

    /***/ 3: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var assign = __webpack_require__(42);

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        virtualPage: function virtualPage(configs) {
          configs = assign.assign(
            {
              command: "send",
              type: "pageview",
              page: "",
            },
            configs
          );

          ga(configs.command, configs.type, configs.page);
        },
        sendEvent: function sendEvent(configs) {
          configs = assign.assign(
            {
              command: "send",
              type: "event",
              eventCategory: "",
              eventAction: "",
              eventLabel: "",
            },
            configs
          );

          ga(
            configs.command,
            configs.type,
            configs.eventCategory,
            configs.eventAction,
            configs.eventLabel
          );
        },
      };

      /***/
    },

    /***/ 30: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = {
        version: "0.27.2",
      };

      /***/
    },

    /***/ 31: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var isObject = __webpack_require__(11),
        now = __webpack_require__(75),
        toNumber = __webpack_require__(76);

      /** Error message constants. */
      var FUNC_ERROR_TEXT = "Expected a function";

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max,
        nativeMin = Math.min;

      /**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */
      function debounce(func, wait, options) {
        var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing
            ? nativeMax(toNumber(options.maxWait) || 0, wait)
            : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
            thisArg = lastThis;

          lastArgs = lastThis = undefined;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          // Reset any `maxWait` timer.
          lastInvokeTime = time;
          // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
          // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

          return maxing
            ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.
          return (
            lastCallTime === undefined ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && timeSinceLastInvoke >= maxWait)
          );
        }

        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined;
          return result;
        }

        function cancel() {
          if (timerId !== undefined) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined;
        }

        function flush() {
          return timerId === undefined ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
            isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              // Handle invocations in a tight loop.
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      module.exports = debounce;

      /***/
    },

    /***/ 32: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var root = __webpack_require__(21);

      /** Built-in value references. */
      var _Symbol = root.Symbol;

      module.exports = _Symbol;

      /***/
    },

    /***/ 33: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */
      // var SVGPolyfill = require("../polyfills/svg");

      var viewport = __webpack_require__(20);
      var Handlers = __webpack_require__(7);
      var requestEstimatePopup = __webpack_require__(16);
      var scrollBlocker = __webpack_require__(10);
      var debounce = __webpack_require__(31);
      var throttle = __webpack_require__(74);

      /**
       * @private
       */
      var DOM = {};
      var handlers = new Handlers();
      var marker = {
        enableMobileHandlers: false,
        navIcoAnimateTimer: false,
      };

      // SVGPolyfill.init();

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: function init() {
          requestEstimatePopup.init();
          setDOM();
          initHandlers();
          fixSafariScroll();
          // toggleTransparentLayout();

          /* http://gitlab.BCL.office/mercdev.com/Web/merge_requests/902  -  */
        },
        isOpen: isOpen,
        on: handlers.add.bind(handlers),
        off: handlers.remove.bind(handlers),
      };

      /**
       * @private
       */
      function isOpen() {
        return DOM.nav.classList.contains("active");
      }

      /**
       * @private
       */
      function setDOM() {
        DOM.nav = document.querySelector(".js-nav");
        DOM.header = document.querySelector(".l-header");
        DOM.content = document.querySelector(".c-slides");
        DOM.main = document.querySelector(".c-slides-main");

        // for mobile
        DOM.mobileRequestEstimateLink = DOM.nav.querySelector(
          ".js-nav_request_estimate_link"
        );
        DOM.navIco = DOM.nav.querySelector(".js-nav_ico");
        DOM.navWrap = DOM.nav.querySelector(".c-nav_wrap");
        DOM.navOverlay = DOM.nav.querySelector(".c-nav_overlay");
        DOM.scrollable = document.querySelectorAll(".scrollable");
      }

      /**
       * @private
       */
      function initHandlers() {
        viewport.isMobile() && enableMobileHandlers();

        initToggleTransparentLayout();

        window.addEventListener(
          "resize",
          debounce(function () {
            viewport.isMobile()
              ? enableMobileHandlers()
              : disableMobileHandlers();

            // close mobile menu on viewport change (for iPad)
            if (isOpen() && !viewport.isMobile()) {
              toggleNavIcon();
            }
          }, 300)
        );
      }

      function fixSafariScroll() {
        // About the problem: https://github.com/scottjehl/device-bugs/issues/23
        function getSafariVersion() {
          var navUserAgent = navigator.userAgent;
          var tempVersionOffset = void 0;
          var tempVersion = void 0;
          var browserVersion = void 0;

          if ((tempVersionOffset = navUserAgent.indexOf("Safari")) !== -1) {
            browserVersion = navUserAgent.substring(tempVersionOffset + 7);

            if ((tempVersionOffset = navUserAgent.indexOf("Version")) !== -1) {
              browserVersion = navUserAgent.substring(tempVersionOffset + 8);
            }
          } else {
            return false;
          }

          if ((tempVersion = browserVersion.indexOf(";")) != -1) {
            browserVersion = browserVersion.substring(0, tempVersion);
          }

          if ((tempVersion = browserVersion.indexOf(" ")) !== -1) {
            browserVersion = browserVersion.substring(0, tempVersion);
          }

          return parseFloat(browserVersion);
        }

        var safariVersion = getSafariVersion();

        if (safariVersion && safariVersion < 13) {
          if (DOM.main) {
            if (DOM.header) {
              DOM.header.classList.add("l-header--sticky");
            }
            if (DOM.content) {
              DOM.content.classList.add("c-slides--relative");
            }
          }
        }
      }

      /**
       * @private
       */
      function enableMobileHandlers() {
        if (!marker.enableMobileHandlers) {
          marker.enableMobileHandlers = true;

          navCollapse();

          window.addEventListener(
            "scroll",
            throttle(function () {
              navCollapse();
            }, 300)
          );

          DOM.mobileRequestEstimateLink.addEventListener(
            "click",
            requestEstimateShow
          );

          // nav ico
          DOM.navIco.addEventListener("click", toggleNavIcon);
        }
      }

      /**
       * @private
       */
      function disableMobileHandlers() {
        if (marker.enableMobileHandlers) {
          marker.enableMobileHandlers = false;

          navCollapse();

          window.removeEventListener("scroll", navCollapse);

          DOM.mobileRequestEstimateLink.removeEventListener(
            "click",
            requestEstimateShow
          );

          // nav ico
          DOM.navIco.removeEventListener("click", toggleNavIcon);
        }
      }

      /**
       * @private
       */
      function navCollapse() {
        var isCollapse = isHeaderScrolled();
        var domNavClassList = DOM.nav.classList;

        if (isCollapse) domNavClassList.add("collapse");
        else domNavClassList.remove("collapse");

        handlers.call("collapse", [isCollapse], DOM.nav);
      }

      /**
       * @private
       * @returns {boolean}
       */
      function isHeaderScrolled() {
        if (isOpen()) {
          return false;
        }

        return window.pageYOffset &&
          window.pageYOffset > DOM.nav.parentNode.offsetHeight
          ? true
          : false;
      }

      /**
       * @private
       */
      function requestEstimateShow() {
        requestEstimatePopup.show();
      }

      /**
       * @private
       */

      function toggleNavIcon() {
        var isActive = DOM.nav.classList.toggle("active");

        iosBodyScrolling(isActive);

        DOM.navIco.classList.toggle("active");
        DOM.header.classList.toggle("opened");

        handlers.call("active", [isActive], DOM.nav);
        !isActive &&
          viewport.isMobile() &&
          requestEstimatePopup.isShow() &&
          requestEstimatePopup.hide();
        // if (!isActive && !requestEstimatePopup.isShow()) {
        // 	scrollBlocker.scrollOn();
        // } else {
        // 	scrollBlocker.scrollOff();
        // }
      }

      function iosBodyScrolling(bool) {
        window.removeEventListener("touchmove", prevent);
        [].forEach.call(DOM.scrollable, function (item) {
          item.removeEventListener("touchstart", elPos);
          item.removeEventListener("touchmove", stopProp);
        });

        if (bool) {
          window.addEventListener("touchmove", prevent);
          [].forEach.call(DOM.scrollable, function (item) {
            item.addEventListener("touchstart", elPos);
            item.addEventListener("touchmove", stopProp);
          });
        }
      }

      function prevent(e) {
        e.preventDefault();
      }

      function elPos(e) {
        if (e.currentTarget.scrollTop === 0) {
          e.currentTarget.scrollTop = 1;
        } else if (
          e.currentTarget.scrollHeight ===
          e.currentTarget.scrollTop + e.currentTarget.offsetHeight
        ) {
          e.currentTarget.scrollTop -= 1;
        }
      }

      function stopProp(e) {
        e.stopPropagation();
      }

      function initToggleTransparentLayout() {
        var isTransparentSupport = DOM.header.classList.contains(
          "js-toggle-transparent"
        );

        if (viewport.isMobile() || !isTransparentSupport) return;

        toggleTransparentLayout();

        window.addEventListener(
          "scroll",
          throttle(function () {
            toggleTransparentLayout();
          }, 300)
        );
      }

      function toggleTransparentLayout() {
        var isScrolled = window.pageYOffset > 0;

        DOM.header.classList.toggle("l-header--transparent", !isScrolled);
      }

      /***/
    },

    /***/ 34: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var global = __webpack_require__(35);
      var core = __webpack_require__(9);
      var ctx = __webpack_require__(88);
      var hide = __webpack_require__(90);
      var has = __webpack_require__(40);
      var PROTOTYPE = "prototype";

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var IS_WRAP = type & $export.W;
        var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
        var expProto = exports[PROTOTYPE];
        var target = IS_GLOBAL
          ? global
          : IS_STATIC
          ? global[name]
          : (global[name] || {})[PROTOTYPE];
        var key, own, out;
        if (IS_GLOBAL) source = name;
        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined;
          if (own && has(exports, key)) continue;
          // export native or passed
          out = own ? target[key] : source[key];
          // prevent global pollution for namespaces
          exports[key] =
            IS_GLOBAL && typeof target[key] != "function"
              ? source[key]
              : // bind timers to global for call from export context
              IS_BIND && own
              ? ctx(out, global)
              : // wrap global constructors for prevent change them in library
              IS_WRAP && target[key] == out
              ? (function (C) {
                  var F = function F(a, b, c) {
                    if (this instanceof C) {
                      switch (arguments.length) {
                        case 0:
                          return new C();
                        case 1:
                          return new C(a);
                        case 2:
                          return new C(a, b);
                      }
                      return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                  };
                  F[PROTOTYPE] = C[PROTOTYPE];
                  return F;
                  // make static versions for prototype methods
                })(out)
              : IS_PROTO && typeof out == "function"
              ? ctx(Function.call, out)
              : out;
          // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
          if (IS_PROTO) {
            (exports.virtual || (exports.virtual = {}))[key] = out;
            // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            if (type & $export.R && expProto && !expProto[key])
              hide(expProto, key, out);
          }
        }
      };
      // type bitmap
      $export.F = 1; // forced
      $export.G = 2; // global
      $export.S = 4; // static
      $export.P = 8; // proto
      $export.B = 16; // bind
      $export.W = 32; // wrap
      $export.U = 64; // safe
      $export.R = 128; // real proto method for `library`
      module.exports = $export;

      /***/
    },

    /***/ 35: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
      var global = (module.exports =
        typeof window != "undefined" && window.Math == Math
          ? window
          : typeof self != "undefined" && self.Math == Math
          ? self
          : // eslint-disable-next-line no-new-func
            Function("return this")());
      if (typeof __g == "number") __g = global; // eslint-disable-line no-undef

      /***/
    },

    /***/ 36: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var anObject = __webpack_require__(91);
      var IE8_DOM_DEFINE = __webpack_require__(37);
      var toPrimitive = __webpack_require__(38);
      var dP = Object.defineProperty;

      exports.f = __webpack_require__(6)
        ? Object.defineProperty
        : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return dP(O, P, Attributes);
              } catch (e) {
                /* empty */
              }
            if ("get" in Attributes || "set" in Attributes)
              throw TypeError("Accessors not supported!");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O;
          };

      /***/
    },

    /***/ 37: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports =
        !__webpack_require__(6) &&
        !__webpack_require__(18)(function () {
          return (
            Object.defineProperty(__webpack_require__(92)("div"), "a", {
              get: function get() {
                return 7;
              },
            }).a != 7
          );
        });

      /***/
    },

    /***/ 38: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // 7.1.1 ToPrimitive(input [, PreferredType])
      var isObject = __webpack_require__(17);
      // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string
      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (
          S &&
          typeof (fn = it.toString) == "function" &&
          !isObject((val = fn.call(it)))
        )
          return val;
        if (
          typeof (fn = it.valueOf) == "function" &&
          !isObject((val = fn.call(it)))
        )
          return val;
        if (
          !S &&
          typeof (fn = it.toString) == "function" &&
          !isObject((val = fn.call(it)))
        )
          return val;
        throw TypeError("Can't convert object to primitive value");
      };

      /***/
    },

    /***/ 39: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value,
        };
      };

      /***/
    },

    /***/ 4: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _dom = __webpack_require__(136);

      var Methods = {
        addClass: _dom.addClass,
        removeClass: _dom.removeClass,
        hasClass: _dom.hasClass,
        toggleClass: _dom.toggleClass,
        attr: _dom.attr,
        removeAttr: _dom.removeAttr,
        transform: _dom.transform,
        transition: _dom.transition,
        on: _dom.on,
        off: _dom.off,
        trigger: _dom.trigger,
        transitionEnd: _dom.transitionEnd,
        outerWidth: _dom.outerWidth,
        outerHeight: _dom.outerHeight,
        styles: _dom.styles,
        offset: _dom.offset,
        css: _dom.css,
        each: _dom.each,
        html: _dom.html,
        text: _dom.text,
        is: _dom.is,
        index: _dom.index,
        eq: _dom.eq,
        append: _dom.append,
        prepend: _dom.prepend,
        next: _dom.next,
        nextAll: _dom.nextAll,
        prev: _dom.prev,
        prevAll: _dom.prevAll,
        parent: _dom.parent,
        parents: _dom.parents,
        closest: _dom.closest,
        find: _dom.find,
        children: _dom.children,
        filter: _dom.filter,
        remove: _dom.remove,
      };
      Object.keys(Methods).forEach(function (methodName) {
        Object.defineProperty(_dom.$.fn, methodName, {
          value: Methods[methodName],
          writable: true,
        });
      });
      exports.default = _dom.$;

      /***/
    },

    /***/ 40: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var hasOwnProperty = {}.hasOwnProperty;
      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };

      /***/
    },

    /***/ 41: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // to indexed object, toObject with fallback for non-array-like ES3 strings
      var IObject = __webpack_require__(96);
      var defined = __webpack_require__(98);
      module.exports = function (it) {
        return IObject(defined(it));
      };

      /***/
    },

    /***/ 42: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = {
        assign: function assign(target, firstSource) {
          if (target === undefined || target === null) {
            throw new TypeError("Cannot convert first argument to object");
          }

          var to = Object(target);
          for (var i = 1; i < arguments.length; i++) {
            var nextSource = arguments[i];
            if (nextSource === undefined || nextSource === null) {
              continue;
            }

            var keysArray = Object.keys(Object(nextSource));
            for (
              var nextIndex = 0, len = keysArray.length;
              nextIndex < len;
              nextIndex++
            ) {
              var nextKey = keysArray[nextIndex];
              var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
              if (desc !== undefined && desc.enumerable) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
          return to;
        },
      };

      /***/
    },

    /***/ 43: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };

      function _objectWithoutProperties(obj, keys) {
        var target = {};
        for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;
          if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
          target[i] = obj[i];
        }
        return target;
      }

      function _asyncToGenerator(fn) {
        return function () {
          var gen = fn.apply(this, arguments);
          return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);
                var value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(
                  function (value) {
                    step("next", value);
                  },
                  function (err) {
                    step("throw", err);
                  }
                );
              }
            }
            return step("next");
          });
        };
      }

      var Promise = __webpack_require__(104);
      var googleAnalytics = __webpack_require__(3);
      var axios = __webpack_require__(49);

      if (!window.Promise) {
        window.Promise = Promise;
      }

      module.exports = {
        cache: {},

        sendRequest: (function () {
          var _ref = _asyncToGenerator(
            /*#__PURE__*/ regeneratorRuntime.mark(function _callee() {
              var formData =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              var formType = arguments[1];
              var formIdRequest = arguments[2];

              var _ref2, _ref2$data, sent, data;

              return regeneratorRuntime.wrap(
                function _callee$(_context) {
                  while (1) {
                    switch ((_context.prev = _context.next)) {
                      case 0:
                        formData.page = document.location.pathname;
                        formData.pageType = this._getPageType();

                        this.cache[formIdRequest] = {};

                        _context.next = 5;
                        return axios.post(
                          undefined
                            ? "http://localhost:5001/api/core/requestEstimate"
                            : "/api/core/requestEstimate",
                          _extends({}, this.cache[formIdRequest], formData)
                        );

                      case 5:
                        _ref2 = _context.sent;
                        _ref2$data = _ref2.data;
                        sent = _ref2$data.sent;
                        data = _objectWithoutProperties(_ref2$data, ["sent"]);

                        this.cache[formIdRequest] = _extends(
                          {},
                          data,
                          formData
                        );

                        _context.prev = 10;

                        this._sendAnalytics(formIdRequest, formType);
                        _context.next = 17;
                        break;

                      case 14:
                        _context.prev = 14;
                        _context.t0 = _context["catch"](10);

                        console.error("Analytics request failed", _context.t0);

                      case 17:
                        _context.prev = 17;
                        return _context.abrupt(
                          "return",
                          this.cache[formIdRequest]
                        );

                      case 20:
                      case "end":
                        return _context.stop();
                    }
                  }
                },
                _callee,
                this,
                [[10, 14, 17, 20]]
              );
            })
          );

          function sendRequest() {
            return _ref.apply(this, arguments);
          }

          return sendRequest;
        })(),

        _sendAnalytics: function _sendAnalytics(formIdRequest, formType) {
          if (!window.google_trackConversion) return;

          switch (formIdRequest) {
            case "request-estimate-step1":
              window.google_trackConversion({
                google_conversion_id: 950055030,
                google_conversion_language: "en",
                google_conversion_format: "3",
                google_conversion_color: "ffffff",
                google_conversion_label: "KAoeCP7g6VwQ9uCCxQM",
                google_remarketing_only: false,
              });

              window.google_trackConversion({
                google_conversion_id: 875350916,
                google_conversion_language: "en",
                google_conversion_format: "3",
                google_conversion_color: "ffffff",
                google_conversion_label: "qFB6CIqku28QhJezoQM",
                google_remarketing_only: false,
              });

              if (typeof conversionGoal !== "undefined")
                window.optimizely.push(["trackEvent", conversionGoal]);

              _gaq.push(["_trackEvent", "formStepFirst", true]);
              yaCounter38650490.reachGoal("SUBMIT");

              if (formType === "footer") {
                var virtualPage = "/feedback_footer_wwd";

                switch (document.location.pathname) {
                  case "/what-we-do/ble":
                    virtualPage = "/ble_feedback_footer";
                    break;
                  case "/what-we-do/indoor":
                    virtualPage = "/ibeacon_feedback_footer";
                    break;
                  case "/what-we-do/applewatch":
                    virtualPage = "/watch_feedback_footer";
                    break;
                  case "/what-we-do/appletv":
                    virtualPage = "/appletv_feedback_footer";
                    break;
                  default:
                    break;
                }

                if (virtualPage)
                  googleAnalytics.virtualPage({ page: virtualPage });
              }
              googleAnalytics.virtualPage({ page: "/thankyou_1_step" });
              break;
            case "request-estimate-step2":
              googleAnalytics.virtualPage({ page: "/thankyou_2_step" });
              break;
          }
        },

        _getPageType: function _getPageType() {
          var page = window.location.pathname;

          switch (page) {
            case "/what-we-do/mobile":
            case "/what-we-do/ios":
            case "/what-we-do/android":
              return "Mobile Development Enquiry";
            case "/what-we-do/desktop":
            case "/what-we-do/mac":
            case "/what-we-do/windows":
              return "Desktop Development Enquiry";

            case "/what-we-do/web":
              return "Web Development Enquiry";

            case "/what-we-do/ble":
              return "BLE Development Enquiry";

            case "/what-we-do/applewatch":
            case "/what-we-do/smartwatch":
            case "/what-we-do/androidwatch":
              return "Smart Watch Development Enquiry";

            case "/what-we-do/ellpa":
            case "/what-we-do/appletv":
            case "/what-we-do/smarttv":
              return "Multimedia App Development Enquiry";

            default:
              return "App Development Enquiry";
          }
        },
      };

      /***/
    },

    /***/ 44: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }

      var Support = __webpack_require__(14);
      var formActions = __webpack_require__(43);

      __webpack_require__(107);
      __webpack_require__(108);

      /**
       * @public
       * @constructor
       */
      var requestEstimateForm = function requestEstimateForm() {
        if (!(this instanceof requestEstimateForm)) {
          new requestEstimateForm();
        }

        /**
         * @public
         * @type {Object}
         */
        this.DOM = {};
        this.data = {};
        this.formStep = 1;
        this.isSend = false;
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.init = function (container) {
        if (!container) return false;

        this.setDOM(container);
        this.initHandlers();
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.setDOM = function (container) {
        this.DOM.container = container;

        this.DOM.content = this.DOM.container.querySelector(
          ".js-request_content"
        );
        this.DOM.title = this.DOM.container.querySelector(
          ".js-request_title span"
        );
        this.DOM.success = this.DOM.container.querySelector(
          ".js-request_success"
        );
        this.DOM.fail = this.DOM.container.querySelector(".js-request_fail");

        this.DOM.form = this.DOM.container.querySelector(".js-request_form");
        this.DOM.formSteps = {
          wrap: this.DOM.form.querySelector(".js-request_steps"),
          step: this.DOM.form.querySelectorAll(".js-request_step"),
        };
        this.DOM.footer = this.DOM.form.querySelector(".b-request_footer");
        (this.DOM.formReload = Array.from(
          this.DOM.container.querySelectorAll(".js-request_reload")
        )),
          (this.DOM.formSubmit =
            this.DOM.footer.querySelector(".js-request_submit"));
        this.DOM.budget = this.DOM.form.querySelector(".js-request_budget");
        this.DOM.adviser = this.DOM.form.querySelector(".js-request_adviser");
        this.DOM.fields = {
          text: Array.apply(
            null,
            this.DOM.form.querySelectorAll(".js-request_field")
          ),
          radio: {
            budget: Array.apply(
              null,
              this.DOM.form.querySelectorAll("[name='budget']")
            ),
            adviser: Array.apply(
              null,
              this.DOM.form.querySelectorAll("[name='adviser']")
            ),
          },
          required: [],
        };
      };

      /**
       * @public
       * @param text {String}
       */
      requestEstimateForm.prototype.setTitle = function (text) {
        if (this.DOM.title) this.DOM.title.innerHTML = text;
      };

      /**
       * @public
       * @return {String}
       */
      requestEstimateForm.prototype.getTitle = function () {
        return this.DOM.title.innerHTML;
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.initHandlers = function () {
        var self = this;

        this.DOM.form.onsubmit = function () {
          self.checkFormStep() && self.sendRequest();
          return false;
        };

        this.DOM.fields.text.map(function (field) {
          field.addEventListener("keyup", function () {
            if (this.value) {
              this.classList.add("full");
            } else {
              this.classList.remove("full");
            }

            self.data[this.name] = this.value;
          });

          field.addEventListener("blur", function () {
            self.data[this.name] = this.value;
          });

          if (field.classList.contains("required")) {
            self.DOM.fields.required.push(field);

            field.addEventListener("focus", function () {
              this.parentNode.classList.remove("error");
            });
          }

          if (field.classList.contains("radio")) {
            field.addEventListener("focus", function () {
              var id = this.parentNode.parentNode.getAttribute("for");

              var radio = document.getElementById(id);

              radio.checked = true;
              self.data[radio.name] = radio.value;
            });
          }

          return field;
        });

        var _DOM$fields$radio = this.DOM.fields.radio,
          budget = _DOM$fields$radio.budget,
          adviser = _DOM$fields$radio.adviser;

        []
          .concat(_toConsumableArray(budget), _toConsumableArray(adviser))
          .map(function (field) {
            field.onchange = function () {
              self.data[this.name] = this.value;
              this.checked && self.DOM.budget.classList.remove("error");
              this.checked && self.DOM.adviser.classList.remove("error");
            };
            return field;
          });

        this.DOM.formReload.map(function (button) {
          button.addEventListener("click", function () {
            return self.clearForm();
          });
        });
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.onShow = function () {
        !Support.isSafari() && this.autofocus(0);
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.onHide = function () {
        this.DOM.container.classList.remove("finished");
        this.DOM.content.classList.remove("g-hide");
        this.DOM.fail.classList.add("g-hide");
        this.DOM.success.classList.add("g-hide");
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.nextFormStep = function () {
        this.formStep++;

        if (this.formStep === 2) {
          this.DOM.formSteps.wrap.classList.remove("fst");
          this.DOM.formSteps.wrap.classList.add("sec");
        } else if (this.formStep === 3) {
          this.DOM.formSteps.wrap.classList.remove("sec");
          this.DOM.formSteps.wrap.classList.add("third");

          this.setTitle("Thank you!");
        }

        setTimeout(
          function () {
            this.autofocus(1);
          }.bind(this),
          1000
        );

        /* if (this.formStep !== 1) {
 	_gaq.push(['_trackEvent', 'formSubmit', true]);
 	yaCounter38650490.reachGoal('SUBMIT');
 } */
      };

      /**
       * @public
       * @param i {Number}
       */
      requestEstimateForm.prototype.autofocus = function (i) {
        this.DOM.formSteps.step[i].querySelector(".autofocus").focus();
      };

      /**
       * @public
       */
      requestEstimateForm.prototype.prevFormStep = function () {
        this.formStep -= 2;
        this.DOM.formSteps.wrap.classList.remove("third");
        this.DOM.formSteps.wrap.classList.add("fst");
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.checkFormStep = function () {
        return this.isFormStepFirst()
          ? this.checkFormStepFirst()
          : this.isFormStepLast()
          ? this.checkFormStepThird()
          : this.checkFormStepSecond();
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.checkFormStepFirst = function () {
        var result = true;

        this.DOM.fields.required.map(function (field) {
          var value = field.value.trim();

          if (!value) {
            field.parentNode.classList.add("error");
            field.value = "";
            result = false;
          } else if (field.name === "mail") {
            var isValid = false;

            /*
             *  RegEx has ben taken from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email
             *  Browsers that implement the specification should be using an algorithm equivalent to the following regular expression:
             *
             *  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
             */

            var isEmailValid = value.match(
              /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]{1,63}@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/
            );
            var isPhoneValid = value
              .replace(/\s/g, "")
              .match(
                /^(\+?([0-9][\-.]?){3,4}|(\+?[0-9][\-.]?)?\([0-9]{3}\)[\-.]?)([0-9][\-.]?){2}[0-9][^@]*$/i
              );

            if (isEmailValid || isPhoneValid) {
              isValid = true;
            }

            if (!isValid) {
              field.parentNode.classList.add("error");
              result = false;
            }
          }

          return field;
        });

        return result;
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.checkFormStepSecond = function () {
        var result = false;

        this.DOM.fields.radio.budget.map(function (field) {
          field.checked && (result = true);

          return field;
        });

        !result && this.DOM.budget.classList.add("error");

        return result;
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.checkFormStepThird = function () {
        var result = this.DOM.fields.radio.adviser.some(function (field) {
          return field.checked;
        });

        !result && this.DOM.adviser.classList.add("error");

        return result;
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.isFormStepFirst = function () {
        return this.formStep < 2;
      };

      requestEstimateForm.prototype.isFormStepLast = function () {
        return this.formStep > 2;
      };

      requestEstimateForm.prototype.setSending = function (status) {
        this.isSending = status;
        this.DOM.form.classList.toggle("js-is-sending", status);
      };

      /**
       * @public
       * @param isError {Boolean}
       */
      requestEstimateForm.prototype.showResult = function () {
        this.DOM.container.classList.add("finished");
        this.DOM.formSteps.wrap.classList.add("g-hide");

        if (this.DOM.title) this.DOM.title.classList.add("g-hide");

        this.DOM.footer.classList.add("g-hide");
        this.DOM.success.classList.remove("g-hide");
        this.prevFormStep();
      };

      requestEstimateForm.prototype.showError = function () {
        this.DOM.formSteps.wrap.classList.add("g-hide");

        if (this.DOM.title) this.DOM.title.classList.add("g-hide");

        this.DOM.footer.classList.add("g-hide");
        this.DOM.fail.classList.remove("g-hide");
      };

      requestEstimateForm.prototype.hideResult = function () {
        this.DOM.formSteps.wrap.classList.remove("g-hide");

        if (this.DOM.title) this.DOM.title.classList.remove("g-hide");

        this.DOM.footer.classList.remove("g-hide");
        this.DOM.fail.classList.add("g-hide");
        this.DOM.success.classList.add("g-hide");
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.clearForm = function () {
        this.setTitle("Request a Project Estimation");
        this.hideResult();

        this.DOM.fields.text.map(function (field) {
          field.parentNode.classList.remove("error");
          field.classList.remove("full");
          field.value = "";

          return field;
        });

        var _DOM$fields$radio2 = this.DOM.fields.radio,
          budget = _DOM$fields$radio2.budget,
          adviser = _DOM$fields$radio2.adviser;

        []
          .concat(_toConsumableArray(budget), _toConsumableArray(adviser))
          .map(function (field) {
            field.checked = false;
            return field;
          });

        this.data = {};
      };

      /**
       * @public
       * @param formType {String}
       * @returns {Boolean}
       */
      requestEstimateForm.prototype.sendRequest = function () {
        var self = this;

        if (this.isSending) return;
        this.setSending(true);

        this.data.step = this.formStep - 1;
        var formData = this.data;

        var formIdRequest = self.isFormStepFirst()
          ? "request-estimate-step1"
          : "request-estimate-step2";
        var formType = self.DOM.form.getAttribute("data-type");

        formActions
          .sendRequest(formData, formType, formIdRequest)
          .then(function (data) {
            self.data = data;
            self.setSending(false);

            if (!self.isFormStepLast()) {
              self.nextFormStep();
            } else {
              self.showResult();
            }
          })
          .catch(function (error) {
            console.error(error);
            self.setSending(false);
            self.showError();
          });
      };

      /**
       * @public
       * @type {Handlers}
       */
      module.exports = requestEstimateForm;

      /***/
    },

    /***/ 45: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var Support = __webpack_require__(14);
      var googleAnalytics = __webpack_require__(3);
      var formActions = __webpack_require__(43);
      var Handlers = __webpack_require__(7);
      var assign = __webpack_require__(42);

      /**
       * @public
       * @constructor
       */
      var requestAdviserForm = function requestAdviserForm() {
        if (!(this instanceof requestAdviserForm)) {
          new requestAdviserForm();
        }

        /**
         * @public
         * @type {Object}
         */
        this.DOM = {};
        this.data = {};
        this.isSend = false;
        this.handlers = new Handlers();

        this.on = this.handlers.add.bind(this.handlers);
        this.off = this.handlers.remove.bind(this.handlers);
      };

      requestAdviserForm.prototype.setAdviser = function (radioButtons) {
        var referrer = this.getReferrerUrlFromCookies();

        for (var i = 0; i < radioButtons.length; i++) {
          var value = radioButtons[i].value.toLowerCase().trim();

          // https://www.appfutura.com/
          // https://clutch.co/
          // https://www.goodfirms.co/

          var canCheck =
            (value === "appfutura" &&
              referrer.match(/https:\/\/(www\.)?appfutura\.com[^a-z]/i)) ||
            (value === "clutch" &&
              referrer.match(/https:\/\/(www\.)?clutch\.co[^a-z]?/i)) ||
            (value === "google" &&
              referrer.match(/https:\/\/(www\.)?google\./i)) ||
            (value === "goodfirms" &&
              referrer.match(/https:\/\/(www\.)?goodfirms\.co[^a-z]?/i));

          if (canCheck) {
            var radioButton = radioButtons[i];

            radioButton.checked = true;
            this.data[radioButton.name] = radioButton.value;

            break;
          }
        }
      };

      requestAdviserForm.prototype.getReferrerUrlFromCookies = function () {
        return document.cookie.replace(
          /(?:(?:^|.*;\s*)referrerUrl\s*\=\s*([^;]*).*$)|^.*$/,
          "$1"
        );
      };

      requestAdviserForm.prototype.setReferrerUrlIntoCookies = function () {
        var referrer = null;
        var search = document.location.search;

        if (search.match(/[^a-z]?utm_source=appfutura[^a-z]?/i)) {
          referrer = "https://www.appfutura.com/";
        } else if (search.match(/[^a-z]?utm_source=clutch[^a-z]?/i)) {
          referrer = "https://clutch.co/";
        } else if (search.match(/[^a-z]?utm_source=goodfirms[^a-z]?/i)) {
          referrer = "https://www.goodfirms.co/";
        } else if (search.match(/[^a-z]?gclid=/i)) {
          referrer = "https://www.google.com/";
        } else {
          referrer = document.referrer;
        }

        if (!referrer) {
          document.cookie =
            "referrerUrl=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        } else {
          var cookieReferrer = this.getReferrerUrlFromCookies();

          if (
            cookieReferrer !== referrer &&
            !referrer.match(
              /https:\/\/([a-z]{3}\.)?(mercdev|BCLdevelopment)\.com/i
            )
          ) {
            document.cookie = "referrerUrl=" + referrer + "; path=/;";
          }
        }
      };

      /**
       * @public
       */
      requestAdviserForm.prototype.init = function (container) {
        if (!container) return false;

        this.setReferrerUrlIntoCookies();
        this.setDOM(container);
        this.initHandlers();
      };

      /**
       * @public
       */
      requestAdviserForm.prototype.setDOM = function (container) {
        this.DOM.container = container;

        this.DOM.form = this.DOM.container.querySelector(".js-request_form");
        this.DOM.formSubmit = this.DOM.form.querySelector(".js-request_submit");
        this.DOM.adviser = this.DOM.form.querySelector(".js-request_adviser");
        this.DOM.fields = {
          text: Array.apply(
            null,
            this.DOM.form.querySelectorAll(".js-request_field")
          ),
          radio: Array.apply(
            null,
            this.DOM.form.querySelectorAll("[name='adviser']")
          ),
          required: [],
        };

        this.setAdviser(this.DOM.fields.radio);
      };

      /**
       * @public
       */
      requestAdviserForm.prototype.initHandlers = function () {
        var self = this;

        this.DOM.form.onsubmit = function () {
          self.checkForm() && self.sendRequest();
          return false;
        };

        this.DOM.fields.text.map(function (field) {
          field.addEventListener("keyup", function () {
            if (this.value) {
              this.classList.add("full");
            } else {
              this.classList.remove("full");
            }
          });

          field.addEventListener("blur", function () {
            self.data[this.name] = this.value;
          });

          if (field.classList.contains("required")) {
            self.DOM.fields.required.push(field);

            field.addEventListener("focus", function () {
              this.parentNode.classList.remove("error");
            });
          }

          if (field.classList.contains("radio")) {
            field.addEventListener("focus", function () {
              var id = this.parentNode.parentNode.getAttribute("for");

              var radio = document.getElementById(id);

              radio.checked = true;
              self.data[radio.name] = radio.value;
            });
          }

          return field;
        });

        this.DOM.fields.radio.map(function (field) {
          field.onchange = function () {
            self.data[this.name] = this.value;
            this.checked && self.DOM.adviser.classList.remove("error");
          };
          return field;
        });
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestAdviserForm.prototype.checkForm = function () {
        /*var result = false;
     this.DOM.fields.radio.map(function(field) {
        field.checked && (result = true);
         return field;
    });
     !result && this.DOM.adviser.classList.add("error");
     return result;*/

        return true;
      };

      requestAdviserForm.prototype.setSending = function (status) {
        this.isSending = status;
        this.DOM.form.classList.toggle("js-is-sending", status);
      };

      requestAdviserForm.prototype.showError = function () {
        this.DOM.fail.classList.remove("g-hide");
      };

      /**
       * @public
       * @returns {Boolean}
       */
      requestAdviserForm.prototype.clearForm = function () {
        this.DOM.fields.text.map(function (field) {
          field.parentNode.classList.remove("error");
          field.classList.remove("full");
          field.value = "";

          return field;
        });

        this.DOM.adviser.classList.remove("error");

        this.DOM.fields.radio.map(function (field) {
          field.checked = false;
          return field;
        });

        this.data = {};

        this.setAdviser(this.DOM.fields.radio);
      };

      /**
       * @public
       * @param formType {String}
       * @returns {Boolean}
       */
      requestAdviserForm.prototype.sendRequest = function () {
        var self = this;
        var formData = this.data;

        if (this.isSending) return;
        this.setSending(true);

        var formIdRequest = "request-estimate-adviser";
        var formType = self.DOM.form.getAttribute("data-type");

        if (formActions.cache["request-estimate-step2"]) {
          formData = assign.assign(
            {},
            formActions.cache["request-estimate-step2"],
            formData
          );
        }

        formActions
          .sendRequest(formData, formType, formIdRequest)
          .then(function (data) {
            self.data = data;

            self.setSending(false);
            self.handlers.call("done");
            self.clearForm();
          })
          .catch(function (error) {
            console.error(error);
            self.setSending(false);
            self.showError();
            self.clearForm();
          });
      };

      /**
       * @public
       * @type {Handlers}
       */
      module.exports = requestAdviserForm;

      /***/
    },

    /***/ 46: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return (
          value != null &&
          (typeof value === "undefined" ? "undefined" : _typeof(value)) ==
            "object"
        );
      }

      module.exports = isObjectLike;

      /***/
    },

    /***/ 47: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _Symbol = __webpack_require__(32),
        getRawTag = __webpack_require__(80),
        objectToString = __webpack_require__(81);

      /** `Object#toString` result references. */
      var nullTag = "[object Null]",
        undefinedTag = "[object Undefined]";

      /** Built-in value references. */
      var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value)
          ? getRawTag(value)
          : objectToString(value);
      }

      module.exports = baseGetTag;

      /***/
    },

    /***/ 48: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var googleAnalytics = __webpack_require__(3);
      var requestEstimatePopup = __webpack_require__(16);

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: function init(className, isHeaderLink) {
          if (typeof isHeaderLink === "undefined") isHeaderLink = false;

          var links = document.querySelectorAll(
            className || ".js-request_estimate_link"
          );
          var self = this;

          for (var i = 0; i < links.length; i++) {
            var link = links[i];

            if (link) {
              requestEstimatePopup.init();

              link.addEventListener("click", function () {
                if (isHeaderLink) {
                  googleAnalytics.virtualPage({ page: "/feedback_head" });
                } else {
                  self.getGoogleVirtualPageAddress();
                }
                this.classList.add("active");
                requestEstimatePopup.show();

                _gaq.push(["_trackEvent", "popupLink", "click&show"]);
              });

              requestEstimatePopup.on("hide", function () {
                link.classList.remove("active");
              });
            }
          }
        },
        getGoogleVirtualPageAddress: function getGoogleVirtualPageAddress() {
          var virtualPage = "";
          switch (document.location.pathname) {
            case "/what-we-do/ble":
              virtualPage = "/ble_feedback";
              break;
            case "/what-we-do/indoor":
              virtualPage = "/ibeacon_feedback";
              break;
            case "/what-we-do/applewatch":
              virtualPage = "/watch_feedback";
              break;
            case "/what-we-do/appletv":
              virtualPage = "/appletv_feedback";
              break;
            default:
              break;
          }

          if (virtualPage) googleAnalytics.virtualPage({ page: virtualPage });
        },
      };

      /***/
    },

    /***/ 49: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = __webpack_require__(51);

      /***/
    },

    /***/ 5: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      /**
       * SSR Window 3.0.0
       * Better handling for window object in SSR environment
       * https://github.com/nolimits4web/ssr-window
       *
       * Copyright 2020, Vladimir Kharlampidi
       *
       * Licensed under MIT
       *
       * Released on: November 9, 2020
       */
      /* eslint-disable no-param-reassign */
      function isObject(obj) {
        return (
          obj !== null &&
          (typeof obj === "undefined" ? "undefined" : _typeof(obj)) ===
            "object" &&
          "constructor" in obj &&
          obj.constructor === Object
        );
      }
      function extend(target, src) {
        if (target === void 0) {
          target = {};
        }
        if (src === void 0) {
          src = {};
        }
        Object.keys(src).forEach(function (key) {
          if (typeof target[key] === "undefined") target[key] = src[key];
          else if (
            isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0
          ) {
            extend(target[key], src[key]);
          }
        });
      }

      var ssrDocument = {
        body: {},
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        activeElement: {
          blur: function blur() {},
          nodeName: "",
        },
        querySelector: function querySelector() {
          return null;
        },
        querySelectorAll: function querySelectorAll() {
          return [];
        },
        getElementById: function getElementById() {
          return null;
        },
        createEvent: function createEvent() {
          return {
            initEvent: function initEvent() {},
          };
        },
        createElement: function createElement() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function setAttribute() {},
            getElementsByTagName: function getElementsByTagName() {
              return [];
            },
          };
        },
        createElementNS: function createElementNS() {
          return {};
        },
        importNode: function importNode() {
          return null;
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: "",
        },
      };
      function getDocument() {
        var doc = typeof document !== "undefined" ? document : {};
        extend(doc, ssrDocument);
        return doc;
      }

      var ssrWindow = {
        document: ssrDocument,
        navigator: {
          userAgent: "",
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: "",
        },
        history: {
          replaceState: function replaceState() {},
          pushState: function pushState() {},
          go: function go() {},
          back: function back() {},
        },
        CustomEvent: function CustomEvent() {
          return this;
        },
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        getComputedStyle: function getComputedStyle() {
          return {
            getPropertyValue: function getPropertyValue() {
              return "";
            },
          };
        },
        Image: function Image() {},
        Date: function Date() {},
        screen: {},
        setTimeout: function setTimeout() {},
        clearTimeout: function clearTimeout() {},
        matchMedia: function matchMedia() {
          return {};
        },
        requestAnimationFrame: function requestAnimationFrame(callback) {
          if (typeof setTimeout === "undefined") {
            callback();
            return null;
          }
          return setTimeout(callback, 0);
        },
        cancelAnimationFrame: function cancelAnimationFrame(id) {
          if (typeof setTimeout === "undefined") {
            return;
          }
          clearTimeout(id);
        },
      };
      function getWindow() {
        var win = typeof window !== "undefined" ? window : {};
        extend(win, ssrWindow);
        return win;
      }

      exports.extend = extend;
      exports.getDocument = getDocument;
      exports.getWindow = getWindow;
      exports.ssrDocument = ssrDocument;
      exports.ssrWindow = ssrWindow;

      /***/
    },

    /***/ 50: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (global) {
        var _typeof =
          typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
            ? function (obj) {
                return typeof obj;
              }
            : function (obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };

        /** Detect free variable `global` from Node.js. */
        var freeGlobal =
          (typeof global === "undefined" ? "undefined" : _typeof(global)) ==
            "object" &&
          global &&
          global.Object === Object &&
          global;

        module.exports = freeGlobal;
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(13));

      /***/
    },

    /***/ 51: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);
      var bind = __webpack_require__(22);
      var Axios = __webpack_require__(52);
      var mergeConfig = __webpack_require__(29);
      var defaults = __webpack_require__(15);

      /**
       * Create an instance of Axios
       *
       * @param {Object} defaultConfig The default config for the instance
       * @return {Axios} A new instance of Axios
       */
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);

        // Copy axios.prototype to instance
        utils.extend(instance, Axios.prototype, context);

        // Copy context to instance
        utils.extend(instance, context);

        // Factory for creating new instances
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };

        return instance;
      }

      // Create the default instance to be exported
      var axios = createInstance(defaults);

      // Expose Axios class to allow class inheritance
      axios.Axios = Axios;

      // Expose Cancel & CancelToken
      axios.CanceledError = __webpack_require__(8);
      axios.CancelToken = __webpack_require__(70);
      axios.isCancel = __webpack_require__(28);
      axios.VERSION = __webpack_require__(30).version;
      axios.toFormData = __webpack_require__(25);

      // Expose AxiosError class
      axios.AxiosError = __webpack_require__(2);

      // alias for CanceledError for backward compatibility
      axios.Cancel = axios.CanceledError;

      // Expose all/spread
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = __webpack_require__(71);

      // Expose isAxiosError
      axios.isAxiosError = __webpack_require__(72);

      module.exports = axios;

      // Allow use of default import syntax in TypeScript
      module.exports.default = axios;

      /***/
    },

    /***/ 52: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);
      var buildURL = __webpack_require__(23);
      var InterceptorManager = __webpack_require__(53);
      var dispatchRequest = __webpack_require__(54);
      var mergeConfig = __webpack_require__(29);
      var buildFullPath = __webpack_require__(27);
      var validator = __webpack_require__(69);

      var validators = validator.validators;
      /**
       * Create a new instance of Axios
       *
       * @param {Object} instanceConfig The default config for the instance
       */
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager(),
        };
      }

      /**
       * Dispatch a request
       *
       * @param {Object} config The config specific for this request (merged with this.defaults)
       */
      Axios.prototype.request = function request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/
        // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }

        config = mergeConfig(this.defaults, config);

        // Set config.method
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }

        var transitional = config.transitional;

        if (transitional !== undefined) {
          validator.assertOptions(
            transitional,
            {
              silentJSONParsing: validators.transitional(validators.boolean),
              forcedJSONParsing: validators.transitional(validators.boolean),
              clarifyTimeoutError: validators.transitional(validators.boolean),
            },
            false
          );
        }

        // filter out skipped interceptors
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(
          interceptor
        ) {
          if (
            typeof interceptor.runWhen === "function" &&
            interceptor.runWhen(config) === false
          ) {
            return;
          }

          synchronousRequestInterceptors =
            synchronousRequestInterceptors && interceptor.synchronous;

          requestInterceptorChain.unshift(
            interceptor.fulfilled,
            interceptor.rejected
          );
        });

        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(
          interceptor
        ) {
          responseInterceptorChain.push(
            interceptor.fulfilled,
            interceptor.rejected
          );
        });

        var promise;

        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, undefined];

          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);

          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }

          return promise;
        }

        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }

        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }

        while (responseInterceptorChain.length) {
          promise = promise.then(
            responseInterceptorChain.shift(),
            responseInterceptorChain.shift()
          );
        }

        return promise;
      };

      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        var fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      };

      // Provide aliases for supported request methods
      utils.forEach(
        ["delete", "get", "head", "options"],
        function forEachMethodNoData(method) {
          /*eslint func-names:0*/
          Axios.prototype[method] = function (url, config) {
            return this.request(
              mergeConfig(config || {}, {
                method: method,
                url: url,
                data: (config || {}).data,
              })
            );
          };
        }
      );

      utils.forEach(
        ["post", "put", "patch"],
        function forEachMethodWithData(method) {
          /*eslint func-names:0*/

          function generateHTTPMethod(isForm) {
            return function httpMethod(url, data, config) {
              return this.request(
                mergeConfig(config || {}, {
                  method: method,
                  headers: isForm
                    ? {
                        "Content-Type": "multipart/form-data",
                      }
                    : {},
                  url: url,
                  data: data,
                })
              );
            };
          }

          Axios.prototype[method] = generateHTTPMethod();

          Axios.prototype[method + "Form"] = generateHTTPMethod(true);
        }
      );

      module.exports = Axios;

      /***/
    },

    /***/ 53: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      function InterceptorManager() {
        this.handlers = [];
      }

      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      InterceptorManager.prototype.use = function use(
        fulfilled,
        rejected,
        options
      ) {
        this.handlers.push({
          fulfilled: fulfilled,
          rejected: rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null,
        });
        return this.handlers.length - 1;
      };

      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       */
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };

      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       */
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };

      module.exports = InterceptorManager;

      /***/
    },

    /***/ 54: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);
      var transformData = __webpack_require__(55);
      var isCancel = __webpack_require__(28);
      var defaults = __webpack_require__(15);
      var CanceledError = __webpack_require__(8);

      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }

        if (config.signal && config.signal.aborted) {
          throw new CanceledError();
        }
      }

      /**
       * Dispatch a request to the server using the configured adapter.
       *
       * @param {object} config The config that is to be used for the request
       * @returns {Promise} The Promise to be fulfilled
       */
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);

        // Ensure headers exist
        config.headers = config.headers || {};

        // Transform request data
        config.data = transformData.call(
          config,
          config.data,
          config.headers,
          config.transformRequest
        );

        // Flatten headers
        config.headers = utils.merge(
          config.headers.common || {},
          config.headers[config.method] || {},
          config.headers
        );

        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config.headers[method];
          }
        );

        var adapter = config.adapter || defaults.adapter;

        return adapter(config).then(
          function onAdapterResolution(response) {
            throwIfCancellationRequested(config);

            // Transform response data
            response.data = transformData.call(
              config,
              response.data,
              response.headers,
              config.transformResponse
            );

            return response;
          },
          function onAdapterRejection(reason) {
            if (!isCancel(reason)) {
              throwIfCancellationRequested(config);

              // Transform response data
              if (reason && reason.response) {
                reason.response.data = transformData.call(
                  config,
                  reason.response.data,
                  reason.response.headers,
                  config.transformResponse
                );
              }
            }

            return Promise.reject(reason);
          }
        );
      };

      /***/
    },

    /***/ 55: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);
      var defaults = __webpack_require__(15);

      /**
       * Transform the data for a request or a response
       *
       * @param {Object|String} data The data to be transformed
       * @param {Array} headers The headers for the request or response
       * @param {Array|Function} fns A single function or Array of functions
       * @returns {*} The resulting transformed data
       */
      module.exports = function transformData(data, headers, fns) {
        var context = this || defaults;
        /*eslint no-param-reassign:0*/
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });

        return data;
      };

      /***/
    },

    /***/ 56: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (
            name !== normalizedName &&
            name.toUpperCase() === normalizedName.toUpperCase()
          ) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };

      /***/
    },

    /***/ 57: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (global) {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <http://feross.org>
         * @license  MIT
         */
        /* eslint-disable no-proto */

        var base64 = __webpack_require__(58);
        var ieee754 = __webpack_require__(59);
        var isArray = __webpack_require__(60);

        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;

        /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
        Buffer.TYPED_ARRAY_SUPPORT =
          global.TYPED_ARRAY_SUPPORT !== undefined
            ? global.TYPED_ARRAY_SUPPORT
            : typedArraySupport();

        /*
         * Export kMaxLength after typed array support is determined.
         */
        exports.kMaxLength = kMaxLength();

        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function foo() {
                return 42;
              },
            };
            return (
              arr.foo() === 42 && // typed array instances can be augmented
              typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
              arr.subarray(1, 1).byteLength === 0
            ); // ie10 has broken `subarray`
          } catch (e) {
            return false;
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
        }

        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError("Invalid typed array length");
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = new Uint8Array(length);
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            if (that === null) {
              that = new Buffer(length);
            }
            that.length = length;
          }

          return that;
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
            return new Buffer(arg, encodingOrOffset, length);
          }

          // Common case.
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            }
            return allocUnsafe(this, arg);
          }
          return from(this, arg, encodingOrOffset, length);
        }

        Buffer.poolSize = 8192; // not used by this implementation

        // TODO: Legacy, not needed anymore. Remove in next major version.
        Buffer._augment = function (arr) {
          arr.__proto__ = Buffer.prototype;
          return arr;
        };

        function from(that, value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('"value" argument must not be a number');
          }

          if (
            typeof ArrayBuffer !== "undefined" &&
            value instanceof ArrayBuffer
          ) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }

          if (typeof value === "string") {
            return fromString(that, value, encodingOrOffset);
          }

          return fromObject(that, value);
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function (value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };

        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
          if (
            typeof Symbol !== "undefined" &&
            Symbol.species &&
            Buffer[Symbol.species] === Buffer
          ) {
            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
            });
          }
        }

        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }

        function alloc(that, size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(that, size);
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === "string"
              ? createBuffer(that, size).fill(fill, encoding)
              : createBuffer(that, size).fill(fill);
          }
          return createBuffer(that, size);
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function (size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };

        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }
          return that;
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function (size) {
          return allocUnsafe(null, size);
        };
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(null, size);
        };

        function fromString(that, string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }

          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);

          var actual = that.write(string, encoding);

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            that = that.slice(0, actual);
          }

          return that;
        }

        function fromArrayLike(that, array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          that = createBuffer(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255;
          }
          return that;
        }

        function fromArrayBuffer(that, array, byteOffset, length) {
          array.byteLength; // this throws if `array` is not a valid ArrayBuffer

          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError("'offset' is out of bounds");
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError("'length' is out of bounds");
          }

          if (byteOffset === undefined && length === undefined) {
            array = new Uint8Array(array);
          } else if (length === undefined) {
            array = new Uint8Array(array, byteOffset);
          } else {
            array = new Uint8Array(array, byteOffset, length);
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = array;
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            that = fromArrayLike(that, array);
          }
          return that;
        }

        function fromObject(that, obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);

            if (that.length === 0) {
              return that;
            }

            obj.copy(that, 0, 0, len);
            return that;
          }

          if (obj) {
            if (
              (typeof ArrayBuffer !== "undefined" &&
                obj.buffer instanceof ArrayBuffer) ||
              "length" in obj
            ) {
              if (typeof obj.length !== "number" || isnan(obj.length)) {
                return createBuffer(that, 0);
              }
              return fromArrayLike(that, obj);
            }

            if (obj.type === "Buffer" && isArray(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }

          throw new TypeError(
            "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
          );
        }

        function checked(length) {
          // Note: cannot use `length < kMaxLength()` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= kMaxLength()) {
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum " +
                "size: 0x" +
                kMaxLength().toString(16) +
                " bytes"
            );
          }
          return length | 0;
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0;
          }
          return Buffer.alloc(+length);
        }

        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer);
        };

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError("Arguments must be Buffers");
          }

          if (a === b) return 0;

          var x = a.length;
          var y = b.length;

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };

        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }

          if (list.length === 0) {
            return Buffer.alloc(0);
          }

          var i;
          if (length === undefined) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }

          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list.length; ++i) {
            var buf = list[i];
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length;
          }
          if (
            typeof ArrayBuffer !== "undefined" &&
            typeof ArrayBuffer.isView === "function" &&
            (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
          ) {
            return string.byteLength;
          }
          if (typeof string !== "string") {
            string = "" + string;
          }

          var len = string.length;
          if (len === 0) return 0;

          // Use a for loop to avoid recursion
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
              case undefined:
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase) return utf8ToBytes(string).length; // assume utf8
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.byteLength = byteLength;

        function slowToString(encoding, start, end) {
          var loweredCase = false;

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0;
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return "";
          }

          if (end === undefined || end > this.length) {
            end = this.length;
          }

          if (end <= 0) {
            return "";
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0;
          start >>>= 0;

          if (end <= start) {
            return "";
          }

          if (!encoding) encoding = "utf8";

          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);

              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);

              case "ascii":
                return asciiSlice(this, start, end);

              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);

              case "base64":
                return base64Slice(this, start, end);

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }

        // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
        // Buffer instances.
        Buffer.prototype._isBuffer = true;

        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }
          return this;
        };

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };

        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return "";
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b))
            throw new TypeError("Argument must be a Buffer");
          if (this === b) return true;
          return Buffer.compare(this, b) === 0;
        };

        Buffer.prototype.inspect = function inspect() {
          var str = "";
          var max = exports.INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
            if (this.length > max) str += " ... ";
          }
          return "<Buffer " + str + ">";
        };

        Buffer.prototype.compare = function compare(
          target,
          start,
          end,
          thisStart,
          thisEnd
        ) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError("Argument must be a Buffer");
          }

          if (start === undefined) {
            start = 0;
          }
          if (end === undefined) {
            end = target ? target.length : 0;
          }
          if (thisStart === undefined) {
            thisStart = 0;
          }
          if (thisEnd === undefined) {
            thisEnd = this.length;
          }

          if (
            start < 0 ||
            end > target.length ||
            thisStart < 0 ||
            thisEnd > this.length
          ) {
            throw new RangeError("out of range index");
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }

          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;

          if (this === target) return 0;

          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);

          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1;

          // Normalize byteOffset
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff;
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000;
          }
          byteOffset = +byteOffset; // Coerce to Number.
          if (isNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1;
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir) return -1;
            else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;
            else return -1;
          }

          // Normalize val
          if (typeof val === "string") {
            val = Buffer.from(val, encoding);
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 0xff; // Search for a byte value [0-255]
            if (
              Buffer.TYPED_ARRAY_SUPPORT &&
              typeof Uint8Array.prototype.indexOf === "function"
            ) {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(
                  buffer,
                  val,
                  byteOffset
                );
              } else {
                return Uint8Array.prototype.lastIndexOf.call(
                  buffer,
                  val,
                  byteOffset
                );
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }

          throw new TypeError("val must be string, number or Buffer");
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase();
            if (
              encoding === "ucs2" ||
              encoding === "ucs-2" ||
              encoding === "utf16le" ||
              encoding === "utf-16le"
            ) {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i];
            } else {
              return buf.readUInt16BE(i * indexSize);
            }
          }

          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (
                read(arr, i) ===
                read(val, foundIndex === -1 ? 0 : i - foundIndex)
              ) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found) return i;
            }
          }

          return -1;
        }

        Buffer.prototype.includes = function includes(
          val,
          byteOffset,
          encoding
        ) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };

        Buffer.prototype.lastIndexOf = function lastIndexOf(
          val,
          byteOffset,
          encoding
        ) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }

          // must be an even number of digits
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");

          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(
            utf8ToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          );
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(
            utf16leToBytes(string, buf.length - offset),
            buf,
            offset,
            length
          );
        }

        Buffer.prototype.write = function write(
          string,
          offset,
          length,
          encoding
        ) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = "utf8";
            } else {
              encoding = length;
              length = undefined;
            }
            // legacy write(string, encoding, offset, length) - remove in v0.13
          } else {
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          }

          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;

          if (
            (string.length > 0 && (length < 0 || offset < 0)) ||
            offset > this.length
          ) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }

          if (!encoding) encoding = "utf8";

          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);

              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);

              case "ascii":
                return asciiWrite(this, string, offset, length);

              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length);

              case "base64":
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);

              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        };

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];

          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence =
              firstByte > 0xef
                ? 4
                : firstByte > 0xdf
                ? 3
                : firstByte > 0xbf
                ? 2
                : 1;

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 0xc0) === 0x80) {
                    tempCodePoint =
                      ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                    if (tempCodePoint > 0x7f) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0xc) |
                      ((secondByte & 0x3f) << 0x6) |
                      (thirdByte & 0x3f);
                    if (
                      tempCodePoint > 0x7ff &&
                      (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                    ) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if (
                    (secondByte & 0xc0) === 0x80 &&
                    (thirdByte & 0xc0) === 0x80 &&
                    (fourthByte & 0xc0) === 0x80
                  ) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0x12) |
                      ((secondByte & 0x3f) << 0xc) |
                      ((thirdByte & 0x3f) << 0x6) |
                      (fourthByte & 0x3f);
                    if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xfffd;
              bytesPerSequence = 1;
            } else if (codePoint > 0xffff) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000;
              res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
              codePoint = 0xdc00 | (codePoint & 0x3ff);
            }

            res.push(codePoint);
            i += bytesPerSequence;
          }

          return decodeCodePointsArray(res);
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000;

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
            );
          }
          return res;
        }

        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7f);
          }
          return ret;
        }

        function latin1Slice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }

        function hexSlice(buf, start, end) {
          var len = buf.length;

          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;

          var out = "";
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }
          return out;
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;

          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }

          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }

          if (end < start) end = start;

          var newBuf;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);
            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }

          return newBuf;
        };

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint");
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length");
        }

        Buffer.prototype.readUIntLE = function readUIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);

          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }

          return val;
        };

        Buffer.prototype.readUIntBE = function readUIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length);
          }

          var val = this[offset + --byteLength];
          var mul = 1;
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul;
          }

          return val;
        };

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };

        Buffer.prototype.readUInt16LE = function readUInt16LE(
          offset,
          noAssert
        ) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | (this[offset + 1] << 8);
        };

        Buffer.prototype.readUInt16BE = function readUInt16BE(
          offset,
          noAssert
        ) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return (this[offset] << 8) | this[offset + 1];
        };

        Buffer.prototype.readUInt32LE = function readUInt32LE(
          offset,
          noAssert
        ) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return (
            (this[offset] |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16)) +
            this[offset + 3] * 0x1000000
          );
        };

        Buffer.prototype.readUInt32BE = function readUInt32BE(
          offset,
          noAssert
        ) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return (
            this[offset] * 0x1000000 +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
          );
        };

        Buffer.prototype.readIntLE = function readIntLE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);

          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }
          mul *= 0x80;

          if (val >= mul) val -= Math.pow(2, 8 * byteLength);

          return val;
        };

        Buffer.prototype.readIntBE = function readIntBE(
          offset,
          byteLength,
          noAssert
        ) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);

          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul;
          }
          mul *= 0x80;

          if (val >= mul) val -= Math.pow(2, 8 * byteLength);

          return val;
        };

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 0x80)) return this[offset];
          return (0xff - this[offset] + 1) * -1;
        };

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | (this[offset + 1] << 8);
          return val & 0x8000 ? val | 0xffff0000 : val;
        };

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | (this[offset] << 8);
          return val & 0x8000 ? val | 0xffff0000 : val;
        };

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return (
            this[offset] |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
          );
        };

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return (
            (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            this[offset + 3]
          );
        };

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };

        Buffer.prototype.readDoubleLE = function readDoubleLE(
          offset,
          noAssert
        ) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };

        Buffer.prototype.readDoubleBE = function readDoubleBE(
          offset,
          noAssert
        ) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var mul = 1;
          var i = 0;
          this[offset] = value & 0xff;
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUIntBE = function writeUIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 0xff;
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUInt8 = function writeUInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 0xff;
          return offset + 1;
        };

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffff + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] =
              (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
              ((littleEndian ? i : 1 - i) * 8);
          }
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffffffff + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] =
              (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
          }
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };

        Buffer.prototype.writeIntLE = function writeIntLE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);

            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 0xff;
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeIntBE = function writeIntBE(
          value,
          offset,
          byteLength,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);

            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = byteLength - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 0xff;
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeInt8 = function writeInt8(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 0xff + value + 1;
          this[offset] = value & 0xff;
          return offset + 1;
        };

        Buffer.prototype.writeInt16LE = function writeInt16LE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };

        Buffer.prototype.writeInt16BE = function writeInt16BE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };

        Buffer.prototype.writeInt32LE = function writeInt32LE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };

        Buffer.prototype.writeInt32BE = function writeInt32BE(
          value,
          offset,
          noAssert
        ) {
          value = +value;
          offset = offset | 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (value < 0) value = 0xffffffff + value + 1;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
          if (offset < 0) throw new RangeError("Index out of range");
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              4,
              3.4028234663852886e38,
              -3.4028234663852886e38
            );
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeFloatBE = function writeFloatBE(
          value,
          offset,
          noAssert
        ) {
          return writeFloat(this, value, offset, false, noAssert);
        };

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(
              buf,
              value,
              offset,
              8,
              1.7976931348623157e308,
              -1.7976931348623157e308
            );
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(
          value,
          offset,
          noAssert
        ) {
          return writeDouble(this, value, offset, false, noAssert);
        };

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;

          // Copy 0 bytes; we're done
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (end < 0) throw new RangeError("sourceEnd out of bounds");

          // Are we oob?
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }

          var len = end - start;
          var i;

          if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            // ascending copy from start
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, start + len),
              targetStart
            );
          }

          return len;
        };

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (code < 256) {
                val = code;
              }
            }
            if (encoding !== undefined && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
          } else if (typeof val === "number") {
            val = val & 255;
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }

          if (end <= start) {
            return this;
          }

          start = start >>> 0;
          end = end === undefined ? this.length : end >>> 0;

          if (!val) val = 0;

          var i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer.isBuffer(val)
              ? val
              : utf8ToBytes(new Buffer(val, encoding).toString());
            var len = bytes.length;
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }

          return this;
        };

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

        function base64clean(str) {
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = stringtrim(str).replace(INVALID_BASE64_RE, "");
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return "";
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + "=";
          }
          return str;
        }

        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, "");
        }

        function toHex(n) {
          if (n < 16) return "0" + n.toString(16);
          return n.toString(16);
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);

            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  continue;
                }

                // valid lead
                leadSurrogate = codePoint;

                continue;
              }

              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                leadSurrogate = codePoint;
                continue;
              }

              // valid surrogate pair
              codePoint =
                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
            }

            leadSurrogate = null;

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              bytes.push(
                (codePoint >> 0xc) | 0xe0,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              );
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              bytes.push(
                (codePoint >> 0x12) | 0xf0,
                ((codePoint >> 0xc) & 0x3f) | 0x80,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              );
            } else {
              throw new Error("Invalid code point");
            }
          }

          return bytes;
        }

        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xff);
          }
          return byteArray;
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;

            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }

          return byteArray;
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }

        function isnan(val) {
          return val !== val; // eslint-disable-line no-self-compare
        }
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(13));

      /***/
    },

    /***/ 58: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;

      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

      var code =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;

      function getLens(b64) {
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len;

        var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

        return [validLen, placeHoldersLen];
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];

        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

        var curByte = 0;

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

        var i;
        for (i = 0; i < len; i += 4) {
          tmp =
            (revLookup[b64.charCodeAt(i)] << 18) |
            (revLookup[b64.charCodeAt(i + 1)] << 12) |
            (revLookup[b64.charCodeAt(i + 2)] << 6) |
            revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = (tmp >> 16) & 0xff;
          arr[curByte++] = (tmp >> 8) & 0xff;
          arr[curByte++] = tmp & 0xff;
        }

        if (placeHoldersLen === 2) {
          tmp =
            (revLookup[b64.charCodeAt(i)] << 2) |
            (revLookup[b64.charCodeAt(i + 1)] >> 4);
          arr[curByte++] = tmp & 0xff;
        }

        if (placeHoldersLen === 1) {
          tmp =
            (revLookup[b64.charCodeAt(i)] << 10) |
            (revLookup[b64.charCodeAt(i + 1)] << 4) |
            (revLookup[b64.charCodeAt(i + 2)] >> 2);
          arr[curByte++] = (tmp >> 8) & 0xff;
          arr[curByte++] = tmp & 0xff;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return (
          lookup[(num >> 18) & 0x3f] +
          lookup[(num >> 12) & 0x3f] +
          lookup[(num >> 6) & 0x3f] +
          lookup[num & 0x3f]
        );
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp =
            ((uint8[i] << 16) & 0xff0000) +
            ((uint8[i + 1] << 8) & 0xff00) +
            (uint8[i + 2] & 0xff);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }

      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (
          var i = 0, len2 = len - extraBytes;
          i < len2;
          i += maxChunkLength
        ) {
          parts.push(
            encodeChunk(
              uint8,
              i,
              i + maxChunkLength > len2 ? len2 : i + maxChunkLength
            )
          );
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(
            lookup[tmp >> 10] +
              lookup[(tmp >> 4) & 0x3f] +
              lookup[(tmp << 2) & 0x3f] +
              "="
          );
        }

        return parts.join("");
      }

      /***/
    },

    /***/ 59: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];

        i += d;

        e = s & ((1 << -nBits) - 1);
        s >>= -nBits;
        nBits += eLen;
        for (
          ;
          nBits > 0;
          e = e * 256 + buffer[offset + i], i += d, nBits -= 8
        ) {}

        m = e & ((1 << -nBits) - 1);
        e >>= -nBits;
        nBits += mLen;
        for (
          ;
          nBits > 0;
          m = m * 256 + buffer[offset + i], i += d, nBits -= 8
        ) {}

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (
          ;
          mLen >= 8;
          buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
        ) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (
          ;
          eLen > 0;
          buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
        ) {}

        buffer[offset + i - d] |= s * 128;
      };

      /***/
    },

    /***/ 6: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // Thank's IE8 for his funny defineProperty
      module.exports = !__webpack_require__(18)(function () {
        return (
          Object.defineProperty({}, "a", {
            get: function get() {
              return 7;
            },
          }).a != 7
        );
      });

      /***/
    },

    /***/ 60: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var toString = {}.toString;

      module.exports =
        Array.isArray ||
        function (arr) {
          return toString.call(arr) == "[object Array]";
        };

      /***/
    },

    /***/ 61: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var AxiosError = __webpack_require__(2);

      /**
       * Resolve or reject a Promise based on response status.
       *
       * @param {Function} resolve A function that resolves the promise.
       * @param {Function} reject A function that rejects the promise.
       * @param {object} response The response.
       */
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (
          !response.status ||
          !validateStatus ||
          validateStatus(response.status)
        ) {
          resolve(response);
        } else {
          reject(
            new AxiosError(
              "Request failed with status code " + response.status,
              [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][
                Math.floor(response.status / 100) - 4
              ],
              response.config,
              response.request,
              response
            )
          );
        }
      };

      /***/
    },

    /***/ 62: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      module.exports = utils.isStandardBrowserEnv()
        ? // Standard browser envs support document.cookie
          (function standardBrowserEnv() {
            return {
              write: function write(
                name,
                value,
                expires,
                path,
                domain,
                secure
              ) {
                var cookie = [];
                cookie.push(name + "=" + encodeURIComponent(value));

                if (utils.isNumber(expires)) {
                  cookie.push("expires=" + new Date(expires).toGMTString());
                }

                if (utils.isString(path)) {
                  cookie.push("path=" + path);
                }

                if (utils.isString(domain)) {
                  cookie.push("domain=" + domain);
                }

                if (secure === true) {
                  cookie.push("secure");
                }

                document.cookie = cookie.join("; ");
              },

              read: function read(name) {
                var match = document.cookie.match(
                  new RegExp("(^|;\\s*)(" + name + ")=([^;]*)")
                );
                return match ? decodeURIComponent(match[3]) : null;
              },

              remove: function remove(name) {
                this.write(name, "", Date.now() - 86400000);
              },
            };
          })()
        : // Non standard browser env (web workers, react-native) lack needed support.
          (function nonStandardBrowserEnv() {
            return {
              write: function write() {},
              read: function read() {
                return null;
              },
              remove: function remove() {},
            };
          })();

      /***/
    },

    /***/ 63: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Determines whether the specified URL is absolute
       *
       * @param {string} url The URL to test
       * @returns {boolean} True if the specified URL is absolute, otherwise false
       */

      module.exports = function isAbsoluteURL(url) {
        // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
        // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
        // by any combination of letters, digits, plus, period, or hyphen.
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };

      /***/
    },

    /***/ 64: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Creates a new URL by combining the specified URLs
       *
       * @param {string} baseURL The base URL
       * @param {string} relativeURL The relative URL
       * @returns {string} The combined URL
       */

      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL
          ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "")
          : baseURL;
      };

      /***/
    },

    /***/ 65: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      // Headers whose duplicates are ignored by node
      // c.f. https://nodejs.org/api/http.html#http_message_headers
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent",
      ];

      /**
       * Parse headers into an object
       *
       * ```
       * Date: Wed, 27 Aug 2014 08:58:49 GMT
       * Content-Type: application/json
       * Connection: keep-alive
       * Transfer-Encoding: chunked
       * ```
       *
       * @param {String} headers Headers needing to be parsed
       * @returns {Object} Headers parsed into an object
       */
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;

        if (!headers) {
          return parsed;
        }

        utils.forEach(headers.split("\n"), function parser(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));

          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });

        return parsed;
      };

      /***/
    },

    /***/ 66: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      module.exports = utils.isStandardBrowserEnv()
        ? // Standard browser envs have full support of the APIs needed to test
          // whether the request URL is of the same origin as current location.
          (function standardBrowserEnv() {
            var msie = /(msie|trident)/i.test(navigator.userAgent);
            var urlParsingNode = document.createElement("a");
            var originURL;

            /**
             * Parse a URL to discover it's components
             *
             * @param {String} url The URL to be parsed
             * @returns {Object}
             */
            function resolveURL(url) {
              var href = url;

              if (msie) {
                // IE needs attribute set twice to normalize properties
                urlParsingNode.setAttribute("href", href);
                href = urlParsingNode.href;
              }

              urlParsingNode.setAttribute("href", href);

              // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
              return {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol
                  ? urlParsingNode.protocol.replace(/:$/, "")
                  : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search
                  ? urlParsingNode.search.replace(/^\?/, "")
                  : "",
                hash: urlParsingNode.hash
                  ? urlParsingNode.hash.replace(/^#/, "")
                  : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname:
                  urlParsingNode.pathname.charAt(0) === "/"
                    ? urlParsingNode.pathname
                    : "/" + urlParsingNode.pathname,
              };
            }

            originURL = resolveURL(window.location.href);

            /**
             * Determine if a URL shares the same origin as the current location
             *
             * @param {String} requestURL The URL to test
             * @returns {boolean} True if URL shares the same origin, otherwise false
             */
            return function isURLSameOrigin(requestURL) {
              var parsed = utils.isString(requestURL)
                ? resolveURL(requestURL)
                : requestURL;
              return (
                parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host
              );
            };
          })()
        : // Non standard browser envs (web workers, react-native) lack needed support.
          (function nonStandardBrowserEnv() {
            return function isURLSameOrigin() {
              return true;
            };
          })();

      /***/
    },

    /***/ 67: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = function parseProtocol(url) {
        var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return (match && match[1]) || "";
      };

      /***/
    },

    /***/ 68: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // eslint-disable-next-line strict
      module.exports = null;

      /***/
    },

    /***/ 69: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var VERSION = __webpack_require__(30).version;
      var AxiosError = __webpack_require__(2);

      var validators = {};

      // eslint-disable-next-line func-names
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(
        function (type, i) {
          validators[type] = function validator(thing) {
            return (
              (typeof thing === "undefined" ? "undefined" : _typeof(thing)) ===
                type || "a" + (i < 1 ? "n " : " ") + type
            );
          };
        }
      );

      var deprecatedWarnings = {};

      /**
       * Transitional option validator
       * @param {function|boolean?} validator - set to false if the transitional option has been removed
       * @param {string?} version - deprecated version / removed since version
       * @param {string?} message - some message with additional info
       * @returns {function}
       */
      validators.transitional = function transitional(
        validator,
        version,
        message
      ) {
        function formatMessage(opt, desc) {
          return (
            "[Axios v" +
            VERSION +
            "] Transitional option '" +
            opt +
            "'" +
            desc +
            (message ? ". " + message : "")
          );
        }

        // eslint-disable-next-line func-names
        return function (value, opt, opts) {
          if (validator === false) {
            throw new AxiosError(
              formatMessage(
                opt,
                " has been removed" + (version ? " in " + version : "")
              ),
              AxiosError.ERR_DEPRECATED
            );
          }

          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" +
                  version +
                  " and will be removed in the near future"
              )
            );
          }

          return validator ? validator(value, opt, opts) : true;
        };
      };

      /**
       * Assert object's properties type
       * @param {object} options
       * @param {object} schema
       * @param {boolean?} allowUnknown
       */

      function assertOptions(options, schema, allowUnknown) {
        if (
          (typeof options === "undefined" ? "undefined" : _typeof(options)) !==
          "object"
        ) {
          throw new AxiosError(
            "options must be an object",
            AxiosError.ERR_BAD_OPTION_VALUE
          );
        }
        var keys = Object.keys(options);
        var i = keys.length;
        while (i-- > 0) {
          var opt = keys[i];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === undefined || validator(value, opt, options);
            if (result !== true) {
              throw new AxiosError(
                "option " + opt + " must be " + result,
                AxiosError.ERR_BAD_OPTION_VALUE
              );
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw new AxiosError(
              "Unknown option " + opt,
              AxiosError.ERR_BAD_OPTION
            );
          }
        }
      }

      module.exports = {
        assertOptions: assertOptions,
        validators: validators,
      };

      /***/
    },

    /***/ 7: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * @public
       * @constructor
       */

      var Handlers = function Handlers() {
        if (!(this instanceof Handlers)) {
          new Handlers();
        }

        /**
         * @public
         * @type {Object}
         */
        this.list = {};
      };

      /**
       * @public
       * @param event {String}
       * @param callback {Function}
       * @returns {Number}
       */
      Handlers.prototype.add = function (event, callback) {
        if (!this.list.hasOwnProperty(event)) {
          this.list[event] = [];
        }

        this.list[event].push(callback);

        return this.list[event].length - 1;
      };

      /**
       * @public
       * @param event {String}
       * @param fn {Function}
       * @returns {Handlers}
       */
      Handlers.prototype.remove = function (event, fn) {
        if (this.hasHandlers(event)) {
          this.list[event] = this.list[event].filter(function (handler) {
            return handler !== fn;
          });
        }

        return this;
      };

      /**
       * @public
       * @param event {String}
       * @returns {Boolean}
       */
      Handlers.prototype.hasHandlers = function (event) {
        return this.list.hasOwnProperty(event) && this.list[event].length
          ? true
          : false;
      };

      /**
       * @public
       * @param event {String}
       * @param args {Array}
       * @param context {*}
       * @returns {Handlers}
       */
      Handlers.prototype.call = function (event, args, context) {
        if (this.hasHandlers(event)) {
          this.list[event].map(function (handler) {
            handler && handler.apply(context || null, args);
          });
        }

        return this;
      };

      /**
       * @public
       * @type {Handlers}
       */
      module.exports = Handlers;

      /***/
    },

    /***/ 70: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var CanceledError = __webpack_require__(8);

      /**
       * A `CancelToken` is an object that can be used to request cancellation of an operation.
       *
       * @class
       * @param {Function} executor The executor function.
       */
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }

        var resolvePromise;

        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });

        var token = this;

        // eslint-disable-next-line func-names
        this.promise.then(function (cancel) {
          if (!token._listeners) return;

          var i;
          var l = token._listeners.length;

          for (i = 0; i < l; i++) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });

        // eslint-disable-next-line func-names
        this.promise.then = function (onfulfilled) {
          var _resolve;
          // eslint-disable-next-line func-names
          var promise = new Promise(function (resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);

          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };

          return promise;
        };

        executor(function cancel(message) {
          if (token.reason) {
            // Cancellation has already been requested
            return;
          }

          token.reason = new CanceledError(message);
          resolvePromise(token.reason);
        });
      }

      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };

      /**
       * Subscribe to the cancel signal
       */

      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }

        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };

      /**
       * Unsubscribe from the cancel signal
       */

      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };

      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token,
          cancel: cancel,
        };
      };

      module.exports = CancelToken;

      /***/
    },

    /***/ 71: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Syntactic sugar for invoking a function and expanding an array for arguments.
       *
       * Common use case would be to use `Function.prototype.apply`.
       *
       *  ```js
       *  function f(x, y, z) {}
       *  var args = [1, 2, 3];
       *  f.apply(null, args);
       *  ```
       *
       * With `spread` this example can be re-written.
       *
       *  ```js
       *  spread(function(x, y, z) {})([1, 2, 3]);
       *  ```
       *
       * @param {Function} callback
       * @returns {Function}
       */

      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };

      /***/
    },

    /***/ 72: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var utils = __webpack_require__(0);

      /**
       * Determines whether the payload is an error thrown by Axios
       *
       * @param {*} payload The value to test
       * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
       */
      module.exports = function isAxiosError(payload) {
        return utils.isObject(payload) && payload.isAxiosError === true;
      };

      /***/
    },

    /***/ 73: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies.
       * @private
       */

      var googleAnalytics = __webpack_require__(3);
      var nav = __webpack_require__(33);
      var requestEstimateLink = __webpack_require__(48);

      /**
       * @public
       * @type {Object}
       */
      module.exports = {
        init: function init() {
          nav.on("collapse", onNavCollapse);
          nav.init();

          requestEstimateLink.init(".js-request_estimate_link", true);
          initHandlers();
        },
      };

      /**
       * @private
       */
      function initHandlers() {
        var emailLink = document.querySelector(
          ".l-header .l-mail-link.b-nav_footer_email"
        );

        emailLink.addEventListener("click", sendGoogleAnalyticsEvent);
      }

      /**
       * @private
       */
      function sendGoogleAnalyticsEvent() {
        googleAnalytics.sendEvent({
          eventCategory: "request",
          eventAction: "email",
          eventLabel: "tab",
        });
      }

      /**
       * @private
       * @param isCollapse {Boolean}
       */
      function onNavCollapse(isCollapse) {
        var siteNavClassList = document.querySelector(
          ".js-site-navigation"
        ).classList;

        if (isCollapse) siteNavClassList.add("collapse");
        else siteNavClassList.remove("collapse");
      }

      /***/
    },

    /***/ 74: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var debounce = __webpack_require__(31),
        isObject = __webpack_require__(11);

      /** Error message constants. */
      var FUNC_ERROR_TEXT = "Expected a function";

      /**
       * Creates a throttled function that only invokes `func` at most once per
       * every `wait` milliseconds. The throttled function comes with a `cancel`
       * method to cancel delayed `func` invocations and a `flush` method to
       * immediately invoke them. Provide `options` to indicate whether `func`
       * should be invoked on the leading and/or trailing edge of the `wait`
       * timeout. The `func` is invoked with the last arguments provided to the
       * throttled function. Subsequent calls to the throttled function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the throttled function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=true]
       *  Specify invoking on the leading edge of the timeout.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // Avoid excessively updating the position while scrolling.
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
       * jQuery(element).on('click', throttled);
       *
       * // Cancel the trailing throttled invocation.
       * jQuery(window).on('popstate', throttled.cancel);
       */
      function throttle(func, wait, options) {
        var leading = true,
          trailing = true;

        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading: leading,
          maxWait: wait,
          trailing: trailing,
        });
      }

      module.exports = throttle;

      /***/
    },

    /***/ 75: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var root = __webpack_require__(21);

      /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */
      var now = function now() {
        return root.Date.now();
      };

      module.exports = now;

      /***/
    },

    /***/ 76: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var baseTrim = __webpack_require__(77),
        isObject = __webpack_require__(11),
        isSymbol = __webpack_require__(79);

      /** Used as references for various `Number` constants. */
      var NAN = 0 / 0;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Built-in method references without a dependency on `root`. */
      var freeParseInt = parseInt;

      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other =
            typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value)
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : reIsBadHex.test(value)
          ? NAN
          : +value;
      }

      module.exports = toNumber;

      /***/
    },

    /***/ 77: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var trimmedEndIndex = __webpack_require__(78);

      /** Used to match leading whitespace. */
      var reTrimStart = /^\s+/;

      /**
       * The base implementation of `_.trim`.
       *
       * @private
       * @param {string} string The string to trim.
       * @returns {string} Returns the trimmed string.
       */
      function baseTrim(string) {
        return string
          ? string
              .slice(0, trimmedEndIndex(string) + 1)
              .replace(reTrimStart, "")
          : string;
      }

      module.exports = baseTrim;

      /***/
    },

    /***/ 78: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /** Used to match a single whitespace character. */
      var reWhitespace = /\s/;

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedEndIndex(string) {
        var index = string.length;

        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }

      module.exports = trimmedEndIndex;

      /***/
    },

    /***/ 79: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _typeof =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
          ? function (obj) {
              return typeof obj;
            }
          : function (obj) {
              return obj &&
                typeof Symbol === "function" &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? "symbol"
                : typeof obj;
            };

      var baseGetTag = __webpack_require__(47),
        isObjectLike = __webpack_require__(46);

      /** `Object#toString` result references. */
      var symbolTag = "[object Symbol]";

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (
          (typeof value === "undefined" ? "undefined" : _typeof(value)) ==
            "symbol" ||
          (isObjectLike(value) && baseGetTag(value) == symbolTag)
        );
      }

      module.exports = isSymbol;

      /***/
    },

    /***/ 8: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var AxiosError = __webpack_require__(2);
      var utils = __webpack_require__(0);

      /**
       * A `CanceledError` is an object that is thrown when an operation is canceled.
       *
       * @class
       * @param {string=} message The message.
       */
      function CanceledError(message) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        AxiosError.call(
          this,
          message == null ? "canceled" : message,
          AxiosError.ERR_CANCELED
        );
        this.name = "CanceledError";
      }

      utils.inherits(CanceledError, AxiosError, {
        __CANCEL__: true,
      });

      module.exports = CanceledError;

      /***/
    },

    /***/ 80: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var _Symbol = __webpack_require__(32);

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /** Built-in value references. */
      var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }

      module.exports = getRawTag;

      /***/
    },

    /***/ 81: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /** Used for built-in method references. */
      var objectProto = Object.prototype;

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      module.exports = objectToString;

      /***/
    },

    /***/ 82: /***/ function (module, exports, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */ (function (module) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

        var _typeof =
          typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
            ? function (obj) {
                return typeof obj;
              }
            : function (obj) {
                return obj &&
                  typeof Symbol === "function" &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? "symbol"
                  : typeof obj;
              };

        /*!
         * jQuery JavaScript Library v2.2.4
         * http://jquery.com/
         *
         * Includes Sizzle.js
         * http://sizzlejs.com/
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2016-05-20T17:23Z
         */

        (function (global, factory) {
          if (
            (false ? "undefined" : _typeof(module)) === "object" &&
            _typeof(module.exports) === "object"
          ) {
            // For CommonJS and CommonJS-like environments where a proper `window`
            // is present, execute the factory and get jQuery.
            // For environments that do not have a `window` with a `document`
            // (such as Node.js), expose a factory as module.exports.
            // This accentuates the need for the creation of a real `window`.
            // e.g. var jQuery = require("jquery")(window);
            // See ticket #14549 for more info.
            module.exports = global.document
              ? factory(global, true)
              : function (w) {
                  if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                  }
                  return factory(w);
                };
          } else {
            factory(global);
          }

          // Pass this if window is not defined yet
        })(
          typeof window !== "undefined" ? window : undefined,
          function (window, noGlobal) {
            // Support: Firefox 18+
            // Can't be in strict mode, several libs including ASP.NET trace
            // the stack via arguments.caller.callee and Firefox dies if
            // you try to trace through "use strict" call chains. (#13335)
            //"use strict";
            var arr = [];

            var document = window.document;

            var _slice = arr.slice;

            var concat = arr.concat;

            var push = arr.push;

            var indexOf = arr.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var support = {};

            var version = "2.2.4",
              // Define a local copy of jQuery
              jQuery = function jQuery(selector, context) {
                // The jQuery object is actually just the init constructor 'enhanced'
                // Need init if jQuery is called (just allow error to be thrown if not included)
                return new jQuery.fn.init(selector, context);
              },
              // Support: Android<4.1
              // Make sure we trim BOM and NBSP
              rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
              // Matches dashed string for camelizing
              rmsPrefix = /^-ms-/,
              rdashAlpha = /-([\da-z])/gi,
              // Used by jQuery.camelCase as callback to replace()
              fcamelCase = function fcamelCase(all, letter) {
                return letter.toUpperCase();
              };

            jQuery.fn = jQuery.prototype = {
              // The current version of jQuery being used
              jquery: version,

              constructor: jQuery,

              // Start with an empty selector
              selector: "",

              // The default length of a jQuery object is 0
              length: 0,

              toArray: function toArray() {
                return _slice.call(this);
              },

              // Get the Nth element in the matched element set OR
              // Get the whole matched element set as a clean array
              get: function get(num) {
                return num != null
                  ? // Return just the one element from the set
                    num < 0
                    ? this[num + this.length]
                    : this[num]
                  : // Return all the elements in a clean array
                    _slice.call(this);
              },

              // Take an array of elements and push it onto the stack
              // (returning the new matched element set)
              pushStack: function pushStack(elems) {
                // Build a new jQuery matched element set
                var ret = jQuery.merge(this.constructor(), elems);

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;
                ret.context = this.context;

                // Return the newly-formed element set
                return ret;
              },

              // Execute a callback for every element in the matched set.
              each: function each(callback) {
                return jQuery.each(this, callback);
              },

              map: function map(callback) {
                return this.pushStack(
                  jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                  })
                );
              },

              slice: function slice() {
                return this.pushStack(_slice.apply(this, arguments));
              },

              first: function first() {
                return this.eq(0);
              },

              last: function last() {
                return this.eq(-1);
              },

              eq: function eq(i) {
                var len = this.length,
                  j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
              },

              end: function end() {
                return this.prevObject || this.constructor();
              },

              // For internal use only.
              // Behaves like an Array's method, not like a jQuery method.
              push: push,
              sort: arr.sort,
              splice: arr.splice,
            };

            jQuery.extend = jQuery.fn.extend = function () {
              var options,
                name,
                src,
                copy,
                copyIsArray,
                clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

              // Handle a deep copy situation
              if (typeof target === "boolean") {
                deep = target;

                // Skip the boolean and the target
                target = arguments[i] || {};
                i++;
              }

              // Handle case when target is a string or something (possible in deep copy)
              if (
                (typeof target === "undefined"
                  ? "undefined"
                  : _typeof(target)) !== "object" &&
                !jQuery.isFunction(target)
              ) {
                target = {};
              }

              // Extend jQuery itself if only one argument is passed
              if (i === length) {
                target = this;
                i--;
              }

              for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                  // Extend the base object
                  for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                      continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (
                      deep &&
                      copy &&
                      (jQuery.isPlainObject(copy) ||
                        (copyIsArray = jQuery.isArray(copy)))
                    ) {
                      if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];
                      } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                      }

                      // Never move original objects, clone them
                      target[name] = jQuery.extend(deep, clone, copy);

                      // Don't bring in undefined values
                    } else if (copy !== undefined) {
                      target[name] = copy;
                    }
                  }
                }
              }

              // Return the modified object
              return target;
            };

            jQuery.extend({
              // Unique for each copy of jQuery on the page
              expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

              // Assume jQuery is ready without the ready module
              isReady: true,

              error: function error(msg) {
                throw new Error(msg);
              },

              noop: function noop() {},

              isFunction: function isFunction(obj) {
                return jQuery.type(obj) === "function";
              },

              isArray: Array.isArray,

              isWindow: function isWindow(obj) {
                return obj != null && obj === obj.window;
              },

              isNumeric: function isNumeric(obj) {
                // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                // subtraction forces infinities to NaN
                // adding 1 corrects loss of precision from parseFloat (#15100)
                var realStringObj = obj && obj.toString();
                return (
                  !jQuery.isArray(obj) &&
                  realStringObj - parseFloat(realStringObj) + 1 >= 0
                );
              },

              isPlainObject: function isPlainObject(obj) {
                var key;

                // Not plain objects:
                // - Any object or value whose internal [[Class]] property is not "[object Object]"
                // - DOM nodes
                // - window
                if (
                  jQuery.type(obj) !== "object" ||
                  obj.nodeType ||
                  jQuery.isWindow(obj)
                ) {
                  return false;
                }

                // Not own constructor property must be Object
                if (
                  obj.constructor &&
                  !hasOwn.call(obj, "constructor") &&
                  !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")
                ) {
                  return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own
                for (key in obj) {
                }

                return key === undefined || hasOwn.call(obj, key);
              },

              isEmptyObject: function isEmptyObject(obj) {
                var name;
                for (name in obj) {
                  return false;
                }
                return true;
              },

              type: function type(obj) {
                if (obj == null) {
                  return obj + "";
                }

                // Support: Android<4.0, iOS<6 (functionish RegExp)
                return (typeof obj === "undefined"
                  ? "undefined"
                  : _typeof(obj)) === "object" || typeof obj === "function"
                  ? class2type[toString.call(obj)] || "object"
                  : typeof obj === "undefined"
                  ? "undefined"
                  : _typeof(obj);
              },

              // Evaluates a script in a global context
              globalEval: function globalEval(code) {
                var script,
                  indirect = eval;

                code = jQuery.trim(code);

                if (code) {
                  // If the code includes a valid, prologue position
                  // strict mode pragma, execute code by injecting a
                  // script tag into the document.
                  if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head
                      .appendChild(script)
                      .parentNode.removeChild(script);
                  } else {
                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval

                    indirect(code);
                  }
                }
              },

              // Convert dashed to camelCase; used by the css and data modules
              // Support: IE9-11+
              // Microsoft forgot to hump their vendor prefix (#9572)
              camelCase: function camelCase(string) {
                return string
                  .replace(rmsPrefix, "ms-")
                  .replace(rdashAlpha, fcamelCase);
              },

              nodeName: function nodeName(elem, name) {
                return (
                  elem.nodeName &&
                  elem.nodeName.toLowerCase() === name.toLowerCase()
                );
              },

              each: function each(obj, callback) {
                var length,
                  i = 0;

                if (isArrayLike(obj)) {
                  length = obj.length;
                  for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                      break;
                    }
                  }
                } else {
                  for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                      break;
                    }
                  }
                }

                return obj;
              },

              // Support: Android<4.1
              trim: function trim(text) {
                return text == null ? "" : (text + "").replace(rtrim, "");
              },

              // results is for internal usage only
              makeArray: function makeArray(arr, results) {
                var ret = results || [];

                if (arr != null) {
                  if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                  } else {
                    push.call(ret, arr);
                  }
                }

                return ret;
              },

              inArray: function inArray(elem, arr, i) {
                return arr == null ? -1 : indexOf.call(arr, elem, i);
              },

              merge: function merge(first, second) {
                var len = +second.length,
                  j = 0,
                  i = first.length;

                for (; j < len; j++) {
                  first[i++] = second[j];
                }

                first.length = i;

                return first;
              },

              grep: function grep(elems, callback, invert) {
                var callbackInverse,
                  matches = [],
                  i = 0,
                  length = elems.length,
                  callbackExpect = !invert;

                // Go through the array, only saving the items
                // that pass the validator function
                for (; i < length; i++) {
                  callbackInverse = !callback(elems[i], i);
                  if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                  }
                }

                return matches;
              },

              // arg is for internal usage only
              map: function map(elems, callback, arg) {
                var length,
                  value,
                  i = 0,
                  ret = [];

                // Go through the array, translating each of the items to their new values
                if (isArrayLike(elems)) {
                  length = elems.length;
                  for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                      ret.push(value);
                    }
                  }

                  // Go through every key on the object,
                } else {
                  for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                      ret.push(value);
                    }
                  }
                }

                // Flatten any nested arrays
                return concat.apply([], ret);
              },

              // A global GUID counter for objects
              guid: 1,

              // Bind a function to a context, optionally partially applying any
              // arguments.
              proxy: function proxy(fn, context) {
                var tmp, args, proxy;

                if (typeof context === "string") {
                  tmp = fn[context];
                  context = fn;
                  fn = tmp;
                }

                // Quick check to determine if target is callable, in the spec
                // this throws a TypeError, but we will just return undefined.
                if (!jQuery.isFunction(fn)) {
                  return undefined;
                }

                // Simulated bind
                args = _slice.call(arguments, 2);
                proxy = function proxy() {
                  return fn.apply(
                    context || this,
                    args.concat(_slice.call(arguments))
                  );
                };

                // Set the guid of unique handler to the same of original handler, so it can be removed
                proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                return proxy;
              },

              now: Date.now,

              // jQuery.support is not used in Core but other projects attach their
              // properties to it so it needs to exist.
              support: support,
            });

            // JSHint would error on this code due to the Symbol not being defined in ES5.
            // Defining this global in .jshintrc would create a danger of using the global
            // unguarded in another place, it seems safer to just disable JSHint for these
            // three lines.
            /* jshint ignore: start */
            if (typeof Symbol === "function") {
              jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
            }
            /* jshint ignore: end */

            // Populate the class2type map
            jQuery.each(
              "Boolean Number String Function Array Date RegExp Object Error Symbol".split(
                " "
              ),
              function (i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
              }
            );

            function isArrayLike(obj) {
              // Support: iOS 8.2 (not reproducible in simulator)
              // `in` check used to prevent JIT error (gh-2145)
              // hasOwn isn't used here due to false negatives
              // regarding Nodelist length in IE
              var length = !!obj && "length" in obj && obj.length,
                type = jQuery.type(obj);

              if (type === "function" || jQuery.isWindow(obj)) {
                return false;
              }

              return (
                type === "array" ||
                length === 0 ||
                (typeof length === "number" && length > 0 && length - 1 in obj)
              );
            }
            var Sizzle =
              /*!
               * Sizzle CSS Selector Engine v2.2.1
               * http://sizzlejs.com/
               *
               * Copyright jQuery Foundation and other contributors
               * Released under the MIT license
               * http://jquery.org/license
               *
               * Date: 2015-10-17
               */
              (function (window) {
                var i,
                  support,
                  Expr,
                  getText,
                  isXML,
                  tokenize,
                  compile,
                  select,
                  outermostContext,
                  sortInput,
                  hasDuplicate,
                  // Local document vars
                  setDocument,
                  document,
                  docElem,
                  documentIsHTML,
                  rbuggyQSA,
                  rbuggyMatches,
                  matches,
                  contains,
                  // Instance-specific data
                  expando = "sizzle" + 1 * new Date(),
                  preferredDoc = window.document,
                  dirruns = 0,
                  done = 0,
                  classCache = createCache(),
                  tokenCache = createCache(),
                  compilerCache = createCache(),
                  sortOrder = function sortOrder(a, b) {
                    if (a === b) {
                      hasDuplicate = true;
                    }
                    return 0;
                  },
                  // General-purpose constants
                  MAX_NEGATIVE = 1 << 31,
                  // Instance methods
                  hasOwn = {}.hasOwnProperty,
                  arr = [],
                  pop = arr.pop,
                  push_native = arr.push,
                  push = arr.push,
                  slice = arr.slice,
                  // Use a stripped-down indexOf as it's faster than native
                  // http://jsperf.com/thor-indexof-vs-for/5
                  indexOf = function indexOf(list, elem) {
                    var i = 0,
                      len = list.length;
                    for (; i < len; i++) {
                      if (list[i] === elem) {
                        return i;
                      }
                    }
                    return -1;
                  },
                  booleans =
                    "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                  // Regular expressions

                  // http://www.w3.org/TR/css3-selectors/#whitespace
                  whitespace = "[\\x20\\t\\r\\n\\f]",
                  // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                  identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                  // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                  attributes =
                    "\\[" +
                    whitespace +
                    "*(" +
                    identifier +
                    ")(?:" +
                    whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" +
                    whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
                    identifier +
                    "))|)" +
                    whitespace +
                    "*\\]",
                  pseudos =
                    ":(" +
                    identifier +
                    ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" +
                    attributes +
                    ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",
                  // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                  rwhitespace = new RegExp(whitespace + "+", "g"),
                  rtrim = new RegExp(
                    "^" +
                      whitespace +
                      "+|((?:^|[^\\\\])(?:\\\\.)*)" +
                      whitespace +
                      "+$",
                    "g"
                  ),
                  rcomma = new RegExp(
                    "^" + whitespace + "*," + whitespace + "*"
                  ),
                  rcombinators = new RegExp(
                    "^" +
                      whitespace +
                      "*([>+~]|" +
                      whitespace +
                      ")" +
                      whitespace +
                      "*"
                  ),
                  rattributeQuotes = new RegExp(
                    "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]",
                    "g"
                  ),
                  rpseudo = new RegExp(pseudos),
                  ridentifier = new RegExp("^" + identifier + "$"),
                  matchExpr = {
                    ID: new RegExp("^#(" + identifier + ")"),
                    CLASS: new RegExp("^\\.(" + identifier + ")"),
                    TAG: new RegExp("^(" + identifier + "|[*])"),
                    ATTR: new RegExp("^" + attributes),
                    PSEUDO: new RegExp("^" + pseudos),
                    CHILD: new RegExp(
                      "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
                        whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" +
                        whitespace +
                        "*(?:([+-]|)" +
                        whitespace +
                        "*(\\d+)|))" +
                        whitespace +
                        "*\\)|)",
                      "i"
                    ),
                    bool: new RegExp("^(?:" + booleans + ")$", "i"),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    needsContext: new RegExp(
                      "^" +
                        whitespace +
                        "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace +
                        "*((?:-\\d)?\\d*)" +
                        whitespace +
                        "*\\)|)(?=[^-]|$)",
                      "i"
                    ),
                  },
                  rinputs = /^(?:input|select|textarea|button)$/i,
                  rheader = /^h\d$/i,
                  rnative = /^[^{]+\{\s*\[native \w/,
                  // Easily-parseable/retrievable ID or TAG or CLASS selectors
                  rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                  rsibling = /[+~]/,
                  rescape = /'|\\/g,
                  // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                  runescape = new RegExp(
                    "\\\\([\\da-f]{1,6}" +
                      whitespace +
                      "?|(" +
                      whitespace +
                      ")|.)",
                    "ig"
                  ),
                  funescape = function funescape(
                    _,
                    escaped,
                    escapedWhitespace
                  ) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace
                      ? escaped
                      : high < 0
                      ? // BMP codepoint
                        String.fromCharCode(high + 0x10000)
                      : // Supplemental Plane codepoint (surrogate pair)
                        String.fromCharCode(
                          (high >> 10) | 0xd800,
                          (high & 0x3ff) | 0xdc00
                        );
                  },
                  // Used for iframes
                  // See setDocument()
                  // Removing the function wrapper causes a "Permission Denied"
                  // error in IE
                  unloadHandler = function unloadHandler() {
                    setDocument();
                  };

                // Optimize for push.apply( _, NodeList )
                try {
                  push.apply(
                    (arr = slice.call(preferredDoc.childNodes)),
                    preferredDoc.childNodes
                  );
                  // Support: Android<4.0
                  // Detect silently failing push.apply
                  arr[preferredDoc.childNodes.length].nodeType;
                } catch (e) {
                  push = {
                    apply: arr.length
                      ? // Leverage slice if possible
                        function (target, els) {
                          push_native.apply(target, slice.call(els));
                        }
                      : // Support: IE<9
                        // Otherwise append directly
                        function (target, els) {
                          var j = target.length,
                            i = 0;
                          // Can't trust NodeList.length
                          while ((target[j++] = els[i++])) {}
                          target.length = j - 1;
                        },
                  };
                }

                function Sizzle(selector, context, results, seed) {
                  var m,
                    i,
                    elem,
                    nid,
                    nidselect,
                    match,
                    groups,
                    newSelector,
                    newContext = context && context.ownerDocument,
                    // nodeType defaults to 9, since context defaults to document
                    nodeType = context ? context.nodeType : 9;

                  results = results || [];

                  // Return early from calls with invalid selector or context
                  if (
                    typeof selector !== "string" ||
                    !selector ||
                    (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
                  ) {
                    return results;
                  }

                  // Try to shortcut find operations (as opposed to filters) in HTML documents
                  if (!seed) {
                    if (
                      (context
                        ? context.ownerDocument || context
                        : preferredDoc) !== document
                    ) {
                      setDocument(context);
                    }
                    context = context || document;

                    if (documentIsHTML) {
                      // If the selector is sufficiently simple, try using a "get*By*" DOM method
                      // (excepting DocumentFragment context, where the methods don't exist)
                      if (
                        nodeType !== 11 &&
                        (match = rquickExpr.exec(selector))
                      ) {
                        // ID selector
                        if ((m = match[1])) {
                          // Document context
                          if (nodeType === 9) {
                            if ((elem = context.getElementById(m))) {
                              // Support: IE, Opera, Webkit
                              // TODO: identify versions
                              // getElementById can match elements by name instead of ID
                              if (elem.id === m) {
                                results.push(elem);
                                return results;
                              }
                            } else {
                              return results;
                            }

                            // Element context
                          } else {
                            // Support: IE, Opera, Webkit
                            // TODO: identify versions
                            // getElementById can match elements by name instead of ID
                            if (
                              newContext &&
                              (elem = newContext.getElementById(m)) &&
                              contains(context, elem) &&
                              elem.id === m
                            ) {
                              results.push(elem);
                              return results;
                            }
                          }

                          // Type selector
                        } else if (match[2]) {
                          push.apply(
                            results,
                            context.getElementsByTagName(selector)
                          );
                          return results;

                          // Class selector
                        } else if (
                          (m = match[3]) &&
                          support.getElementsByClassName &&
                          context.getElementsByClassName
                        ) {
                          push.apply(
                            results,
                            context.getElementsByClassName(m)
                          );
                          return results;
                        }
                      }

                      // Take advantage of querySelectorAll
                      if (
                        support.qsa &&
                        !compilerCache[selector + " "] &&
                        (!rbuggyQSA || !rbuggyQSA.test(selector))
                      ) {
                        if (nodeType !== 1) {
                          newContext = context;
                          newSelector = selector;

                          // qSA looks outside Element context, which is not what we want
                          // Thanks to Andrew Dupont for this workaround technique
                          // Support: IE <=8
                          // Exclude object elements
                        } else if (
                          context.nodeName.toLowerCase() !== "object"
                        ) {
                          // Capture the context ID, setting it first if necessary
                          if ((nid = context.getAttribute("id"))) {
                            nid = nid.replace(rescape, "\\$&");
                          } else {
                            context.setAttribute("id", (nid = expando));
                          }

                          // Prefix every selector in the list
                          groups = tokenize(selector);
                          i = groups.length;
                          nidselect = ridentifier.test(nid)
                            ? "#" + nid
                            : "[id='" + nid + "']";
                          while (i--) {
                            groups[i] = nidselect + " " + toSelector(groups[i]);
                          }
                          newSelector = groups.join(",");

                          // Expand context for sibling selectors
                          newContext =
                            (rsibling.test(selector) &&
                              testContext(context.parentNode)) ||
                            context;
                        }

                        if (newSelector) {
                          try {
                            push.apply(
                              results,
                              newContext.querySelectorAll(newSelector)
                            );
                            return results;
                          } catch (qsaError) {
                          } finally {
                            if (nid === expando) {
                              context.removeAttribute("id");
                            }
                          }
                        }
                      }
                    }
                  }

                  // All others
                  return select(
                    selector.replace(rtrim, "$1"),
                    context,
                    results,
                    seed
                  );
                }

                /**
                 * Create key-value caches of limited size
                 * @returns {function(string, object)} Returns the Object data after storing it on itself with
                 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                 *	deleting the oldest entry
                 */
                function createCache() {
                  var keys = [];

                  function cache(key, value) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key + " ") > Expr.cacheLength) {
                      // Only keep the most recent entries
                      delete cache[keys.shift()];
                    }
                    return (cache[key + " "] = value);
                  }
                  return cache;
                }

                /**
                 * Mark a function for special use by Sizzle
                 * @param {Function} fn The function to mark
                 */
                function markFunction(fn) {
                  fn[expando] = true;
                  return fn;
                }

                /**
                 * Support testing using an element
                 * @param {Function} fn Passed the created div and expects a boolean result
                 */
                function assert(fn) {
                  var div = document.createElement("div");

                  try {
                    return !!fn(div);
                  } catch (e) {
                    return false;
                  } finally {
                    // Remove from its parent by default
                    if (div.parentNode) {
                      div.parentNode.removeChild(div);
                    }
                    // release memory in IE
                    div = null;
                  }
                }

                /**
                 * Adds the same handler for all of the specified attrs
                 * @param {String} attrs Pipe-separated list of attributes
                 * @param {Function} handler The method that will be applied
                 */
                function addHandle(attrs, handler) {
                  var arr = attrs.split("|"),
                    i = arr.length;

                  while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                  }
                }

                /**
                 * Checks document order of two siblings
                 * @param {Element} a
                 * @param {Element} b
                 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                 */
                function siblingCheck(a, b) {
                  var cur = b && a,
                    diff =
                      cur &&
                      a.nodeType === 1 &&
                      b.nodeType === 1 &&
                      (~b.sourceIndex || MAX_NEGATIVE) -
                        (~a.sourceIndex || MAX_NEGATIVE);

                  // Use IE sourceIndex if available on both nodes
                  if (diff) {
                    return diff;
                  }

                  // Check if b follows a
                  if (cur) {
                    while ((cur = cur.nextSibling)) {
                      if (cur === b) {
                        return -1;
                      }
                    }
                  }

                  return a ? 1 : -1;
                }

                /**
                 * Returns a function to use in pseudos for input types
                 * @param {String} type
                 */
                function createInputPseudo(type) {
                  return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                  };
                }

                /**
                 * Returns a function to use in pseudos for buttons
                 * @param {String} type
                 */
                function createButtonPseudo(type) {
                  return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (
                      (name === "input" || name === "button") &&
                      elem.type === type
                    );
                  };
                }

                /**
                 * Returns a function to use in pseudos for positionals
                 * @param {Function} fn
                 */
                function createPositionalPseudo(fn) {
                  return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                      var j,
                        matchIndexes = fn([], seed.length, argument),
                        i = matchIndexes.length;

                      // Match elements found at the specified indexes
                      while (i--) {
                        if (seed[(j = matchIndexes[i])]) {
                          seed[j] = !(matches[j] = seed[j]);
                        }
                      }
                    });
                  });
                }

                /**
                 * Checks a node for validity as a Sizzle context
                 * @param {Element|Object=} context
                 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                 */
                function testContext(context) {
                  return (
                    context &&
                    typeof context.getElementsByTagName !== "undefined" &&
                    context
                  );
                }

                // Expose support vars for convenience
                support = Sizzle.support = {};

                /**
                 * Detects XML nodes
                 * @param {Element|Object} elem An element or a document
                 * @returns {Boolean} True iff elem is a non-HTML XML node
                 */
                isXML = Sizzle.isXML = function (elem) {
                  // documentElement is verified for cases where it doesn't yet exist
                  // (such as loading iframes in IE - #4833)
                  var documentElement =
                    elem && (elem.ownerDocument || elem).documentElement;
                  return documentElement
                    ? documentElement.nodeName !== "HTML"
                    : false;
                };

                /**
                 * Sets document-related variables once based on the current document
                 * @param {Element|Object} [doc] An element or document object to use to set the document
                 * @returns {Object} Returns the current document
                 */
                setDocument = Sizzle.setDocument = function (node) {
                  var hasCompare,
                    parent,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                  // Return early if doc is invalid or already selected
                  if (
                    doc === document ||
                    doc.nodeType !== 9 ||
                    !doc.documentElement
                  ) {
                    return document;
                  }

                  // Update global variables
                  document = doc;
                  docElem = document.documentElement;
                  documentIsHTML = !isXML(document);

                  // Support: IE 9-11, Edge
                  // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                  if (
                    (parent = document.defaultView) &&
                    parent.top !== parent
                  ) {
                    // Support: IE 11
                    if (parent.addEventListener) {
                      parent.addEventListener("unload", unloadHandler, false);

                      // Support: IE 9 - 10 only
                    } else if (parent.attachEvent) {
                      parent.attachEvent("onunload", unloadHandler);
                    }
                  }

                  /* Attributes
   ---------------------------------------------------------------------- */

                  // Support: IE<8
                  // Verify that getAttribute really returns attributes and not properties
                  // (excepting IE8 booleans)
                  support.attributes = assert(function (div) {
                    div.className = "i";
                    return !div.getAttribute("className");
                  });

                  /* getElement(s)By*
   ---------------------------------------------------------------------- */

                  // Check if getElementsByTagName("*") returns only elements
                  support.getElementsByTagName = assert(function (div) {
                    div.appendChild(document.createComment(""));
                    return !div.getElementsByTagName("*").length;
                  });

                  // Support: IE<9
                  support.getElementsByClassName = rnative.test(
                    document.getElementsByClassName
                  );

                  // Support: IE<10
                  // Check if getElementById returns elements by name
                  // The broken getElementById methods don't pick up programatically-set names,
                  // so use a roundabout getElementsByName test
                  support.getById = assert(function (div) {
                    docElem.appendChild(div).id = expando;
                    return (
                      !document.getElementsByName ||
                      !document.getElementsByName(expando).length
                    );
                  });

                  // ID find and filter
                  if (support.getById) {
                    Expr.find["ID"] = function (id, context) {
                      if (
                        typeof context.getElementById !== "undefined" &&
                        documentIsHTML
                      ) {
                        var m = context.getElementById(id);
                        return m ? [m] : [];
                      }
                    };
                    Expr.filter["ID"] = function (id) {
                      var attrId = id.replace(runescape, funescape);
                      return function (elem) {
                        return elem.getAttribute("id") === attrId;
                      };
                    };
                  } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find["ID"];

                    Expr.filter["ID"] = function (id) {
                      var attrId = id.replace(runescape, funescape);
                      return function (elem) {
                        var node =
                          typeof elem.getAttributeNode !== "undefined" &&
                          elem.getAttributeNode("id");
                        return node && node.value === attrId;
                      };
                    };
                  }

                  // Tag
                  Expr.find["TAG"] = support.getElementsByTagName
                    ? function (tag, context) {
                        if (
                          typeof context.getElementsByTagName !== "undefined"
                        ) {
                          return context.getElementsByTagName(tag);

                          // DocumentFragment nodes don't have gEBTN
                        } else if (support.qsa) {
                          return context.querySelectorAll(tag);
                        }
                      }
                    : function (tag, context) {
                        var elem,
                          tmp = [],
                          i = 0,
                          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                          results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                          while ((elem = results[i++])) {
                            if (elem.nodeType === 1) {
                              tmp.push(elem);
                            }
                          }

                          return tmp;
                        }
                        return results;
                      };

                  // Class
                  Expr.find["CLASS"] =
                    support.getElementsByClassName &&
                    function (className, context) {
                      if (
                        typeof context.getElementsByClassName !== "undefined" &&
                        documentIsHTML
                      ) {
                        return context.getElementsByClassName(className);
                      }
                    };

                  /* QSA/matchesSelector
   ---------------------------------------------------------------------- */

                  // QSA and matchesSelector support

                  // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                  rbuggyMatches = [];

                  // qSa(:focus) reports false when true (Chrome 21)
                  // We allow this because of a bug in IE8/9 that throws an error
                  // whenever `document.activeElement` is accessed on an iframe
                  // So, we allow :focus to pass through QSA all the time to avoid the IE error
                  // See http://bugs.jquery.com/ticket/13378
                  rbuggyQSA = [];

                  if ((support.qsa = rnative.test(document.querySelectorAll))) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (div) {
                      // Select is set to empty string on purpose
                      // This is to test IE's treatment of not explicitly
                      // setting a boolean content attribute,
                      // since its presence should be enough
                      // http://bugs.jquery.com/ticket/12359
                      docElem.appendChild(div).innerHTML =
                        "<a id='" +
                        expando +
                        "'></a>" +
                        "<select id='" +
                        expando +
                        "-\r\\' msallowcapture=''>" +
                        "<option selected=''></option></select>";

                      // Support: IE8, Opera 11-12.16
                      // Nothing should be selected when empty strings follow ^= or $= or *=
                      // The test attribute must be unknown in Opera but "safe" for WinRT
                      // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                      if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                      }

                      // Support: IE8
                      // Boolean attributes and "value" are not treated correctly
                      if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push(
                          "\\[" + whitespace + "*(?:value|" + booleans + ")"
                        );
                      }

                      // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                      if (
                        !div.querySelectorAll("[id~=" + expando + "-]").length
                      ) {
                        rbuggyQSA.push("~=");
                      }

                      // Webkit/Opera - :checked should return selected option elements
                      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                      // IE8 throws error here and will not see later tests
                      if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                      }

                      // Support: Safari 8+, iOS 8+
                      // https://bugs.webkit.org/show_bug.cgi?id=136851
                      // In-page `selector#id sibing-combinator selector` fails
                      if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                      }
                    });

                    assert(function (div) {
                      // Support: Windows 8 Native Apps
                      // The type and name attributes are restricted during .innerHTML assignment
                      var input = document.createElement("input");
                      input.setAttribute("type", "hidden");
                      div.appendChild(input).setAttribute("name", "D");

                      // Support: IE8
                      // Enforce case-sensitivity of name attribute
                      if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                      }

                      // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                      // IE8 throws error here and will not see later tests
                      if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                      }

                      // Opera 10-11 does not throw on post-comma invalid pseudos
                      div.querySelectorAll("*,:x");
                      rbuggyQSA.push(",.*:");
                    });
                  }

                  if (
                    (support.matchesSelector = rnative.test(
                      (matches =
                        docElem.matches ||
                        docElem.webkitMatchesSelector ||
                        docElem.mozMatchesSelector ||
                        docElem.oMatchesSelector ||
                        docElem.msMatchesSelector)
                    ))
                  ) {
                    assert(function (div) {
                      // Check to see if it's possible to do matchesSelector
                      // on a disconnected node (IE 9)
                      support.disconnectedMatch = matches.call(div, "div");

                      // This should fail with an exception
                      // Gecko does not error, returns false instead
                      matches.call(div, "[s!='']:x");
                      rbuggyMatches.push("!=", pseudos);
                    });
                  }

                  rbuggyQSA =
                    rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                  rbuggyMatches =
                    rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                  /* Contains
   ---------------------------------------------------------------------- */
                  hasCompare = rnative.test(docElem.compareDocumentPosition);

                  // Element contains another
                  // Purposefully self-exclusive
                  // As in, an element does not contain itself
                  contains =
                    hasCompare || rnative.test(docElem.contains)
                      ? function (a, b) {
                          var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                          return (
                            a === bup ||
                            !!(
                              bup &&
                              bup.nodeType === 1 &&
                              (adown.contains
                                ? adown.contains(bup)
                                : a.compareDocumentPosition &&
                                  a.compareDocumentPosition(bup) & 16)
                            )
                          );
                        }
                      : function (a, b) {
                          if (b) {
                            while ((b = b.parentNode)) {
                              if (b === a) {
                                return true;
                              }
                            }
                          }
                          return false;
                        };

                  /* Sorting
   ---------------------------------------------------------------------- */

                  // Document order sorting
                  sortOrder = hasCompare
                    ? function (a, b) {
                        // Flag for duplicate removal
                        if (a === b) {
                          hasDuplicate = true;
                          return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare =
                          !a.compareDocumentPosition -
                          !b.compareDocumentPosition;
                        if (compare) {
                          return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare =
                          (a.ownerDocument || a) === (b.ownerDocument || b)
                            ? a.compareDocumentPosition(b)
                            : // Otherwise we know they are disconnected
                              1;

                        // Disconnected nodes
                        if (
                          compare & 1 ||
                          (!support.sortDetached &&
                            b.compareDocumentPosition(a) === compare)
                        ) {
                          // Choose the first element that is related to our preferred document
                          if (
                            a === document ||
                            (a.ownerDocument === preferredDoc &&
                              contains(preferredDoc, a))
                          ) {
                            return -1;
                          }
                          if (
                            b === document ||
                            (b.ownerDocument === preferredDoc &&
                              contains(preferredDoc, b))
                          ) {
                            return 1;
                          }

                          // Maintain original order
                          return sortInput
                            ? indexOf(sortInput, a) - indexOf(sortInput, b)
                            : 0;
                        }

                        return compare & 4 ? -1 : 1;
                      }
                    : function (a, b) {
                        // Exit early if the nodes are identical
                        if (a === b) {
                          hasDuplicate = true;
                          return 0;
                        }

                        var cur,
                          i = 0,
                          aup = a.parentNode,
                          bup = b.parentNode,
                          ap = [a],
                          bp = [b];

                        // Parentless nodes are either documents or disconnected
                        if (!aup || !bup) {
                          return a === document
                            ? -1
                            : b === document
                            ? 1
                            : aup
                            ? -1
                            : bup
                            ? 1
                            : sortInput
                            ? indexOf(sortInput, a) - indexOf(sortInput, b)
                            : 0;

                          // If the nodes are siblings, we can do a quick check
                        } else if (aup === bup) {
                          return siblingCheck(a, b);
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ((cur = cur.parentNode)) {
                          ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                          bp.unshift(cur);
                        }

                        // Walk down the tree looking for a discrepancy
                        while (ap[i] === bp[i]) {
                          i++;
                        }

                        return i
                          ? // Do a sibling check if the nodes have a common ancestor
                            siblingCheck(ap[i], bp[i])
                          : // Otherwise nodes in our document sort first
                          ap[i] === preferredDoc
                          ? -1
                          : bp[i] === preferredDoc
                          ? 1
                          : 0;
                      };

                  return document;
                };

                Sizzle.matches = function (expr, elements) {
                  return Sizzle(expr, null, null, elements);
                };

                Sizzle.matchesSelector = function (elem, expr) {
                  // Set document vars if needed
                  if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                  }

                  // Make sure that attribute selectors are quoted
                  expr = expr.replace(rattributeQuotes, "='$1']");

                  if (
                    support.matchesSelector &&
                    documentIsHTML &&
                    !compilerCache[expr + " "] &&
                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                    (!rbuggyQSA || !rbuggyQSA.test(expr))
                  ) {
                    try {
                      var ret = matches.call(elem, expr);

                      // IE 9's matchesSelector returns false on disconnected nodes
                      if (
                        ret ||
                        support.disconnectedMatch ||
                        // As well, disconnected nodes are said to be in a document
                        // fragment in IE 9
                        (elem.document && elem.document.nodeType !== 11)
                      ) {
                        return ret;
                      }
                    } catch (e) {}
                  }

                  return Sizzle(expr, document, null, [elem]).length > 0;
                };

                Sizzle.contains = function (context, elem) {
                  // Set document vars if needed
                  if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                  }
                  return contains(context, elem);
                };

                Sizzle.attr = function (elem, name) {
                  // Set document vars if needed
                  if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                  }

                  var fn = Expr.attrHandle[name.toLowerCase()],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val =
                      fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
                        ? fn(elem, name, !documentIsHTML)
                        : undefined;

                  return val !== undefined
                    ? val
                    : support.attributes || !documentIsHTML
                    ? elem.getAttribute(name)
                    : (val = elem.getAttributeNode(name)) && val.specified
                    ? val.value
                    : null;
                };

                Sizzle.error = function (msg) {
                  throw new Error(
                    "Syntax error, unrecognized expression: " + msg
                  );
                };

                /**
                 * Document sorting and removing duplicates
                 * @param {ArrayLike} results
                 */
                Sizzle.uniqueSort = function (results) {
                  var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                  // Unless we *know* we can detect duplicates, assume their presence
                  hasDuplicate = !support.detectDuplicates;
                  sortInput = !support.sortStable && results.slice(0);
                  results.sort(sortOrder);

                  if (hasDuplicate) {
                    while ((elem = results[i++])) {
                      if (elem === results[i]) {
                        j = duplicates.push(i);
                      }
                    }
                    while (j--) {
                      results.splice(duplicates[j], 1);
                    }
                  }

                  // Clear input after sorting to release objects
                  // See https://github.com/jquery/sizzle/pull/225
                  sortInput = null;

                  return results;
                };

                /**
                 * Utility function for retrieving the text value of an array of DOM nodes
                 * @param {Array|Element} elem
                 */
                getText = Sizzle.getText = function (elem) {
                  var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                  if (!nodeType) {
                    // If no nodeType, this is expected to be an array
                    while ((node = elem[i++])) {
                      // Do not traverse comment nodes
                      ret += getText(node);
                    }
                  } else if (
                    nodeType === 1 ||
                    nodeType === 9 ||
                    nodeType === 11
                  ) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if (typeof elem.textContent === "string") {
                      return elem.textContent;
                    } else {
                      // Traverse its children
                      for (
                        elem = elem.firstChild;
                        elem;
                        elem = elem.nextSibling
                      ) {
                        ret += getText(elem);
                      }
                    }
                  } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                  }
                  // Do not include comment or processing instruction nodes

                  return ret;
                };

                Expr = Sizzle.selectors = {
                  // Can be adjusted by the user
                  cacheLength: 50,

                  createPseudo: markFunction,

                  match: matchExpr,

                  attrHandle: {},

                  find: {},

                  relative: {
                    ">": { dir: "parentNode", first: true },
                    " ": { dir: "parentNode" },
                    "+": { dir: "previousSibling", first: true },
                    "~": { dir: "previousSibling" },
                  },

                  preFilter: {
                    ATTR: function ATTR(match) {
                      match[1] = match[1].replace(runescape, funescape);

                      // Move the given value to match[3] whether quoted or unquoted
                      match[3] = (
                        match[3] ||
                        match[4] ||
                        match[5] ||
                        ""
                      ).replace(runescape, funescape);

                      if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                      }

                      return match.slice(0, 4);
                    },

                    CHILD: function CHILD(match) {
                      /* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
                      match[1] = match[1].toLowerCase();

                      if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) {
                          Sizzle.error(match[0]);
                        }

                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4]
                          ? match[5] + (match[6] || 1)
                          : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");

                        // other types prohibit arguments
                      } else if (match[3]) {
                        Sizzle.error(match[0]);
                      }

                      return match;
                    },

                    PSEUDO: function PSEUDO(match) {
                      var excess,
                        unquoted = !match[6] && match[2];

                      if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                      }

                      // Accept quoted arguments as-is
                      if (match[3]) {
                        match[2] = match[4] || match[5] || "";

                        // Strip excess characters from unquoted arguments
                      } else if (
                        unquoted &&
                        rpseudo.test(unquoted) &&
                        // Get excess from tokenize (recursively)
                        (excess = tokenize(unquoted, true)) &&
                        // advance to the next closing parenthesis
                        (excess =
                          unquoted.indexOf(")", unquoted.length - excess) -
                          unquoted.length)
                      ) {
                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                      }

                      // Return only captures needed by the pseudo filter method (type and argument)
                      return match.slice(0, 3);
                    },
                  },

                  filter: {
                    TAG: function TAG(nodeNameSelector) {
                      var nodeName = nodeNameSelector
                        .replace(runescape, funescape)
                        .toLowerCase();
                      return nodeNameSelector === "*"
                        ? function () {
                            return true;
                          }
                        : function (elem) {
                            return (
                              elem.nodeName &&
                              elem.nodeName.toLowerCase() === nodeName
                            );
                          };
                    },

                    CLASS: function CLASS(className) {
                      var pattern = classCache[className + " "];

                      return (
                        pattern ||
                        ((pattern = new RegExp(
                          "(^|" +
                            whitespace +
                            ")" +
                            className +
                            "(" +
                            whitespace +
                            "|$)"
                        )) &&
                          classCache(className, function (elem) {
                            return pattern.test(
                              (typeof elem.className === "string" &&
                                elem.className) ||
                                (typeof elem.getAttribute !== "undefined" &&
                                  elem.getAttribute("class")) ||
                                ""
                            );
                          }))
                      );
                    },

                    ATTR: function ATTR(name, operator, check) {
                      return function (elem) {
                        var result = Sizzle.attr(elem, name);

                        if (result == null) {
                          return operator === "!=";
                        }
                        if (!operator) {
                          return true;
                        }

                        result += "";

                        return operator === "="
                          ? result === check
                          : operator === "!="
                          ? result !== check
                          : operator === "^="
                          ? check && result.indexOf(check) === 0
                          : operator === "*="
                          ? check && result.indexOf(check) > -1
                          : operator === "$="
                          ? check && result.slice(-check.length) === check
                          : operator === "~="
                          ? (
                              " " +
                              result.replace(rwhitespace, " ") +
                              " "
                            ).indexOf(check) > -1
                          : operator === "|="
                          ? result === check ||
                            result.slice(0, check.length + 1) === check + "-"
                          : false;
                      };
                    },

                    CHILD: function CHILD(type, what, argument, first, last) {
                      var simple = type.slice(0, 3) !== "nth",
                        forward = type.slice(-4) !== "last",
                        ofType = what === "of-type";

                      return first === 1 && last === 0
                        ? // Shortcut for :nth-*(n)
                          function (elem) {
                            return !!elem.parentNode;
                          }
                        : function (elem, context, xml) {
                            var cache,
                              uniqueCache,
                              outerCache,
                              node,
                              nodeIndex,
                              start,
                              dir =
                                simple !== forward
                                  ? "nextSibling"
                                  : "previousSibling",
                              parent = elem.parentNode,
                              name = ofType && elem.nodeName.toLowerCase(),
                              useCache = !xml && !ofType,
                              diff = false;

                            if (parent) {
                              // :(first|last|only)-(child|of-type)
                              if (simple) {
                                while (dir) {
                                  node = elem;
                                  while ((node = node[dir])) {
                                    if (
                                      ofType
                                        ? node.nodeName.toLowerCase() === name
                                        : node.nodeType === 1
                                    ) {
                                      return false;
                                    }
                                  }
                                  // Reverse direction for :only-* (if we haven't yet done so)
                                  start = dir =
                                    type === "only" && !start && "nextSibling";
                                }
                                return true;
                              }

                              start = [
                                forward ? parent.firstChild : parent.lastChild,
                              ];

                              // non-xml :nth-child(...) stores cache data on `parent`
                              if (forward && useCache) {
                                // Seek `elem` from a previously-cached index

                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache =
                                  node[expando] || (node[expando] = {});

                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache =
                                  outerCache[node.uniqueID] ||
                                  (outerCache[node.uniqueID] = {});

                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node =
                                  nodeIndex && parent.childNodes[nodeIndex];

                                while (
                                  (node =
                                    (++nodeIndex && node && node[dir]) ||
                                    // Fallback to seeking `elem` from the start
                                    (diff = nodeIndex = 0) ||
                                    start.pop())
                                ) {
                                  // When found, cache indexes on `parent` and break
                                  if (
                                    node.nodeType === 1 &&
                                    ++diff &&
                                    node === elem
                                  ) {
                                    uniqueCache[type] = [
                                      dirruns,
                                      nodeIndex,
                                      diff,
                                    ];
                                    break;
                                  }
                                }
                              } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                  // ...in a gzip-friendly way
                                  node = elem;
                                  outerCache =
                                    node[expando] || (node[expando] = {});

                                  // Support: IE <9 only
                                  // Defend against cloned attroperties (jQuery gh-1709)
                                  uniqueCache =
                                    outerCache[node.uniqueID] ||
                                    (outerCache[node.uniqueID] = {});

                                  cache = uniqueCache[type] || [];
                                  nodeIndex = cache[0] === dirruns && cache[1];
                                  diff = nodeIndex;
                                }

                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                  // Use the same loop as above to seek `elem` from the start
                                  while (
                                    (node =
                                      (++nodeIndex && node && node[dir]) ||
                                      (diff = nodeIndex = 0) ||
                                      start.pop())
                                  ) {
                                    if (
                                      (ofType
                                        ? node.nodeName.toLowerCase() === name
                                        : node.nodeType === 1) &&
                                      ++diff
                                    ) {
                                      // Cache the index of each encountered element
                                      if (useCache) {
                                        outerCache =
                                          node[expando] || (node[expando] = {});

                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache =
                                          outerCache[node.uniqueID] ||
                                          (outerCache[node.uniqueID] = {});

                                        uniqueCache[type] = [dirruns, diff];
                                      }

                                      if (node === elem) {
                                        break;
                                      }
                                    }
                                  }
                                }
                              }

                              // Incorporate the offset, then check against cycle size
                              diff -= last;
                              return (
                                diff === first ||
                                (diff % first === 0 && diff / first >= 0)
                              );
                            }
                          };
                    },

                    PSEUDO: function PSEUDO(pseudo, argument) {
                      // pseudo-class names are case-insensitive
                      // http://www.w3.org/TR/selectors/#pseudo-classes
                      // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                      // Remember that setFilters inherits from pseudos
                      var args,
                        fn =
                          Expr.pseudos[pseudo] ||
                          Expr.setFilters[pseudo.toLowerCase()] ||
                          Sizzle.error("unsupported pseudo: " + pseudo);

                      // The user may use createPseudo to indicate that
                      // arguments are needed to create the filter function
                      // just as Sizzle does
                      if (fn[expando]) {
                        return fn(argument);
                      }

                      // But maintain support for old signatures
                      if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(
                          pseudo.toLowerCase()
                        )
                          ? markFunction(function (seed, matches) {
                              var idx,
                                matched = fn(seed, argument),
                                i = matched.length;
                              while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                              }
                            })
                          : function (elem) {
                              return fn(elem, 0, args);
                            };
                      }

                      return fn;
                    },
                  },

                  pseudos: {
                    // Potentially complex pseudos
                    not: markFunction(function (selector) {
                      // Trim the selector passed to compile
                      // to avoid treating leading and trailing
                      // spaces as combinators
                      var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1"));

                      return matcher[expando]
                        ? markFunction(function (seed, matches, context, xml) {
                            var elem,
                              unmatched = matcher(seed, null, xml, []),
                              i = seed.length;

                            // Match elements unmatched by `matcher`
                            while (i--) {
                              if ((elem = unmatched[i])) {
                                seed[i] = !(matches[i] = elem);
                              }
                            }
                          })
                        : function (elem, context, xml) {
                            input[0] = elem;
                            matcher(input, null, xml, results);
                            // Don't keep the element (issue #299)
                            input[0] = null;
                            return !results.pop();
                          };
                    }),

                    has: markFunction(function (selector) {
                      return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                      };
                    }),

                    contains: markFunction(function (text) {
                      text = text.replace(runescape, funescape);
                      return function (elem) {
                        return (
                          (
                            elem.textContent ||
                            elem.innerText ||
                            getText(elem)
                          ).indexOf(text) > -1
                        );
                      };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    lang: markFunction(function (lang) {
                      // lang value must be a valid identifier
                      if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                      }
                      lang = lang.replace(runescape, funescape).toLowerCase();
                      return function (elem) {
                        var elemLang;
                        do {
                          if (
                            (elemLang = documentIsHTML
                              ? elem.lang
                              : elem.getAttribute("xml:lang") ||
                                elem.getAttribute("lang"))
                          ) {
                            elemLang = elemLang.toLowerCase();
                            return (
                              elemLang === lang ||
                              elemLang.indexOf(lang + "-") === 0
                            );
                          }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                      };
                    }),

                    // Miscellaneous
                    target: function target(elem) {
                      var hash = window.location && window.location.hash;
                      return hash && hash.slice(1) === elem.id;
                    },

                    root: function root(elem) {
                      return elem === docElem;
                    },

                    focus: function focus(elem) {
                      return (
                        elem === document.activeElement &&
                        (!document.hasFocus || document.hasFocus()) &&
                        !!(elem.type || elem.href || ~elem.tabIndex)
                      );
                    },

                    // Boolean properties
                    enabled: function enabled(elem) {
                      return elem.disabled === false;
                    },

                    disabled: function disabled(elem) {
                      return elem.disabled === true;
                    },

                    checked: function checked(elem) {
                      // In CSS3, :checked should return both checked and selected elements
                      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                      var nodeName = elem.nodeName.toLowerCase();
                      return (
                        (nodeName === "input" && !!elem.checked) ||
                        (nodeName === "option" && !!elem.selected)
                      );
                    },

                    selected: function selected(elem) {
                      // Accessing this property makes selected-by-default
                      // options in Safari work properly
                      if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                      }

                      return elem.selected === true;
                    },

                    // Contents
                    empty: function empty(elem) {
                      // http://www.w3.org/TR/selectors/#empty-pseudo
                      // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                      //   but not by others (comment: 8; processing instruction: 7; etc.)
                      // nodeType < 6 works because attributes (2) do not appear as children
                      for (
                        elem = elem.firstChild;
                        elem;
                        elem = elem.nextSibling
                      ) {
                        if (elem.nodeType < 6) {
                          return false;
                        }
                      }
                      return true;
                    },

                    parent: function parent(elem) {
                      return !Expr.pseudos["empty"](elem);
                    },

                    // Element/input types
                    header: function header(elem) {
                      return rheader.test(elem.nodeName);
                    },

                    input: function input(elem) {
                      return rinputs.test(elem.nodeName);
                    },

                    button: function button(elem) {
                      var name = elem.nodeName.toLowerCase();
                      return (
                        (name === "input" && elem.type === "button") ||
                        name === "button"
                      );
                    },

                    text: function text(elem) {
                      var attr;
                      return (
                        elem.nodeName.toLowerCase() === "input" &&
                        elem.type === "text" &&
                        // Support: IE<8
                        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                        ((attr = elem.getAttribute("type")) == null ||
                          attr.toLowerCase() === "text")
                      );
                    },

                    // Position-in-collection
                    first: createPositionalPseudo(function () {
                      return [0];
                    }),

                    last: createPositionalPseudo(function (
                      matchIndexes,
                      length
                    ) {
                      return [length - 1];
                    }),

                    eq: createPositionalPseudo(function (
                      matchIndexes,
                      length,
                      argument
                    ) {
                      return [argument < 0 ? argument + length : argument];
                    }),

                    even: createPositionalPseudo(function (
                      matchIndexes,
                      length
                    ) {
                      var i = 0;
                      for (; i < length; i += 2) {
                        matchIndexes.push(i);
                      }
                      return matchIndexes;
                    }),

                    odd: createPositionalPseudo(function (
                      matchIndexes,
                      length
                    ) {
                      var i = 1;
                      for (; i < length; i += 2) {
                        matchIndexes.push(i);
                      }
                      return matchIndexes;
                    }),

                    lt: createPositionalPseudo(function (
                      matchIndexes,
                      length,
                      argument
                    ) {
                      var i = argument < 0 ? argument + length : argument;
                      for (; --i >= 0; ) {
                        matchIndexes.push(i);
                      }
                      return matchIndexes;
                    }),

                    gt: createPositionalPseudo(function (
                      matchIndexes,
                      length,
                      argument
                    ) {
                      var i = argument < 0 ? argument + length : argument;
                      for (; ++i < length; ) {
                        matchIndexes.push(i);
                      }
                      return matchIndexes;
                    }),
                  },
                };

                Expr.pseudos["nth"] = Expr.pseudos["eq"];

                // Add button/input type pseudos
                for (i in {
                  radio: true,
                  checkbox: true,
                  file: true,
                  password: true,
                  image: true,
                }) {
                  Expr.pseudos[i] = createInputPseudo(i);
                }
                for (i in { submit: true, reset: true }) {
                  Expr.pseudos[i] = createButtonPseudo(i);
                }

                // Easy API for creating new setFilters
                function setFilters() {}
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();

                tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                  var matched,
                    match,
                    tokens,
                    type,
                    soFar,
                    groups,
                    preFilters,
                    cached = tokenCache[selector + " "];

                  if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                  }

                  soFar = selector;
                  groups = [];
                  preFilters = Expr.preFilter;

                  while (soFar) {
                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                      if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                      }
                      groups.push((tokens = []));
                    }

                    matched = false;

                    // Combinators
                    if ((match = rcombinators.exec(soFar))) {
                      matched = match.shift();
                      tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " "),
                      });
                      soFar = soFar.slice(matched.length);
                    }

                    // Filters
                    for (type in Expr.filter) {
                      if (
                        (match = matchExpr[type].exec(soFar)) &&
                        (!preFilters[type] || (match = preFilters[type](match)))
                      ) {
                        matched = match.shift();
                        tokens.push({
                          value: matched,
                          type: type,
                          matches: match,
                        });
                        soFar = soFar.slice(matched.length);
                      }
                    }

                    if (!matched) {
                      break;
                    }
                  }

                  // Return the length of the invalid excess
                  // if we're just parsing
                  // Otherwise, throw an error or return tokens
                  return parseOnly
                    ? soFar.length
                    : soFar
                    ? Sizzle.error(selector)
                    : // Cache the tokens
                      tokenCache(selector, groups).slice(0);
                };

                function toSelector(tokens) {
                  var i = 0,
                    len = tokens.length,
                    selector = "";
                  for (; i < len; i++) {
                    selector += tokens[i].value;
                  }
                  return selector;
                }

                function addCombinator(matcher, combinator, base) {
                  var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;

                  return combinator.first
                    ? // Check against closest ancestor/preceding element
                      function (elem, context, xml) {
                        while ((elem = elem[dir])) {
                          if (elem.nodeType === 1 || checkNonElements) {
                            return matcher(elem, context, xml);
                          }
                        }
                      }
                    : // Check against all ancestor/preceding elements
                      function (elem, context, xml) {
                        var oldCache,
                          uniqueCache,
                          outerCache,
                          newCache = [dirruns, doneName];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if (xml) {
                          while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                              if (matcher(elem, context, xml)) {
                                return true;
                              }
                            }
                          }
                        } else {
                          while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                              outerCache =
                                elem[expando] || (elem[expando] = {});

                              // Support: IE <9 only
                              // Defend against cloned attroperties (jQuery gh-1709)
                              uniqueCache =
                                outerCache[elem.uniqueID] ||
                                (outerCache[elem.uniqueID] = {});

                              if (
                                (oldCache = uniqueCache[dir]) &&
                                oldCache[0] === dirruns &&
                                oldCache[1] === doneName
                              ) {
                                // Assign to newCache so results back-propagate to previous elements
                                return (newCache[2] = oldCache[2]);
                              } else {
                                // Reuse newcache so results back-propagate to previous elements
                                uniqueCache[dir] = newCache;

                                // A match means we're done; a fail means we have to keep checking
                                if (
                                  (newCache[2] = matcher(elem, context, xml))
                                ) {
                                  return true;
                                }
                              }
                            }
                          }
                        }
                      };
                }

                function elementMatcher(matchers) {
                  return matchers.length > 1
                    ? function (elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                          if (!matchers[i](elem, context, xml)) {
                            return false;
                          }
                        }
                        return true;
                      }
                    : matchers[0];
                }

                function multipleContexts(selector, contexts, results) {
                  var i = 0,
                    len = contexts.length;
                  for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                  }
                  return results;
                }

                function condense(unmatched, map, filter, context, xml) {
                  var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                  for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                      if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                          map.push(i);
                        }
                      }
                    }
                  }

                  return newUnmatched;
                }

                function setMatcher(
                  preFilter,
                  selector,
                  matcher,
                  postFilter,
                  postFinder,
                  postSelector
                ) {
                  if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                  }
                  if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                  }
                  return markFunction(function (seed, results, context, xml) {
                    var temp,
                      i,
                      elem,
                      preMap = [],
                      postMap = [],
                      preexisting = results.length,
                      // Get initial elements from seed or context
                      elems =
                        seed ||
                        multipleContexts(
                          selector || "*",
                          context.nodeType ? [context] : context,
                          []
                        ),
                      // Prefilter to get matcher input, preserving a map for seed-results synchronization
                      matcherIn =
                        preFilter && (seed || !selector)
                          ? condense(elems, preMap, preFilter, context, xml)
                          : elems,
                      matcherOut = matcher
                        ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                          postFinder ||
                          (seed ? preFilter : preexisting || postFilter)
                          ? // ...intermediate processing is necessary
                            []
                          : // ...otherwise use results directly
                            results
                        : matcherIn;

                    // Find primary matches
                    if (matcher) {
                      matcher(matcherIn, matcherOut, context, xml);
                    }

                    // Apply postFilter
                    if (postFilter) {
                      temp = condense(matcherOut, postMap);
                      postFilter(temp, [], context, xml);

                      // Un-match failing elements by moving them back to matcherIn
                      i = temp.length;
                      while (i--) {
                        if ((elem = temp[i])) {
                          matcherOut[postMap[i]] = !(matcherIn[postMap[i]] =
                            elem);
                        }
                      }
                    }

                    if (seed) {
                      if (postFinder || preFilter) {
                        if (postFinder) {
                          // Get the final matcherOut by condensing this intermediate into postFinder contexts
                          temp = [];
                          i = matcherOut.length;
                          while (i--) {
                            if ((elem = matcherOut[i])) {
                              // Restore matcherIn since elem is not yet a final match
                              temp.push((matcherIn[i] = elem));
                            }
                          }
                          postFinder(null, (matcherOut = []), temp, xml);
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                          if (
                            (elem = matcherOut[i]) &&
                            (temp = postFinder
                              ? indexOf(seed, elem)
                              : preMap[i]) > -1
                          ) {
                            seed[temp] = !(results[temp] = elem);
                          }
                        }
                      }

                      // Add elements to results, through postFinder if defined
                    } else {
                      matcherOut = condense(
                        matcherOut === results
                          ? matcherOut.splice(preexisting, matcherOut.length)
                          : matcherOut
                      );
                      if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                      } else {
                        push.apply(results, matcherOut);
                      }
                    }
                  });
                }

                function matcherFromTokens(tokens) {
                  var checkContext,
                    matcher,
                    j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,
                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(
                      function (elem) {
                        return elem === checkContext;
                      },
                      implicitRelative,
                      true
                    ),
                    matchAnyContext = addCombinator(
                      function (elem) {
                        return indexOf(checkContext, elem) > -1;
                      },
                      implicitRelative,
                      true
                    ),
                    matchers = [
                      function (elem, context, xml) {
                        var ret =
                          (!leadingRelative &&
                            (xml || context !== outermostContext)) ||
                          ((checkContext = context).nodeType
                            ? matchContext(elem, context, xml)
                            : matchAnyContext(elem, context, xml));
                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                      },
                    ];

                  for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                      matchers = [
                        addCombinator(elementMatcher(matchers), matcher),
                      ];
                    } else {
                      matcher = Expr.filter[tokens[i].type].apply(
                        null,
                        tokens[i].matches
                      );

                      // Return special upon seeing a positional matcher
                      if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (; j < len; j++) {
                          if (Expr.relative[tokens[j].type]) {
                            break;
                          }
                        }
                        return setMatcher(
                          i > 1 && elementMatcher(matchers),
                          i > 1 &&
                            toSelector(
                              // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                              tokens.slice(0, i - 1).concat({
                                value: tokens[i - 2].type === " " ? "*" : "",
                              })
                            ).replace(rtrim, "$1"),
                          matcher,
                          i < j && matcherFromTokens(tokens.slice(i, j)),
                          j < len &&
                            matcherFromTokens((tokens = tokens.slice(j))),
                          j < len && toSelector(tokens)
                        );
                      }
                      matchers.push(matcher);
                    }
                  }

                  return elementMatcher(matchers);
                }

                function matcherFromGroupMatchers(
                  elementMatchers,
                  setMatchers
                ) {
                  var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function superMatcher(
                      seed,
                      context,
                      xml,
                      results,
                      outermost
                    ) {
                      var elem,
                        j,
                        matcher,
                        matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        setMatched = [],
                        contextBackup = outermostContext,
                        // We must always have either seed elements or outermost context
                        elems =
                          seed ||
                          (byElement && Expr.find["TAG"]("*", outermost)),
                        // Use integer dirruns iff this is the outermost matcher
                        dirrunsUnique = (dirruns +=
                          contextBackup == null ? 1 : Math.random() || 0.1),
                        len = elems.length;

                      if (outermost) {
                        outermostContext =
                          context === document || context || outermost;
                      }

                      // Add elements passing elementMatchers directly to results
                      // Support: IE<9, Safari
                      // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                      for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                          j = 0;
                          if (!context && elem.ownerDocument !== document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                          }
                          while ((matcher = elementMatchers[j++])) {
                            if (matcher(elem, context || document, xml)) {
                              results.push(elem);
                              break;
                            }
                          }
                          if (outermost) {
                            dirruns = dirrunsUnique;
                          }
                        }

                        // Track unmatched elements for set filters
                        if (bySet) {
                          // They will have gone through all possible matchers
                          if ((elem = !matcher && elem)) {
                            matchedCount--;
                          }

                          // Lengthen the array for every element, matched or not
                          if (seed) {
                            unmatched.push(elem);
                          }
                        }
                      }

                      // `i` is now the count of elements visited above, and adding it to `matchedCount`
                      // makes the latter nonnegative.
                      matchedCount += i;

                      // Apply set filters to unmatched elements
                      // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                      // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                      // no element matchers and no seed.
                      // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                      // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                      // numerically zero.
                      if (bySet && i !== matchedCount) {
                        j = 0;
                        while ((matcher = setMatchers[j++])) {
                          matcher(unmatched, setMatched, context, xml);
                        }

                        if (seed) {
                          // Reintegrate element matches to eliminate the need for sorting
                          if (matchedCount > 0) {
                            while (i--) {
                              if (!(unmatched[i] || setMatched[i])) {
                                setMatched[i] = pop.call(results);
                              }
                            }
                          }

                          // Discard index placeholder values to get only actual matches
                          setMatched = condense(setMatched);
                        }

                        // Add matches to results
                        push.apply(results, setMatched);

                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                        if (
                          outermost &&
                          !seed &&
                          setMatched.length > 0 &&
                          matchedCount + setMatchers.length > 1
                        ) {
                          Sizzle.uniqueSort(results);
                        }
                      }

                      // Override manipulation of globals by nested matchers
                      if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                      }

                      return unmatched;
                    };

                  return bySet ? markFunction(superMatcher) : superMatcher;
                }

                compile = Sizzle.compile = function (
                  selector,
                  match /* Internal Use Only */
                ) {
                  var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];

                  if (!cached) {
                    // Generate a function of recursive functions that can be used to check each element
                    if (!match) {
                      match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                      cached = matcherFromTokens(match[i]);
                      if (cached[expando]) {
                        setMatchers.push(cached);
                      } else {
                        elementMatchers.push(cached);
                      }
                    }

                    // Cache the compiled function
                    cached = compilerCache(
                      selector,
                      matcherFromGroupMatchers(elementMatchers, setMatchers)
                    );

                    // Save selector and tokenization
                    cached.selector = selector;
                  }
                  return cached;
                };

                /**
                 * A low-level selection function that works with Sizzle's compiled
                 *  selector functions
                 * @param {String|Function} selector A selector or a pre-compiled
                 *  selector function built with Sizzle.compile
                 * @param {Element} context
                 * @param {Array} [results]
                 * @param {Array} [seed] A set of elements to match against
                 */
                select = Sizzle.select = function (
                  selector,
                  context,
                  results,
                  seed
                ) {
                  var i,
                    tokens,
                    token,
                    type,
                    find,
                    compiled = typeof selector === "function" && selector,
                    match =
                      !seed &&
                      tokenize((selector = compiled.selector || selector));

                  results = results || [];

                  // Try to minimize operations if there is only one selector in the list and no seed
                  // (the latter of which guarantees us context)
                  if (match.length === 1) {
                    // Reduce context if the leading compound selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (
                      tokens.length > 2 &&
                      (token = tokens[0]).type === "ID" &&
                      support.getById &&
                      context.nodeType === 9 &&
                      documentIsHTML &&
                      Expr.relative[tokens[1].type]
                    ) {
                      context = (Expr.find["ID"](
                        token.matches[0].replace(runescape, funescape),
                        context
                      ) || [])[0];
                      if (!context) {
                        return results;

                        // Precompiled matchers will still verify ancestry, so step up a level
                      } else if (compiled) {
                        context = context.parentNode;
                      }

                      selector = selector.slice(tokens.shift().value.length);
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test(selector)
                      ? 0
                      : tokens.length;
                    while (i--) {
                      token = tokens[i];

                      // Abort if we hit a combinator
                      if (Expr.relative[(type = token.type)]) {
                        break;
                      }
                      if ((find = Expr.find[type])) {
                        // Search, expanding context for leading sibling combinators
                        if (
                          (seed = find(
                            token.matches[0].replace(runescape, funescape),
                            (rsibling.test(tokens[0].type) &&
                              testContext(context.parentNode)) ||
                              context
                          ))
                        ) {
                          // If seed is empty or no tokens remain, we can return early
                          tokens.splice(i, 1);
                          selector = seed.length && toSelector(tokens);
                          if (!selector) {
                            push.apply(results, seed);
                            return results;
                          }

                          break;
                        }
                      }
                    }
                  }

                  // Compile and execute a filtering function if one is not provided
                  // Provide `match` to avoid retokenization if we modified the selector above
                  (compiled || compile(selector, match))(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    !context ||
                      (rsibling.test(selector) &&
                        testContext(context.parentNode)) ||
                      context
                  );
                  return results;
                };

                // One-time assignments

                // Sort stability
                support.sortStable =
                  expando.split("").sort(sortOrder).join("") === expando;

                // Support: Chrome 14-35+
                // Always assume duplicates if they aren't passed to the comparison function
                support.detectDuplicates = !!hasDuplicate;

                // Initialize against the default document
                setDocument();

                // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                // Detached nodes confoundingly follow *each other*
                support.sortDetached = assert(function (div1) {
                  // Should return 1, but returns 4 (following)
                  return (
                    div1.compareDocumentPosition(
                      document.createElement("div")
                    ) & 1
                  );
                });

                // Support: IE<8
                // Prevent attribute/property "interpolation"
                // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                if (
                  !assert(function (div) {
                    div.innerHTML = "<a href='#'></a>";
                    return div.firstChild.getAttribute("href") === "#";
                  })
                ) {
                  addHandle(
                    "type|href|height|width",
                    function (elem, name, isXML) {
                      if (!isXML) {
                        return elem.getAttribute(
                          name,
                          name.toLowerCase() === "type" ? 1 : 2
                        );
                      }
                    }
                  );
                }

                // Support: IE<9
                // Use defaultValue in place of getAttribute("value")
                if (
                  !support.attributes ||
                  !assert(function (div) {
                    div.innerHTML = "<input/>";
                    div.firstChild.setAttribute("value", "");
                    return div.firstChild.getAttribute("value") === "";
                  })
                ) {
                  addHandle("value", function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                      return elem.defaultValue;
                    }
                  });
                }

                // Support: IE<9
                // Use getAttributeNode to fetch booleans when getAttribute lies
                if (
                  !assert(function (div) {
                    return div.getAttribute("disabled") == null;
                  })
                ) {
                  addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                      return elem[name] === true
                        ? name.toLowerCase()
                        : (val = elem.getAttributeNode(name)) && val.specified
                        ? val.value
                        : null;
                    }
                  });
                }

                return Sizzle;
              })(window);

            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;

            var dir = function dir(elem, _dir, until) {
              var matched = [],
                truncate = until !== undefined;

              while ((elem = elem[_dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                  if (truncate && jQuery(elem).is(until)) {
                    break;
                  }
                  matched.push(elem);
                }
              }
              return matched;
            };

            var _siblings = function _siblings(n, elem) {
              var matched = [];

              for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                  matched.push(n);
                }
              }

              return matched;
            };

            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

            var risSimple = /^.[^:#\[\.,]*$/;

            // Implement the identical functionality for filter and not
            function winnow(elements, qualifier, not) {
              if (jQuery.isFunction(qualifier)) {
                return jQuery.grep(elements, function (elem, i) {
                  /* jshint -W018 */
                  return !!qualifier.call(elem, i, elem) !== not;
                });
              }

              if (qualifier.nodeType) {
                return jQuery.grep(elements, function (elem) {
                  return (elem === qualifier) !== not;
                });
              }

              if (typeof qualifier === "string") {
                if (risSimple.test(qualifier)) {
                  return jQuery.filter(qualifier, elements, not);
                }

                qualifier = jQuery.filter(qualifier, elements);
              }

              return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
              });
            }

            jQuery.filter = function (expr, elems, not) {
              var elem = elems[0];

              if (not) {
                expr = ":not(" + expr + ")";
              }

              return elems.length === 1 && elem.nodeType === 1
                ? jQuery.find.matchesSelector(elem, expr)
                  ? [elem]
                  : []
                : jQuery.find.matches(
                    expr,
                    jQuery.grep(elems, function (elem) {
                      return elem.nodeType === 1;
                    })
                  );
            };

            jQuery.fn.extend({
              find: function find(selector) {
                var i,
                  len = this.length,
                  ret = [],
                  self = this;

                if (typeof selector !== "string") {
                  return this.pushStack(
                    jQuery(selector).filter(function () {
                      for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                          return true;
                        }
                      }
                    })
                  );
                }

                for (i = 0; i < len; i++) {
                  jQuery.find(selector, self[i], ret);
                }

                // Needed because $( selector, context ) becomes $( context ).find( selector )
                ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                ret.selector = this.selector
                  ? this.selector + " " + selector
                  : selector;
                return ret;
              },
              filter: function filter(selector) {
                return this.pushStack(winnow(this, selector || [], false));
              },
              not: function not(selector) {
                return this.pushStack(winnow(this, selector || [], true));
              },
              is: function is(selector) {
                return !!winnow(
                  this,

                  // If this is a positional/relative selector, check membership in the returned set
                  // so $("p:first").is("p:last") won't return true for a doc with two "p".
                  typeof selector === "string" && rneedsContext.test(selector)
                    ? jQuery(selector)
                    : selector || [],
                  false
                ).length;
              },
            });

            // Initialize a jQuery object

            // A central reference to the root jQuery(document)
            var rootjQuery,
              // A simple way to check for HTML strings
              // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
              // Strict HTML recognition (#11290: must start with <)
              rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
              init = (jQuery.fn.init = function (selector, context, root) {
                var match, elem;

                // HANDLE: $(""), $(null), $(undefined), $(false)
                if (!selector) {
                  return this;
                }

                // Method init() accepts an alternate rootjQuery
                // so migrate can support jQuery.sub (gh-2101)
                root = root || rootjQuery;

                // Handle HTML strings
                if (typeof selector === "string") {
                  if (
                    selector[0] === "<" &&
                    selector[selector.length - 1] === ">" &&
                    selector.length >= 3
                  ) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];
                  } else {
                    match = rquickExpr.exec(selector);
                  }

                  // Match html or make sure no context is specified for #id
                  if (match && (match[1] || !context)) {
                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                      context =
                        context instanceof jQuery ? context[0] : context;

                      // Option to run scripts is true for back-compat
                      // Intentionally let the error be thrown if parseHTML is not present
                      jQuery.merge(
                        this,
                        jQuery.parseHTML(
                          match[1],
                          context && context.nodeType
                            ? context.ownerDocument || context
                            : document,
                          true
                        )
                      );

                      // HANDLE: $(html, props)
                      if (
                        rsingleTag.test(match[1]) &&
                        jQuery.isPlainObject(context)
                      ) {
                        for (match in context) {
                          // Properties of context are called as methods if possible
                          if (jQuery.isFunction(this[match])) {
                            this[match](context[match]);

                            // ...and otherwise set as attributes
                          } else {
                            this.attr(match, context[match]);
                          }
                        }
                      }

                      return this;

                      // HANDLE: $(#id)
                    } else {
                      elem = document.getElementById(match[2]);

                      // Support: Blackberry 4.6
                      // gEBID returns nodes no longer in the document (#6963)
                      if (elem && elem.parentNode) {
                        // Inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                      }

                      this.context = document;
                      this.selector = selector;
                      return this;
                    }

                    // HANDLE: $(expr, $(...))
                  } else if (!context || context.jquery) {
                    return (context || root).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                  } else {
                    return this.constructor(context).find(selector);
                  }

                  // HANDLE: $(DOMElement)
                } else if (selector.nodeType) {
                  this.context = this[0] = selector;
                  this.length = 1;
                  return this;

                  // HANDLE: $(function)
                  // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                  return root.ready !== undefined
                    ? root.ready(selector)
                    : // Execute immediately if ready is not present
                      selector(jQuery);
                }

                if (selector.selector !== undefined) {
                  this.selector = selector.selector;
                  this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
              });

            // Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

            // Initialize central reference
            rootjQuery = jQuery(document);

            var rparentsprev = /^(?:parents|prev(?:Until|All))/,
              // Methods guaranteed to produce a unique set when starting from a unique set
              guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true,
              };

            jQuery.fn.extend({
              has: function has(target) {
                var targets = jQuery(target, this),
                  l = targets.length;

                return this.filter(function () {
                  var i = 0;
                  for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                      return true;
                    }
                  }
                });
              },

              closest: function closest(selectors, context) {
                var cur,
                  i = 0,
                  l = this.length,
                  matched = [],
                  pos =
                    rneedsContext.test(selectors) ||
                    typeof selectors !== "string"
                      ? jQuery(selectors, context || this.context)
                      : 0;

                for (; i < l; i++) {
                  for (
                    cur = this[i];
                    cur && cur !== context;
                    cur = cur.parentNode
                  ) {
                    // Always skip document fragments
                    if (
                      cur.nodeType < 11 &&
                      (pos
                        ? pos.index(cur) > -1
                        : // Don't pass non-elements to Sizzle
                          cur.nodeType === 1 &&
                          jQuery.find.matchesSelector(cur, selectors))
                    ) {
                      matched.push(cur);
                      break;
                    }
                  }
                }

                return this.pushStack(
                  matched.length > 1 ? jQuery.uniqueSort(matched) : matched
                );
              },

              // Determine the position of an element within the set
              index: function index(elem) {
                // No argument, return index in parent
                if (!elem) {
                  return this[0] && this[0].parentNode
                    ? this.first().prevAll().length
                    : -1;
                }

                // Index in selector
                if (typeof elem === "string") {
                  return indexOf.call(jQuery(elem), this[0]);
                }

                // Locate the position of the desired element
                return indexOf.call(
                  this,

                  // If it receives a jQuery object, the first element is used
                  elem.jquery ? elem[0] : elem
                );
              },

              add: function add(selector, context) {
                return this.pushStack(
                  jQuery.uniqueSort(
                    jQuery.merge(this.get(), jQuery(selector, context))
                  )
                );
              },

              addBack: function addBack(selector) {
                return this.add(
                  selector == null
                    ? this.prevObject
                    : this.prevObject.filter(selector)
                );
              },
            });

            function sibling(cur, dir) {
              while ((cur = cur[dir]) && cur.nodeType !== 1) {}
              return cur;
            }

            jQuery.each(
              {
                parent: function parent(elem) {
                  var parent = elem.parentNode;
                  return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function parents(elem) {
                  return dir(elem, "parentNode");
                },
                parentsUntil: function parentsUntil(elem, i, until) {
                  return dir(elem, "parentNode", until);
                },
                next: function next(elem) {
                  return sibling(elem, "nextSibling");
                },
                prev: function prev(elem) {
                  return sibling(elem, "previousSibling");
                },
                nextAll: function nextAll(elem) {
                  return dir(elem, "nextSibling");
                },
                prevAll: function prevAll(elem) {
                  return dir(elem, "previousSibling");
                },
                nextUntil: function nextUntil(elem, i, until) {
                  return dir(elem, "nextSibling", until);
                },
                prevUntil: function prevUntil(elem, i, until) {
                  return dir(elem, "previousSibling", until);
                },
                siblings: function siblings(elem) {
                  return _siblings((elem.parentNode || {}).firstChild, elem);
                },
                children: function children(elem) {
                  return _siblings(elem.firstChild);
                },
                contents: function contents(elem) {
                  return (
                    elem.contentDocument || jQuery.merge([], elem.childNodes)
                  );
                },
              },
              function (name, fn) {
                jQuery.fn[name] = function (until, selector) {
                  var matched = jQuery.map(this, fn, until);

                  if (name.slice(-5) !== "Until") {
                    selector = until;
                  }

                  if (selector && typeof selector === "string") {
                    matched = jQuery.filter(selector, matched);
                  }

                  if (this.length > 1) {
                    // Remove duplicates
                    if (!guaranteedUnique[name]) {
                      jQuery.uniqueSort(matched);
                    }

                    // Reverse order for parents* and prev-derivatives
                    if (rparentsprev.test(name)) {
                      matched.reverse();
                    }
                  }

                  return this.pushStack(matched);
                };
              }
            );
            var rnotwhite = /\S+/g;

            // Convert String-formatted options into Object-formatted ones
            function createOptions(options) {
              var object = {};
              jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                object[flag] = true;
              });
              return object;
            }

            /*
             * Create a callback list using the following parameters:
             *
             *	options: an optional list of space-separated options that will change how
             *			the callback list behaves or a more traditional option object
             *
             * By default a callback list will act like an event callback list and can be
             * "fired" multiple times.
             *
             * Possible options:
             *
             *	once:			will ensure the callback list can only be fired once (like a Deferred)
             *
             *	memory:			will keep track of previous values and will call any callback added
             *					after the list has been fired right away with the latest "memorized"
             *					values (like a Deferred)
             *
             *	unique:			will ensure a callback can only be added once (no duplicate in the list)
             *
             *	stopOnFalse:	interrupt callings when a callback returns false
             *
             */
            jQuery.Callbacks = function (options) {
              // Convert options from String-formatted to Object-formatted if needed
              // (we check in cache first)
              options =
                typeof options === "string"
                  ? createOptions(options)
                  : jQuery.extend({}, options);

              var // Flag to know if list is currently firing
                firing,
                // Last fire value for non-forgettable lists
                memory,
                // Flag to know if list was already fired
                _fired,
                // Flag to prevent firing
                _locked,
                // Actual callback list
                list = [],
                // Queue of execution data for repeatable lists
                queue = [],
                // Index of currently firing callback (modified by add/remove as needed)
                firingIndex = -1,
                // Fire callbacks
                fire = function fire() {
                  // Enforce single-firing
                  _locked = options.once;

                  // Execute callbacks for all pending executions,
                  // respecting firingIndex overrides and runtime changes
                  _fired = firing = true;
                  for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                      // Run callback and check for early termination
                      if (
                        list[firingIndex].apply(memory[0], memory[1]) ===
                          false &&
                        options.stopOnFalse
                      ) {
                        // Jump to end and forget the data so .add doesn't re-fire
                        firingIndex = list.length;
                        memory = false;
                      }
                    }
                  }

                  // Forget the data if we're done with it
                  if (!options.memory) {
                    memory = false;
                  }

                  firing = false;

                  // Clean up if we're done firing for good
                  if (_locked) {
                    // Keep an empty list if we have data for future add calls
                    if (memory) {
                      list = [];

                      // Otherwise, this object is spent
                    } else {
                      list = "";
                    }
                  }
                },
                // Actual Callbacks object
                self = {
                  // Add a callback or a collection of callbacks to the list
                  add: function add() {
                    if (list) {
                      // If we have memory from a past run, we should fire after adding
                      if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                      }

                      (function add(args) {
                        jQuery.each(args, function (_, arg) {
                          if (jQuery.isFunction(arg)) {
                            if (!options.unique || !self.has(arg)) {
                              list.push(arg);
                            }
                          } else if (
                            arg &&
                            arg.length &&
                            jQuery.type(arg) !== "string"
                          ) {
                            // Inspect recursively
                            add(arg);
                          }
                        });
                      })(arguments);

                      if (memory && !firing) {
                        fire();
                      }
                    }
                    return this;
                  },

                  // Remove a callback from the list
                  remove: function remove() {
                    jQuery.each(arguments, function (_, arg) {
                      var index;
                      while ((index = jQuery.inArray(arg, list, index)) > -1) {
                        list.splice(index, 1);

                        // Handle firing indexes
                        if (index <= firingIndex) {
                          firingIndex--;
                        }
                      }
                    });
                    return this;
                  },

                  // Check if a given callback is in the list.
                  // If no argument is given, return whether or not list has callbacks attached.
                  has: function has(fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                  },

                  // Remove all callbacks from the list
                  empty: function empty() {
                    if (list) {
                      list = [];
                    }
                    return this;
                  },

                  // Disable .fire and .add
                  // Abort any current/pending executions
                  // Clear all callbacks and values
                  disable: function disable() {
                    _locked = queue = [];
                    list = memory = "";
                    return this;
                  },
                  disabled: function disabled() {
                    return !list;
                  },

                  // Disable .fire
                  // Also disable .add unless we have memory (since it would have no effect)
                  // Abort any pending executions
                  lock: function lock() {
                    _locked = queue = [];
                    if (!memory) {
                      list = memory = "";
                    }
                    return this;
                  },
                  locked: function locked() {
                    return !!_locked;
                  },

                  // Call all callbacks with the given context and arguments
                  fireWith: function fireWith(context, args) {
                    if (!_locked) {
                      args = args || [];
                      args = [context, args.slice ? args.slice() : args];
                      queue.push(args);
                      if (!firing) {
                        fire();
                      }
                    }
                    return this;
                  },

                  // Call all the callbacks with the given arguments
                  fire: function fire() {
                    self.fireWith(this, arguments);
                    return this;
                  },

                  // To know if the callbacks have already been called at least once
                  fired: function fired() {
                    return !!_fired;
                  },
                };

              return self;
            };

            jQuery.extend({
              Deferred: function Deferred(func) {
                var tuples = [
                    // action, add listener, listener list, final state
                    [
                      "resolve",
                      "done",
                      jQuery.Callbacks("once memory"),
                      "resolved",
                    ],
                    [
                      "reject",
                      "fail",
                      jQuery.Callbacks("once memory"),
                      "rejected",
                    ],
                    ["notify", "progress", jQuery.Callbacks("memory")],
                  ],
                  _state = "pending",
                  _promise = {
                    state: function state() {
                      return _state;
                    },
                    always: function always() {
                      deferred.done(arguments).fail(arguments);
                      return this;
                    },
                    then: function then() /* fnDone, fnFail, fnProgress */ {
                      var fns = arguments;
                      return jQuery
                        .Deferred(function (newDefer) {
                          jQuery.each(tuples, function (i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];

                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[tuple[1]](function () {
                              var returned = fn && fn.apply(this, arguments);
                              if (
                                returned &&
                                jQuery.isFunction(returned.promise)
                              ) {
                                returned
                                  .promise()
                                  .progress(newDefer.notify)
                                  .done(newDefer.resolve)
                                  .fail(newDefer.reject);
                              } else {
                                newDefer[tuple[0] + "With"](
                                  this === _promise ? newDefer.promise() : this,
                                  fn ? [returned] : arguments
                                );
                              }
                            });
                          });
                          fns = null;
                        })
                        .promise();
                    },

                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function promise(obj) {
                      return obj != null
                        ? jQuery.extend(obj, _promise)
                        : _promise;
                    },
                  },
                  deferred = {};

                // Keep pipe for back-compat
                _promise.pipe = _promise.then;

                // Add list-specific methods
                jQuery.each(tuples, function (i, tuple) {
                  var list = tuple[2],
                    stateString = tuple[3];

                  // promise[ done | fail | progress ] = list.add
                  _promise[tuple[1]] = list.add;

                  // Handle state
                  if (stateString) {
                    list.add(
                      function () {
                        // state = [ resolved | rejected ]
                        _state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                      },
                      tuples[i ^ 1][2].disable,
                      tuples[2][2].lock
                    );
                  }

                  // deferred[ resolve | reject | notify ]
                  deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](
                      this === deferred ? _promise : this,
                      arguments
                    );
                    return this;
                  };
                  deferred[tuple[0] + "With"] = list.fireWith;
                });

                // Make the deferred a promise
                _promise.promise(deferred);

                // Call given func if any
                if (func) {
                  func.call(deferred, deferred);
                }

                // All done!
                return deferred;
              },

              // Deferred helper
              when: function when(subordinate /* , ..., subordinateN */) {
                var i = 0,
                  resolveValues = _slice.call(arguments),
                  length = resolveValues.length,
                  // the count of uncompleted subordinates
                  remaining =
                    length !== 1 ||
                    (subordinate && jQuery.isFunction(subordinate.promise))
                      ? length
                      : 0,
                  // the master Deferred.
                  // If resolveValues consist of only a single Deferred, just use that.
                  deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                  // Update function for both resolve and progress values
                  updateFunc = function updateFunc(i, contexts, values) {
                    return function (value) {
                      contexts[i] = this;
                      values[i] =
                        arguments.length > 1 ? _slice.call(arguments) : value;
                      if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                      } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                      }
                    };
                  },
                  progressValues,
                  progressContexts,
                  resolveContexts;

                // Add listeners to Deferred subordinates; treat others as resolved
                if (length > 1) {
                  progressValues = new Array(length);
                  progressContexts = new Array(length);
                  resolveContexts = new Array(length);
                  for (; i < length; i++) {
                    if (
                      resolveValues[i] &&
                      jQuery.isFunction(resolveValues[i].promise)
                    ) {
                      resolveValues[i]
                        .promise()
                        .progress(
                          updateFunc(i, progressContexts, progressValues)
                        )
                        .done(updateFunc(i, resolveContexts, resolveValues))
                        .fail(deferred.reject);
                    } else {
                      --remaining;
                    }
                  }
                }

                // If we're not waiting on anything, resolve the master
                if (!remaining) {
                  deferred.resolveWith(resolveContexts, resolveValues);
                }

                return deferred.promise();
              },
            });

            // The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function (fn) {
              // Add the callback
              jQuery.ready.promise().done(fn);

              return this;
            };

            jQuery.extend({
              // Is the DOM ready to be used? Set to true once it occurs.
              isReady: false,

              // A counter to track how many items to wait for before
              // the ready event fires. See #6781
              readyWait: 1,

              // Hold (or release) the ready event
              holdReady: function holdReady(hold) {
                if (hold) {
                  jQuery.readyWait++;
                } else {
                  jQuery.ready(true);
                }
              },

              // Handle when the DOM is ready
              ready: function ready(wait) {
                // Abort if there are pending holds or we're already ready
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                  return;
                }

                // Remember that the DOM is ready
                jQuery.isReady = true;

                // If a normal DOM Ready event fired, decrement, and wait if need be
                if (wait !== true && --jQuery.readyWait > 0) {
                  return;
                }

                // If there are functions bound, to execute
                readyList.resolveWith(document, [jQuery]);

                // Trigger any bound ready events
                if (jQuery.fn.triggerHandler) {
                  jQuery(document).triggerHandler("ready");
                  jQuery(document).off("ready");
                }
              },
            });

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {
              document.removeEventListener("DOMContentLoaded", completed);
              window.removeEventListener("load", completed);
              jQuery.ready();
            }

            jQuery.ready.promise = function (obj) {
              if (!readyList) {
                readyList = jQuery.Deferred();

                // Catch cases where $(document).ready() is called
                // after the browser event has already occurred.
                // Support: IE9-10 only
                // Older IE sometimes signals "interactive" too soon
                if (
                  document.readyState === "complete" ||
                  (document.readyState !== "loading" &&
                    !document.documentElement.doScroll)
                ) {
                  // Handle it asynchronously to allow scripts the opportunity to delay ready
                  window.setTimeout(jQuery.ready);
                } else {
                  // Use the handy event callback
                  document.addEventListener("DOMContentLoaded", completed);

                  // A fallback to window.onload, that will always work
                  window.addEventListener("load", completed);
                }
              }
              return readyList.promise(obj);
            };

            // Kick off the DOM ready check even if the user does not
            jQuery.ready.promise();

            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var access = function access(
              elems,
              fn,
              key,
              value,
              chainable,
              emptyGet,
              raw
            ) {
              var i = 0,
                len = elems.length,
                bulk = key == null;

              // Sets many values
              if (jQuery.type(key) === "object") {
                chainable = true;
                for (i in key) {
                  access(elems, fn, i, key[i], true, emptyGet, raw);
                }

                // Sets one value
              } else if (value !== undefined) {
                chainable = true;

                if (!jQuery.isFunction(value)) {
                  raw = true;
                }

                if (bulk) {
                  // Bulk operations run against the entire set
                  if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                  } else {
                    bulk = fn;
                    fn = function fn(elem, key, value) {
                      return bulk.call(jQuery(elem), value);
                    };
                  }
                }

                if (fn) {
                  for (; i < len; i++) {
                    fn(
                      elems[i],
                      key,
                      raw ? value : value.call(elems[i], i, fn(elems[i], key))
                    );
                  }
                }
              }

              return chainable
                ? elems
                : // Gets
                bulk
                ? fn.call(elems)
                : len
                ? fn(elems[0], key)
                : emptyGet;
            };
            var acceptData = function acceptData(owner) {
              // Accepts only:
              //  - Node
              //    - Node.ELEMENT_NODE
              //    - Node.DOCUMENT_NODE
              //  - Object
              //    - Any
              /* jshint -W018 */
              return (
                owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
              );
            };

            function Data() {
              this.expando = jQuery.expando + Data.uid++;
            }

            Data.uid = 1;

            Data.prototype = {
              register: function register(owner, initial) {
                var value = initial || {};

                // If it is a node unlikely to be stringify-ed or looped over
                // use plain assignment
                if (owner.nodeType) {
                  owner[this.expando] = value;

                  // Otherwise secure it in a non-enumerable, non-writable property
                  // configurability must be true to allow the property to be
                  // deleted with the delete operator
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true,
                  });
                }
                return owner[this.expando];
              },
              cache: function cache(owner) {
                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (!acceptData(owner)) {
                  return {};
                }

                // Check if the owner object already has a cache
                var value = owner[this.expando];

                // If not, create one
                if (!value) {
                  value = {};

                  // We can accept data for non-element nodes in modern browsers,
                  // but we should not, see #8335.
                  // Always return an empty object.
                  if (acceptData(owner)) {
                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                      owner[this.expando] = value;

                      // Otherwise secure it in a non-enumerable property
                      // configurable must be true to allow the property to be
                      // deleted when data is removed
                    } else {
                      Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: true,
                      });
                    }
                  }
                }

                return value;
              },
              set: function set(owner, data, value) {
                var prop,
                  cache = this.cache(owner);

                // Handle: [ owner, key, value ] args
                if (typeof data === "string") {
                  cache[data] = value;

                  // Handle: [ owner, { properties } ] args
                } else {
                  // Copy the properties one-by-one to the cache object
                  for (prop in data) {
                    cache[prop] = data[prop];
                  }
                }
                return cache;
              },
              get: function get(owner, key) {
                return key === undefined
                  ? this.cache(owner)
                  : owner[this.expando] && owner[this.expando][key];
              },
              access: function access(owner, key, value) {
                var stored;

                // In cases where either:
                //
                //   1. No key was specified
                //   2. A string key was specified, but no value provided
                //
                // Take the "read" path and allow the get method to determine
                // which value to return, respectively either:
                //
                //   1. The entire cache object
                //   2. The data stored at the key
                //
                if (
                  key === undefined ||
                  (key && typeof key === "string" && value === undefined)
                ) {
                  stored = this.get(owner, key);

                  return stored !== undefined
                    ? stored
                    : this.get(owner, jQuery.camelCase(key));
                }

                // When the key is not a string, or both a key and value
                // are specified, set or extend (existing objects) with either:
                //
                //   1. An object of properties
                //   2. A key and value
                //
                this.set(owner, key, value);

                // Since the "set" path can have two possible entry points
                // return the expected data based on which path was taken[*]
                return value !== undefined ? value : key;
              },
              remove: function remove(owner, key) {
                var i,
                  name,
                  camel,
                  cache = owner[this.expando];

                if (cache === undefined) {
                  return;
                }

                if (key === undefined) {
                  this.register(owner);
                } else {
                  // Support array or space separated string of keys
                  if (jQuery.isArray(key)) {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat(key.map(jQuery.camelCase));
                  } else {
                    camel = jQuery.camelCase(key);

                    // Try the string as a key before any manipulation
                    if (key in cache) {
                      name = [key, camel];
                    } else {
                      // If a key with the spaces exists, use it.
                      // Otherwise, create an array by matching non-whitespace
                      name = camel;
                      name =
                        name in cache ? [name] : name.match(rnotwhite) || [];
                    }
                  }

                  i = name.length;

                  while (i--) {
                    delete cache[name[i]];
                  }
                }

                // Remove the expando if there's no more data
                if (key === undefined || jQuery.isEmptyObject(cache)) {
                  // Support: Chrome <= 35-45+
                  // Webkit & Blink performance suffers when deleting properties
                  // from DOM nodes, so set to undefined instead
                  // https://code.google.com/p/chromium/issues/detail?id=378607
                  if (owner.nodeType) {
                    owner[this.expando] = undefined;
                  } else {
                    delete owner[this.expando];
                  }
                }
              },
              hasData: function hasData(owner) {
                var cache = owner[this.expando];
                return cache !== undefined && !jQuery.isEmptyObject(cache);
              },
            };
            var dataPriv = new Data();

            var dataUser = new Data();

            //	Implementation Summary
            //
            //	1. Enforce API surface and semantic compatibility with 1.9.x branch
            //	2. Improve the module's maintainability by reducing the storage
            //		paths to a single mechanism.
            //	3. Use the same single mechanism to support "private" and "user" data.
            //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
            //	5. Avoid exposing implementation details on user objects (eg. expando properties)
            //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
              rmultiDash = /[A-Z]/g;

            function dataAttr(elem, key, data) {
              var name;

              // If nothing was found internally, try to fetch any
              // data from the HTML5 data-* attribute
              if (data === undefined && elem.nodeType === 1) {
                name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
                data = elem.getAttribute(name);

                if (typeof data === "string") {
                  try {
                    data =
                      data === "true"
                        ? true
                        : data === "false"
                        ? false
                        : data === "null"
                        ? null
                        : // Only convert to a number if it doesn't change the string
                        +data + "" === data
                        ? +data
                        : rbrace.test(data)
                        ? jQuery.parseJSON(data)
                        : data;
                  } catch (e) {}

                  // Make sure we set the data so it isn't changed later
                  dataUser.set(elem, key, data);
                } else {
                  data = undefined;
                }
              }
              return data;
            }

            jQuery.extend({
              hasData: function hasData(elem) {
                return dataUser.hasData(elem) || dataPriv.hasData(elem);
              },

              data: function data(elem, name, _data) {
                return dataUser.access(elem, name, _data);
              },

              removeData: function removeData(elem, name) {
                dataUser.remove(elem, name);
              },

              // TODO: Now that all calls to _data and _removeData have been replaced
              // with direct calls to dataPriv methods, these can be deprecated.
              _data: function _data(elem, name, data) {
                return dataPriv.access(elem, name, data);
              },

              _removeData: function _removeData(elem, name) {
                dataPriv.remove(elem, name);
              },
            });

            jQuery.fn.extend({
              data: function data(key, value) {
                var i,
                  name,
                  data,
                  elem = this[0],
                  attrs = elem && elem.attributes;

                // Gets all values
                if (key === undefined) {
                  if (this.length) {
                    data = dataUser.get(elem);

                    if (
                      elem.nodeType === 1 &&
                      !dataPriv.get(elem, "hasDataAttrs")
                    ) {
                      i = attrs.length;
                      while (i--) {
                        // Support: IE11+
                        // The attrs elements can be null (#14894)
                        if (attrs[i]) {
                          name = attrs[i].name;
                          if (name.indexOf("data-") === 0) {
                            name = jQuery.camelCase(name.slice(5));
                            dataAttr(elem, name, data[name]);
                          }
                        }
                      }
                      dataPriv.set(elem, "hasDataAttrs", true);
                    }
                  }

                  return data;
                }

                // Sets multiple values
                if (
                  (typeof key === "undefined" ? "undefined" : _typeof(key)) ===
                  "object"
                ) {
                  return this.each(function () {
                    dataUser.set(this, key);
                  });
                }

                return access(
                  this,
                  function (value) {
                    var data, camelKey;

                    // The calling jQuery object (element matches) is not empty
                    // (and therefore has an element appears at this[ 0 ]) and the
                    // `value` parameter was not undefined. An empty jQuery object
                    // will result in `undefined` for elem = this[ 0 ] which will
                    // throw an exception if an attempt to read a data cache is made.
                    if (elem && value === undefined) {
                      // Attempt to get data from the cache
                      // with the key as-is
                      data =
                        dataUser.get(elem, key) ||
                        // Try to find dashed key if it exists (gh-2779)
                        // This is for 2.2.x only
                        dataUser.get(
                          elem,
                          key.replace(rmultiDash, "-$&").toLowerCase()
                        );

                      if (data !== undefined) {
                        return data;
                      }

                      camelKey = jQuery.camelCase(key);

                      // Attempt to get data from the cache
                      // with the key camelized
                      data = dataUser.get(elem, camelKey);
                      if (data !== undefined) {
                        return data;
                      }

                      // Attempt to "discover" the data in
                      // HTML5 custom data-* attrs
                      data = dataAttr(elem, camelKey, undefined);
                      if (data !== undefined) {
                        return data;
                      }

                      // We tried really hard, but the data doesn't exist.
                      return;
                    }

                    // Set the data...
                    camelKey = jQuery.camelCase(key);
                    this.each(function () {
                      // First, attempt to store a copy or reference of any
                      // data that might've been store with a camelCased key.
                      var data = dataUser.get(this, camelKey);

                      // For HTML5 data-* attribute interop, we have to
                      // store property names with dashes in a camelCase form.
                      // This might not apply to all properties...*
                      dataUser.set(this, camelKey, value);

                      // *... In the case of properties that might _actually_
                      // have dashes, we need to also store a copy of that
                      // unchanged property.
                      if (key.indexOf("-") > -1 && data !== undefined) {
                        dataUser.set(this, key, value);
                      }
                    });
                  },
                  null,
                  value,
                  arguments.length > 1,
                  null,
                  true
                );
              },

              removeData: function removeData(key) {
                return this.each(function () {
                  dataUser.remove(this, key);
                });
              },
            });

            jQuery.extend({
              queue: function queue(elem, type, data) {
                var queue;

                if (elem) {
                  type = (type || "fx") + "queue";
                  queue = dataPriv.get(elem, type);

                  // Speed up dequeue by getting out quickly if this is just a lookup
                  if (data) {
                    if (!queue || jQuery.isArray(data)) {
                      queue = dataPriv.access(
                        elem,
                        type,
                        jQuery.makeArray(data)
                      );
                    } else {
                      queue.push(data);
                    }
                  }
                  return queue || [];
                }
              },

              dequeue: function dequeue(elem, type) {
                type = type || "fx";

                var queue = jQuery.queue(elem, type),
                  startLength = queue.length,
                  fn = queue.shift(),
                  hooks = jQuery._queueHooks(elem, type),
                  next = function next() {
                    jQuery.dequeue(elem, type);
                  };

                // If the fx queue is dequeued, always remove the progress sentinel
                if (fn === "inprogress") {
                  fn = queue.shift();
                  startLength--;
                }

                if (fn) {
                  // Add a progress sentinel to prevent the fx queue from being
                  // automatically dequeued
                  if (type === "fx") {
                    queue.unshift("inprogress");
                  }

                  // Clear up the last queue stop function
                  delete hooks.stop;
                  fn.call(elem, next, hooks);
                }

                if (!startLength && hooks) {
                  hooks.empty.fire();
                }
              },

              // Not public - generate a queueHooks object, or return the current one
              _queueHooks: function _queueHooks(elem, type) {
                var key = type + "queueHooks";
                return (
                  dataPriv.get(elem, key) ||
                  dataPriv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function () {
                      dataPriv.remove(elem, [type + "queue", key]);
                    }),
                  })
                );
              },
            });

            jQuery.fn.extend({
              queue: function queue(type, data) {
                var setter = 2;

                if (typeof type !== "string") {
                  data = type;
                  type = "fx";
                  setter--;
                }

                if (arguments.length < setter) {
                  return jQuery.queue(this[0], type);
                }

                return data === undefined
                  ? this
                  : this.each(function () {
                      var queue = jQuery.queue(this, type, data);

                      // Ensure a hooks for this queue
                      jQuery._queueHooks(this, type);

                      if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                      }
                    });
              },
              dequeue: function dequeue(type) {
                return this.each(function () {
                  jQuery.dequeue(this, type);
                });
              },
              clearQueue: function clearQueue(type) {
                return this.queue(type || "fx", []);
              },

              // Get a promise resolved when queues of a certain type
              // are emptied (fx is the type by default)
              promise: function promise(type, obj) {
                var tmp,
                  count = 1,
                  defer = jQuery.Deferred(),
                  elements = this,
                  i = this.length,
                  resolve = function resolve() {
                    if (!--count) {
                      defer.resolveWith(elements, [elements]);
                    }
                  };

                if (typeof type !== "string") {
                  obj = type;
                  type = undefined;
                }
                type = type || "fx";

                while (i--) {
                  tmp = dataPriv.get(elements[i], type + "queueHooks");
                  if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                  }
                }
                resolve();
                return defer.promise(obj);
              },
            });
            var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

            var rcssNum = new RegExp(
              "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$",
              "i"
            );

            var cssExpand = ["Top", "Right", "Bottom", "Left"];

            var isHidden = function isHidden(elem, el) {
              // isHidden might be called from jQuery#filter function;
              // in that case, element will be second argument
              elem = el || elem;
              return (
                jQuery.css(elem, "display") === "none" ||
                !jQuery.contains(elem.ownerDocument, elem)
              );
            };

            function adjustCSS(elem, prop, valueParts, tween) {
              var adjusted,
                scale = 1,
                maxIterations = 20,
                currentValue = tween
                  ? function () {
                      return tween.cur();
                    }
                  : function () {
                      return jQuery.css(elem, prop, "");
                    },
                initial = currentValue(),
                unit =
                  (valueParts && valueParts[3]) ||
                  (jQuery.cssNumber[prop] ? "" : "px"),
                // Starting value computation is required for potential unit mismatches
                initialInUnit =
                  (jQuery.cssNumber[prop] || (unit !== "px" && +initial)) &&
                  rcssNum.exec(jQuery.css(elem, prop));

              if (initialInUnit && initialInUnit[3] !== unit) {
                // Trust units reported by jQuery.css
                unit = unit || initialInUnit[3];

                // Make sure we update the tween properties later on
                valueParts = valueParts || [];

                // Iteratively approximate from a nonzero starting point
                initialInUnit = +initial || 1;

                do {
                  // If previous iteration zeroed out, double until we get *something*.
                  // Use string for doubling so we don't accidentally see scale as unchanged below
                  scale = scale || ".5";

                  // Adjust and apply
                  initialInUnit = initialInUnit / scale;
                  jQuery.style(elem, prop, initialInUnit + unit);

                  // Update scale, tolerating zero or NaN from tween.cur()
                  // Break the loop if scale is unchanged or perfect, or if we've just had enough.
                } while (
                  scale !== (scale = currentValue() / initial) &&
                  scale !== 1 &&
                  --maxIterations
                );
              }

              if (valueParts) {
                initialInUnit = +initialInUnit || +initial || 0;

                // Apply relative offset (+=/-=) if specified
                adjusted = valueParts[1]
                  ? initialInUnit + (valueParts[1] + 1) * valueParts[2]
                  : +valueParts[2];
                if (tween) {
                  tween.unit = unit;
                  tween.start = initialInUnit;
                  tween.end = adjusted;
                }
              }
              return adjusted;
            }
            var rcheckableType = /^(?:checkbox|radio)$/i;

            var rtagName = /<([\w:-]+)/;

            var rscriptType = /^$|\/(?:java|ecma)script/i;

            // We have to close these tags to support XHTML (#13200)
            var wrapMap = {
              // Support: IE9
              option: [1, "<select multiple='multiple'>", "</select>"],

              // XHTML parsers do not magically insert elements in the
              // same way that tag soup parsers do. So we cannot shorten
              // this by omitting <tbody> or other required elements.
              thead: [1, "<table>", "</table>"],
              col: [2, "<table><colgroup>", "</colgroup></table>"],
              tr: [2, "<table><tbody>", "</tbody></table>"],
              td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

              _default: [0, "", ""],
            };

            // Support: IE9
            wrapMap.optgroup = wrapMap.option;

            wrapMap.tbody =
              wrapMap.tfoot =
              wrapMap.colgroup =
              wrapMap.caption =
                wrapMap.thead;
            wrapMap.th = wrapMap.td;

            function getAll(context, tag) {
              // Support: IE9-11+
              // Use typeof to avoid zero-argument method invocation on host objects (#15151)
              var ret =
                typeof context.getElementsByTagName !== "undefined"
                  ? context.getElementsByTagName(tag || "*")
                  : typeof context.querySelectorAll !== "undefined"
                  ? context.querySelectorAll(tag || "*")
                  : [];

              return tag === undefined || (tag && jQuery.nodeName(context, tag))
                ? jQuery.merge([context], ret)
                : ret;
            }

            // Mark scripts as having already been evaluated
            function setGlobalEval(elems, refElements) {
              var i = 0,
                l = elems.length;

              for (; i < l; i++) {
                dataPriv.set(
                  elems[i],
                  "globalEval",
                  !refElements || dataPriv.get(refElements[i], "globalEval")
                );
              }
            }

            var rhtml = /<|&#?\w+;/;

            function buildFragment(
              elems,
              context,
              scripts,
              selection,
              ignored
            ) {
              var elem,
                tmp,
                tag,
                wrap,
                contains,
                j,
                fragment = context.createDocumentFragment(),
                nodes = [],
                i = 0,
                l = elems.length;

              for (; i < l; i++) {
                elem = elems[i];

                if (elem || elem === 0) {
                  // Add nodes directly
                  if (jQuery.type(elem) === "object") {
                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                    // Convert non-html into a text node
                  } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));

                    // Convert html into DOM nodes
                  } else {
                    tmp =
                      tmp || fragment.appendChild(context.createElement("div"));

                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML =
                      wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while (j--) {
                      tmp = tmp.lastChild;
                    }

                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                  }
                }
              }

              // Remove wrapper from fragment
              fragment.textContent = "";

              i = 0;
              while ((elem = nodes[i++])) {
                // Skip elements already in the context collection (trac-4087)
                if (selection && jQuery.inArray(elem, selection) > -1) {
                  if (ignored) {
                    ignored.push(elem);
                  }
                  continue;
                }

                contains = jQuery.contains(elem.ownerDocument, elem);

                // Append to fragment
                tmp = getAll(fragment.appendChild(elem), "script");

                // Preserve script evaluation history
                if (contains) {
                  setGlobalEval(tmp);
                }

                // Capture executables
                if (scripts) {
                  j = 0;
                  while ((elem = tmp[j++])) {
                    if (rscriptType.test(elem.type || "")) {
                      scripts.push(elem);
                    }
                  }
                }
              }

              return fragment;
            }

            (function () {
              var fragment = document.createDocumentFragment(),
                div = fragment.appendChild(document.createElement("div")),
                input = document.createElement("input");

              // Support: Android 4.0-4.3, Safari<=5.1
              // Check state lost if the name is set (#11217)
              // Support: Windows Web Apps (WWA)
              // `name` and `type` must use .setAttribute for WWA (#14901)
              input.setAttribute("type", "radio");
              input.setAttribute("checked", "checked");
              input.setAttribute("name", "t");

              div.appendChild(input);

              // Support: Safari<=5.1, Android<4.2
              // Older WebKit doesn't clone checked state correctly in fragments
              support.checkClone = div
                .cloneNode(true)
                .cloneNode(true).lastChild.checked;

              // Support: IE<=11+
              // Make sure textarea (and checkbox) defaultValue is properly cloned
              div.innerHTML = "<textarea>x</textarea>";
              support.noCloneChecked =
                !!div.cloneNode(true).lastChild.defaultValue;
            })();

            var rkeyEvent = /^key/,
              rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
              rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

            function returnTrue() {
              return true;
            }

            function returnFalse() {
              return false;
            }

            // Support: IE9
            // See #13393 for more info
            function safeActiveElement() {
              try {
                return document.activeElement;
              } catch (err) {}
            }

            function _on(elem, types, selector, data, fn, one) {
              var origFn, type;

              // Types can be a map of types/handlers
              if (
                (typeof types === "undefined"
                  ? "undefined"
                  : _typeof(types)) === "object"
              ) {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") {
                  // ( types-Object, data )
                  data = data || selector;
                  selector = undefined;
                }
                for (type in types) {
                  _on(elem, type, selector, data, types[type], one);
                }
                return elem;
              }

              if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
              } else if (fn == null) {
                if (typeof selector === "string") {
                  // ( types, selector, fn )
                  fn = data;
                  data = undefined;
                } else {
                  // ( types, data, fn )
                  fn = data;
                  data = selector;
                  selector = undefined;
                }
              }
              if (fn === false) {
                fn = returnFalse;
              } else if (!fn) {
                return elem;
              }

              if (one === 1) {
                origFn = fn;
                fn = function fn(event) {
                  // Can use an empty set, since event contains the info
                  jQuery().off(event);
                  return origFn.apply(this, arguments);
                };

                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
              }
              return elem.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
              });
            }

            /*
             * Helper functions for managing events -- not part of the public interface.
             * Props to Dean Edwards' addEvent library for many of the ideas.
             */
            jQuery.event = {
              global: {},

              add: function add(elem, types, handler, data, selector) {
                var handleObjIn,
                  eventHandle,
                  tmp,
                  events,
                  t,
                  handleObj,
                  special,
                  handlers,
                  type,
                  namespaces,
                  origType,
                  elemData = dataPriv.get(elem);

                // Don't attach events to noData or text/comment nodes (but allow plain objects)
                if (!elemData) {
                  return;
                }

                // Caller can pass in an object of custom data in lieu of the handler
                if (handler.handler) {
                  handleObjIn = handler;
                  handler = handleObjIn.handler;
                  selector = handleObjIn.selector;
                }

                // Make sure that the handler has a unique ID, used to find/remove it later
                if (!handler.guid) {
                  handler.guid = jQuery.guid++;
                }

                // Init the element's event structure and main handler, if this is the first
                if (!(events = elemData.events)) {
                  events = elemData.events = {};
                }
                if (!(eventHandle = elemData.handle)) {
                  eventHandle = elemData.handle = function (e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" &&
                      jQuery.event.triggered !== e.type
                      ? jQuery.event.dispatch.apply(elem, arguments)
                      : undefined;
                  };
                }

                // Handle multiple events separated by a space
                types = (types || "").match(rnotwhite) || [""];
                t = types.length;
                while (t--) {
                  tmp = rtypenamespace.exec(types[t]) || [];
                  type = origType = tmp[1];
                  namespaces = (tmp[2] || "").split(".").sort();

                  // There *must* be a type, no attaching namespace-only handlers
                  if (!type) {
                    continue;
                  }

                  // If event changes its type, use the special event handlers for the changed type
                  special = jQuery.event.special[type] || {};

                  // If selector defined, determine special event api type, otherwise given type
                  type =
                    (selector ? special.delegateType : special.bindType) ||
                    type;

                  // Update special based on newly reset type
                  special = jQuery.event.special[type] || {};

                  // handleObj is passed to all event handlers
                  handleObj = jQuery.extend(
                    {
                      type: type,
                      origType: origType,
                      data: data,
                      handler: handler,
                      guid: handler.guid,
                      selector: selector,
                      needsContext:
                        selector &&
                        jQuery.expr.match.needsContext.test(selector),
                      namespace: namespaces.join("."),
                    },
                    handleObjIn
                  );

                  // Init the event handler queue if we're the first
                  if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (
                      !special.setup ||
                      special.setup.call(
                        elem,
                        data,
                        namespaces,
                        eventHandle
                      ) === false
                    ) {
                      if (elem.addEventListener) {
                        elem.addEventListener(type, eventHandle);
                      }
                    }
                  }

                  if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                      handleObj.handler.guid = handler.guid;
                    }
                  }

                  // Add to the element's handler list, delegates in front
                  if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                  } else {
                    handlers.push(handleObj);
                  }

                  // Keep track of which events have ever been used, for event optimization
                  jQuery.event.global[type] = true;
                }
              },

              // Detach an event or set of events from an element
              remove: function remove(
                elem,
                types,
                handler,
                selector,
                mappedTypes
              ) {
                var j,
                  origCount,
                  tmp,
                  events,
                  t,
                  handleObj,
                  special,
                  handlers,
                  type,
                  namespaces,
                  origType,
                  elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

                if (!elemData || !(events = elemData.events)) {
                  return;
                }

                // Once for each type.namespace in types; type may be omitted
                types = (types || "").match(rnotwhite) || [""];
                t = types.length;
                while (t--) {
                  tmp = rtypenamespace.exec(types[t]) || [];
                  type = origType = tmp[1];
                  namespaces = (tmp[2] || "").split(".").sort();

                  // Unbind all events (on this namespace, if provided) for the element
                  if (!type) {
                    for (type in events) {
                      jQuery.event.remove(
                        elem,
                        type + types[t],
                        handler,
                        selector,
                        true
                      );
                    }
                    continue;
                  }

                  special = jQuery.event.special[type] || {};
                  type =
                    (selector ? special.delegateType : special.bindType) ||
                    type;
                  handlers = events[type] || [];
                  tmp =
                    tmp[2] &&
                    new RegExp(
                      "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"
                    );

                  // Remove matching events
                  origCount = j = handlers.length;
                  while (j--) {
                    handleObj = handlers[j];

                    if (
                      (mappedTypes || origType === handleObj.origType) &&
                      (!handler || handler.guid === handleObj.guid) &&
                      (!tmp || tmp.test(handleObj.namespace)) &&
                      (!selector ||
                        selector === handleObj.selector ||
                        (selector === "**" && handleObj.selector))
                    ) {
                      handlers.splice(j, 1);

                      if (handleObj.selector) {
                        handlers.delegateCount--;
                      }
                      if (special.remove) {
                        special.remove.call(elem, handleObj);
                      }
                    }
                  }

                  // Remove generic event handler if we removed something and no more handlers exist
                  // (avoids potential for endless recursion during removal of special event handlers)
                  if (origCount && !handlers.length) {
                    if (
                      !special.teardown ||
                      special.teardown.call(
                        elem,
                        namespaces,
                        elemData.handle
                      ) === false
                    ) {
                      jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                  }
                }

                // Remove data and the expando if it's no longer used
                if (jQuery.isEmptyObject(events)) {
                  dataPriv.remove(elem, "handle events");
                }
              },

              dispatch: function dispatch(event) {
                // Make a writable jQuery.Event from the native event object
                event = jQuery.event.fix(event);

                var i,
                  j,
                  ret,
                  matched,
                  handleObj,
                  handlerQueue = [],
                  args = _slice.call(arguments),
                  handlers =
                    (dataPriv.get(this, "events") || {})[event.type] || [],
                  special = jQuery.event.special[event.type] || {};

                // Use the fix-ed jQuery.Event rather than the (read-only) native event
                args[0] = event;
                event.delegateTarget = this;

                // Call the preDispatch hook for the mapped type, and let it bail if desired
                if (
                  special.preDispatch &&
                  special.preDispatch.call(this, event) === false
                ) {
                  return;
                }

                // Determine handlers
                handlerQueue = jQuery.event.handlers.call(
                  this,
                  event,
                  handlers
                );

                // Run delegates first; they may want to stop propagation beneath us
                i = 0;
                while (
                  (matched = handlerQueue[i++]) &&
                  !event.isPropagationStopped()
                ) {
                  event.currentTarget = matched.elem;

                  j = 0;
                  while (
                    (handleObj = matched.handlers[j++]) &&
                    !event.isImmediatePropagationStopped()
                  ) {
                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if (
                      !event.rnamespace ||
                      event.rnamespace.test(handleObj.namespace)
                    ) {
                      event.handleObj = handleObj;
                      event.data = handleObj.data;

                      ret = (
                        (jQuery.event.special[handleObj.origType] || {})
                          .handle || handleObj.handler
                      ).apply(matched.elem, args);

                      if (ret !== undefined) {
                        if ((event.result = ret) === false) {
                          event.preventDefault();
                          event.stopPropagation();
                        }
                      }
                    }
                  }
                }

                // Call the postDispatch hook for the mapped type
                if (special.postDispatch) {
                  special.postDispatch.call(this, event);
                }

                return event.result;
              },

              handlers: function handlers(event, _handlers) {
                var i,
                  matches,
                  sel,
                  handleObj,
                  handlerQueue = [],
                  delegateCount = _handlers.delegateCount,
                  cur = event.target;

                // Support (at least): Chrome, IE9
                // Find delegate handlers
                // Black-hole SVG <use> instance trees (#13180)
                //
                // Support: Firefox<=42+
                // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
                if (
                  delegateCount &&
                  cur.nodeType &&
                  (event.type !== "click" ||
                    isNaN(event.button) ||
                    event.button < 1)
                ) {
                  for (; cur !== this; cur = cur.parentNode || this) {
                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (
                      cur.nodeType === 1 &&
                      (cur.disabled !== true || event.type !== "click")
                    ) {
                      matches = [];
                      for (i = 0; i < delegateCount; i++) {
                        handleObj = _handlers[i];

                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";

                        if (matches[sel] === undefined) {
                          matches[sel] = handleObj.needsContext
                            ? jQuery(sel, this).index(cur) > -1
                            : jQuery.find(sel, this, null, [cur]).length;
                        }
                        if (matches[sel]) {
                          matches.push(handleObj);
                        }
                      }
                      if (matches.length) {
                        handlerQueue.push({ elem: cur, handlers: matches });
                      }
                    }
                  }
                }

                // Add the remaining (directly-bound) handlers
                if (delegateCount < _handlers.length) {
                  handlerQueue.push({
                    elem: this,
                    handlers: _handlers.slice(delegateCount),
                  });
                }

                return handlerQueue;
              },

              // Includes some event props shared by KeyEvent and MouseEvent
              props: (
                "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
                "metaKey relatedTarget shiftKey target timeStamp view which"
              ).split(" "),

              fixHooks: {},

              keyHooks: {
                props: "char charCode key keyCode".split(" "),
                filter: function filter(event, original) {
                  // Add which for key events
                  if (event.which == null) {
                    event.which =
                      original.charCode != null
                        ? original.charCode
                        : original.keyCode;
                  }

                  return event;
                },
              },

              mouseHooks: {
                props: (
                  "button buttons clientX clientY offsetX offsetY pageX pageY " +
                  "screenX screenY toElement"
                ).split(" "),
                filter: function filter(event, original) {
                  var eventDoc,
                    doc,
                    body,
                    button = original.button;

                  // Calculate pageX/Y if missing and clientX/Y available
                  if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX =
                      original.clientX +
                      ((doc && doc.scrollLeft) ||
                        (body && body.scrollLeft) ||
                        0) -
                      ((doc && doc.clientLeft) ||
                        (body && body.clientLeft) ||
                        0);
                    event.pageY =
                      original.clientY +
                      ((doc && doc.scrollTop) ||
                        (body && body.scrollTop) ||
                        0) -
                      ((doc && doc.clientTop) || (body && body.clientTop) || 0);
                  }

                  // Add which for click: 1 === left; 2 === middle; 3 === right
                  // Note: button is not normalized, so don't use it
                  if (!event.which && button !== undefined) {
                    event.which =
                      button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                  }

                  return event;
                },
              },

              fix: function fix(event) {
                if (event[jQuery.expando]) {
                  return event;
                }

                // Create a writable copy of the event object and normalize some properties
                var i,
                  prop,
                  copy,
                  type = event.type,
                  originalEvent = event,
                  fixHook = this.fixHooks[type];

                if (!fixHook) {
                  this.fixHooks[type] = fixHook = rmouseEvent.test(type)
                    ? this.mouseHooks
                    : rkeyEvent.test(type)
                    ? this.keyHooks
                    : {};
                }
                copy = fixHook.props
                  ? this.props.concat(fixHook.props)
                  : this.props;

                event = new jQuery.Event(originalEvent);

                i = copy.length;
                while (i--) {
                  prop = copy[i];
                  event[prop] = originalEvent[prop];
                }

                // Support: Cordova 2.5 (WebKit) (#13255)
                // All events should have a target; Cordova deviceready doesn't
                if (!event.target) {
                  event.target = document;
                }

                // Support: Safari 6.0+, Chrome<28
                // Target should not be a text node (#504, #13143)
                if (event.target.nodeType === 3) {
                  event.target = event.target.parentNode;
                }

                return fixHook.filter
                  ? fixHook.filter(event, originalEvent)
                  : event;
              },

              special: {
                load: {
                  // Prevent triggered image.load events from bubbling to window.load
                  noBubble: true,
                },
                focus: {
                  // Fire native event if possible so blur/focus sequence is correct
                  trigger: function trigger() {
                    if (this !== safeActiveElement() && this.focus) {
                      this.focus();
                      return false;
                    }
                  },
                  delegateType: "focusin",
                },
                blur: {
                  trigger: function trigger() {
                    if (this === safeActiveElement() && this.blur) {
                      this.blur();
                      return false;
                    }
                  },
                  delegateType: "focusout",
                },
                click: {
                  // For checkbox, fire native event so checked state will be right
                  trigger: function trigger() {
                    if (
                      this.type === "checkbox" &&
                      this.click &&
                      jQuery.nodeName(this, "input")
                    ) {
                      this.click();
                      return false;
                    }
                  },

                  // For cross-browser consistency, don't fire native .click() on links
                  _default: function _default(event) {
                    return jQuery.nodeName(event.target, "a");
                  },
                },

                beforeunload: {
                  postDispatch: function postDispatch(event) {
                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                      event.originalEvent.returnValue = event.result;
                    }
                  },
                },
              },
            };

            jQuery.removeEvent = function (elem, type, handle) {
              // This "if" is needed for plain objects
              if (elem.removeEventListener) {
                elem.removeEventListener(type, handle);
              }
            };

            jQuery.Event = function (src, props) {
              // Allow instantiation without the 'new' keyword
              if (!(this instanceof jQuery.Event)) {
                return new jQuery.Event(src, props);
              }

              // Event object
              if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;

                // Events bubbling up the document may have been marked as prevented
                // by a handler lower down the tree; reflect the correct value.
                this.isDefaultPrevented =
                  src.defaultPrevented ||
                  (src.defaultPrevented === undefined &&
                    // Support: Android<4.0
                    src.returnValue === false)
                    ? returnTrue
                    : returnFalse;

                // Event type
              } else {
                this.type = src;
              }

              // Put explicitly provided properties onto the event object
              if (props) {
                jQuery.extend(this, props);
              }

              // Create a timestamp if incoming event doesn't have one
              this.timeStamp = (src && src.timeStamp) || jQuery.now();

              // Mark it as fixed
              this[jQuery.expando] = true;
            };

            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
              constructor: jQuery.Event,
              isDefaultPrevented: returnFalse,
              isPropagationStopped: returnFalse,
              isImmediatePropagationStopped: returnFalse,
              isSimulated: false,

              preventDefault: function preventDefault() {
                var e = this.originalEvent;

                this.isDefaultPrevented = returnTrue;

                if (e && !this.isSimulated) {
                  e.preventDefault();
                }
              },
              stopPropagation: function stopPropagation() {
                var e = this.originalEvent;

                this.isPropagationStopped = returnTrue;

                if (e && !this.isSimulated) {
                  e.stopPropagation();
                }
              },
              stopImmediatePropagation: function stopImmediatePropagation() {
                var e = this.originalEvent;

                this.isImmediatePropagationStopped = returnTrue;

                if (e && !this.isSimulated) {
                  e.stopImmediatePropagation();
                }

                this.stopPropagation();
              },
            };

            // Create mouseenter/leave events using mouseover/out and event-time checks
            // so that event delegation works in jQuery.
            // Do the same for pointerenter/pointerleave and pointerover/pointerout
            //
            // Support: Safari 7 only
            // Safari sends mouseenter too often; see:
            // https://code.google.com/p/chromium/issues/detail?id=470258
            // for the description of the bug (it existed in older Chrome versions as well).
            jQuery.each(
              {
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout",
              },
              function (orig, fix) {
                jQuery.event.special[orig] = {
                  delegateType: fix,
                  bindType: fix,

                  handle: function handle(event) {
                    var ret,
                      target = this,
                      related = event.relatedTarget,
                      handleObj = event.handleObj;

                    // For mouseenter/leave call the handler if related is outside the target.
                    // NB: No relatedTarget if the mouse left/entered the browser window
                    if (
                      !related ||
                      (related !== target && !jQuery.contains(target, related))
                    ) {
                      event.type = handleObj.origType;
                      ret = handleObj.handler.apply(this, arguments);
                      event.type = fix;
                    }
                    return ret;
                  },
                };
              }
            );

            jQuery.fn.extend({
              on: function on(types, selector, data, fn) {
                return _on(this, types, selector, data, fn);
              },
              one: function one(types, selector, data, fn) {
                return _on(this, types, selector, data, fn, 1);
              },
              off: function off(types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) {
                  // ( event )  dispatched jQuery.Event
                  handleObj = types.handleObj;
                  jQuery(types.delegateTarget).off(
                    handleObj.namespace
                      ? handleObj.origType + "." + handleObj.namespace
                      : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                  );
                  return this;
                }
                if (
                  (typeof types === "undefined"
                    ? "undefined"
                    : _typeof(types)) === "object"
                ) {
                  // ( types-object [, selector] )
                  for (type in types) {
                    this.off(type, selector, types[type]);
                  }
                  return this;
                }
                if (selector === false || typeof selector === "function") {
                  // ( types [, fn] )
                  fn = selector;
                  selector = undefined;
                }
                if (fn === false) {
                  fn = returnFalse;
                }
                return this.each(function () {
                  jQuery.event.remove(this, types, fn, selector);
                });
              },
            });

            var rxhtmlTag =
                /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
              // Support: IE 10-11, Edge 10240+
              // In IE/Edge using regex groups here causes severe slowdowns.
              // See https://connect.microsoft.com/IE/feedback/details/1736512/
              rnoInnerhtml = /<script|<style|<link/i,
              // checked="checked" or checked
              rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
              rscriptTypeMasked = /^true\/(.*)/,
              rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

            // Manipulating tables requires a tbody
            function manipulationTarget(elem, content) {
              return jQuery.nodeName(elem, "table") &&
                jQuery.nodeName(
                  content.nodeType !== 11 ? content : content.firstChild,
                  "tr"
                )
                ? elem.getElementsByTagName("tbody")[0] ||
                    elem.appendChild(elem.ownerDocument.createElement("tbody"))
                : elem;
            }

            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript(elem) {
              elem.type =
                (elem.getAttribute("type") !== null) + "/" + elem.type;
              return elem;
            }
            function restoreScript(elem) {
              var match = rscriptTypeMasked.exec(elem.type);

              if (match) {
                elem.type = match[1];
              } else {
                elem.removeAttribute("type");
              }

              return elem;
            }

            function cloneCopyEvent(src, dest) {
              var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

              if (dest.nodeType !== 1) {
                return;
              }

              // 1. Copy private data: events, handlers, etc.
              if (dataPriv.hasData(src)) {
                pdataOld = dataPriv.access(src);
                pdataCur = dataPriv.set(dest, pdataOld);
                events = pdataOld.events;

                if (events) {
                  delete pdataCur.handle;
                  pdataCur.events = {};

                  for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                      jQuery.event.add(dest, type, events[type][i]);
                    }
                  }
                }
              }

              // 2. Copy user data
              if (dataUser.hasData(src)) {
                udataOld = dataUser.access(src);
                udataCur = jQuery.extend({}, udataOld);

                dataUser.set(dest, udataCur);
              }
            }

            // Fix IE bugs, see support tests
            function fixInput(src, dest) {
              var nodeName = dest.nodeName.toLowerCase();

              // Fails to persist the checked state of a cloned checkbox or radio button.
              if (nodeName === "input" && rcheckableType.test(src.type)) {
                dest.checked = src.checked;

                // Fails to return the selected option to the default selected state when cloning options
              } else if (nodeName === "input" || nodeName === "textarea") {
                dest.defaultValue = src.defaultValue;
              }
            }

            function domManip(collection, args, callback, ignored) {
              // Flatten any nested arrays
              args = concat.apply([], args);

              var fragment,
                first,
                scripts,
                hasScripts,
                node,
                doc,
                i = 0,
                l = collection.length,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction(value);

              // We can't cloneNode fragments that contain checked, in WebKit
              if (
                isFunction ||
                (l > 1 &&
                  typeof value === "string" &&
                  !support.checkClone &&
                  rchecked.test(value))
              ) {
                return collection.each(function (index) {
                  var self = collection.eq(index);
                  if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                  }
                  domManip(self, args, callback, ignored);
                });
              }

              if (l) {
                fragment = buildFragment(
                  args,
                  collection[0].ownerDocument,
                  false,
                  collection,
                  ignored
                );
                first = fragment.firstChild;

                if (fragment.childNodes.length === 1) {
                  fragment = first;
                }

                // Require either new content or an interest in ignored elements to invoke the callback
                if (first || ignored) {
                  scripts = jQuery.map(
                    getAll(fragment, "script"),
                    disableScript
                  );
                  hasScripts = scripts.length;

                  // Use the original fragment for the last item
                  // instead of the first because it can end up
                  // being emptied incorrectly in certain situations (#8070).
                  for (; i < l; i++) {
                    node = fragment;

                    if (i !== iNoClone) {
                      node = jQuery.clone(node, true, true);

                      // Keep references to cloned scripts for later restoration
                      if (hasScripts) {
                        // Support: Android<4.1, PhantomJS<2
                        // push.apply(_, arraylike) throws on ancient WebKit
                        jQuery.merge(scripts, getAll(node, "script"));
                      }
                    }

                    callback.call(collection[i], node, i);
                  }

                  if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;

                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);

                    // Evaluate executable scripts on first document insertion
                    for (i = 0; i < hasScripts; i++) {
                      node = scripts[i];
                      if (
                        rscriptType.test(node.type || "") &&
                        !dataPriv.access(node, "globalEval") &&
                        jQuery.contains(doc, node)
                      ) {
                        if (node.src) {
                          // Optional AJAX dependency, but won't run scripts if not present
                          if (jQuery._evalUrl) {
                            jQuery._evalUrl(node.src);
                          }
                        } else {
                          jQuery.globalEval(
                            node.textContent.replace(rcleanScript, "")
                          );
                        }
                      }
                    }
                  }
                }
              }

              return collection;
            }

            function _remove(elem, selector, keepData) {
              var node,
                nodes = selector ? jQuery.filter(selector, elem) : elem,
                i = 0;

              for (; (node = nodes[i]) != null; i++) {
                if (!keepData && node.nodeType === 1) {
                  jQuery.cleanData(getAll(node));
                }

                if (node.parentNode) {
                  if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                  }
                  node.parentNode.removeChild(node);
                }
              }

              return elem;
            }

            jQuery.extend({
              htmlPrefilter: function htmlPrefilter(html) {
                return html.replace(rxhtmlTag, "<$1></$2>");
              },

              clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
                var i,
                  l,
                  srcElements,
                  destElements,
                  clone = elem.cloneNode(true),
                  inPage = jQuery.contains(elem.ownerDocument, elem);

                // Fix IE cloning issues
                if (
                  !support.noCloneChecked &&
                  (elem.nodeType === 1 || elem.nodeType === 11) &&
                  !jQuery.isXMLDoc(elem)
                ) {
                  // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                  destElements = getAll(clone);
                  srcElements = getAll(elem);

                  for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                  }
                }

                // Copy the events from the original to the clone
                if (dataAndEvents) {
                  if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                      cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                  } else {
                    cloneCopyEvent(elem, clone);
                  }
                }

                // Preserve script evaluation history
                destElements = getAll(clone, "script");
                if (destElements.length > 0) {
                  setGlobalEval(
                    destElements,
                    !inPage && getAll(elem, "script")
                  );
                }

                // Return the cloned set
                return clone;
              },

              cleanData: function cleanData(elems) {
                var data,
                  elem,
                  type,
                  special = jQuery.event.special,
                  i = 0;

                for (; (elem = elems[i]) !== undefined; i++) {
                  if (acceptData(elem)) {
                    if ((data = elem[dataPriv.expando])) {
                      if (data.events) {
                        for (type in data.events) {
                          if (special[type]) {
                            jQuery.event.remove(elem, type);

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                          } else {
                            jQuery.removeEvent(elem, type, data.handle);
                          }
                        }
                      }

                      // Support: Chrome <= 35-45+
                      // Assign undefined instead of using delete, see Data#remove
                      elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                      // Support: Chrome <= 35-45+
                      // Assign undefined instead of using delete, see Data#remove
                      elem[dataUser.expando] = undefined;
                    }
                  }
                }
              },
            });

            jQuery.fn.extend({
              // Keep domManip exposed until 3.0 (gh-2225)
              domManip: domManip,

              detach: function detach(selector) {
                return _remove(this, selector, true);
              },

              remove: function remove(selector) {
                return _remove(this, selector);
              },

              text: function text(value) {
                return access(
                  this,
                  function (value) {
                    return value === undefined
                      ? jQuery.text(this)
                      : this.empty().each(function () {
                          if (
                            this.nodeType === 1 ||
                            this.nodeType === 11 ||
                            this.nodeType === 9
                          ) {
                            this.textContent = value;
                          }
                        });
                  },
                  null,
                  value,
                  arguments.length
                );
              },

              append: function append() {
                return domManip(this, arguments, function (elem) {
                  if (
                    this.nodeType === 1 ||
                    this.nodeType === 11 ||
                    this.nodeType === 9
                  ) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                  }
                });
              },

              prepend: function prepend() {
                return domManip(this, arguments, function (elem) {
                  if (
                    this.nodeType === 1 ||
                    this.nodeType === 11 ||
                    this.nodeType === 9
                  ) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                  }
                });
              },

              before: function before() {
                return domManip(this, arguments, function (elem) {
                  if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                  }
                });
              },

              after: function after() {
                return domManip(this, arguments, function (elem) {
                  if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                  }
                });
              },

              empty: function empty() {
                var elem,
                  i = 0;

                for (; (elem = this[i]) != null; i++) {
                  if (elem.nodeType === 1) {
                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                  }
                }

                return this;
              },

              clone: function clone(dataAndEvents, deepDataAndEvents) {
                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                deepDataAndEvents =
                  deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                return this.map(function () {
                  return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                });
              },

              html: function html(value) {
                return access(
                  this,
                  function (value) {
                    var elem = this[0] || {},
                      i = 0,
                      l = this.length;

                    if (value === undefined && elem.nodeType === 1) {
                      return elem.innerHTML;
                    }

                    // See if we can take a shortcut and just use innerHTML
                    if (
                      typeof value === "string" &&
                      !rnoInnerhtml.test(value) &&
                      !wrapMap[
                        (rtagName.exec(value) || ["", ""])[1].toLowerCase()
                      ]
                    ) {
                      value = jQuery.htmlPrefilter(value);

                      try {
                        for (; i < l; i++) {
                          elem = this[i] || {};

                          // Remove element nodes and prevent memory leaks
                          if (elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem, false));
                            elem.innerHTML = value;
                          }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                      } catch (e) {}
                    }

                    if (elem) {
                      this.empty().append(value);
                    }
                  },
                  null,
                  value,
                  arguments.length
                );
              },

              replaceWith: function replaceWith() {
                var ignored = [];

                // Make the changes, replacing each non-ignored context element with the new content
                return domManip(
                  this,
                  arguments,
                  function (elem) {
                    var parent = this.parentNode;

                    if (jQuery.inArray(this, ignored) < 0) {
                      jQuery.cleanData(getAll(this));
                      if (parent) {
                        parent.replaceChild(elem, this);
                      }
                    }

                    // Force callback invocation
                  },
                  ignored
                );
              },
            });

            jQuery.each(
              {
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith",
              },
              function (name, original) {
                jQuery.fn[name] = function (selector) {
                  var elems,
                    ret = [],
                    insert = jQuery(selector),
                    last = insert.length - 1,
                    i = 0;

                  for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);

                    // Support: QtWebKit
                    // .get() because push.apply(_, arraylike) throws
                    push.apply(ret, elems.get());
                  }

                  return this.pushStack(ret);
                };
              }
            );

            var iframe,
              elemdisplay = {
                // Support: Firefox
                // We have to pre-define these values for FF (#10227)
                HTML: "block",
                BODY: "block",
              };

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */

            // Called only from within defaultDisplay
            function actualDisplay(name, doc) {
              var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
                display = jQuery.css(elem[0], "display");

              // We don't have any data stored on the element,
              // so use "detach" method as fast way to get rid of the element
              elem.detach();

              return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay(nodeName) {
              var doc = document,
                display = elemdisplay[nodeName];

              if (!display) {
                display = actualDisplay(nodeName, doc);

                // If the simple way fails, read from inside an iframe
                if (display === "none" || !display) {
                  // Use the already-created iframe if possible
                  iframe = (
                    iframe ||
                    jQuery("<iframe frameborder='0' width='0' height='0'/>")
                  ).appendTo(doc.documentElement);

                  // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                  doc = iframe[0].contentDocument;

                  // Support: IE
                  doc.write();
                  doc.close();

                  display = actualDisplay(nodeName, doc);
                  iframe.detach();
                }

                // Store the correct default display
                elemdisplay[nodeName] = display;
              }

              return display;
            }
            var rmargin = /^margin/;

            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

            var getStyles = function getStyles(elem) {
              // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
              // IE throws on elements created in popups
              // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
              var view = elem.ownerDocument.defaultView;

              if (!view || !view.opener) {
                view = window;
              }

              return view.getComputedStyle(elem);
            };

            var swap = function swap(elem, options, callback, args) {
              var ret,
                name,
                old = {};

              // Remember the old values, and insert the new ones
              for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
              }

              ret = callback.apply(elem, args || []);

              // Revert the old values
              for (name in options) {
                elem.style[name] = old[name];
              }

              return ret;
            };

            var documentElement = document.documentElement;

            (function () {
              var pixelPositionVal,
                boxSizingReliableVal,
                pixelMarginRightVal,
                reliableMarginLeftVal,
                container = document.createElement("div"),
                div = document.createElement("div");

              // Finish early in limited (non-browser) environments
              if (!div.style) {
                return;
              }

              // Support: IE9-11+
              // Style of cloned element affects source element cloned (#8908)
              div.style.backgroundClip = "content-box";
              div.cloneNode(true).style.backgroundClip = "";
              support.clearCloneStyle =
                div.style.backgroundClip === "content-box";

              container.style.cssText =
                "border:0;width:8px;height:0;top:0;left:-9999px;" +
                "padding:0;margin-top:1px;position:absolute";
              container.appendChild(div);

              // Executing both pixelPosition & boxSizingReliable tests require only one layout
              // so they're executed at the same time to save the second computation.
              function computeStyleTests() {
                div.style.cssText =
                  // Support: Firefox<29, Android 2.3
                  // Vendor-prefix box-sizing
                  "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                  "position:relative;display:block;" +
                  "margin:auto;border:1px;padding:1px;" +
                  "top:1%;width:50%";
                div.innerHTML = "";
                documentElement.appendChild(container);

                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = divStyle.top !== "1%";
                reliableMarginLeftVal = divStyle.marginLeft === "2px";
                boxSizingReliableVal = divStyle.width === "4px";

                // Support: Android 4.0 - 4.3 only
                // Some styles come back with percentage values, even though they shouldn't
                div.style.marginRight = "50%";
                pixelMarginRightVal = divStyle.marginRight === "4px";

                documentElement.removeChild(container);
              }

              jQuery.extend(support, {
                pixelPosition: function pixelPosition() {
                  // This test is executed only once but we still do memoizing
                  // since we can use the boxSizingReliable pre-computing.
                  // No need to check if the test was already performed, though.
                  computeStyleTests();
                  return pixelPositionVal;
                },
                boxSizingReliable: function boxSizingReliable() {
                  if (boxSizingReliableVal == null) {
                    computeStyleTests();
                  }
                  return boxSizingReliableVal;
                },
                pixelMarginRight: function pixelMarginRight() {
                  // Support: Android 4.0-4.3
                  // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
                  // since that compresses better and they're computed together anyway.
                  if (boxSizingReliableVal == null) {
                    computeStyleTests();
                  }
                  return pixelMarginRightVal;
                },
                reliableMarginLeft: function reliableMarginLeft() {
                  // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                  if (boxSizingReliableVal == null) {
                    computeStyleTests();
                  }
                  return reliableMarginLeftVal;
                },
                reliableMarginRight: function reliableMarginRight() {
                  // Support: Android 2.3
                  // Check if div with explicit width and no margin-right incorrectly
                  // gets computed margin-right based on width of container. (#3333)
                  // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                  // This support function is only executed once so no memoizing is needed.
                  var ret,
                    marginDiv = div.appendChild(document.createElement("div"));

                  // Reset CSS: box-sizing; display; margin; border; padding
                  marginDiv.style.cssText = div.style.cssText =
                    // Support: Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;box-sizing:content-box;" +
                    "display:block;margin:0;border:0;padding:0";
                  marginDiv.style.marginRight = marginDiv.style.width = "0";
                  div.style.width = "1px";
                  documentElement.appendChild(container);

                  ret = !parseFloat(
                    window.getComputedStyle(marginDiv).marginRight
                  );

                  documentElement.removeChild(container);
                  div.removeChild(marginDiv);

                  return ret;
                },
              });
            })();

            function curCSS(elem, name, computed) {
              var width,
                minWidth,
                maxWidth,
                ret,
                style = elem.style;

              computed = computed || getStyles(elem);
              ret = computed
                ? computed.getPropertyValue(name) || computed[name]
                : undefined;

              // Support: Opera 12.1x only
              // Fall back to style even without computed
              // computed is undefined for elems on document fragments
              if (
                (ret === "" || ret === undefined) &&
                !jQuery.contains(elem.ownerDocument, elem)
              ) {
                ret = jQuery.style(elem, name);
              }

              // Support: IE9
              // getPropertyValue is only needed for .css('filter') (#12537)
              if (computed) {
                // A tribute to the "awesome hack by Dean Edwards"
                // Android Browser returns percentage for some values,
                // but width seems to be reliably pixels.
                // This is against the CSSOM draft spec:
                // http://dev.w3.org/csswg/cssom/#resolved-values
                if (
                  !support.pixelMarginRight() &&
                  rnumnonpx.test(ret) &&
                  rmargin.test(name)
                ) {
                  // Remember the original values
                  width = style.width;
                  minWidth = style.minWidth;
                  maxWidth = style.maxWidth;

                  // Put in the new values to get a computed value out
                  style.minWidth = style.maxWidth = style.width = ret;
                  ret = computed.width;

                  // Revert the changed values
                  style.width = width;
                  style.minWidth = minWidth;
                  style.maxWidth = maxWidth;
                }
              }

              return ret !== undefined
                ? // Support: IE9-11+
                  // IE returns zIndex value as an integer.
                  ret + ""
                : ret;
            }

            function addGetHookIf(conditionFn, hookFn) {
              // Define the hook, we'll check on the first run if it's really needed.
              return {
                get: function get() {
                  if (conditionFn()) {
                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                  }

                  // Hook needed; redefine it so that the support test is not executed again.
                  return (this.get = hookFn).apply(this, arguments);
                },
              };
            }

            var // Swappable if display is none or starts with table
              // except "table", "table-cell", or "table-caption"
              // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
              rdisplayswap = /^(none|table(?!-c[ea]).+)/,
              cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block",
              },
              cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400",
              },
              cssPrefixes = ["Webkit", "O", "Moz", "ms"],
              emptyStyle = document.createElement("div").style;

            // Return a css property mapped to a potentially vendor prefixed property
            function vendorPropName(name) {
              // Shortcut for names that are not vendor prefixed
              if (name in emptyStyle) {
                return name;
              }

              // Check for vendor prefixed names
              var capName = name[0].toUpperCase() + name.slice(1),
                i = cssPrefixes.length;

              while (i--) {
                name = cssPrefixes[i] + capName;
                if (name in emptyStyle) {
                  return name;
                }
              }
            }

            function setPositiveNumber(elem, value, subtract) {
              // Any relative (+/-) values have already been
              // normalized at this point
              var matches = rcssNum.exec(value);
              return matches
                ? // Guard against undefined "subtract", e.g., when used as in cssHooks
                  Math.max(0, matches[2] - (subtract || 0)) +
                    (matches[3] || "px")
                : value;
            }

            function augmentWidthOrHeight(
              elem,
              name,
              extra,
              isBorderBox,
              styles
            ) {
              var i =
                  extra === (isBorderBox ? "border" : "content")
                    ? // If we already have the right measurement, avoid augmentation
                      4
                    : // Otherwise initialize for horizontal or vertical properties
                    name === "width"
                    ? 1
                    : 0,
                val = 0;

              for (; i < 4; i += 2) {
                // Both box models exclude margin, so add it if we want it
                if (extra === "margin") {
                  val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                }

                if (isBorderBox) {
                  // border-box includes padding, so remove it if we want content
                  if (extra === "content") {
                    val -= jQuery.css(
                      elem,
                      "padding" + cssExpand[i],
                      true,
                      styles
                    );
                  }

                  // At this point, extra isn't border nor margin, so remove border
                  if (extra !== "margin") {
                    val -= jQuery.css(
                      elem,
                      "border" + cssExpand[i] + "Width",
                      true,
                      styles
                    );
                  }
                } else {
                  // At this point, extra isn't content, so add padding
                  val += jQuery.css(
                    elem,
                    "padding" + cssExpand[i],
                    true,
                    styles
                  );

                  // At this point, extra isn't content nor padding, so add border
                  if (extra !== "padding") {
                    val += jQuery.css(
                      elem,
                      "border" + cssExpand[i] + "Width",
                      true,
                      styles
                    );
                  }
                }
              }

              return val;
            }

            function getWidthOrHeight(elem, name, extra) {
              // Start with offset property, which is equivalent to the border-box value
              var valueIsBorderBox = true,
                val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                styles = getStyles(elem),
                isBorderBox =
                  jQuery.css(elem, "boxSizing", false, styles) === "border-box";

              // Some non-html elements return undefined for offsetWidth, so check for null/undefined
              // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
              // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
              if (val <= 0 || val == null) {
                // Fall back to computed then uncomputed css if necessary
                val = curCSS(elem, name, styles);
                if (val < 0 || val == null) {
                  val = elem.style[name];
                }

                // Computed unit is not pixels. Stop here and return.
                if (rnumnonpx.test(val)) {
                  return val;
                }

                // Check for style in case a browser which returns unreliable values
                // for getComputedStyle silently falls back to the reliable elem.style
                valueIsBorderBox =
                  isBorderBox &&
                  (support.boxSizingReliable() || val === elem.style[name]);

                // Normalize "", auto, and prepare for extra
                val = parseFloat(val) || 0;
              }

              // Use the active box-sizing model to add/subtract irrelevant styles
              return (
                val +
                augmentWidthOrHeight(
                  elem,
                  name,
                  extra || (isBorderBox ? "border" : "content"),
                  valueIsBorderBox,
                  styles
                ) +
                "px"
              );
            }

            function showHide(elements, show) {
              var display,
                elem,
                hidden,
                values = [],
                index = 0,
                length = elements.length;

              for (; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                  continue;
                }

                values[index] = dataPriv.get(elem, "olddisplay");
                display = elem.style.display;
                if (show) {
                  // Reset the inline display of this element to learn if it is
                  // being hidden by cascaded rules or not
                  if (!values[index] && display === "none") {
                    elem.style.display = "";
                  }

                  // Set elements which have been overridden with display: none
                  // in a stylesheet to whatever the default browser style is
                  // for such an element
                  if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = dataPriv.access(
                      elem,
                      "olddisplay",
                      defaultDisplay(elem.nodeName)
                    );
                  }
                } else {
                  hidden = isHidden(elem);

                  if (display !== "none" || !hidden) {
                    dataPriv.set(
                      elem,
                      "olddisplay",
                      hidden ? display : jQuery.css(elem, "display")
                    );
                  }
                }
              }

              // Set the display of most of the elements in a second loop
              // to avoid the constant reflow
              for (index = 0; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                  continue;
                }
                if (
                  !show ||
                  elem.style.display === "none" ||
                  elem.style.display === ""
                ) {
                  elem.style.display = show ? values[index] || "" : "none";
                }
              }

              return elements;
            }

            jQuery.extend({
              // Add in style property hooks for overriding the default
              // behavior of getting and setting a style property
              cssHooks: {
                opacity: {
                  get: function get(elem, computed) {
                    if (computed) {
                      // We should always get a number back from opacity
                      var ret = curCSS(elem, "opacity");
                      return ret === "" ? "1" : ret;
                    }
                  },
                },
              },

              // Don't automatically add "px" to these possibly-unitless properties
              cssNumber: {
                animationIterationCount: true,
                columnCount: true,
                fillOpacity: true,
                flexGrow: true,
                flexShrink: true,
                fontWeight: true,
                lineHeight: true,
                opacity: true,
                order: true,
                orphans: true,
                widows: true,
                zIndex: true,
                zoom: true,
              },

              // Add in properties whose names you wish to fix before
              // setting or getting the value
              cssProps: {
                float: "cssFloat",
              },

              // Get and set the style property on a DOM Node
              style: function style(elem, name, value, extra) {
                // Don't set styles on text and comment nodes
                if (
                  !elem ||
                  elem.nodeType === 3 ||
                  elem.nodeType === 8 ||
                  !elem.style
                ) {
                  return;
                }

                // Make sure that we're working with the right name
                var ret,
                  type,
                  hooks,
                  origName = jQuery.camelCase(name),
                  style = elem.style;

                name =
                  jQuery.cssProps[origName] ||
                  (jQuery.cssProps[origName] =
                    vendorPropName(origName) || origName);

                // Gets hook for the prefixed version, then unprefixed version
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                // Check if we're setting a value
                if (value !== undefined) {
                  type =
                    typeof value === "undefined" ? "undefined" : _typeof(value);

                  // Convert "+=" or "-=" to relative numbers (#7345)
                  if (
                    type === "string" &&
                    (ret = rcssNum.exec(value)) &&
                    ret[1]
                  ) {
                    value = adjustCSS(elem, name, ret);

                    // Fixes bug #9237
                    type = "number";
                  }

                  // Make sure that null and NaN values aren't set (#7116)
                  if (value == null || value !== value) {
                    return;
                  }

                  // If a number was passed in, add the unit (except for certain CSS properties)
                  if (type === "number") {
                    value +=
                      (ret && ret[3]) ||
                      (jQuery.cssNumber[origName] ? "" : "px");
                  }

                  // Support: IE9-11+
                  // background-* props affect original clone's values
                  if (
                    !support.clearCloneStyle &&
                    value === "" &&
                    name.indexOf("background") === 0
                  ) {
                    style[name] = "inherit";
                  }

                  // If a hook was provided, use that value, otherwise just set the specified value
                  if (
                    !hooks ||
                    !("set" in hooks) ||
                    (value = hooks.set(elem, value, extra)) !== undefined
                  ) {
                    style[name] = value;
                  }
                } else {
                  // If a hook was provided get the non-computed value from there
                  if (
                    hooks &&
                    "get" in hooks &&
                    (ret = hooks.get(elem, false, extra)) !== undefined
                  ) {
                    return ret;
                  }

                  // Otherwise just get the value from the style object
                  return style[name];
                }
              },

              css: function css(elem, name, extra, styles) {
                var val,
                  num,
                  hooks,
                  origName = jQuery.camelCase(name);

                // Make sure that we're working with the right name
                name =
                  jQuery.cssProps[origName] ||
                  (jQuery.cssProps[origName] =
                    vendorPropName(origName) || origName);

                // Try prefixed name followed by the unprefixed name
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                // If a hook was provided get the computed value from there
                if (hooks && "get" in hooks) {
                  val = hooks.get(elem, true, extra);
                }

                // Otherwise, if a way to get the computed value exists, use that
                if (val === undefined) {
                  val = curCSS(elem, name, styles);
                }

                // Convert "normal" to computed value
                if (val === "normal" && name in cssNormalTransform) {
                  val = cssNormalTransform[name];
                }

                // Make numeric if forced or a qualifier was provided and val looks numeric
                if (extra === "" || extra) {
                  num = parseFloat(val);
                  return extra === true || isFinite(num) ? num || 0 : val;
                }
                return val;
              },
            });

            jQuery.each(["height", "width"], function (i, name) {
              jQuery.cssHooks[name] = {
                get: function get(elem, computed, extra) {
                  if (computed) {
                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) &&
                      elem.offsetWidth === 0
                      ? swap(elem, cssShow, function () {
                          return getWidthOrHeight(elem, name, extra);
                        })
                      : getWidthOrHeight(elem, name, extra);
                  }
                },

                set: function set(elem, value, extra) {
                  var matches,
                    styles = extra && getStyles(elem),
                    subtract =
                      extra &&
                      augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        jQuery.css(elem, "boxSizing", false, styles) ===
                          "border-box",
                        styles
                      );

                  // Convert to pixels if value adjustment is needed
                  if (
                    subtract &&
                    (matches = rcssNum.exec(value)) &&
                    (matches[3] || "px") !== "px"
                  ) {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                  }

                  return setPositiveNumber(elem, value, subtract);
                },
              };
            });

            jQuery.cssHooks.marginLeft = addGetHookIf(
              support.reliableMarginLeft,
              function (elem, computed) {
                if (computed) {
                  return (
                    (parseFloat(curCSS(elem, "marginLeft")) ||
                      elem.getBoundingClientRect().left -
                        swap(elem, { marginLeft: 0 }, function () {
                          return elem.getBoundingClientRect().left;
                        })) + "px"
                  );
                }
              }
            );

            // Support: Android 2.3
            jQuery.cssHooks.marginRight = addGetHookIf(
              support.reliableMarginRight,
              function (elem, computed) {
                if (computed) {
                  return swap(elem, { display: "inline-block" }, curCSS, [
                    elem,
                    "marginRight",
                  ]);
                }
              }
            );

            // These hooks are used by animate to expand properties
            jQuery.each(
              {
                margin: "",
                padding: "",
                border: "Width",
              },
              function (prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                  expand: function expand(value) {
                    var i = 0,
                      expanded = {},
                      // Assumes a single number if not a string
                      parts =
                        typeof value === "string" ? value.split(" ") : [value];

                    for (; i < 4; i++) {
                      expanded[prefix + cssExpand[i] + suffix] =
                        parts[i] || parts[i - 2] || parts[0];
                    }

                    return expanded;
                  },
                };

                if (!rmargin.test(prefix)) {
                  jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
              }
            );

            jQuery.fn.extend({
              css: function css(name, value) {
                return access(
                  this,
                  function (elem, name, value) {
                    var styles,
                      len,
                      map = {},
                      i = 0;

                    if (jQuery.isArray(name)) {
                      styles = getStyles(elem);
                      len = name.length;

                      for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                      }

                      return map;
                    }

                    return value !== undefined
                      ? jQuery.style(elem, name, value)
                      : jQuery.css(elem, name);
                  },
                  name,
                  value,
                  arguments.length > 1
                );
              },
              show: function show() {
                return showHide(this, true);
              },
              hide: function hide() {
                return showHide(this);
              },
              toggle: function toggle(state) {
                if (typeof state === "boolean") {
                  return state ? this.show() : this.hide();
                }

                return this.each(function () {
                  if (isHidden(this)) {
                    jQuery(this).show();
                  } else {
                    jQuery(this).hide();
                  }
                });
              },
            });

            function Tween(elem, options, prop, end, easing) {
              return new Tween.prototype.init(elem, options, prop, end, easing);
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
              constructor: Tween,
              init: function init(elem, options, prop, end, easing, unit) {
                this.elem = elem;
                this.prop = prop;
                this.easing = easing || jQuery.easing._default;
                this.options = options;
                this.start = this.now = this.cur();
                this.end = end;
                this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
              },
              cur: function cur() {
                var hooks = Tween.propHooks[this.prop];

                return hooks && hooks.get
                  ? hooks.get(this)
                  : Tween.propHooks._default.get(this);
              },
              run: function run(percent) {
                var eased,
                  hooks = Tween.propHooks[this.prop];

                if (this.options.duration) {
                  this.pos = eased = jQuery.easing[this.easing](
                    percent,
                    this.options.duration * percent,
                    0,
                    1,
                    this.options.duration
                  );
                } else {
                  this.pos = eased = percent;
                }
                this.now = (this.end - this.start) * eased + this.start;

                if (this.options.step) {
                  this.options.step.call(this.elem, this.now, this);
                }

                if (hooks && hooks.set) {
                  hooks.set(this);
                } else {
                  Tween.propHooks._default.set(this);
                }
                return this;
              },
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
              _default: {
                get: function get(tween) {
                  var result;

                  // Use a property on the element directly when it is not a DOM element,
                  // or when there is no matching style property that exists.
                  if (
                    tween.elem.nodeType !== 1 ||
                    (tween.elem[tween.prop] != null &&
                      tween.elem.style[tween.prop] == null)
                  ) {
                    return tween.elem[tween.prop];
                  }

                  // Passing an empty string as a 3rd parameter to .css will automatically
                  // attempt a parseFloat and fallback to a string if the parse fails.
                  // Simple values such as "10px" are parsed to Float;
                  // complex values such as "rotate(1rad)" are returned as-is.
                  result = jQuery.css(tween.elem, tween.prop, "");

                  // Empty strings, null, undefined and "auto" are converted to 0.
                  return !result || result === "auto" ? 0 : result;
                },
                set: function set(tween) {
                  // Use step hook for back compat.
                  // Use cssHook if its there.
                  // Use .style if available and use plain properties where available.
                  if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                  } else if (
                    tween.elem.nodeType === 1 &&
                    (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
                      jQuery.cssHooks[tween.prop])
                  ) {
                    jQuery.style(
                      tween.elem,
                      tween.prop,
                      tween.now + tween.unit
                    );
                  } else {
                    tween.elem[tween.prop] = tween.now;
                  }
                },
              },
            };

            // Support: IE9
            // Panic based approach to setting things on disconnected nodes
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
              set: function set(tween) {
                if (tween.elem.nodeType && tween.elem.parentNode) {
                  tween.elem[tween.prop] = tween.now;
                }
              },
            };

            jQuery.easing = {
              linear: function linear(p) {
                return p;
              },
              swing: function swing(p) {
                return 0.5 - Math.cos(p * Math.PI) / 2;
              },
              _default: "swing",
            };

            jQuery.fx = Tween.prototype.init;

            // Back Compat <1.8 extension point
            jQuery.fx.step = {};

            var fxNow,
              timerId,
              rfxtypes = /^(?:toggle|show|hide)$/,
              rrun = /queueHooks$/;

            // Animations created synchronously will run synchronously
            function createFxNow() {
              window.setTimeout(function () {
                fxNow = undefined;
              });
              return (fxNow = jQuery.now());
            }

            // Generate parameters to create a standard animation
            function genFx(type, includeWidth) {
              var which,
                i = 0,
                attrs = { height: type };

              // If we include width, step value is 1 to do all cssExpand values,
              // otherwise step value is 2 to skip over Left and Right
              includeWidth = includeWidth ? 1 : 0;
              for (; i < 4; i += 2 - includeWidth) {
                which = cssExpand[i];
                attrs["margin" + which] = attrs["padding" + which] = type;
              }

              if (includeWidth) {
                attrs.opacity = attrs.width = type;
              }

              return attrs;
            }

            function createTween(value, prop, animation) {
              var tween,
                collection = (Animation.tweeners[prop] || []).concat(
                  Animation.tweeners["*"]
                ),
                index = 0,
                length = collection.length;
              for (; index < length; index++) {
                if ((tween = collection[index].call(animation, prop, value))) {
                  // We're done with this property
                  return tween;
                }
              }
            }

            function defaultPrefilter(elem, props, opts) {
              /* jshint validthis: true */
              var prop,
                value,
                toggle,
                tween,
                hooks,
                oldfire,
                display,
                checkDisplay,
                anim = this,
                orig = {},
                style = elem.style,
                hidden = elem.nodeType && isHidden(elem),
                dataShow = dataPriv.get(elem, "fxshow");

              // Handle queue: false promises
              if (!opts.queue) {
                hooks = jQuery._queueHooks(elem, "fx");
                if (hooks.unqueued == null) {
                  hooks.unqueued = 0;
                  oldfire = hooks.empty.fire;
                  hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                      oldfire();
                    }
                  };
                }
                hooks.unqueued++;

                anim.always(function () {
                  // Ensure the complete handler is called before this completes
                  anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                      hooks.empty.fire();
                    }
                  });
                });
              }

              // Height/width overflow pass
              if (
                elem.nodeType === 1 &&
                ("height" in props || "width" in props)
              ) {
                // Make sure that nothing sneaks out
                // Record all 3 overflow attributes because IE9-10 do not
                // change the overflow attribute when overflowX and
                // overflowY are set to the same value
                opts.overflow = [
                  style.overflow,
                  style.overflowX,
                  style.overflowY,
                ];

                // Set display property to inline-block for height/width
                // animations on inline elements that are having width/height animated
                display = jQuery.css(elem, "display");

                // Test default display if display is currently "none"
                checkDisplay =
                  display === "none"
                    ? dataPriv.get(elem, "olddisplay") ||
                      defaultDisplay(elem.nodeName)
                    : display;

                if (
                  checkDisplay === "inline" &&
                  jQuery.css(elem, "float") === "none"
                ) {
                  style.display = "inline-block";
                }
              }

              if (opts.overflow) {
                style.overflow = "hidden";
                anim.always(function () {
                  style.overflow = opts.overflow[0];
                  style.overflowX = opts.overflow[1];
                  style.overflowY = opts.overflow[2];
                });
              }

              // show/hide pass
              for (prop in props) {
                value = props[prop];
                if (rfxtypes.exec(value)) {
                  delete props[prop];
                  toggle = toggle || value === "toggle";
                  if (value === (hidden ? "hide" : "show")) {
                    // If there is dataShow left over from a stopped hide or show
                    // and we are going to proceed with show, we should pretend to be hidden
                    if (
                      value === "show" &&
                      dataShow &&
                      dataShow[prop] !== undefined
                    ) {
                      hidden = true;
                    } else {
                      continue;
                    }
                  }
                  orig[prop] =
                    (dataShow && dataShow[prop]) || jQuery.style(elem, prop);

                  // Any non-fx value stops us from restoring the original display value
                } else {
                  display = undefined;
                }
              }

              if (!jQuery.isEmptyObject(orig)) {
                if (dataShow) {
                  if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                  }
                } else {
                  dataShow = dataPriv.access(elem, "fxshow", {});
                }

                // Store state if its toggle - enables .stop().toggle() to "reverse"
                if (toggle) {
                  dataShow.hidden = !hidden;
                }
                if (hidden) {
                  jQuery(elem).show();
                } else {
                  anim.done(function () {
                    jQuery(elem).hide();
                  });
                }
                anim.done(function () {
                  var prop;

                  dataPriv.remove(elem, "fxshow");
                  for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                  }
                });
                for (prop in orig) {
                  tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                  if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                      tween.end = tween.start;
                      tween.start =
                        prop === "width" || prop === "height" ? 1 : 0;
                    }
                  }
                }

                // If this is a noop like .hide().hide(), restore an overwritten display value
              } else if (
                (display === "none"
                  ? defaultDisplay(elem.nodeName)
                  : display) === "inline"
              ) {
                style.display = display;
              }
            }

            function propFilter(props, specialEasing) {
              var index, name, easing, value, hooks;

              // camelCase, specialEasing and expand cssHook pass
              for (index in props) {
                name = jQuery.camelCase(index);
                easing = specialEasing[name];
                value = props[index];
                if (jQuery.isArray(value)) {
                  easing = value[1];
                  value = props[index] = value[0];
                }

                if (index !== name) {
                  props[name] = value;
                  delete props[index];
                }

                hooks = jQuery.cssHooks[name];
                if (hooks && "expand" in hooks) {
                  value = hooks.expand(value);
                  delete props[name];

                  // Not quite $.extend, this won't overwrite existing keys.
                  // Reusing 'index' because we have the correct "name"
                  for (index in value) {
                    if (!(index in props)) {
                      props[index] = value[index];
                      specialEasing[index] = easing;
                    }
                  }
                } else {
                  specialEasing[name] = easing;
                }
              }
            }

            function Animation(elem, properties, options) {
              var result,
                stopped,
                index = 0,
                length = Animation.prefilters.length,
                deferred = jQuery.Deferred().always(function () {
                  // Don't match elem in the :animated selector
                  delete tick.elem;
                }),
                tick = function tick() {
                  if (stopped) {
                    return false;
                  }
                  var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(
                      0,
                      animation.startTime + animation.duration - currentTime
                    ),
                    // Support: Android 2.3
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                  for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                  }

                  deferred.notifyWith(elem, [animation, percent, remaining]);

                  if (percent < 1 && length) {
                    return remaining;
                  } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                  }
                },
                animation = deferred.promise({
                  elem: elem,
                  props: jQuery.extend({}, properties),
                  opts: jQuery.extend(
                    true,
                    {
                      specialEasing: {},
                      easing: jQuery.easing._default,
                    },
                    options
                  ),
                  originalProperties: properties,
                  originalOptions: options,
                  startTime: fxNow || createFxNow(),
                  duration: options.duration,
                  tweens: [],
                  createTween: function createTween(prop, end) {
                    var tween = jQuery.Tween(
                      elem,
                      animation.opts,
                      prop,
                      end,
                      animation.opts.specialEasing[prop] ||
                        animation.opts.easing
                    );
                    animation.tweens.push(tween);
                    return tween;
                  },
                  stop: function stop(gotoEnd) {
                    var index = 0,
                      // If we are going to the end, we want to run all the tweens
                      // otherwise we skip this part
                      length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                      return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                      animation.tweens[index].run(1);
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if (gotoEnd) {
                      deferred.notifyWith(elem, [animation, 1, 0]);
                      deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                      deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                  },
                }),
                props = animation.props;

              propFilter(props, animation.opts.specialEasing);

              for (; index < length; index++) {
                result = Animation.prefilters[index].call(
                  animation,
                  elem,
                  props,
                  animation.opts
                );
                if (result) {
                  if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(
                      animation.elem,
                      animation.opts.queue
                    ).stop = jQuery.proxy(result.stop, result);
                  }
                  return result;
                }
              }

              jQuery.map(props, createTween, animation);

              if (jQuery.isFunction(animation.opts.start)) {
                animation.opts.start.call(elem, animation);
              }

              jQuery.fx.timer(
                jQuery.extend(tick, {
                  elem: elem,
                  anim: animation,
                  queue: animation.opts.queue,
                })
              );

              // attach callbacks from options
              return animation
                .progress(animation.opts.progress)
                .done(animation.opts.done, animation.opts.complete)
                .fail(animation.opts.fail)
                .always(animation.opts.always);
            }

            jQuery.Animation = jQuery.extend(Animation, {
              tweeners: {
                "*": [
                  function (prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                  },
                ],
              },

              tweener: function tweener(props, callback) {
                if (jQuery.isFunction(props)) {
                  callback = props;
                  props = ["*"];
                } else {
                  props = props.match(rnotwhite);
                }

                var prop,
                  index = 0,
                  length = props.length;

                for (; index < length; index++) {
                  prop = props[index];
                  Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                  Animation.tweeners[prop].unshift(callback);
                }
              },

              prefilters: [defaultPrefilter],

              prefilter: function prefilter(callback, prepend) {
                if (prepend) {
                  Animation.prefilters.unshift(callback);
                } else {
                  Animation.prefilters.push(callback);
                }
              },
            });

            jQuery.speed = function (speed, easing, fn) {
              var opt =
                speed &&
                (typeof speed === "undefined"
                  ? "undefined"
                  : _typeof(speed)) === "object"
                  ? jQuery.extend({}, speed)
                  : {
                      complete:
                        fn ||
                        (!fn && easing) ||
                        (jQuery.isFunction(speed) && speed),
                      duration: speed,
                      easing:
                        (fn && easing) ||
                        (easing && !jQuery.isFunction(easing) && easing),
                    };

              opt.duration = jQuery.fx.off
                ? 0
                : typeof opt.duration === "number"
                ? opt.duration
                : opt.duration in jQuery.fx.speeds
                ? jQuery.fx.speeds[opt.duration]
                : jQuery.fx.speeds._default;

              // Normalize opt.queue - true/undefined/null -> "fx"
              if (opt.queue == null || opt.queue === true) {
                opt.queue = "fx";
              }

              // Queueing
              opt.old = opt.complete;

              opt.complete = function () {
                if (jQuery.isFunction(opt.old)) {
                  opt.old.call(this);
                }

                if (opt.queue) {
                  jQuery.dequeue(this, opt.queue);
                }
              };

              return opt;
            };

            jQuery.fn.extend({
              fadeTo: function fadeTo(speed, to, easing, callback) {
                // Show any hidden elements after setting opacity to 0
                return (
                  this.filter(isHidden)
                    .css("opacity", 0)
                    .show()

                    // Animate to the value specified
                    .end()
                    .animate({ opacity: to }, speed, easing, callback)
                );
              },
              animate: function animate(prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop),
                  optall = jQuery.speed(speed, easing, callback),
                  doAnimation = function doAnimation() {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || dataPriv.get(this, "finish")) {
                      anim.stop(true);
                    }
                  };
                doAnimation.finish = doAnimation;

                return empty || optall.queue === false
                  ? this.each(doAnimation)
                  : this.queue(optall.queue, doAnimation);
              },
              stop: function stop(type, clearQueue, gotoEnd) {
                var stopQueue = function stopQueue(hooks) {
                  var stop = hooks.stop;
                  delete hooks.stop;
                  stop(gotoEnd);
                };

                if (typeof type !== "string") {
                  gotoEnd = clearQueue;
                  clearQueue = type;
                  type = undefined;
                }
                if (clearQueue && type !== false) {
                  this.queue(type || "fx", []);
                }

                return this.each(function () {
                  var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get(this);

                  if (index) {
                    if (data[index] && data[index].stop) {
                      stopQueue(data[index]);
                    }
                  } else {
                    for (index in data) {
                      if (data[index] && data[index].stop && rrun.test(index)) {
                        stopQueue(data[index]);
                      }
                    }
                  }

                  for (index = timers.length; index--; ) {
                    if (
                      timers[index].elem === this &&
                      (type == null || timers[index].queue === type)
                    ) {
                      timers[index].anim.stop(gotoEnd);
                      dequeue = false;
                      timers.splice(index, 1);
                    }
                  }

                  // Start the next in the queue if the last step wasn't forced.
                  // Timers currently will call their complete callbacks, which
                  // will dequeue but only if they were gotoEnd.
                  if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                  }
                });
              },
              finish: function finish(type) {
                if (type !== false) {
                  type = type || "fx";
                }
                return this.each(function () {
                  var index,
                    data = dataPriv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                  // Enable finishing flag on private data
                  data.finish = true;

                  // Empty the queue first
                  jQuery.queue(this, type, []);

                  if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                  }

                  // Look for any active animations, and finish them
                  for (index = timers.length; index--; ) {
                    if (
                      timers[index].elem === this &&
                      timers[index].queue === type
                    ) {
                      timers[index].anim.stop(true);
                      timers.splice(index, 1);
                    }
                  }

                  // Look for any animations in the old queue and finish them
                  for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                      queue[index].finish.call(this);
                    }
                  }

                  // Turn off finishing flag
                  delete data.finish;
                });
              },
            });

            jQuery.each(["toggle", "show", "hide"], function (i, name) {
              var cssFn = jQuery.fn[name];
              jQuery.fn[name] = function (speed, easing, callback) {
                return speed == null || typeof speed === "boolean"
                  ? cssFn.apply(this, arguments)
                  : this.animate(genFx(name, true), speed, easing, callback);
              };
            });

            // Generate shortcuts for custom animations
            jQuery.each(
              {
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: { opacity: "show" },
                fadeOut: { opacity: "hide" },
                fadeToggle: { opacity: "toggle" },
              },
              function (name, props) {
                jQuery.fn[name] = function (speed, easing, callback) {
                  return this.animate(props, speed, easing, callback);
                };
              }
            );

            jQuery.timers = [];
            jQuery.fx.tick = function () {
              var timer,
                i = 0,
                timers = jQuery.timers;

              fxNow = jQuery.now();

              for (; i < timers.length; i++) {
                timer = timers[i];

                // Checks the timer has not already been removed
                if (!timer() && timers[i] === timer) {
                  timers.splice(i--, 1);
                }
              }

              if (!timers.length) {
                jQuery.fx.stop();
              }
              fxNow = undefined;
            };

            jQuery.fx.timer = function (timer) {
              jQuery.timers.push(timer);
              if (timer()) {
                jQuery.fx.start();
              } else {
                jQuery.timers.pop();
              }
            };

            jQuery.fx.interval = 13;
            jQuery.fx.start = function () {
              if (!timerId) {
                timerId = window.setInterval(
                  jQuery.fx.tick,
                  jQuery.fx.interval
                );
              }
            };

            jQuery.fx.stop = function () {
              window.clearInterval(timerId);

              timerId = null;
            };

            jQuery.fx.speeds = {
              slow: 600,
              fast: 200,

              // Default speed
              _default: 400,
            };

            // Based off of the plugin by Clint Helfers, with permission.
            // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function (time, type) {
              time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
              type = type || "fx";

              return this.queue(type, function (next, hooks) {
                var timeout = window.setTimeout(next, time);
                hooks.stop = function () {
                  window.clearTimeout(timeout);
                };
              });
            };

            (function () {
              var input = document.createElement("input"),
                select = document.createElement("select"),
                opt = select.appendChild(document.createElement("option"));

              input.type = "checkbox";

              // Support: iOS<=5.1, Android<=4.2+
              // Default value for a checkbox should be "on"
              support.checkOn = input.value !== "";

              // Support: IE<=11+
              // Must access selectedIndex to make default options select
              support.optSelected = opt.selected;

              // Support: Android<=2.3
              // Options inside disabled selects are incorrectly marked as disabled
              select.disabled = true;
              support.optDisabled = !opt.disabled;

              // Support: IE<=11+
              // An input loses its value after becoming a radio
              input = document.createElement("input");
              input.value = "t";
              input.type = "radio";
              support.radioValue = input.value === "t";
            })();

            var boolHook,
              attrHandle = jQuery.expr.attrHandle;

            jQuery.fn.extend({
              attr: function attr(name, value) {
                return access(
                  this,
                  jQuery.attr,
                  name,
                  value,
                  arguments.length > 1
                );
              },

              removeAttr: function removeAttr(name) {
                return this.each(function () {
                  jQuery.removeAttr(this, name);
                });
              },
            });

            jQuery.extend({
              attr: function attr(elem, name, value) {
                var ret,
                  hooks,
                  nType = elem.nodeType;

                // Don't get/set attributes on text, comment and attribute nodes
                if (nType === 3 || nType === 8 || nType === 2) {
                  return;
                }

                // Fallback to prop when attributes are not supported
                if (typeof elem.getAttribute === "undefined") {
                  return jQuery.prop(elem, name, value);
                }

                // All attributes are lowercase
                // Grab necessary hook if one is defined
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                  name = name.toLowerCase();
                  hooks =
                    jQuery.attrHooks[name] ||
                    (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
                }

                if (value !== undefined) {
                  if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                  }

                  if (
                    hooks &&
                    "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined
                  ) {
                    return ret;
                  }

                  elem.setAttribute(name, value + "");
                  return value;
                }

                if (
                  hooks &&
                  "get" in hooks &&
                  (ret = hooks.get(elem, name)) !== null
                ) {
                  return ret;
                }

                ret = jQuery.find.attr(elem, name);

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ? undefined : ret;
              },

              attrHooks: {
                type: {
                  set: function set(elem, value) {
                    if (
                      !support.radioValue &&
                      value === "radio" &&
                      jQuery.nodeName(elem, "input")
                    ) {
                      var val = elem.value;
                      elem.setAttribute("type", value);
                      if (val) {
                        elem.value = val;
                      }
                      return value;
                    }
                  },
                },
              },

              removeAttr: function removeAttr(elem, value) {
                var name,
                  propName,
                  i = 0,
                  attrNames = value && value.match(rnotwhite);

                if (attrNames && elem.nodeType === 1) {
                  while ((name = attrNames[i++])) {
                    propName = jQuery.propFix[name] || name;

                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {
                      // Set corresponding property to false
                      elem[propName] = false;
                    }

                    elem.removeAttribute(name);
                  }
                }
              },
            });

            // Hooks for boolean attributes
            boolHook = {
              set: function set(elem, value, name) {
                if (value === false) {
                  // Remove boolean attributes when set to false
                  jQuery.removeAttr(elem, name);
                } else {
                  elem.setAttribute(name, name);
                }
                return name;
              },
            };
            jQuery.each(
              jQuery.expr.match.bool.source.match(/\w+/g),
              function (i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;

                attrHandle[name] = function (elem, name, isXML) {
                  var ret, handle;
                  if (!isXML) {
                    // Avoid an infinite loop by temporarily removing this function from the getter
                    handle = attrHandle[name];
                    attrHandle[name] = ret;
                    ret =
                      getter(elem, name, isXML) != null
                        ? name.toLowerCase()
                        : null;
                    attrHandle[name] = handle;
                  }
                  return ret;
                };
              }
            );

            var rfocusable = /^(?:input|select|textarea|button)$/i,
              rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend({
              prop: function prop(name, value) {
                return access(
                  this,
                  jQuery.prop,
                  name,
                  value,
                  arguments.length > 1
                );
              },

              removeProp: function removeProp(name) {
                return this.each(function () {
                  delete this[jQuery.propFix[name] || name];
                });
              },
            });

            jQuery.extend({
              prop: function prop(elem, name, value) {
                var ret,
                  hooks,
                  nType = elem.nodeType;

                // Don't get/set properties on text, comment and attribute nodes
                if (nType === 3 || nType === 8 || nType === 2) {
                  return;
                }

                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                  // Fix name and attach hooks
                  name = jQuery.propFix[name] || name;
                  hooks = jQuery.propHooks[name];
                }

                if (value !== undefined) {
                  if (
                    hooks &&
                    "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined
                  ) {
                    return ret;
                  }

                  return (elem[name] = value);
                }

                if (
                  hooks &&
                  "get" in hooks &&
                  (ret = hooks.get(elem, name)) !== null
                ) {
                  return ret;
                }

                return elem[name];
              },

              propHooks: {
                tabIndex: {
                  get: function get(elem) {
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");

                    return tabindex
                      ? parseInt(tabindex, 10)
                      : rfocusable.test(elem.nodeName) ||
                        (rclickable.test(elem.nodeName) && elem.href)
                      ? 0
                      : -1;
                  },
                },
              },

              propFix: {
                for: "htmlFor",
                class: "className",
              },
            });

            // Support: IE <=11 only
            // Accessing the selectedIndex property
            // forces the browser to respect setting selected
            // on the option
            // The getter ensures a default option is selected
            // when in an optgroup
            if (!support.optSelected) {
              jQuery.propHooks.selected = {
                get: function get(elem) {
                  var parent = elem.parentNode;
                  if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                  }
                  return null;
                },
                set: function set(elem) {
                  var parent = elem.parentNode;
                  if (parent) {
                    parent.selectedIndex;

                    if (parent.parentNode) {
                      parent.parentNode.selectedIndex;
                    }
                  }
                },
              };
            }

            jQuery.each(
              [
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable",
              ],
              function () {
                jQuery.propFix[this.toLowerCase()] = this;
              }
            );

            var rclass = /[\t\r\n\f]/g;

            function getClass(elem) {
              return (elem.getAttribute && elem.getAttribute("class")) || "";
            }

            jQuery.fn.extend({
              addClass: function addClass(value) {
                var classes,
                  elem,
                  cur,
                  curValue,
                  clazz,
                  j,
                  finalValue,
                  i = 0;

                if (jQuery.isFunction(value)) {
                  return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                  });
                }

                if (typeof value === "string" && value) {
                  classes = value.match(rnotwhite) || [];

                  while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur =
                      elem.nodeType === 1 &&
                      (" " + curValue + " ").replace(rclass, " ");

                    if (cur) {
                      j = 0;
                      while ((clazz = classes[j++])) {
                        if (cur.indexOf(" " + clazz + " ") < 0) {
                          cur += clazz + " ";
                        }
                      }

                      // Only assign if different to avoid unneeded rendering.
                      finalValue = jQuery.trim(cur);
                      if (curValue !== finalValue) {
                        elem.setAttribute("class", finalValue);
                      }
                    }
                  }
                }

                return this;
              },

              removeClass: function removeClass(value) {
                var classes,
                  elem,
                  cur,
                  curValue,
                  clazz,
                  j,
                  finalValue,
                  i = 0;

                if (jQuery.isFunction(value)) {
                  return this.each(function (j) {
                    jQuery(this).removeClass(
                      value.call(this, j, getClass(this))
                    );
                  });
                }

                if (!arguments.length) {
                  return this.attr("class", "");
                }

                if (typeof value === "string" && value) {
                  classes = value.match(rnotwhite) || [];

                  while ((elem = this[i++])) {
                    curValue = getClass(elem);

                    // This expression is here for better compressibility (see addClass)
                    cur =
                      elem.nodeType === 1 &&
                      (" " + curValue + " ").replace(rclass, " ");

                    if (cur) {
                      j = 0;
                      while ((clazz = classes[j++])) {
                        // Remove *all* instances
                        while (cur.indexOf(" " + clazz + " ") > -1) {
                          cur = cur.replace(" " + clazz + " ", " ");
                        }
                      }

                      // Only assign if different to avoid unneeded rendering.
                      finalValue = jQuery.trim(cur);
                      if (curValue !== finalValue) {
                        elem.setAttribute("class", finalValue);
                      }
                    }
                  }
                }

                return this;
              },

              toggleClass: function toggleClass(value, stateVal) {
                var type =
                  typeof value === "undefined" ? "undefined" : _typeof(value);

                if (typeof stateVal === "boolean" && type === "string") {
                  return stateVal
                    ? this.addClass(value)
                    : this.removeClass(value);
                }

                if (jQuery.isFunction(value)) {
                  return this.each(function (i) {
                    jQuery(this).toggleClass(
                      value.call(this, i, getClass(this), stateVal),
                      stateVal
                    );
                  });
                }

                return this.each(function () {
                  var className, i, self, classNames;

                  if (type === "string") {
                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnotwhite) || [];

                    while ((className = classNames[i++])) {
                      // Check each className given, space separated list
                      if (self.hasClass(className)) {
                        self.removeClass(className);
                      } else {
                        self.addClass(className);
                      }
                    }

                    // Toggle whole class name
                  } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {
                      // Store className if set
                      dataPriv.set(this, "__className__", className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) {
                      this.setAttribute(
                        "class",
                        className || value === false
                          ? ""
                          : dataPriv.get(this, "__className__") || ""
                      );
                    }
                  }
                });
              },

              hasClass: function hasClass(selector) {
                var className,
                  elem,
                  i = 0;

                className = " " + selector + " ";
                while ((elem = this[i++])) {
                  if (
                    elem.nodeType === 1 &&
                    (" " + getClass(elem) + " ")
                      .replace(rclass, " ")
                      .indexOf(className) > -1
                  ) {
                    return true;
                  }
                }

                return false;
              },
            });

            var rreturn = /\r/g,
              rspaces = /[\x20\t\r\n\f]+/g;

            jQuery.fn.extend({
              val: function val(value) {
                var hooks,
                  ret,
                  isFunction,
                  elem = this[0];

                if (!arguments.length) {
                  if (elem) {
                    hooks =
                      jQuery.valHooks[elem.type] ||
                      jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (
                      hooks &&
                      "get" in hooks &&
                      (ret = hooks.get(elem, "value")) !== undefined
                    ) {
                      return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string"
                      ? // Handle most common string cases
                        ret.replace(rreturn, "")
                      : // Handle cases where value is null/undef or number
                      ret == null
                      ? ""
                      : ret;
                  }

                  return;
                }

                isFunction = jQuery.isFunction(value);

                return this.each(function (i) {
                  var val;

                  if (this.nodeType !== 1) {
                    return;
                  }

                  if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                  } else {
                    val = value;
                  }

                  // Treat null/undefined as ""; convert numbers to string
                  if (val == null) {
                    val = "";
                  } else if (typeof val === "number") {
                    val += "";
                  } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                      return value == null ? "" : value + "";
                    });
                  }

                  hooks =
                    jQuery.valHooks[this.type] ||
                    jQuery.valHooks[this.nodeName.toLowerCase()];

                  // If set returns undefined, fall back to normal setting
                  if (
                    !hooks ||
                    !("set" in hooks) ||
                    hooks.set(this, val, "value") === undefined
                  ) {
                    this.value = val;
                  }
                });
              },
            });

            jQuery.extend({
              valHooks: {
                option: {
                  get: function get(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null
                      ? val
                      : // Support: IE10-11+
                        // option.text throws exceptions (#14686, #14858)
                        // Strip and collapse whitespace
                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
                  },
                },
                select: {
                  get: function get(elem) {
                    var value,
                      option,
                      options = elem.options,
                      index = elem.selectedIndex,
                      one = elem.type === "select-one" || index < 0,
                      values = one ? null : [],
                      max = one ? index + 1 : options.length,
                      i = index < 0 ? max : one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                      option = options[i];

                      // IE8-9 doesn't update selected after form reset (#2551)
                      if (
                        (option.selected || i === index) &&
                        // Don't return options that are disabled or in a disabled optgroup
                        (support.optDisabled
                          ? !option.disabled
                          : option.getAttribute("disabled") === null) &&
                        (!option.parentNode.disabled ||
                          !jQuery.nodeName(option.parentNode, "optgroup"))
                      ) {
                        // Get the specific value for the option
                        value = jQuery(option).val();

                        // We don't need an array for one selects
                        if (one) {
                          return value;
                        }

                        // Multi-Selects return an array
                        values.push(value);
                      }
                    }

                    return values;
                  },

                  set: function set(elem, value) {
                    var optionSet,
                      option,
                      options = elem.options,
                      values = jQuery.makeArray(value),
                      i = options.length;

                    while (i--) {
                      option = options[i];
                      if (
                        (option.selected =
                          jQuery.inArray(
                            jQuery.valHooks.option.get(option),
                            values
                          ) > -1)
                      ) {
                        optionSet = true;
                      }
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                      elem.selectedIndex = -1;
                    }
                    return values;
                  },
                },
              },
            });

            // Radios and checkboxes getter/setter
            jQuery.each(["radio", "checkbox"], function () {
              jQuery.valHooks[this] = {
                set: function set(elem, value) {
                  if (jQuery.isArray(value)) {
                    return (elem.checked =
                      jQuery.inArray(jQuery(elem).val(), value) > -1);
                  }
                },
              };
              if (!support.checkOn) {
                jQuery.valHooks[this].get = function (elem) {
                  return elem.getAttribute("value") === null
                    ? "on"
                    : elem.value;
                };
              }
            });

            // Return jQuery for attributes-only inclusion

            var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

            jQuery.extend(jQuery.event, {
              trigger: function trigger(event, data, elem, onlyHandlers) {
                var i,
                  cur,
                  tmp,
                  bubbleType,
                  ontype,
                  handle,
                  special,
                  eventPath = [elem || document],
                  type = hasOwn.call(event, "type") ? event.type : event,
                  namespaces = hasOwn.call(event, "namespace")
                    ? event.namespace.split(".")
                    : [];

                cur = tmp = elem = elem || document;

                // Don't do events on text and comment nodes
                if (elem.nodeType === 3 || elem.nodeType === 8) {
                  return;
                }

                // focus/blur morphs to focusin/out; ensure we're not firing them right now
                if (rfocusMorph.test(type + jQuery.event.triggered)) {
                  return;
                }

                if (type.indexOf(".") > -1) {
                  // Namespaced trigger; create a regexp to match event type in handle()
                  namespaces = type.split(".");
                  type = namespaces.shift();
                  namespaces.sort();
                }
                ontype = type.indexOf(":") < 0 && "on" + type;

                // Caller can pass in a jQuery.Event object, Object, or just an event type string
                event = event[jQuery.expando]
                  ? event
                  : new jQuery.Event(
                      type,
                      (typeof event === "undefined"
                        ? "undefined"
                        : _typeof(event)) === "object" && event
                    );

                // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                event.isTrigger = onlyHandlers ? 2 : 3;
                event.namespace = namespaces.join(".");
                event.rnamespace = event.namespace
                  ? new RegExp(
                      "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"
                    )
                  : null;

                // Clean up the event in case it is being reused
                event.result = undefined;
                if (!event.target) {
                  event.target = elem;
                }

                // Clone any incoming data and prepend the event, creating the handler arg list
                data = data == null ? [event] : jQuery.makeArray(data, [event]);

                // Allow special events to draw outside the lines
                special = jQuery.event.special[type] || {};
                if (
                  !onlyHandlers &&
                  special.trigger &&
                  special.trigger.apply(elem, data) === false
                ) {
                  return;
                }

                // Determine event propagation path in advance, per W3C events spec (#9951)
                // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                if (
                  !onlyHandlers &&
                  !special.noBubble &&
                  !jQuery.isWindow(elem)
                ) {
                  bubbleType = special.delegateType || type;
                  if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                  }
                  for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                  }

                  // Only add window if we got to document (e.g., not plain obj or detached DOM)
                  if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(
                      tmp.defaultView || tmp.parentWindow || window
                    );
                  }
                }

                // Fire handlers on the event path
                i = 0;
                while (
                  (cur = eventPath[i++]) &&
                  !event.isPropagationStopped()
                ) {
                  event.type = i > 1 ? bubbleType : special.bindType || type;

                  // jQuery handler
                  handle =
                    (dataPriv.get(cur, "events") || {})[event.type] &&
                    dataPriv.get(cur, "handle");
                  if (handle) {
                    handle.apply(cur, data);
                  }

                  // Native handler
                  handle = ontype && cur[ontype];
                  if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                      event.preventDefault();
                    }
                  }
                }
                event.type = type;

                // If nobody prevented the default action, do it now
                if (!onlyHandlers && !event.isDefaultPrevented()) {
                  if (
                    (!special._default ||
                      special._default.apply(eventPath.pop(), data) ===
                        false) &&
                    acceptData(elem)
                  ) {
                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (
                      ontype &&
                      jQuery.isFunction(elem[type]) &&
                      !jQuery.isWindow(elem)
                    ) {
                      // Don't re-trigger an onFOO event when we call its FOO() method
                      tmp = elem[ontype];

                      if (tmp) {
                        elem[ontype] = null;
                      }

                      // Prevent re-triggering of the same event, since we already bubbled it above
                      jQuery.event.triggered = type;
                      elem[type]();
                      jQuery.event.triggered = undefined;

                      if (tmp) {
                        elem[ontype] = tmp;
                      }
                    }
                  }
                }

                return event.result;
              },

              // Piggyback on a donor event to simulate a different one
              // Used only for `focus(in | out)` events
              simulate: function simulate(type, elem, event) {
                var e = jQuery.extend(new jQuery.Event(), event, {
                  type: type,
                  isSimulated: true,
                });

                jQuery.event.trigger(e, null, elem);
              },
            });

            jQuery.fn.extend({
              trigger: function trigger(type, data) {
                return this.each(function () {
                  jQuery.event.trigger(type, data, this);
                });
              },
              triggerHandler: function triggerHandler(type, data) {
                var elem = this[0];
                if (elem) {
                  return jQuery.event.trigger(type, data, elem, true);
                }
              },
            });

            jQuery.each(
              (
                "blur focus focusin focusout load resize scroll unload click dblclick " +
                "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                "change select submit keydown keypress keyup error contextmenu"
              ).split(" "),
              function (i, name) {
                // Handle event binding
                jQuery.fn[name] = function (data, fn) {
                  return arguments.length > 0
                    ? this.on(name, null, data, fn)
                    : this.trigger(name);
                };
              }
            );

            jQuery.fn.extend({
              hover: function hover(fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
              },
            });

            support.focusin = "onfocusin" in window;

            // Support: Firefox
            // Firefox doesn't have focus(in | out) events
            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
            //
            // Support: Chrome, Safari
            // focus(in | out) events fire after focus & blur events,
            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
            // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
            if (!support.focusin) {
              jQuery.each(
                { focus: "focusin", blur: "focusout" },
                function (orig, fix) {
                  // Attach a single capturing handler on the document while someone wants focusin/focusout
                  var handler = function handler(event) {
                    jQuery.event.simulate(
                      fix,
                      event.target,
                      jQuery.event.fix(event)
                    );
                  };

                  jQuery.event.special[fix] = {
                    setup: function setup() {
                      var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix);

                      if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                      }
                      dataPriv.access(doc, fix, (attaches || 0) + 1);
                    },
                    teardown: function teardown() {
                      var doc = this.ownerDocument || this,
                        attaches = dataPriv.access(doc, fix) - 1;

                      if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                      } else {
                        dataPriv.access(doc, fix, attaches);
                      }
                    },
                  };
                }
              );
            }
            var location = window.location;

            var nonce = jQuery.now();

            var rquery = /\?/;

            // Support: Android 2.3
            // Workaround failure to string-cast null input
            jQuery.parseJSON = function (data) {
              return JSON.parse(data + "");
            };

            // Cross-browser xml parsing
            jQuery.parseXML = function (data) {
              var xml;
              if (!data || typeof data !== "string") {
                return null;
              }

              // Support: IE9
              try {
                xml = new window.DOMParser().parseFromString(data, "text/xml");
              } catch (e) {
                xml = undefined;
              }

              if (!xml || xml.getElementsByTagName("parsererror").length) {
                jQuery.error("Invalid XML: " + data);
              }
              return xml;
            };

            var rhash = /#.*$/,
              rts = /([?&])_=[^&]*/,
              rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
              // #7653, #8125, #8152: local protocol detection
              rlocalProtocol =
                /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
              rnoContent = /^(?:GET|HEAD)$/,
              rprotocol = /^\/\//,
              /* Prefilters
               * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
               * 2) These are called:
               *    - BEFORE asking for a transport
               *    - AFTER param serialization (s.data is a string if s.processData is true)
               * 3) key is the dataType
               * 4) the catchall symbol "*" can be used
               * 5) execution will start with transport dataType and THEN continue down to "*" if needed
               */
              prefilters = {},
              /* Transports bindings
               * 1) key is the dataType
               * 2) the catchall symbol "*" can be used
               * 3) selection will start with transport dataType and THEN go to "*" if needed
               */
              transports = {},
              // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
              allTypes = "*/".concat("*"),
              // Anchor tag for parsing the document origin
              originAnchor = document.createElement("a");
            originAnchor.href = location.href;

            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports(structure) {
              // dataTypeExpression is optional and defaults to "*"
              return function (dataTypeExpression, func) {
                if (typeof dataTypeExpression !== "string") {
                  func = dataTypeExpression;
                  dataTypeExpression = "*";
                }

                var dataType,
                  i = 0,
                  dataTypes =
                    dataTypeExpression.toLowerCase().match(rnotwhite) || [];

                if (jQuery.isFunction(func)) {
                  // For each dataType in the dataTypeExpression
                  while ((dataType = dataTypes[i++])) {
                    // Prepend if requested
                    if (dataType[0] === "+") {
                      dataType = dataType.slice(1) || "*";
                      (structure[dataType] = structure[dataType] || []).unshift(
                        func
                      );

                      // Otherwise append
                    } else {
                      (structure[dataType] = structure[dataType] || []).push(
                        func
                      );
                    }
                  }
                }
              };
            }

            // Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports(
              structure,
              options,
              originalOptions,
              jqXHR
            ) {
              var inspected = {},
                seekingTransport = structure === transports;

              function inspect(dataType) {
                var selected;
                inspected[dataType] = true;
                jQuery.each(
                  structure[dataType] || [],
                  function (_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(
                      options,
                      originalOptions,
                      jqXHR
                    );
                    if (
                      typeof dataTypeOrTransport === "string" &&
                      !seekingTransport &&
                      !inspected[dataTypeOrTransport]
                    ) {
                      options.dataTypes.unshift(dataTypeOrTransport);
                      inspect(dataTypeOrTransport);
                      return false;
                    } else if (seekingTransport) {
                      return !(selected = dataTypeOrTransport);
                    }
                  }
                );
                return selected;
              }

              return (
                inspect(options.dataTypes[0]) ||
                (!inspected["*"] && inspect("*"))
              );
            }

            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ajaxExtend(target, src) {
              var key,
                deep,
                flatOptions = jQuery.ajaxSettings.flatOptions || {};

              for (key in src) {
                if (src[key] !== undefined) {
                  (flatOptions[key] ? target : deep || (deep = {}))[key] =
                    src[key];
                }
              }
              if (deep) {
                jQuery.extend(true, target, deep);
              }

              return target;
            }

            /* Handles responses to an ajax request:
             * - finds the right dataType (mediates between content-type and expected dataType)
             * - returns the corresponding response
             */
            function ajaxHandleResponses(s, jqXHR, responses) {
              var ct,
                type,
                finalDataType,
                firstDataType,
                contents = s.contents,
                dataTypes = s.dataTypes;

              // Remove auto dataType and get content-type in the process
              while (dataTypes[0] === "*") {
                dataTypes.shift();
                if (ct === undefined) {
                  ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                }
              }

              // Check if we're dealing with a known content-type
              if (ct) {
                for (type in contents) {
                  if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                  }
                }
              }

              // Check to see if we have a response for the expected dataType
              if (dataTypes[0] in responses) {
                finalDataType = dataTypes[0];
              } else {
                // Try convertible dataTypes
                for (type in responses) {
                  if (
                    !dataTypes[0] ||
                    s.converters[type + " " + dataTypes[0]]
                  ) {
                    finalDataType = type;
                    break;
                  }
                  if (!firstDataType) {
                    firstDataType = type;
                  }
                }

                // Or just use first one
                finalDataType = finalDataType || firstDataType;
              }

              // If we found a dataType
              // We add the dataType to the list if needed
              // and return the corresponding response
              if (finalDataType) {
                if (finalDataType !== dataTypes[0]) {
                  dataTypes.unshift(finalDataType);
                }
                return responses[finalDataType];
              }
            }

            /* Chain conversions given the request and the original response
             * Also sets the responseXXX fields on the jqXHR instance
             */
            function ajaxConvert(s, response, jqXHR, isSuccess) {
              var conv2,
                current,
                conv,
                tmp,
                prev,
                converters = {},
                // Work with a copy of dataTypes in case we need to modify it for conversion
                dataTypes = s.dataTypes.slice();

              // Create converters map with lowercased keys
              if (dataTypes[1]) {
                for (conv in s.converters) {
                  converters[conv.toLowerCase()] = s.converters[conv];
                }
              }

              current = dataTypes.shift();

              // Convert to each sequential dataType
              while (current) {
                if (s.responseFields[current]) {
                  jqXHR[s.responseFields[current]] = response;
                }

                // Apply the dataFilter if provided
                if (!prev && isSuccess && s.dataFilter) {
                  response = s.dataFilter(response, s.dataType);
                }

                prev = current;
                current = dataTypes.shift();

                if (current) {
                  // There's only work to do if current dataType is non-auto
                  if (current === "*") {
                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                  } else if (prev !== "*" && prev !== current) {
                    // Seek a direct converter
                    conv =
                      converters[prev + " " + current] ||
                      converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                      for (conv2 in converters) {
                        // If conv2 outputs current
                        tmp = conv2.split(" ");
                        if (tmp[1] === current) {
                          // If prev can be converted to accepted input
                          conv =
                            converters[prev + " " + tmp[0]] ||
                            converters["* " + tmp[0]];
                          if (conv) {
                            // Condense equivalence converters
                            if (conv === true) {
                              conv = converters[conv2];

                              // Otherwise, insert the intermediate dataType
                            } else if (converters[conv2] !== true) {
                              current = tmp[0];
                              dataTypes.unshift(tmp[1]);
                            }
                            break;
                          }
                        }
                      }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {
                      // Unless errors are allowed to bubble, catch and return them
                      if (conv && s.throws) {
                        response = conv(response);
                      } else {
                        try {
                          response = conv(response);
                        } catch (e) {
                          return {
                            state: "parsererror",
                            error: conv
                              ? e
                              : "No conversion from " + prev + " to " + current,
                          };
                        }
                      }
                    }
                  }
                }
              }

              return { state: "success", data: response };
            }

            jQuery.extend({
              // Counter for holding the number of active queries
              active: 0,

              // Last-Modified header cache for next request
              lastModified: {},
              etag: {},

              ajaxSettings: {
                url: location.href,
                type: "GET",
                isLocal: rlocalProtocol.test(location.protocol),
                global: true,
                processData: true,
                async: true,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                /*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

                accepts: {
                  "*": allTypes,
                  text: "text/plain",
                  html: "text/html",
                  xml: "application/xml, text/xml",
                  json: "application/json, text/javascript",
                },

                contents: {
                  xml: /\bxml\b/,
                  html: /\bhtml/,
                  json: /\bjson\b/,
                },

                responseFields: {
                  xml: "responseXML",
                  text: "responseText",
                  json: "responseJSON",
                },

                // Data converters
                // Keys separate source (or catchall "*") and destination types with a single space
                converters: {
                  // Convert anything to text
                  "* text": String,

                  // Text to html (true = no transformation)
                  "text html": true,

                  // Evaluate text as a json expression
                  "text json": jQuery.parseJSON,

                  // Parse text as xml
                  "text xml": jQuery.parseXML,
                },

                // For options that shouldn't be deep extended:
                // you can add your own custom options here if
                // and when you create one that shouldn't be
                // deep extended (see ajaxExtend)
                flatOptions: {
                  url: true,
                  context: true,
                },
              },

              // Creates a full fledged settings object into target
              // with both ajaxSettings and settings fields.
              // If target is omitted, writes into ajaxSettings.
              ajaxSetup: function ajaxSetup(target, settings) {
                return settings
                  ? // Building a settings object
                    ajaxExtend(
                      ajaxExtend(target, jQuery.ajaxSettings),
                      settings
                    )
                  : // Extending ajaxSettings
                    ajaxExtend(jQuery.ajaxSettings, target);
              },

              ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
              ajaxTransport: addToPrefiltersOrTransports(transports),

              // Main method
              ajax: function ajax(url, options) {
                // If url is an object, simulate pre-1.5 signature
                if (
                  (typeof url === "undefined" ? "undefined" : _typeof(url)) ===
                  "object"
                ) {
                  options = url;
                  url = undefined;
                }

                // Force options to be an object
                options = options || {};

                var transport,
                  // URL without anti-cache param
                  cacheURL,
                  // Response headers
                  responseHeadersString,
                  responseHeaders,
                  // timeout handle
                  timeoutTimer,
                  // Url cleanup var
                  urlAnchor,
                  // To know if global events are to be dispatched
                  fireGlobals,
                  // Loop variable
                  i,
                  // Create the final options object
                  s = jQuery.ajaxSetup({}, options),
                  // Callbacks context
                  callbackContext = s.context || s,
                  // Context for global events is callbackContext if it is a DOM node or jQuery collection
                  globalEventContext =
                    s.context &&
                    (callbackContext.nodeType || callbackContext.jquery)
                      ? jQuery(callbackContext)
                      : jQuery.event,
                  // Deferreds
                  deferred = jQuery.Deferred(),
                  completeDeferred = jQuery.Callbacks("once memory"),
                  // Status-dependent callbacks
                  _statusCode = s.statusCode || {},
                  // Headers (they are sent all at once)
                  requestHeaders = {},
                  requestHeadersNames = {},
                  // The jqXHR state
                  state = 0,
                  // Default abort message
                  strAbort = "canceled",
                  // Fake xhr
                  jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function getResponseHeader(key) {
                      var match;
                      if (state === 2) {
                        if (!responseHeaders) {
                          responseHeaders = {};
                          while (
                            (match = rheaders.exec(responseHeadersString))
                          ) {
                            responseHeaders[match[1].toLowerCase()] = match[2];
                          }
                        }
                        match = responseHeaders[key.toLowerCase()];
                      }
                      return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function getAllResponseHeaders() {
                      return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function setRequestHeader(name, value) {
                      var lname = name.toLowerCase();
                      if (!state) {
                        name = requestHeadersNames[lname] =
                          requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                      }
                      return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function overrideMimeType(type) {
                      if (!state) {
                        s.mimeType = type;
                      }
                      return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function statusCode(map) {
                      var code;
                      if (map) {
                        if (state < 2) {
                          for (code in map) {
                            // Lazy-add the new callback in a way that preserves old ones
                            _statusCode[code] = [_statusCode[code], map[code]];
                          }
                        } else {
                          // Execute the appropriate callbacks
                          jqXHR.always(map[jqXHR.status]);
                        }
                      }
                      return this;
                    },

                    // Cancel the request
                    abort: function abort(statusText) {
                      var finalText = statusText || strAbort;
                      if (transport) {
                        transport.abort(finalText);
                      }
                      done(0, finalText);
                      return this;
                    },
                  };

                // Attach deferreds
                deferred.promise(jqXHR).complete = completeDeferred.add;
                jqXHR.success = jqXHR.done;
                jqXHR.error = jqXHR.fail;

                // Remove hash character (#7531: and string promotion)
                // Add protocol if not provided (prefilters might expect it)
                // Handle falsy url in the settings object (#10093: consistency with old signature)
                // We also use the url parameter if available
                s.url = ((url || s.url || location.href) + "")
                  .replace(rhash, "")
                  .replace(rprotocol, location.protocol + "//");

                // Alias method option to type as per ticket #12004
                s.type = options.method || options.type || s.method || s.type;

                // Extract dataTypes list
                s.dataTypes = jQuery
                  .trim(s.dataType || "*")
                  .toLowerCase()
                  .match(rnotwhite) || [""];

                // A cross-domain request is in order when the origin doesn't match the current origin.
                if (s.crossDomain == null) {
                  urlAnchor = document.createElement("a");

                  // Support: IE8-11+
                  // IE throws exception if url is malformed, e.g. http://example.com:80x/
                  try {
                    urlAnchor.href = s.url;

                    // Support: IE8-11+
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain =
                      originAnchor.protocol + "//" + originAnchor.host !==
                      urlAnchor.protocol + "//" + urlAnchor.host;
                  } catch (e) {
                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                  }
                }

                // Convert data if not already a string
                if (s.data && s.processData && typeof s.data !== "string") {
                  s.data = jQuery.param(s.data, s.traditional);
                }

                // Apply prefilters
                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                // If request was aborted inside a prefilter, stop there
                if (state === 2) {
                  return jqXHR;
                }

                // We can fire global events as of now if asked to
                // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                fireGlobals = jQuery.event && s.global;

                // Watch for a new set of requests
                if (fireGlobals && jQuery.active++ === 0) {
                  jQuery.event.trigger("ajaxStart");
                }

                // Uppercase the type
                s.type = s.type.toUpperCase();

                // Determine if request has content
                s.hasContent = !rnoContent.test(s.type);

                // Save the URL in case we're toying with the If-Modified-Since
                // and/or If-None-Match header later on
                cacheURL = s.url;

                // More options handling for requests with no content
                if (!s.hasContent) {
                  // If data is available, append data to url
                  if (s.data) {
                    cacheURL = s.url +=
                      (rquery.test(cacheURL) ? "&" : "?") + s.data;

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                  }

                  // Add anti-cache in url if needed
                  if (s.cache === false) {
                    s.url = rts.test(cacheURL)
                      ? // If there is already a '_' parameter, set its value
                        cacheURL.replace(rts, "$1_=" + nonce++)
                      : // Otherwise add one to the end
                        cacheURL +
                        (rquery.test(cacheURL) ? "&" : "?") +
                        "_=" +
                        nonce++;
                  }
                }

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if (s.ifModified) {
                  if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader(
                      "If-Modified-Since",
                      jQuery.lastModified[cacheURL]
                    );
                  }
                  if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader(
                      "If-None-Match",
                      jQuery.etag[cacheURL]
                    );
                  }
                }

                // Set the correct header, if data is being sent
                if (
                  (s.data && s.hasContent && s.contentType !== false) ||
                  options.contentType
                ) {
                  jqXHR.setRequestHeader("Content-Type", s.contentType);
                }

                // Set the Accepts header for the server, depending on the dataType
                jqXHR.setRequestHeader(
                  "Accept",
                  s.dataTypes[0] && s.accepts[s.dataTypes[0]]
                    ? s.accepts[s.dataTypes[0]] +
                        (s.dataTypes[0] !== "*"
                          ? ", " + allTypes + "; q=0.01"
                          : "")
                    : s.accepts["*"]
                );

                // Check for headers option
                for (i in s.headers) {
                  jqXHR.setRequestHeader(i, s.headers[i]);
                }

                // Allow custom headers/mimetypes and early abort
                if (
                  s.beforeSend &&
                  (s.beforeSend.call(callbackContext, jqXHR, s) === false ||
                    state === 2)
                ) {
                  // Abort if not done already and return
                  return jqXHR.abort();
                }

                // Aborting is no longer a cancellation
                strAbort = "abort";

                // Install callbacks on deferreds
                for (i in { success: 1, error: 1, complete: 1 }) {
                  jqXHR[i](s[i]);
                }

                // Get transport
                transport = inspectPrefiltersOrTransports(
                  transports,
                  s,
                  options,
                  jqXHR
                );

                // If no transport, we auto-abort
                if (!transport) {
                  done(-1, "No Transport");
                } else {
                  jqXHR.readyState = 1;

                  // Send global event
                  if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                  }

                  // If request was aborted inside ajaxSend, stop there
                  if (state === 2) {
                    return jqXHR;
                  }

                  // Timeout
                  if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                      jqXHR.abort("timeout");
                    }, s.timeout);
                  }

                  try {
                    state = 1;
                    transport.send(requestHeaders, done);
                  } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                      done(-1, e);

                      // Simply rethrow otherwise
                    } else {
                      throw e;
                    }
                  }
                }

                // Callback for when everything is done
                function done(status, nativeStatusText, responses, headers) {
                  var isSuccess,
                    success,
                    error,
                    response,
                    modified,
                    statusText = nativeStatusText;

                  // Called once
                  if (state === 2) {
                    return;
                  }

                  // State is "done" now
                  state = 2;

                  // Clear timeout if it exists
                  if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                  }

                  // Dereference transport for early garbage collection
                  // (no matter how long the jqXHR object will be used)
                  transport = undefined;

                  // Cache response headers
                  responseHeadersString = headers || "";

                  // Set readyState
                  jqXHR.readyState = status > 0 ? 4 : 0;

                  // Determine if successful
                  isSuccess = (status >= 200 && status < 300) || status === 304;

                  // Get response data
                  if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                  }

                  // Convert no matter what (that way responseXXX fields are always set)
                  response = ajaxConvert(s, response, jqXHR, isSuccess);

                  // If successful, handle type chaining
                  if (isSuccess) {
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                      modified = jqXHR.getResponseHeader("Last-Modified");
                      if (modified) {
                        jQuery.lastModified[cacheURL] = modified;
                      }
                      modified = jqXHR.getResponseHeader("etag");
                      if (modified) {
                        jQuery.etag[cacheURL] = modified;
                      }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                      statusText = "nocontent";

                      // if not modified
                    } else if (status === 304) {
                      statusText = "notmodified";

                      // If we have data, let's convert it
                    } else {
                      statusText = response.state;
                      success = response.data;
                      error = response.error;
                      isSuccess = !error;
                    }
                  } else {
                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                      statusText = "error";
                      if (status < 0) {
                        status = 0;
                      }
                    }
                  }

                  // Set data for the fake xhr object
                  jqXHR.status = status;
                  jqXHR.statusText = (nativeStatusText || statusText) + "";

                  // Success/Error
                  if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                      success,
                      statusText,
                      jqXHR,
                    ]);
                  } else {
                    deferred.rejectWith(callbackContext, [
                      jqXHR,
                      statusText,
                      error,
                    ]);
                  }

                  // Status-dependent callbacks
                  jqXHR.statusCode(_statusCode);
                  _statusCode = undefined;

                  if (fireGlobals) {
                    globalEventContext.trigger(
                      isSuccess ? "ajaxSuccess" : "ajaxError",
                      [jqXHR, s, isSuccess ? success : error]
                    );
                  }

                  // Complete
                  completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText,
                  ]);

                  if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                    // Handle the global AJAX counter
                    if (!--jQuery.active) {
                      jQuery.event.trigger("ajaxStop");
                    }
                  }
                }

                return jqXHR;
              },

              getJSON: function getJSON(url, data, callback) {
                return jQuery.get(url, data, callback, "json");
              },

              getScript: function getScript(url, callback) {
                return jQuery.get(url, undefined, callback, "script");
              },
            });

            jQuery.each(["get", "post"], function (i, method) {
              jQuery[method] = function (url, data, callback, type) {
                // Shift arguments if data argument was omitted
                if (jQuery.isFunction(data)) {
                  type = type || callback;
                  callback = data;
                  data = undefined;
                }

                // The url can be an options object (which then must have .url)
                return jQuery.ajax(
                  jQuery.extend(
                    {
                      url: url,
                      type: method,
                      dataType: type,
                      data: data,
                      success: callback,
                    },
                    jQuery.isPlainObject(url) && url
                  )
                );
              };
            });

            jQuery._evalUrl = function (url) {
              return jQuery.ajax({
                url: url,

                // Make this explicit, since user can override this through ajaxSetup (#11264)
                type: "GET",
                dataType: "script",
                async: false,
                global: false,
                throws: true,
              });
            };

            jQuery.fn.extend({
              wrapAll: function wrapAll(html) {
                var wrap;

                if (jQuery.isFunction(html)) {
                  return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                  });
                }

                if (this[0]) {
                  // The elements to wrap the target around
                  wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                  if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                  }

                  wrap
                    .map(function () {
                      var elem = this;

                      while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                      }

                      return elem;
                    })
                    .append(this);
                }

                return this;
              },

              wrapInner: function wrapInner(html) {
                if (jQuery.isFunction(html)) {
                  return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                  });
                }

                return this.each(function () {
                  var self = jQuery(this),
                    contents = self.contents();

                  if (contents.length) {
                    contents.wrapAll(html);
                  } else {
                    self.append(html);
                  }
                });
              },

              wrap: function wrap(html) {
                var isFunction = jQuery.isFunction(html);

                return this.each(function (i) {
                  jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                });
              },

              unwrap: function unwrap() {
                return this.parent()
                  .each(function () {
                    if (!jQuery.nodeName(this, "body")) {
                      jQuery(this).replaceWith(this.childNodes);
                    }
                  })
                  .end();
              },
            });

            jQuery.expr.filters.hidden = function (elem) {
              return !jQuery.expr.filters.visible(elem);
            };
            jQuery.expr.filters.visible = function (elem) {
              // Support: Opera <= 12.12
              // Opera reports offsetWidths and offsetHeights less than zero on some elements
              // Use OR instead of AND as the element is not visible if either is true
              // See tickets #10406 and #13132
              return (
                elem.offsetWidth > 0 ||
                elem.offsetHeight > 0 ||
                elem.getClientRects().length > 0
              );
            };

            var r20 = /%20/g,
              rbracket = /\[\]$/,
              rCRLF = /\r?\n/g,
              rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
              rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams(prefix, obj, traditional, add) {
              var name;

              if (jQuery.isArray(obj)) {
                // Serialize array item.
                jQuery.each(obj, function (i, v) {
                  if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                  } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                      prefix +
                        "[" +
                        ((typeof v === "undefined"
                          ? "undefined"
                          : _typeof(v)) === "object" && v != null
                          ? i
                          : "") +
                        "]",
                      v,
                      traditional,
                      add
                    );
                  }
                });
              } else if (!traditional && jQuery.type(obj) === "object") {
                // Serialize object item.
                for (name in obj) {
                  buildParams(
                    prefix + "[" + name + "]",
                    obj[name],
                    traditional,
                    add
                  );
                }
              } else {
                // Serialize scalar item.
                add(prefix, obj);
              }
            }

            // Serialize an array of form elements or a set of
            // key/values into a query string
            jQuery.param = function (a, traditional) {
              var prefix,
                s = [],
                add = function add(key, value) {
                  // If value is a function, invoke it and return its value
                  value = jQuery.isFunction(value)
                    ? value()
                    : value == null
                    ? ""
                    : value;
                  s[s.length] =
                    encodeURIComponent(key) + "=" + encodeURIComponent(value);
                };

              // Set traditional to true for jQuery <= 1.3.2 behavior.
              if (traditional === undefined) {
                traditional =
                  jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
              }

              // If an array was passed in, assume that it is an array of form elements.
              if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
                // Serialize the form elements
                jQuery.each(a, function () {
                  add(this.name, this.value);
                });
              } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (prefix in a) {
                  buildParams(prefix, a[prefix], traditional, add);
                }
              }

              // Return the resulting serialization
              return s.join("&").replace(r20, "+");
            };

            jQuery.fn.extend({
              serialize: function serialize() {
                return jQuery.param(this.serializeArray());
              },
              serializeArray: function serializeArray() {
                return this.map(function () {
                  // Can add propHook for "elements" to filter or add form elements
                  var elements = jQuery.prop(this, "elements");
                  return elements ? jQuery.makeArray(elements) : this;
                })
                  .filter(function () {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return (
                      this.name &&
                      !jQuery(this).is(":disabled") &&
                      rsubmittable.test(this.nodeName) &&
                      !rsubmitterTypes.test(type) &&
                      (this.checked || !rcheckableType.test(type))
                    );
                  })
                  .map(function (i, elem) {
                    var val = jQuery(this).val();

                    return val == null
                      ? null
                      : jQuery.isArray(val)
                      ? jQuery.map(val, function (val) {
                          return {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n"),
                          };
                        })
                      : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                  })
                  .get();
              },
            });

            jQuery.ajaxSettings.xhr = function () {
              try {
                return new window.XMLHttpRequest();
              } catch (e) {}
            };

            var xhrSuccessStatus = {
                // File protocol always yields status code 0, assume 200
                0: 200,

                // Support: IE9
                // #1450: sometimes IE returns 1223 when it should be 204
                1223: 204,
              },
              xhrSupported = jQuery.ajaxSettings.xhr();

            support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
            support.ajax = xhrSupported = !!xhrSupported;

            jQuery.ajaxTransport(function (options) {
              var _callback, errorCallback;

              // Cross domain only allowed if supported through XMLHttpRequest
              if (support.cors || (xhrSupported && !options.crossDomain)) {
                return {
                  send: function send(headers, complete) {
                    var i,
                      xhr = options.xhr();

                    xhr.open(
                      options.type,
                      options.url,
                      options.async,
                      options.username,
                      options.password
                    );

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                      for (i in options.xhrFields) {
                        xhr[i] = options.xhrFields[i];
                      }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                      xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                      headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                      xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    _callback = function callback(type) {
                      return function () {
                        if (_callback) {
                          _callback =
                            errorCallback =
                            xhr.onload =
                            xhr.onerror =
                            xhr.onabort =
                            xhr.onreadystatechange =
                              null;

                          if (type === "abort") {
                            xhr.abort();
                          } else if (type === "error") {
                            // Support: IE9
                            // On a manual native abort, IE9 throws
                            // errors on any property access that is not readyState
                            if (typeof xhr.status !== "number") {
                              complete(0, "error");
                            } else {
                              complete(
                                // File: protocol always yields status 0; see #8605, #14207
                                xhr.status,
                                xhr.statusText
                              );
                            }
                          } else {
                            complete(
                              xhrSuccessStatus[xhr.status] || xhr.status,
                              xhr.statusText,

                              // Support: IE9 only
                              // IE9 has no XHR2 but throws on binary (trac-11426)
                              // For XHR2 non-text, let the caller handle it (gh-2498)
                              (xhr.responseType || "text") !== "text" ||
                                typeof xhr.responseText !== "string"
                                ? { binary: xhr.response }
                                : { text: xhr.responseText },
                              xhr.getAllResponseHeaders()
                            );
                          }
                        }
                      };
                    };

                    // Listen to events
                    xhr.onload = _callback();
                    errorCallback = xhr.onerror = _callback("error");

                    // Support: IE9
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if (xhr.onabort !== undefined) {
                      xhr.onabort = errorCallback;
                    } else {
                      xhr.onreadystatechange = function () {
                        // Check readyState before timeout as it changes
                        if (xhr.readyState === 4) {
                          // Allow onerror to be called first,
                          // but that will not handle a native abort
                          // Also, save errorCallback to a variable
                          // as xhr.onerror cannot be accessed
                          window.setTimeout(function () {
                            if (_callback) {
                              errorCallback();
                            }
                          });
                        }
                      };
                    }

                    // Create the abort callback
                    _callback = _callback("abort");

                    try {
                      // Do send the request (this may raise an exception)
                      xhr.send((options.hasContent && options.data) || null);
                    } catch (e) {
                      // #14683: Only rethrow if this hasn't been notified as an error yet
                      if (_callback) {
                        throw e;
                      }
                    }
                  },

                  abort: function abort() {
                    if (_callback) {
                      _callback();
                    }
                  },
                };
              }
            });

            // Install script dataType
            jQuery.ajaxSetup({
              accepts: {
                script:
                  "text/javascript, application/javascript, " +
                  "application/ecmascript, application/x-ecmascript",
              },
              contents: {
                script: /\b(?:java|ecma)script\b/,
              },
              converters: {
                "text script": function textScript(text) {
                  jQuery.globalEval(text);
                  return text;
                },
              },
            });

            // Handle cache's special case and crossDomain
            jQuery.ajaxPrefilter("script", function (s) {
              if (s.cache === undefined) {
                s.cache = false;
              }
              if (s.crossDomain) {
                s.type = "GET";
              }
            });

            // Bind script tag hack transport
            jQuery.ajaxTransport("script", function (s) {
              // This transport only deals with cross domain requests
              if (s.crossDomain) {
                var script, _callback2;
                return {
                  send: function send(_, complete) {
                    script = jQuery("<script>")
                      .prop({
                        charset: s.scriptCharset,
                        src: s.url,
                      })
                      .on(
                        "load error",
                        (_callback2 = function callback(evt) {
                          script.remove();
                          _callback2 = null;
                          if (evt) {
                            complete(
                              evt.type === "error" ? 404 : 200,
                              evt.type
                            );
                          }
                        })
                      );

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                  },
                  abort: function abort() {
                    if (_callback2) {
                      _callback2();
                    }
                  },
                };
              }
            });

            var oldCallbacks = [],
              rjsonp = /(=)\?(?=&|$)|\?\?/;

            // Default jsonp settings
            jQuery.ajaxSetup({
              jsonp: "callback",
              jsonpCallback: function jsonpCallback() {
                var callback =
                  oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                this[callback] = true;
                return callback;
              },
            });

            // Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter(
              "json jsonp",
              function (s, originalSettings, jqXHR) {
                var callbackName,
                  overwritten,
                  responseContainer,
                  jsonProp =
                    s.jsonp !== false &&
                    (rjsonp.test(s.url)
                      ? "url"
                      : typeof s.data === "string" &&
                        (s.contentType || "").indexOf(
                          "application/x-www-form-urlencoded"
                        ) === 0 &&
                        rjsonp.test(s.data) &&
                        "data");

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (jsonProp || s.dataTypes[0] === "jsonp") {
                  // Get callback name, remembering preexisting value associated with it
                  callbackName = s.jsonpCallback = jQuery.isFunction(
                    s.jsonpCallback
                  )
                    ? s.jsonpCallback()
                    : s.jsonpCallback;

                  // Insert callback into url or form data
                  if (jsonProp) {
                    s[jsonProp] = s[jsonProp].replace(
                      rjsonp,
                      "$1" + callbackName
                    );
                  } else if (s.jsonp !== false) {
                    s.url +=
                      (rquery.test(s.url) ? "&" : "?") +
                      s.jsonp +
                      "=" +
                      callbackName;
                  }

                  // Use data converter to retrieve json after script execution
                  s.converters["script json"] = function () {
                    if (!responseContainer) {
                      jQuery.error(callbackName + " was not called");
                    }
                    return responseContainer[0];
                  };

                  // Force json dataType
                  s.dataTypes[0] = "json";

                  // Install callback
                  overwritten = window[callbackName];
                  window[callbackName] = function () {
                    responseContainer = arguments;
                  };

                  // Clean-up function (fires after converters)
                  jqXHR.always(function () {
                    // If previous value didn't exist - remove it
                    if (overwritten === undefined) {
                      jQuery(window).removeProp(callbackName);

                      // Otherwise restore preexisting value
                    } else {
                      window[callbackName] = overwritten;
                    }

                    // Save back as free
                    if (s[callbackName]) {
                      // Make sure that re-using the options doesn't screw things around
                      s.jsonpCallback = originalSettings.jsonpCallback;

                      // Save the callback name for future use
                      oldCallbacks.push(callbackName);
                    }

                    // Call if it was a function and we have a response
                    if (responseContainer && jQuery.isFunction(overwritten)) {
                      overwritten(responseContainer[0]);
                    }

                    responseContainer = overwritten = undefined;
                  });

                  // Delegate to script
                  return "script";
                }
              }
            );

            // Argument "data" should be string of html
            // context (optional): If specified, the fragment will be created in this context,
            // defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function (data, context, keepScripts) {
              if (!data || typeof data !== "string") {
                return null;
              }
              if (typeof context === "boolean") {
                keepScripts = context;
                context = false;
              }
              context = context || document;

              var parsed = rsingleTag.exec(data),
                scripts = !keepScripts && [];

              // Single tag
              if (parsed) {
                return [context.createElement(parsed[1])];
              }

              parsed = buildFragment([data], context, scripts);

              if (scripts && scripts.length) {
                jQuery(scripts).remove();
              }

              return jQuery.merge([], parsed.childNodes);
            };

            // Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function (url, params, callback) {
              if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);
              }

              var selector,
                type,
                response,
                self = this,
                off = url.indexOf(" ");

              if (off > -1) {
                selector = jQuery.trim(url.slice(off));
                url = url.slice(0, off);
              }

              // If it's a function
              if (jQuery.isFunction(params)) {
                // We assume that it's the callback
                callback = params;
                params = undefined;

                // Otherwise, build a param string
              } else if (
                params &&
                (typeof params === "undefined"
                  ? "undefined"
                  : _typeof(params)) === "object"
              ) {
                type = "POST";
              }

              // If we have elements to modify, make the request
              if (self.length > 0) {
                jQuery
                  .ajax({
                    url: url,

                    // If "type" variable is undefined, then "GET" method will be used.
                    // Make value of this field explicit since
                    // user can override it through ajaxSetup method
                    type: type || "GET",
                    dataType: "html",
                    data: params,
                  })
                  .done(function (responseText) {
                    // Save response for use in complete callback
                    response = arguments;

                    self.html(
                      selector
                        ? // If a selector was specified, locate the right elements in a dummy div
                          // Exclude scripts to avoid IE 'Permission Denied' errors
                          jQuery("<div>")
                            .append(jQuery.parseHTML(responseText))
                            .find(selector)
                        : // Otherwise use the full result
                          responseText
                    );

                    // If the request succeeds, this function gets "data", "status", "jqXHR"
                    // but they are ignored because response was set above.
                    // If it fails, this function gets "jqXHR", "status", "error"
                  })
                  .always(
                    callback &&
                      function (jqXHR, status) {
                        self.each(function () {
                          callback.apply(
                            this,
                            response || [jqXHR.responseText, status, jqXHR]
                          );
                        });
                      }
                  );
              }

              return this;
            };

            // Attach a bunch of functions for handling common AJAX events
            jQuery.each(
              [
                "ajaxStart",
                "ajaxStop",
                "ajaxComplete",
                "ajaxError",
                "ajaxSuccess",
                "ajaxSend",
              ],
              function (i, type) {
                jQuery.fn[type] = function (fn) {
                  return this.on(type, fn);
                };
              }
            );

            jQuery.expr.filters.animated = function (elem) {
              return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
              }).length;
            };

            /**
             * Gets a window from an element
             */
            function getWindow(elem) {
              return jQuery.isWindow(elem)
                ? elem
                : elem.nodeType === 9 && elem.defaultView;
            }

            jQuery.offset = {
              setOffset: function setOffset(elem, options, i) {
                var curPosition,
                  curLeft,
                  curCSSTop,
                  curTop,
                  curOffset,
                  curCSSLeft,
                  calculatePosition,
                  position = jQuery.css(elem, "position"),
                  curElem = jQuery(elem),
                  props = {};

                // Set position first, in-case top/left are set even on static elem
                if (position === "static") {
                  elem.style.position = "relative";
                }

                curOffset = curElem.offset();
                curCSSTop = jQuery.css(elem, "top");
                curCSSLeft = jQuery.css(elem, "left");
                calculatePosition =
                  (position === "absolute" || position === "fixed") &&
                  (curCSSTop + curCSSLeft).indexOf("auto") > -1;

                // Need to be able to calculate position if either
                // top or left is auto and position is either absolute or fixed
                if (calculatePosition) {
                  curPosition = curElem.position();
                  curTop = curPosition.top;
                  curLeft = curPosition.left;
                } else {
                  curTop = parseFloat(curCSSTop) || 0;
                  curLeft = parseFloat(curCSSLeft) || 0;
                }

                if (jQuery.isFunction(options)) {
                  // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                  options = options.call(elem, i, jQuery.extend({}, curOffset));
                }

                if (options.top != null) {
                  props.top = options.top - curOffset.top + curTop;
                }
                if (options.left != null) {
                  props.left = options.left - curOffset.left + curLeft;
                }

                if ("using" in options) {
                  options.using.call(elem, props);
                } else {
                  curElem.css(props);
                }
              },
            };

            jQuery.fn.extend({
              offset: function offset(options) {
                if (arguments.length) {
                  return options === undefined
                    ? this
                    : this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i);
                      });
                }

                var docElem,
                  win,
                  elem = this[0],
                  box = { top: 0, left: 0 },
                  doc = elem && elem.ownerDocument;

                if (!doc) {
                  return;
                }

                docElem = doc.documentElement;

                // Make sure it's not a disconnected DOM node
                if (!jQuery.contains(docElem, elem)) {
                  return box;
                }

                box = elem.getBoundingClientRect();
                win = getWindow(doc);
                return {
                  top: box.top + win.pageYOffset - docElem.clientTop,
                  left: box.left + win.pageXOffset - docElem.clientLeft,
                };
              },

              position: function position() {
                if (!this[0]) {
                  return;
                }

                var offsetParent,
                  offset,
                  elem = this[0],
                  parentOffset = { top: 0, left: 0 };

                // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                // because it is its only offset parent
                if (jQuery.css(elem, "position") === "fixed") {
                  // Assume getBoundingClientRect is there when computed position is fixed
                  offset = elem.getBoundingClientRect();
                } else {
                  // Get *real* offsetParent
                  offsetParent = this.offsetParent();

                  // Get correct offsets
                  offset = this.offset();
                  if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                  }

                  // Add offsetParent borders
                  parentOffset.top += jQuery.css(
                    offsetParent[0],
                    "borderTopWidth",
                    true
                  );
                  parentOffset.left += jQuery.css(
                    offsetParent[0],
                    "borderLeftWidth",
                    true
                  );
                }

                // Subtract parent offsets and element margins
                return {
                  top:
                    offset.top -
                    parentOffset.top -
                    jQuery.css(elem, "marginTop", true),
                  left:
                    offset.left -
                    parentOffset.left -
                    jQuery.css(elem, "marginLeft", true),
                };
              },

              // This method will return documentElement in the following cases:
              // 1) For the element inside the iframe without offsetParent, this method will return
              //    documentElement of the parent window
              // 2) For the hidden or detached element
              // 3) For body or html element, i.e. in case of the html node - it will return itself
              //
              // but those exceptions were never presented as a real life use-cases
              // and might be considered as more preferable results.
              //
              // This logic, however, is not guaranteed and can change at any point in the future
              offsetParent: function offsetParent() {
                return this.map(function () {
                  var offsetParent = this.offsetParent;

                  while (
                    offsetParent &&
                    jQuery.css(offsetParent, "position") === "static"
                  ) {
                    offsetParent = offsetParent.offsetParent;
                  }

                  return offsetParent || documentElement;
                });
              },
            });

            // Create scrollLeft and scrollTop methods
            jQuery.each(
              { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
              function (method, prop) {
                var top = "pageYOffset" === prop;

                jQuery.fn[method] = function (val) {
                  return access(
                    this,
                    function (elem, method, val) {
                      var win = getWindow(elem);

                      if (val === undefined) {
                        return win ? win[prop] : elem[method];
                      }

                      if (win) {
                        win.scrollTo(
                          !top ? val : win.pageXOffset,
                          top ? val : win.pageYOffset
                        );
                      } else {
                        elem[method] = val;
                      }
                    },
                    method,
                    val,
                    arguments.length
                  );
                };
              }
            );

            // Support: Safari<7-8+, Chrome<37-44+
            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
            // getComputedStyle returns percent when specified for top/left/bottom/right;
            // rather than make the css module depend on the offset module, just check for it here
            jQuery.each(["top", "left"], function (i, prop) {
              jQuery.cssHooks[prop] = addGetHookIf(
                support.pixelPosition,
                function (elem, computed) {
                  if (computed) {
                    computed = curCSS(elem, prop);

                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test(computed)
                      ? jQuery(elem).position()[prop] + "px"
                      : computed;
                  }
                }
              );
            });

            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each(
              { Height: "height", Width: "width" },
              function (name, type) {
                jQuery.each(
                  {
                    padding: "inner" + name,
                    content: type,
                    "": "outer" + name,
                  },
                  function (defaultExtra, funcName) {
                    // Margin is only for outerHeight, outerWidth
                    jQuery.fn[funcName] = function (margin, value) {
                      var chainable =
                          arguments.length &&
                          (defaultExtra || typeof margin !== "boolean"),
                        extra =
                          defaultExtra ||
                          (margin === true || value === true
                            ? "margin"
                            : "border");

                      return access(
                        this,
                        function (elem, type, value) {
                          var doc;

                          if (jQuery.isWindow(elem)) {
                            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                            // isn't a whole lot we can do. See pull request at this URL for discussion:
                            // https://github.com/jquery/jquery/pull/764
                            return elem.document.documentElement[
                              "client" + name
                            ];
                          }

                          // Get document width or height
                          if (elem.nodeType === 9) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(
                              elem.body["scroll" + name],
                              doc["scroll" + name],
                              elem.body["offset" + name],
                              doc["offset" + name],
                              doc["client" + name]
                            );
                          }

                          return value === undefined
                            ? // Get width or height on the element, requesting but not forcing parseFloat
                              jQuery.css(elem, type, extra)
                            : // Set width or height on the element
                              jQuery.style(elem, type, value, extra);
                        },
                        type,
                        chainable ? margin : undefined,
                        chainable,
                        null
                      );
                    };
                  }
                );
              }
            );

            jQuery.fn.extend({
              bind: function bind(types, data, fn) {
                return this.on(types, null, data, fn);
              },
              unbind: function unbind(types, fn) {
                return this.off(types, null, fn);
              },

              delegate: function delegate(selector, types, data, fn) {
                return this.on(types, selector, data, fn);
              },
              undelegate: function undelegate(selector, types, fn) {
                // ( namespace ) or ( selector, types [, fn] )
                return arguments.length === 1
                  ? this.off(selector, "**")
                  : this.off(types, selector || "**", fn);
              },
              size: function size() {
                return this.length;
              },
            });

            jQuery.fn.andSelf = jQuery.fn.addBack;

            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.

            // Note that for maximum portability, libraries that are not jQuery should
            // declare themselves as anonymous modules, and avoid setting a global if an
            // AMD loader is present. jQuery is a special case. For more information, see
            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

            if (true) {
              !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
              (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return jQuery;
              }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }

            var // Map over jQuery in case of overwrite
              _jQuery = window.jQuery,
              // Map over the $ in case of overwrite
              _$ = window.$;

            jQuery.noConflict = function (deep) {
              if (window.$ === jQuery) {
                window.$ = _$;
              }

              if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery;
              }

              return jQuery;
            };

            // Expose jQuery and $ identifiers, even in AMD
            // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if (!noGlobal) {
              window.jQuery = window.$ = jQuery;
            }

            return jQuery;
          }
        );
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(112)(module));

      /***/
    },

    /***/ 83: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      /**
       * Module dependencies (polyfills).
       * @private
       */

      __webpack_require__(84);
      __webpack_require__(102);

      /**
       * Module dependencies (components).
       * @private
       */
      var header = __webpack_require__(73);
      var requestEstimatePopup = __webpack_require__(16);
      var nav = __webpack_require__(33);

      /**
       * Module dependencies (utils).
       * @private
       */
      var support = __webpack_require__(14);
      var scrollBlocker = __webpack_require__(10);
      __webpack_require__(109);

      __webpack_require__(110);
      __webpack_require__(111);

      /**
       * @private
       */
      var DOM = {};

      /**
       * @private
       */
      function setDOMiOS() {
        DOM.body = document.body;
        DOM.popupWrapper = DOM.body.querySelector(".js-popup-wrapper");
        DOM.bodyWrapper = DOM.body.querySelector(".js-body-wrapper");
      }

      module.exports = {
        init: function init() {
          header.init();

          requestEstimatePopup.init();
          requestEstimatePopup.on("beforeShow", function () {
            support.isiOS() && setDOMiOS();
            if (support.isiOS()) {
              DOM.windowPosition =
                document.documentElement.scrollTop || document.body.scrollTop;
            }
          });

          requestEstimatePopup.on("beforeHide", function () {
            //        ,  noscroll   , .       toggle "noscroll"
            if (!nav.isOpen()) {
              scrollBlocker.scrollOn();
            }
            if (support.isiOS()) {
              window.scroll(0, DOM.windowPosition);
            }
          });
        },
      };

      /***/
    },

    /***/ 84: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true,
      });

      var _defineProperty = __webpack_require__(85);

      var _defineProperty2 = _interopRequireDefault(_defineProperty);

      var _getOwnPropertyDescriptor = __webpack_require__(93);

      var _getOwnPropertyDescriptor2 = _interopRequireDefault(
        _getOwnPropertyDescriptor
      );

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /* eslint-env browser */

      //
      // element-dataset 2.2.6
      //
      // element-dataset is released under the terms of the BSD-3-Clause license.
      // (c) 2015 - 2017 Mark Milstein <mark@epiloque.com>
      //
      // For all details and documentation: https://github.com/epiloque/element-dataset
      //

      function elementDatasetPolyfill() {
        if (
          !document.documentElement.dataset &&
          (!(0, _getOwnPropertyDescriptor2.default)(
            HTMLElement.prototype,
            "dataset"
          ) ||
            !(0, _getOwnPropertyDescriptor2.default)(
              HTMLElement.prototype,
              "dataset"
            ).get)
        ) {
          var descriptor = {};

          descriptor.enumerable = true;

          descriptor.get = function get() {
            var element = this;
            var map = {};
            var attributes = this.attributes;

            function toUpperCase(n0) {
              return n0.charAt(1).toUpperCase();
            }

            function getter() {
              return this.value;
            }

            function setter(name, value) {
              if (typeof value !== "undefined") {
                this.setAttribute(name, value);
              } else {
                this.removeAttribute(name);
              }
            }

            for (var i = 0; i < attributes.length; i += 1) {
              var attribute = attributes[i];

              // This test really should allow any XML Name without
              // colons (and non-uppercase for XHTML)

              if (
                attribute &&
                attribute.name &&
                /^data-\w[\w-]*$/.test(attribute.name)
              ) {
                var name = attribute.name;
                var value = attribute.value;

                // Change to CamelCase

                var propName = name.substr(5).replace(/-./g, toUpperCase);

                (0, _defineProperty2.default)(map, propName, {
                  enumerable: descriptor.enumerable,
                  get: getter.bind({ value: value || "" }),
                  set: setter.bind(element, name),
                });
              }
            }
            return map;
          };

          Object.defineProperty(HTMLElement.prototype, "dataset", descriptor);
        }
      }

      exports.default = elementDatasetPolyfill;

      /***/
    },

    /***/ 85: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = { default: __webpack_require__(86), __esModule: true };

      /***/
    },

    /***/ 86: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      __webpack_require__(87);
      var $Object = __webpack_require__(9).Object;
      module.exports = function defineProperty(it, key, desc) {
        return $Object.defineProperty(it, key, desc);
      };

      /***/
    },

    /***/ 87: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var $export = __webpack_require__(34);
      // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
      $export($export.S + $export.F * !__webpack_require__(6), "Object", {
        defineProperty: __webpack_require__(36).f,
      });

      /***/
    },

    /***/ 88: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // optional / simple context binding
      var aFunction = __webpack_require__(89);
      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;
        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };
          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }
        return function () /* ...args */ {
          return fn.apply(that, arguments);
        };
      };

      /***/
    },

    /***/ 89: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = function (it) {
        if (typeof it != "function")
          throw TypeError(it + " is not a function!");
        return it;
      };

      /***/
    },

    /***/ 9: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var core = (module.exports = { version: "2.6.12" });
      if (typeof __e == "number") __e = core; // eslint-disable-line no-undef

      /***/
    },

    /***/ 90: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var dP = __webpack_require__(36);
      var createDesc = __webpack_require__(39);
      module.exports = __webpack_require__(6)
        ? function (object, key, value) {
            return dP.f(object, key, createDesc(1, value));
          }
        : function (object, key, value) {
            object[key] = value;
            return object;
          };

      /***/
    },

    /***/ 91: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var isObject = __webpack_require__(17);
      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(it + " is not an object!");
        return it;
      };

      /***/
    },

    /***/ 92: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var isObject = __webpack_require__(17);
      var document = __webpack_require__(35).document;
      // typeof document.createElement is 'object' in old IE
      var is = isObject(document) && isObject(document.createElement);
      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };

      /***/
    },

    /***/ 93: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      module.exports = { default: __webpack_require__(94), __esModule: true };

      /***/
    },

    /***/ 94: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      __webpack_require__(95);
      var $Object = __webpack_require__(9).Object;
      module.exports = function getOwnPropertyDescriptor(it, key) {
        return $Object.getOwnPropertyDescriptor(it, key);
      };

      /***/
    },

    /***/ 95: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      var toIObject = __webpack_require__(41);
      var $getOwnPropertyDescriptor = __webpack_require__(99).f;

      __webpack_require__(101)("getOwnPropertyDescriptor", function () {
        return function getOwnPropertyDescriptor(it, key) {
          return $getOwnPropertyDescriptor(toIObject(it), key);
        };
      });

      /***/
    },

    /***/ 96: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      var cof = __webpack_require__(97);
      // eslint-disable-next-line no-prototype-builtins
      module.exports = Object("z").propertyIsEnumerable(0)
        ? Object
        : function (it) {
            return cof(it) == "String" ? it.split("") : Object(it);
          };

      /***/
    },

    /***/ 97: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var toString = {}.toString;

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };

      /***/
    },

    /***/ 98: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      // 7.2.1 RequireObjectCoercible(argument)
      module.exports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };

      /***/
    },

    /***/ 99: /***/ function (module, exports, __webpack_require__) {
      "use strict";

      var pIE = __webpack_require__(100);
      var createDesc = __webpack_require__(39);
      var toIObject = __webpack_require__(41);
      var toPrimitive = __webpack_require__(38);
      var has = __webpack_require__(40);
      var IE8_DOM_DEFINE = __webpack_require__(37);
      var gOPD = Object.getOwnPropertyDescriptor;

      exports.f = __webpack_require__(6)
        ? gOPD
        : function getOwnPropertyDescriptor(O, P) {
            O = toIObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE)
              try {
                return gOPD(O, P);
              } catch (e) {
                /* empty */
              }
            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
          };

      /***/
    },
  },
  [1683]
);
