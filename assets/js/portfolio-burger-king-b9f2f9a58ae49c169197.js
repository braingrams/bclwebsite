webpackJsonp([33],{

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(22);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = function (cache) {
  // eslint-disable-next-line func-names
  return function (thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && _extends(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}

/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = function (TypedArray) {
  // eslint-disable-next-line func-names
  return function (thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createElementIfNotDefined = exports.classesToSelector = exports.getComputedStyle = exports.bindModuleMethods = exports.extend = exports.isObject = exports.getTranslate = exports.now = exports.nextTick = exports.deleteProps = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _ssrWindow = __webpack_require__(5);

function deleteProps(obj) {
  var object = obj;
  Object.keys(object).forEach(function (key) {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return setTimeout(callback, delay);
}

function now() {
  return Date.now();
}

function getComputedStyle(el) {
  var window = (0, _ssrWindow.getWindow)();
  var style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }

  var window = (0, _ssrWindow.getWindow)();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = getComputedStyle(el, null);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(function (a) {
        return a.replace(',', '.');
      }).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function isObject(o) {
  return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }

  return node && (node.nodeType === 1 || node.nodeType === 11);
}

function extend() {
  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  var noExtend = ['__proto__', 'constructor', 'prototype'];

  for (var i = 1; i < arguments.length; i += 1) {
    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      });

      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function bindModuleMethods(instance, obj) {
  Object.keys(obj).forEach(function (key) {
    if (isObject(obj[key])) {
      Object.keys(obj[key]).forEach(function (subKey) {
        if (typeof obj[key][subKey] === 'function') {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }

    instance[key] = obj[key];
  });
}

function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }

  return "." + classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.');
}

function createElementIfNotDefined($container, params, createElements, checkProps) {
  var document = (0, _ssrWindow.getDocument)();

  if (createElements) {
    Object.keys(checkProps).forEach(function (key) {
      if (!params[key] && params.auto === true) {
        var element = document.createElement('div');
        element.className = checkProps[key];
        $container.append(element);
        params[key] = element;
      }
    });
  }

  return params;
}

exports.deleteProps = deleteProps;
exports.nextTick = nextTick;
exports.now = now;
exports.getTranslate = getTranslate;
exports.isObject = isObject;
exports.extend = extend;
exports.bindModuleMethods = bindModuleMethods;
exports.getComputedStyle = getComputedStyle;
exports.classesToSelector = classesToSelector;
exports.createElementIfNotDefined = createElementIfNotDefined;

/***/ }),

/***/ 10:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bodyScrollIsOff = false;
var lastScrollPos = 0;

module.exports = {
    scrollOff: function scrollOff() {
        if (!bodyScrollIsOff) lastScrollPos = document.body.scrollTop;
        bodyScrollIsOff = true;

        document.documentElement.classList.add("noscroll");
        document.documentElement.style.top = '-' + lastScrollPos + 'px';
    },
    scrollOn: function scrollOn() {
        bodyScrollIsOff = false;

        document.documentElement.classList.remove("noscroll");
        document.documentElement.style.top = '';
        document.body.scrollTop = lastScrollPos;
    },
    scrollToggle: function scrollToggle() {
        if (bodyScrollIsOff) {
            this.scrollOn();
        } else {
            this.scrollOff();
        }
    },
    isScrollOff: function isScrollOff() {
        return bodyScrollIsOff;
    }
};

/***/ }),

/***/ 100:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ 101:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(34);
var core = __webpack_require__(9);
var fails = __webpack_require__(18);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ 102:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20170427
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in window.self) {

	// Full polyfill for browsers with no classList support
	// Including IE < Edge missing SVGElement.classList
	if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {

		(function (view) {

			"use strict";

			if (!('Element' in view)) return;

			var classListProp = "classList",
			    protoProp = "prototype",
			    elemCtrProto = view.Element[protoProp],
			    objCtr = Object,
			    strTrim = String[protoProp].trim || function () {
				return this.replace(/^\s+|\s+$/g, "");
			},
			    arrIndexOf = Array[protoProp].indexOf || function (item) {
				var i = 0,
				    len = this.length;
				for (; i < len; i++) {
					if (i in this && this[i] === item) {
						return i;
					}
				}
				return -1;
			}
			// Vendors: please allow content code to instantiate DOMExceptions
			,
			    DOMEx = function DOMEx(type, message) {
				this.name = type;
				this.code = DOMException[type];
				this.message = message;
			},
			    checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
				if (token === "") {
					throw new DOMEx("SYNTAX_ERR", "An invalid or illegal string was specified");
				}
				if (/\s/.test(token)) {
					throw new DOMEx("INVALID_CHARACTER_ERR", "String contains an invalid character");
				}
				return arrIndexOf.call(classList, token);
			},
			    ClassList = function ClassList(elem) {
				var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""),
				    classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
				    i = 0,
				    len = classes.length;
				for (; i < len; i++) {
					this.push(classes[i]);
				}
				this._updateClassName = function () {
					elem.setAttribute("class", this.toString());
				};
			},
			    classListProto = ClassList[protoProp] = [],
			    classListGetter = function classListGetter() {
				return new ClassList(this);
			};
			// Most DOMException implementations don't allow calling DOMException's toString()
			// on non-DOMExceptions. Error's toString() is sufficient here.
			DOMEx[protoProp] = Error[protoProp];
			classListProto.item = function (i) {
				return this[i] || null;
			};
			classListProto.contains = function (token) {
				token += "";
				return checkTokenAndGetIndex(this, token) !== -1;
			};
			classListProto.add = function () {
				var tokens = arguments,
				    i = 0,
				    l = tokens.length,
				    token,
				    updated = false;
				do {
					token = tokens[i] + "";
					if (checkTokenAndGetIndex(this, token) === -1) {
						this.push(token);
						updated = true;
					}
				} while (++i < l);

				if (updated) {
					this._updateClassName();
				}
			};
			classListProto.remove = function () {
				var tokens = arguments,
				    i = 0,
				    l = tokens.length,
				    token,
				    updated = false,
				    index;
				do {
					token = tokens[i] + "";
					index = checkTokenAndGetIndex(this, token);
					while (index !== -1) {
						this.splice(index, 1);
						updated = true;
						index = checkTokenAndGetIndex(this, token);
					}
				} while (++i < l);

				if (updated) {
					this._updateClassName();
				}
			};
			classListProto.toggle = function (token, force) {
				token += "";

				var result = this.contains(token),
				    method = result ? force !== true && "remove" : force !== false && "add";

				if (method) {
					this[method](token);
				}

				if (force === true || force === false) {
					return force;
				} else {
					return !result;
				}
			};
			classListProto.toString = function () {
				return this.join(" ");
			};

			if (objCtr.defineProperty) {
				var classListPropDesc = {
					get: classListGetter,
					enumerable: true,
					configurable: true
				};
				try {
					objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
				} catch (ex) {
					// IE 8 doesn't support enumerable:true
					// adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
					// modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
					if (ex.number === undefined || ex.number === -0x7FF5EC54) {
						classListPropDesc.enumerable = false;
						objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
					}
				}
			} else if (objCtr[protoProp].__defineGetter__) {
				elemCtrProto.__defineGetter__(classListProp, classListGetter);
			}
		})(window.self);
	}

	// There is full or partial native classList support, so just check if we need
	// to normalize the add/remove and toggle APIs.

	(function () {
		"use strict";

		var testElement = document.createElement("_");

		testElement.classList.add("c1", "c2");

		// Polyfill for IE 10/11 and Firefox <26, where classList.add and
		// classList.remove exist but support only one argument at a time.
		if (!testElement.classList.contains("c2")) {
			var createMethod = function createMethod(method) {
				var original = DOMTokenList.prototype[method];

				DOMTokenList.prototype[method] = function (token) {
					var i,
					    len = arguments.length;

					for (i = 0; i < len; i++) {
						token = arguments[i];
						original.call(this, token);
					}
				};
			};
			createMethod('add');
			createMethod('remove');
		}

		testElement.classList.toggle("c3", false);

		// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
		// support the second argument.
		if (testElement.classList.contains("c3")) {
			var _toggle = DOMTokenList.prototype.toggle;

			DOMTokenList.prototype.toggle = function (token, force) {
				if (1 in arguments && !this.contains(token) === !force) {
					return force;
				} else {
					return _toggle.call(this, token);
				}
			};
		}

		testElement = null;
	})();
}

/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var Handlers = __webpack_require__(7);
var scrollBlocker = __webpack_require__(10);

/**
 * @private
 */
var DOM = {};
var handlers = new Handlers();

/**
 * @public
 * @type {Object}
 */
module.exports = {
	init: init,
	on: handlers.add.bind(handlers),
	off: handlers.remove.bind(handlers)
};

/**
 * @private
 */
function init() {
	var close = document.querySelector(".js-popup_close");

	if (close) {
		close.onclick = function () {
			handlers.call("close");
			scrollBlocker.scrollOn();
			_gaq.push(['_trackEvent', 'popupClose', 'click']);
		};
	}
}

/***/ }),

/***/ 104:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function () {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
    setImmediate(fn);
  } || function (fn) {
    setTimeoutFunc(fn, 0);
  };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(105).setImmediate))

/***/ }),

/***/ 105:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(106);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || undefined && undefined.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || undefined && undefined.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),

/***/ 106:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(12)))

/***/ }),

/***/ 107:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var inputs = document.querySelectorAll('.js-request_field');
var activeClassName = 'c-field--focused';

var inputsFocusHandler = function inputsFocusHandler(evt) {
    var target = evt.target;

    var isFocused = evt.type === 'focus';

    isFocused && !target.parentNode.classList.contains(activeClassName) && target.parentNode.classList.add(activeClassName);
    !isFocused && target.parentNode.classList.contains(activeClassName) && target.parentNode.classList.remove(activeClassName);
};

for (var i = 0; i < inputs.length; i++) {
    var el = inputs[i];

    el.addEventListener('focus', inputsFocusHandler);
    el.addEventListener('blur', inputsFocusHandler);
}

/***/ }),

/***/ 108:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var checkboxes = document.querySelectorAll('.ui-checkbox');

function switchDisable(checked, target) {
    var className = 'b-request_submit-disabled';
    var submitBtnWrapper = target.closest('.b-request_form').querySelector('.b-request_submit');
    var submitBtn = submitBtnWrapper.querySelector('input[type="submit"]');

    if (checked) {
        submitBtnWrapper.classList.remove(className);
        submitBtn.removeAttribute("disabled");
    } else {
        submitBtnWrapper.classList.add(className);
        submitBtn.setAttribute("disabled", "disabled");
    }
}

function checkboxesChangeHandler(evt) {
    var target = evt.target;
    var checked = target.checked;


    switchDisable(checked, target);
}

for (var i = 0; i < checkboxes.length; i++) {
    var el = checkboxes[i];

    switchDisable(el.checked, el);

    el.addEventListener('change', checkboxesChangeHandler);
}

/***/ }),

/***/ 109:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! modernizr 3.5.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-cssanimations-touchevents-videoautoplay-setclasses !*/
!function (A, e, t) {
  function n(A, e) {
    return (typeof A === "undefined" ? "undefined" : _typeof(A)) === e;
  }function o() {
    var A, e, t, o, i, r, l;for (var a in y) {
      if (y.hasOwnProperty(a)) {
        if (A = [], e = y[a], e.name && (A.push(e.name.toLowerCase()), e.options && e.options.aliases && e.options.aliases.length)) for (t = 0; t < e.options.aliases.length; t++) {
          A.push(e.options.aliases[t].toLowerCase());
        }for (o = n(e.fn, "function") ? e.fn() : e.fn, i = 0; i < A.length; i++) {
          r = A[i], l = r.split("."), 1 === l.length ? Modernizr[l[0]] = o : (!Modernizr[l[0]] || Modernizr[l[0]] instanceof Boolean || (Modernizr[l[0]] = new Boolean(Modernizr[l[0]])), Modernizr[l[0]][l[1]] = o), E.push((o ? "" : "no-") + l.join("-"));
        }
      }
    }
  }function i(A) {
    var e = v.className,
        t = Modernizr._config.classPrefix || "";if (T && (e = e.baseVal), Modernizr._config.enableJSClass) {
      var n = new RegExp("(^|\\s)" + t + "no-js(\\s|$)");e = e.replace(n, "$1" + t + "js$2");
    }Modernizr._config.enableClasses && (e += " " + t + A.join(" " + t), T ? v.className.baseVal = e : v.className = e);
  }function r() {
    return "function" != typeof e.createElement ? e.createElement(arguments[0]) : T ? e.createElementNS.call(e, "http://www.w3.org/2000/svg", arguments[0]) : e.createElement.apply(e, arguments);
  }function l(A, e) {
    if ("object" == (typeof A === "undefined" ? "undefined" : _typeof(A))) for (var t in A) {
      G(A, t) && l(t, A[t]);
    } else {
      A = A.toLowerCase();var n = A.split("."),
          o = Modernizr[n[0]];if (2 == n.length && (o = o[n[1]]), "undefined" != typeof o) return Modernizr;e = "function" == typeof e ? e() : e, 1 == n.length ? Modernizr[n[0]] = e : (!Modernizr[n[0]] || Modernizr[n[0]] instanceof Boolean || (Modernizr[n[0]] = new Boolean(Modernizr[n[0]])), Modernizr[n[0]][n[1]] = e), i([(e && 0 != e ? "" : "no-") + n.join("-")]), Modernizr._trigger(A, e);
    }return Modernizr;
  }function a() {
    var A = e.body;return A || (A = r(T ? "svg" : "body"), A.fake = !0), A;
  }function s(A, t, n, o) {
    var i,
        l,
        s,
        c,
        u = "modernizr",
        d = r("div"),
        p = a();if (parseInt(n, 10)) for (; n--;) {
      s = r("div"), s.id = o ? o[n] : u + (n + 1), d.appendChild(s);
    }return i = r("style"), i.type = "text/css", i.id = "s" + u, (p.fake ? p : d).appendChild(i), p.appendChild(d), i.styleSheet ? i.styleSheet.cssText = A : i.appendChild(e.createTextNode(A)), d.id = u, p.fake && (p.style.background = "", p.style.overflow = "hidden", c = v.style.overflow, v.style.overflow = "hidden", v.appendChild(p)), l = t(d, A), p.fake ? (p.parentNode.removeChild(p), v.style.overflow = c, v.offsetHeight) : d.parentNode.removeChild(d), !!l;
  }function c(A, e) {
    return function () {
      return A.apply(e, arguments);
    };
  }function u(A, e, t) {
    var o;for (var i in A) {
      if (A[i] in e) return t === !1 ? A[i] : (o = e[A[i]], n(o, "function") ? c(o, t || e) : o);
    }return !1;
  }function d(A, e) {
    return !!~("" + A).indexOf(e);
  }function p(A) {
    return A.replace(/([a-z])-([a-z])/g, function (A, e, t) {
      return e + t.toUpperCase();
    }).replace(/^-/, "");
  }function f(A) {
    return A.replace(/([A-Z])/g, function (A, e) {
      return "-" + e.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }function h(e, t, n) {
    var o;if ("getComputedStyle" in A) {
      o = getComputedStyle.call(A, e, t);var i = A.console;if (null !== o) n && (o = o.getPropertyValue(n));else if (i) {
        var r = i.error ? "error" : "log";i[r].call(i, "getComputedStyle returning null, its possible modernizr test results are inaccurate");
      }
    } else o = !t && e.currentStyle && e.currentStyle[n];return o;
  }function m(e, n) {
    var o = e.length;if ("CSS" in A && "supports" in A.CSS) {
      for (; o--;) {
        if (A.CSS.supports(f(e[o]), n)) return !0;
      }return !1;
    }if ("CSSSupportsRule" in A) {
      for (var i = []; o--;) {
        i.push("(" + f(e[o]) + ":" + n + ")");
      }return i = i.join(" or "), s("@supports (" + i + ") { #modernizr { position: absolute; } }", function (A) {
        return "absolute" == h(A, null, "position");
      });
    }return t;
  }function w(A, e, o, i) {
    function l() {
      s && (delete V.style, delete V.modElem);
    }if (i = n(i, "undefined") ? !1 : i, !n(o, "undefined")) {
      var a = m(A, o);if (!n(a, "undefined")) return a;
    }for (var s, c, u, f, h, w = ["modernizr", "tspan", "samp"]; !V.style && w.length;) {
      s = !0, V.modElem = r(w.shift()), V.style = V.modElem.style;
    }for (u = A.length, c = 0; u > c; c++) {
      if (f = A[c], h = V.style[f], d(f, "-") && (f = p(f)), V.style[f] !== t) {
        if (i || n(o, "undefined")) return l(), "pfx" == e ? f : !0;try {
          V.style[f] = o;
        } catch (g) {}if (V.style[f] != h) return l(), "pfx" == e ? f : !0;
      }
    }return l(), !1;
  }function g(A, e, t, o, i) {
    var r = A.charAt(0).toUpperCase() + A.slice(1),
        l = (A + " " + Z.join(r + " ") + r).split(" ");return n(e, "string") || n(e, "undefined") ? w(l, e, o, i) : (l = (A + " " + Y.join(r + " ") + r).split(" "), u(l, e, t));
  }function R(A, e, n) {
    return g(A, t, t, e, n);
  }var E = [],
      y = [],
      B = { _version: "3.5.0", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function on(A, e) {
      var t = this;setTimeout(function () {
        e(t[A]);
      }, 0);
    }, addTest: function addTest(A, e, t) {
      y.push({ name: A, fn: e, options: t });
    }, addAsyncTest: function addAsyncTest(A) {
      y.push({ name: null, fn: A });
    } },
      Modernizr = function Modernizr() {};Modernizr.prototype = B, Modernizr = new Modernizr();var v = e.documentElement,
      T = "svg" === v.nodeName.toLowerCase(),
      F = B._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];B._prefixes = F, Modernizr.addTest("video", function () {
    var A = r("video"),
        e = !1;try {
      e = !!A.canPlayType, e && (e = new Boolean(e), e.ogg = A.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""), e.h264 = A.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""), e.webm = A.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ""), e.vp9 = A.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, ""), e.hls = A.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, ""));
    } catch (t) {}return e;
  });var G;!function () {
    var A = {}.hasOwnProperty;G = n(A, "undefined") || n(A.call, "undefined") ? function (A, e) {
      return e in A && n(A.constructor.prototype[e], "undefined");
    } : function (e, t) {
      return A.call(e, t);
    };
  }(), B._l = {}, B.on = function (A, e) {
    this._l[A] || (this._l[A] = []), this._l[A].push(e), Modernizr.hasOwnProperty(A) && setTimeout(function () {
      Modernizr._trigger(A, Modernizr[A]);
    }, 0);
  }, B._trigger = function (A, e) {
    if (this._l[A]) {
      var t = this._l[A];setTimeout(function () {
        var A, n;for (A = 0; A < t.length; A++) {
          (n = t[A])(e);
        }
      }, 0), delete this._l[A];
    }
  }, Modernizr._q.push(function () {
    B.addTest = l;
  }), Modernizr.addAsyncTest(function () {
    function A(r) {
      o++, clearTimeout(e);var a = r && "playing" === r.type || 0 !== i.currentTime;return !a && n > o ? void (e = setTimeout(A, t)) : (i.removeEventListener("playing", A, !1), l("videoautoplay", a), void (i.parentNode && i.parentNode.removeChild(i)));
    }var e,
        t = 200,
        n = 5,
        o = 0,
        i = r("video"),
        a = i.style;if (!(Modernizr.video && "autoplay" in i)) return void l("videoautoplay", !1);a.position = "absolute", a.height = 0, a.width = 0;try {
      if (Modernizr.video.ogg) i.src = "data:video/ogg;base64,T2dnUwACAAAAAAAAAABmnCATAAAAAHDEixYBKoB0aGVvcmEDAgEAAQABAAAQAAAQAAAAAAAFAAAAAQAAAAAAAAAAAGIAYE9nZ1MAAAAAAAAAAAAAZpwgEwEAAAACrA7TDlj///////////////+QgXRoZW9yYSsAAABYaXBoLk9yZyBsaWJ0aGVvcmEgMS4xIDIwMDkwODIyIChUaHVzbmVsZGEpAQAAABoAAABFTkNPREVSPWZmbXBlZzJ0aGVvcmEtMC4yOYJ0aGVvcmG+zSj3uc1rGLWpSUoQc5zmMYxSlKQhCDGMYhCEIQhAAAAAAAAAAAAAEW2uU2eSyPxWEvx4OVts5ir1aKtUKBMpJFoQ/nk5m41mUwl4slUpk4kkghkIfDwdjgajQYC8VioUCQRiIQh8PBwMhgLBQIg4FRba5TZ5LI/FYS/Hg5W2zmKvVoq1QoEykkWhD+eTmbjWZTCXiyVSmTiSSCGQh8PB2OBqNBgLxWKhQJBGIhCHw8HAyGAsFAiDgUCw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDAwPEhQUFQ0NDhESFRUUDg4PEhQVFRUOEBETFBUVFRARFBUVFRUVEhMUFRUVFRUUFRUVFRUVFRUVFRUVFRUVEAwLEBQZGxwNDQ4SFRwcGw4NEBQZHBwcDhATFhsdHRwRExkcHB4eHRQYGxwdHh4dGxwdHR4eHh4dHR0dHh4eHRALChAYKDM9DAwOExo6PDcODRAYKDlFOA4RFh0zV1A+EhYlOkRtZ00YIzdAUWhxXDFATldneXhlSFxfYnBkZ2MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEhIVGRoaGhoSFBYaGhoaGhUWGRoaGhoaGRoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhESFh8kJCQkEhQYIiQkJCQWGCEkJCQkJB8iJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQREhgvY2NjYxIVGkJjY2NjGBo4Y2NjY2MvQmNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRISEhUXGBkbEhIVFxgZGxwSFRcYGRscHRUXGBkbHB0dFxgZGxwdHR0YGRscHR0dHhkbHB0dHR4eGxwdHR0eHh4REREUFxocIBERFBcaHCAiERQXGhwgIiUUFxocICIlJRcaHCAiJSUlGhwgIiUlJSkcICIlJSUpKiAiJSUlKSoqEBAQFBgcICgQEBQYHCAoMBAUGBwgKDBAFBgcICgwQEAYHCAoMEBAQBwgKDBAQEBgICgwQEBAYIAoMEBAQGCAgAfF5cdH1e3Ow/L66wGmYnfIUbwdUTe3LMRbqON8B+5RJEvcGxkvrVUjTMrsXYhAnIwe0dTJfOYbWrDYyqUrz7dw/JO4hpmV2LsQQvkUeGq1BsZLx+cu5iV0e0eScJ91VIQYrmqfdVSK7GgjOU0oPaPOu5IcDK1mNvnD+K8LwS87f8Jx2mHtHnUkTGAurWZlNQa74ZLSFH9oF6FPGxzLsjQO5Qe0edcpttd7BXBSqMCL4k/4tFrHIPuEQ7m1/uIWkbDMWVoDdOSuRQ9286kvVUlQjzOE6VrNguN4oRXYGkgcnih7t13/9kxvLYKQezwLTrO44sVmMPgMqORo1E0sm1/9SludkcWHwfJwTSybR4LeAz6ugWVgRaY8mV/9SluQmtHrzsBtRF/wPY+X0JuYTs+ltgrXAmlk10xQHmTu9VSIAk1+vcvU4ml2oNzrNhEtQ3CysNP8UeR35wqpKUBdGdZMSjX4WVi8nJpdpHnbhzEIdx7mwf6W1FKAiucMXrWUWVjyRf23chNtR9mIzDoT/6ZLYailAjhFlZuvPtSeZ+2oREubDoWmT3TguY+JHPdRVSLKxfKH3vgNqJ/9emeEYikGXDFNzaLjvTeGAL61mogOoeG3y6oU4rW55ydoj0lUTSR/mmRhPmF86uwIfzp3FtiufQCmppaHDlGE0r2iTzXIw3zBq5hvaTldjG4CPb9wdxAme0SyedVKczJ9AtYbgPOzYKJvZZImsN7ecrxWZg5dR6ZLj/j4qpWsIA+vYwE+Tca9ounMIsrXMB4Stiib2SPQtZv+FVIpfEbzv8ncZoLBXc3YBqTG1HsskTTotZOYTG+oVUjLk6zhP8bg4RhMUNtfZdO7FdpBuXzhJ5Fh8IKlJG7wtD9ik8rWOJxy6iQ3NwzBpQ219mlyv+FLicYs2iJGSE0u2txzed++D61ZWCiHD/cZdQVCqkO2gJpdpNaObhnDfAPrT89RxdWFZ5hO3MseBSIlANppdZNIV/Rwe5eLTDvkfWKzFnH+QJ7m9QWV1KdwnuIwTNtZdJMoXBf74OhRnh2t+OTGL+AVUnIkyYY+QG7g9itHXyF3OIygG2s2kud679ZWKqSFa9n3IHD6MeLv1lZ0XyduRhiDRtrNnKoyiFVLcBm0ba5Yy3fQkDh4XsFE34isVpOzpa9nR8iCpS4HoxG2rJpnRhf3YboVa1PcRouh5LIJv/uQcPNd095ickTaiGBnWLKVWRc0OnYTSyex/n2FofEPnDG8y3PztHrzOLK1xo6RAml2k9owKajOC0Wr4D5x+3nA0UEhK2m198wuBHF3zlWWVKWLN1CHzLClUfuoYBcx4b1llpeBKmbayaR58njtE9onD66lUcsg0Spm2snsb+8HaJRn4dYcLbCuBuYwziB8/5U1C1DOOz2gZjSZtrLJk6vrLF3hwY4Io9xuT/ruUFRSBkNtUzTOWhjh26irLEPx4jPZL3Fo3QrReoGTTM21xYTT9oFdhTUIvjqTkfkvt0bzgVUjq/hOYY8j60IaO/0AzRBtqkTS6R5ellZd5uKdzzhb8BFlDdAcrwkE0rbXTOPB+7Y0FlZO96qFL4Ykg21StJs8qIW7h16H5hGiv8V2Cflau7QVDepTAHa6Lgt6feiEvJDM21StJsmOH/hynURrKxvUpQ8BH0JF7BiyG2qZpnL/7AOU66gt+reLEXY8pVOCQvSsBtqZTNM8bk9ohRcwD18o/WVkbvrceVKRb9I59IEKysjBeTMmmbA21xu/6iHadLRxuIzkLpi8wZYmmbbWi32RVAUjruxWlJ//iFxE38FI9hNKOoCdhwf5fDe4xZ81lgREhK2m1j78vW1CqkuMu/AjBNK210kzRUX/B+69cMMUG5bYrIeZxVSEZISmkzbXOi9yxwIfPgdsov7R71xuJ7rFcACjG/9PzApqFq7wEgzNJm2suWESPuwrQvejj7cbnQxMkxpm21lUYJL0fKmogPPqywn7e3FvB/FCNxPJ85iVUkCE9/tLKx31G4CgNtWTTPFhMvlu8G4/TrgaZttTChljfNJGgOT2X6EqpETy2tYd9cCBI4lIXJ1/3uVUllZEJz4baqGF64yxaZ+zPLYwde8Uqn1oKANtUrSaTOPHkhvuQP3bBlEJ/LFe4pqQOHUI8T8q7AXx3fLVBgSCVpMba55YxN3rv8U1Dv51bAPSOLlZWebkL8vSMGI21lJmmeVxPRwFlZF1CpqCN8uLwymaZyjbXHCRytogPN3o/n74CNykfT+qqRv5AQlHcRxYrC5KvGmbbUwmZY/29BvF6C1/93x4WVglXDLFpmbapmF89HKTogRwqqSlGbu+oiAkcWFbklC6Zhf+NtTLFpn8oWz+HsNRVSgIxZWON+yVyJlE5tq/+GWLTMutYX9ekTySEQPLVNQQ3OfycwJBM0zNtZcse7CvcKI0V/zh16Dr9OSA21MpmmcrHC+6pTAPHPwoit3LHHqs7jhFNRD6W8+EBGoSEoaZttTCZljfduH/fFisn+dRBGAZYtMzbVMwvul/T/crK1NQh8gN0SRRa9cOux6clC0/mDLFpmbarmF8/e6CopeOLCNW6S/IUUg3jJIYiAcDoMcGeRbOvuTPjXR/tyo79LK3kqqkbxkkMRAOB0GODPItnX3Jnxro/25Ud+llbyVVSN4ySGIgHA6DHBnkWzr7kz410f7cqO/Syt5KqpFVJwn6gBEvBM0zNtZcpGOEPiysW8vvRd2R0f7gtjhqUvXL+gWVwHm4XJDBiMpmmZtrLfPwd/IugP5+fKVSysH1EXreFAcEhelGmbbUmZY4Xdo1vQWVnK19P4RuEnbf0gQnR+lDCZlivNM22t1ESmopPIgfT0duOfQrsjgG4tPxli0zJmF5trdL1JDUIUT1ZXSqQDeR4B8mX3TrRro/2McGeUvLtwo6jIEKMkCUXWsLyZROd9P/rFYNtXPBli0z398iVUlVKAjFlY437JXImUTm2r/4ZYtMy61hf16RPJIU9nZ1MABAwAAAAAAAAAZpwgEwIAAABhp658BScAAAAAAADnUFBQXIDGXLhwtttNHDhw5OcpQRMETBEwRPduylKVB0HRdF0A";else {
        if (!Modernizr.video.h264) return void l("videoautoplay", !1);i.src = "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAs1tZGF0AAACrgYF//+q3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMjYwMSBhMGNkN2QzIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNSAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEwIHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAD2WIhAA3//728P4FNjuZQQAAAu5tb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAAZAABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACGHRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAgAAAAIAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAGQAAAAAAAEAAAAAAZBtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAACgAAAAEAFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAE7bWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAA+3N0YmwAAACXc3RzZAAAAAAAAAABAAAAh2F2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAgACAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAxYXZjQwFkAAr/4QAYZ2QACqzZX4iIhAAAAwAEAAADAFA8SJZYAQAGaOvjyyLAAAAAGHN0dHMAAAAAAAAAAQAAAAEAAAQAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAABRzdHN6AAAAAAAAAsUAAAABAAAAFHN0Y28AAAAAAAAAAQAAADAAAABidWR0YQAAAFptZXRhAAAAAAAAACFoZGxyAAAAAAAAAABtZGlyYXBwbAAAAAAAAAAAAAAAAC1pbHN0AAAAJal0b28AAAAdZGF0YQAAAAEAAAAATGF2ZjU2LjQwLjEwMQ==";
      }
    } catch (s) {
      return void l("videoautoplay", !1);
    }i.setAttribute("autoplay", ""), i.style.cssText = "display:none", v.appendChild(i), setTimeout(function () {
      i.addEventListener("playing", A, !1), e = setTimeout(A, t);
    }, 0);
  });var C = B.testStyles = s;Modernizr.addTest("touchevents", function () {
    var t;if ("ontouchstart" in A || A.DocumentTouch && e instanceof DocumentTouch) t = !0;else {
      var n = ["@media (", F.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");C(n, function (A) {
        t = 9 === A.offsetTop;
      });
    }return t;
  });var Q = "Moz O ms Webkit",
      Z = B._config.usePrefixes ? Q.split(" ") : [];B._cssomPrefixes = Z;var Y = B._config.usePrefixes ? Q.toLowerCase().split(" ") : [];B._domPrefixes = Y;var x = { elem: r("modernizr") };Modernizr._q.push(function () {
    delete x.elem;
  });var V = { style: x.elem.style };Modernizr._q.unshift(function () {
    delete V.style;
  }), B.testAllProps = g, B.testAllProps = R, Modernizr.addTest("cssanimations", R("animationName", "a", !0)), o(), i(E), delete B.addTest, delete B.addAsyncTest;for (var M = 0; M < Modernizr._q.length; M++) {
    Modernizr._q[M]();
  }A.Modernizr = Modernizr;
}(window, document);

/***/ }),

/***/ 11:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ 110:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var $ = __webpack_require__(82);

var _document = document,
    body = _document.body;

var modal = body.querySelector('#privacy-full').content.querySelector('.privacy-modal');
var links = body.querySelectorAll('.privacy-link');
var privacyHash = '#privacy';

function closeBtnClickHandler(evt) {
    var parentNode = evt.target.parentNode;


    body.style.overflow = 'unset';

    $('.privacy-modal').fadeOut(300);
    setTimeout(function () {
        return parentNode.remove();
    }, 300);
    history.back();
}

function openPopup() {
    var _this = this;

    body.style.overflow = 'hidden';

    _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var closeBtn;
        return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.next = 2;
                        return body.append(modal);

                    case 2:

                        $('.privacy-modal').fadeIn(300);
                        history.pushState(null, null, privacyHash);

                        closeBtn = body.querySelector('.privacy-modal_close-btn');


                        closeBtn.addEventListener('click', closeBtnClickHandler);

                    case 6:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, _this);
    }))();
}

function linkClickHandler(evt) {
    evt.preventDefault();

    openPopup();
}

(function privacyHashCkecker() {
    var hash = window.location.hash;

    var isPrivacy = hash === privacyHash;

    if (isPrivacy) {
        openPopup();
    }
})();

for (var i = 0; i < links.length; i++) {
    links[i].addEventListener('click', linkClickHandler);
}

exports.linkClickHandler = linkClickHandler;

/***/ }),

/***/ 111:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var modal = document.querySelector('.cookie-msg');
var closeBtn = modal.querySelector('.cookie-msg__close-btn');
var modalHiddenClassname = 'cookie-msg--hidden';

function closeBtnClickHandler(evt) {
    evt.preventDefault();

    modal.classList.add(modalHiddenClassname);
    window.localStorage.setItem('isCookieAccept', true);
}

window.onload = function () {
    var isCookieAccept = window.localStorage.isCookieAccept;


    !isCookieAccept && setTimeout(function () {
        return modal.classList.remove(modalHiddenClassname);
    }, 5000);
};

closeBtn.addEventListener('click', closeBtnClickHandler);

/***/ }),

/***/ 113:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var googleAnalytics = __webpack_require__(3);

/**
 * @public
 * @type {Object}
 */
module.exports = {
  init: function init() {
    initCopyright();

    var link = document.querySelector(".l-footer .l-mail-link");

    link.addEventListener('click', function () {

      googleAnalytics.sendEvent({
        eventCategory: 'request',
        eventAction: 'email',
        eventLabel: 'footer'
      });
    });
  }
};

function initCopyright() {
  var currentYear = new Date().getFullYear();
  var copyrightElement = document.querySelector('.c-copyright span');
  copyrightElement.innerText = "\xA9 1999-" + currentYear + " Mercury Development LLC";
}

/***/ }),

/***/ 114:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @public
 */

var timer;
var isDisabled = false;

/**
 * @public
 * @type {Object}
 */
module.exports = {
	init: function init() {
		window.addEventListener("scroll", onScroll, false);
	}
};

/**
 * @public
 */
function onScroll() {
	timer && clearTimeout(timer);

	!isDisabled && toggleMouseEvent(true);

	timer = setTimeout(function () {
		toggleMouseEvent(false);
	}, 300);
}

/**
 * @private
 */
function toggleMouseEvent(state) {
	isDisabled = state;
	document.body.classList.toggle("disable-pointer-events", state);
}

/***/ }),

/***/ 12:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),

/***/ 121:
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 122:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
var global = window;

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
    if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
        var a = factory();
        for (var i in a) {
            ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' ? exports : root)[i] = a[i];
        }
    }
})(typeof self !== 'undefined' ? self : undefined, function () {
    return (/******/function (modules) {
            // webpackBootstrap
            /******/ // The module cache
            /******/var installedModules = {};
            /******/
            /******/ // The require function
            /******/function __webpack_require__(moduleId) {
                /******/
                /******/ // Check if module is in cache
                /******/if (installedModules[moduleId]) {
                    /******/return installedModules[moduleId].exports;
                    /******/
                }
                /******/ // Create a new module (and put it into the cache)
                /******/var module = installedModules[moduleId] = {
                    /******/i: moduleId,
                    /******/l: false,
                    /******/exports: {}
                    /******/ };
                /******/
                /******/ // Execute the module function
                /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                /******/
                /******/ // Flag the module as loaded
                /******/module.l = true;
                /******/
                /******/ // Return the exports of the module
                /******/return module.exports;
                /******/
            }
            /******/
            /******/
            /******/ // expose the modules object (__webpack_modules__)
            /******/__webpack_require__.m = modules;
            /******/
            /******/ // expose the module cache
            /******/__webpack_require__.c = installedModules;
            /******/
            /******/ // define getter function for harmony exports
            /******/__webpack_require__.d = function (exports, name, getter) {
                /******/if (!__webpack_require__.o(exports, name)) {
                    /******/Object.defineProperty(exports, name, {
                        /******/configurable: false,
                        /******/enumerable: true,
                        /******/get: getter
                        /******/ });
                    /******/
                }
                /******/
            };
            /******/
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/__webpack_require__.n = function (module) {
                /******/var getter = module && module.__esModule ?
                /******/function getDefault() {
                    return module['default'];
                } :
                /******/function getModuleExports() {
                    return module;
                };
                /******/__webpack_require__.d(getter, 'a', getter);
                /******/return getter;
                /******/
            };
            /******/
            /******/ // Object.prototype.hasOwnProperty.call
            /******/__webpack_require__.o = function (object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
            };
            /******/
            /******/ // __webpack_public_path__
            /******/__webpack_require__.p = "";
            /******/
            /******/ // Load entry module and return exports
            /******/return __webpack_require__(__webpack_require__.s = 7);
            /******/
        }(
        /************************************************************************/
        /******/[
        /* 0 */
        /***/function (module, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            var _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }return target;
            }; /* globals jQuery */

            exports.lory = lory;

            var _detectPrefixes = __webpack_require__(1);

            var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

            var _detectSupportsPassive = __webpack_require__(2);

            var _detectSupportsPassive2 = _interopRequireDefault(_detectSupportsPassive);

            var _dispatchEvent = __webpack_require__(3);

            var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

            var _defaults = __webpack_require__(6);

            var _defaults2 = _interopRequireDefault(_defaults);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            var slice = Array.prototype.slice;

            function lory(slider, opts) {
                var position = void 0;
                var slidesWidth = void 0;
                var frameWidth = void 0;
                var slides = void 0;

                /**
                 * slider DOM elements
                 */
                var frame = void 0;
                var slideContainer = void 0;
                var prevCtrl = void 0;
                var nextCtrl = void 0;
                var prefixes = void 0;
                var transitionEndCallback = void 0;

                var index = 0;
                var options = {};
                var touchEventParams = (0, _detectSupportsPassive2.default)() ? { passive: true } : false;

                /**
                 * if object is jQuery convert to native DOM element
                 */
                if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
                    slider = slider[0];
                }

                /**
                 * private
                 * set active class to element which is the current slide
                 */
                function setActiveElement(slides, currentIndex) {
                    var _options = options,
                        classNameActiveSlide = _options.classNameActiveSlide;

                    slides.forEach(function (element, index) {
                        if (element.classList.contains(classNameActiveSlide)) {
                            element.classList.remove(classNameActiveSlide);
                        }
                    });

                    slides[currentIndex].classList.add(classNameActiveSlide);
                }

                /**
                 * private
                 * setupInfinite: function to setup if infinite is set
                 *
                 * @param  {array} slideArray
                 * @return {array} array of updated slideContainer elements
                 */
                function setupInfinite(slideArray) {
                    var _options2 = options,
                        infinite = _options2.infinite;

                    var front = slideArray.slice(0, infinite);
                    var back = slideArray.slice(slideArray.length - infinite, slideArray.length);

                    front.forEach(function (element) {
                        var cloned = element.cloneNode(true);

                        slideContainer.appendChild(cloned);
                    });

                    back.reverse().forEach(function (element) {
                        var cloned = element.cloneNode(true);

                        slideContainer.insertBefore(cloned, slideContainer.firstChild);
                    });

                    slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);

                    return slice.call(slideContainer.children);
                }

                /**
                 * [dispatchSliderEvent description]
                 * @return {[type]} [description]
                 */
                function dispatchSliderEvent(phase, type, detail) {
                    (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
                }

                /**
                 * translates to a given position in a given time in milliseconds
                 *
                 * @to        {number} number in pixels where to translate to
                 * @duration  {number} time in milliseconds for the transistion
                 * @ease      {string} easing css property
                 */
                function translate(to, duration, ease) {
                    var style = slideContainer && slideContainer.style;

                    if (style) {
                        style[prefixes.transition + 'TimingFunction'] = ease;
                        style[prefixes.transition + 'Duration'] = duration + 'ms';
                        style[prefixes.transform] = 'translateX(' + to + 'px)';
                    }
                }

                /**
                 * returns an element's width
                 */
                function elementWidth(element) {
                    return element.getBoundingClientRect().width || element.offsetWidth;
                }

                /**
                 * slidefunction called by prev, next & touchend
                 *
                 * determine nextIndex and slide to next postion
                 * under restrictions of the defined options
                 *
                 * @direction  {boolean}
                 */
                function slide(nextIndex, direction) {
                    var _options3 = options,
                        slideSpeed = _options3.slideSpeed,
                        slidesToScroll = _options3.slidesToScroll,
                        infinite = _options3.infinite,
                        rewind = _options3.rewind,
                        rewindPrev = _options3.rewindPrev,
                        rewindSpeed = _options3.rewindSpeed,
                        ease = _options3.ease,
                        classNameActiveSlide = _options3.classNameActiveSlide,
                        _options3$classNameDi = _options3.classNameDisabledNextCtrl,
                        classNameDisabledNextCtrl = _options3$classNameDi === undefined ? 'disabled' : _options3$classNameDi,
                        _options3$classNameDi2 = _options3.classNameDisabledPrevCtrl,
                        classNameDisabledPrevCtrl = _options3$classNameDi2 === undefined ? 'disabled' : _options3$classNameDi2;

                    var duration = slideSpeed;

                    var nextSlide = direction ? index + 1 : index - 1;
                    var maxOffset = Math.round(slidesWidth - frameWidth);

                    dispatchSliderEvent('before', 'slide', {
                        index: index,
                        nextSlide: nextSlide
                    });

                    /**
                     * Reset control classes
                     */
                    if (prevCtrl) {
                        prevCtrl.classList.remove(classNameDisabledPrevCtrl);
                    }
                    if (nextCtrl) {
                        nextCtrl.classList.remove(classNameDisabledNextCtrl);
                    }

                    if (typeof nextIndex !== 'number') {
                        if (direction) {
                            if (infinite && index + infinite * 2 !== slides.length) {
                                nextIndex = index + (infinite - index % infinite);
                            } else {
                                nextIndex = index + slidesToScroll;
                            }
                        } else {
                            if (infinite && index % infinite !== 0) {
                                nextIndex = index - index % infinite;
                            } else {
                                nextIndex = index - slidesToScroll;
                            }
                        }
                    }

                    nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);

                    if (infinite && direction === undefined) {
                        nextIndex += infinite;
                    }

                    if (rewindPrev && Math.abs(position.x) === 0 && direction === false) {
                        nextIndex = slides.length - 1;
                        duration = rewindSpeed;
                    }

                    var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);

                    if (rewind && Math.abs(position.x) === maxOffset && direction) {
                        nextOffset = 0;
                        nextIndex = 0;
                        duration = rewindSpeed;
                    }

                    /**
                     * translate to the nextOffset by a defined duration and ease function
                     */
                    translate(nextOffset, duration, ease);

                    /**
                     * update the position with the next position
                     */
                    position.x = nextOffset;

                    /**
                     * update the index with the nextIndex only if
                     * the offset of the nextIndex is in the range of the maxOffset
                     */
                    if (slides[nextIndex].offsetLeft <= maxOffset) {
                        index = nextIndex;
                    }

                    if (infinite && (nextIndex === slides.length - infinite || nextIndex === slides.length - slides.length % infinite || nextIndex === 0)) {
                        if (direction) {
                            index = infinite;
                        }

                        if (!direction) {
                            index = slides.length - infinite * 2;
                        }

                        position.x = slides[index].offsetLeft * -1;

                        transitionEndCallback = function transitionEndCallback() {
                            translate(slides[index].offsetLeft * -1, 0, undefined);
                        };
                    }

                    if (classNameActiveSlide) {
                        setActiveElement(slice.call(slides), index);
                    }

                    /**
                     * update classes for next and prev arrows
                     * based on user settings
                     */
                    if (prevCtrl && !infinite && !rewindPrev && nextIndex === 0) {
                        prevCtrl.classList.add(classNameDisabledPrevCtrl);
                    }

                    if (nextCtrl && !infinite && !rewind && nextIndex + 1 === slides.length) {
                        nextCtrl.classList.add(classNameDisabledNextCtrl);
                    }

                    dispatchSliderEvent('after', 'slide', {
                        currentSlide: index
                    });
                }

                /**
                 * public
                 * setup function
                 */
                function setup() {
                    dispatchSliderEvent('before', 'init');

                    prefixes = (0, _detectPrefixes2.default)();
                    options = _extends({}, _defaults2.default, opts);

                    var _options4 = options,
                        classNameFrame = _options4.classNameFrame,
                        classNameSlideContainer = _options4.classNameSlideContainer,
                        classNamePrevCtrl = _options4.classNamePrevCtrl,
                        classNameNextCtrl = _options4.classNameNextCtrl,
                        _options4$classNameDi = _options4.classNameDisabledNextCtrl,
                        classNameDisabledNextCtrl = _options4$classNameDi === undefined ? 'disabled' : _options4$classNameDi,
                        _options4$classNameDi2 = _options4.classNameDisabledPrevCtrl,
                        classNameDisabledPrevCtrl = _options4$classNameDi2 === undefined ? 'disabled' : _options4$classNameDi2,
                        enableMouseEvents = _options4.enableMouseEvents,
                        classNameActiveSlide = _options4.classNameActiveSlide,
                        initialIndex = _options4.initialIndex;

                    index = initialIndex;
                    frame = slider.getElementsByClassName(classNameFrame)[0];
                    slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
                    prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
                    nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];

                    position = {
                        x: slideContainer.offsetLeft,
                        y: slideContainer.offsetTop
                    };

                    if (options.infinite) {
                        slides = setupInfinite(slice.call(slideContainer.children));
                    } else {
                        slides = slice.call(slideContainer.children);

                        if (prevCtrl && !options.rewindPrev) {
                            prevCtrl.classList.add(classNameDisabledPrevCtrl);
                        }

                        if (nextCtrl && slides.length === 1 && !options.rewind) {
                            nextCtrl.classList.add(classNameDisabledNextCtrl);
                        }
                    }

                    reset();

                    if (classNameActiveSlide) {
                        setActiveElement(slides, index);
                    }

                    if (prevCtrl && nextCtrl) {
                        prevCtrl.addEventListener('click', prev);
                        nextCtrl.addEventListener('click', next);
                    }

                    frame.addEventListener('touchstart', onTouchstart, touchEventParams);

                    if (enableMouseEvents) {
                        frame.addEventListener('mousedown', onTouchstart);
                        frame.addEventListener('click', onClick);
                    }

                    options.window.addEventListener('resize', onResize);

                    dispatchSliderEvent('after', 'init');
                }

                /**
                 * public
                 * reset function: called on resize
                 */
                function reset() {
                    var _options5 = options,
                        infinite = _options5.infinite,
                        ease = _options5.ease,
                        rewindSpeed = _options5.rewindSpeed,
                        rewindOnResize = _options5.rewindOnResize,
                        classNameActiveSlide = _options5.classNameActiveSlide,
                        initialIndex = _options5.initialIndex;

                    slidesWidth = elementWidth(slideContainer);
                    frameWidth = elementWidth(frame);

                    if (frameWidth === slidesWidth) {
                        slidesWidth = slides.reduce(function (previousValue, slide) {
                            return previousValue + elementWidth(slide);
                        }, 0);
                    }

                    if (rewindOnResize) {
                        index = initialIndex;
                    } else {
                        ease = null;
                        rewindSpeed = 0;
                    }

                    if (infinite) {
                        translate(slides[index + infinite].offsetLeft * -1, 0, null);

                        index = index + infinite;
                        position.x = slides[index].offsetLeft * -1;
                    } else {
                        translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
                        position.x = slides[index].offsetLeft * -1;
                    }

                    if (classNameActiveSlide) {
                        setActiveElement(slice.call(slides), index);
                    }
                }

                /**
                 * public
                 * slideTo: called on clickhandler
                 */
                function slideTo(index) {
                    slide(index);
                }

                /**
                 * public
                 * returnIndex function: called on clickhandler
                 */
                function returnIndex() {
                    return index - options.infinite || 0;
                }

                /**
                 * public
                 * prev function: called on clickhandler
                 */
                function prev() {
                    slide(false, false);
                }

                /**
                 * public
                 * next function: called on clickhandler
                 */
                function next() {
                    slide(false, true);
                }

                /**
                 * public
                 * destroy function: called to gracefully destroy the lory instance
                 */
                function destroy() {
                    dispatchSliderEvent('before', 'destroy');

                    // remove event listeners
                    frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
                    frame.removeEventListener('touchstart', onTouchstart, touchEventParams);
                    frame.removeEventListener('touchmove', onTouchmove, touchEventParams);
                    frame.removeEventListener('touchend', onTouchend);
                    frame.removeEventListener('mousemove', onTouchmove);
                    frame.removeEventListener('mousedown', onTouchstart);
                    frame.removeEventListener('mouseup', onTouchend);
                    frame.removeEventListener('mouseleave', onTouchend);
                    frame.removeEventListener('click', onClick);

                    options.window.removeEventListener('resize', onResize);

                    if (prevCtrl) {
                        prevCtrl.removeEventListener('click', prev);
                    }

                    if (nextCtrl) {
                        nextCtrl.removeEventListener('click', next);
                    }

                    // remove cloned slides if infinite is set
                    if (options.infinite) {
                        Array.apply(null, Array(options.infinite)).forEach(function () {
                            slideContainer.removeChild(slideContainer.firstChild);
                            slideContainer.removeChild(slideContainer.lastChild);
                        });
                    }

                    dispatchSliderEvent('after', 'destroy');
                }

                // event handling

                var touchOffset = void 0;
                var delta = void 0;
                var isScrolling = void 0;

                function onTransitionEnd() {
                    if (transitionEndCallback) {
                        transitionEndCallback();

                        transitionEndCallback = undefined;
                    }
                }

                function onTouchstart(event) {
                    var _options6 = options,
                        enableMouseEvents = _options6.enableMouseEvents;

                    var touches = event.touches ? event.touches[0] : event;

                    if (enableMouseEvents) {
                        frame.addEventListener('mousemove', onTouchmove);
                        frame.addEventListener('mouseup', onTouchend);
                        frame.addEventListener('mouseleave', onTouchend);
                    }

                    frame.addEventListener('touchmove', onTouchmove, touchEventParams);
                    frame.addEventListener('touchend', onTouchend);

                    var pageX = touches.pageX,
                        pageY = touches.pageY;

                    touchOffset = {
                        x: pageX,
                        y: pageY,
                        time: Date.now()
                    };

                    isScrolling = undefined;

                    delta = {};

                    dispatchSliderEvent('on', 'touchstart', {
                        event: event
                    });
                }

                function onTouchmove(event) {
                    var touches = event.touches ? event.touches[0] : event;
                    var pageX = touches.pageX,
                        pageY = touches.pageY;

                    delta = {
                        x: pageX - touchOffset.x,
                        y: pageY - touchOffset.y
                    };

                    if (typeof isScrolling === 'undefined') {
                        isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
                    }

                    if (!isScrolling && touchOffset) {
                        translate(position.x + delta.x, 0, null);
                    }

                    // may be
                    dispatchSliderEvent('on', 'touchmove', {
                        event: event
                    });
                }

                function onTouchend(event) {
                    /**
                     * time between touchstart and touchend in milliseconds
                     * @duration {number}
                     */
                    var duration = touchOffset ? Date.now() - touchOffset.time : undefined;

                    /**
                     * is valid if:
                     *
                     * -> swipe attempt time is over 300 ms
                     * and
                     * -> swipe distance is greater than 25px
                     * or
                     * -> swipe distance is more then a third of the swipe area
                     *
                     * @isValidSlide {Boolean}
                     */
                    var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;

                    /**
                     * is out of bounds if:
                     *
                     * -> index is 0 and delta x is greater than 0
                     * or
                     * -> index is the last slide and delta is smaller than 0
                     *
                     * @isOutOfBounds {Boolean}
                     */
                    var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;

                    var direction = delta.x < 0;

                    if (!isScrolling) {
                        if (isValid && !isOutOfBounds) {
                            slide(false, direction);
                        } else {
                            translate(position.x, options.snapBackSpeed);
                        }
                    }

                    touchOffset = undefined;

                    /**
                     * remove eventlisteners after swipe attempt
                     */
                    frame.removeEventListener('touchmove', onTouchmove);
                    frame.removeEventListener('touchend', onTouchend);
                    frame.removeEventListener('mousemove', onTouchmove);
                    frame.removeEventListener('mouseup', onTouchend);
                    frame.removeEventListener('mouseleave', onTouchend);

                    dispatchSliderEvent('on', 'touchend', {
                        event: event
                    });
                }

                function onClick(event) {
                    if (delta.x) {
                        event.preventDefault();
                    }
                }

                function onResize(event) {
                    if (frameWidth !== elementWidth(frame)) {
                        reset();

                        dispatchSliderEvent('on', 'resize', {
                            event: event
                        });
                    }
                }

                // trigger initial setup
                setup();

                // expose public api
                return {
                    setup: setup,
                    reset: reset,
                    slideTo: slideTo,
                    returnIndex: returnIndex,
                    prev: prev,
                    next: next,
                    destroy: destroy
                };
            }

            /***/
        },
        /* 1 */
        /***/function (module, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = detectPrefixes;
            /**
             * Detecting prefixes for saving time and bytes
             */
            function detectPrefixes() {
                var transform = void 0;
                var transition = void 0;
                var transitionEnd = void 0;

                (function () {
                    var el = document.createElement('_');
                    var style = el.style;

                    var prop = void 0;

                    if (style[prop = 'webkitTransition'] === '') {
                        transitionEnd = 'webkitTransitionEnd';
                        transition = prop;
                    }

                    if (style[prop = 'transition'] === '') {
                        transitionEnd = 'transitionend';
                        transition = prop;
                    }

                    if (style[prop = 'webkitTransform'] === '') {
                        transform = prop;
                    }

                    if (style[prop = 'msTransform'] === '') {
                        transform = prop;
                    }

                    if (style[prop = 'transform'] === '') {
                        transform = prop;
                    }

                    document.body.insertBefore(el, null);
                    style[transform] = 'translateX(0)';
                    document.body.removeChild(el);
                })();

                return {
                    transform: transform,
                    transition: transition,
                    transitionEnd: transitionEnd
                };
            }

            /***/
        },
        /* 2 */
        /***/function (module, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = detectSupportsPassive;
            function detectSupportsPassive() {
                var supportsPassive = false;

                try {
                    var opts = Object.defineProperty({}, 'passive', {
                        get: function get() {
                            supportsPassive = true;
                        }
                    });

                    window.addEventListener('testPassive', null, opts);
                    window.removeEventListener('testPassive', null, opts);
                } catch (e) {}

                return supportsPassive;
            }

            /***/
        },
        /* 3 */
        /***/function (module, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = dispatchEvent;

            var _customEvent = __webpack_require__(4);

            var _customEvent2 = _interopRequireDefault(_customEvent);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
            }

            /**
             * dispatch custom events
             *
             * @param  {element} el         slideshow element
             * @param  {string}  type       custom event name
             * @param  {object}  detail     custom detail information
             */
            function dispatchEvent(target, type, detail) {
                var event = new _customEvent2.default(type, {
                    bubbles: true,
                    cancelable: true,
                    detail: detail
                });

                target.dispatchEvent(event);
            }

            /***/
        },
        /* 4 */
        /***/function (module, exports, __webpack_require__) {

            /* WEBPACK VAR INJECTION */(function (global) {
                var NativeCustomEvent = global.CustomEvent;

                function useNative() {
                    try {
                        var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
                        return 'cat' === p.type && 'bar' === p.detail.foo;
                    } catch (e) {}
                    return false;
                }

                /**
                 * Cross-browser `CustomEvent` constructor.
                 *
                 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
                 *
                 * @public
                 */

                module.exports = useNative() ? NativeCustomEvent :

                // IE >= 9
                'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent(type, params) {
                    var e = document.createEvent('CustomEvent');
                    if (params) {
                        e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
                    } else {
                        e.initCustomEvent(type, false, false, void 0);
                    }
                    return e;
                } :

                // IE <= 8
                function CustomEvent(type, params) {
                    var e = document.createEventObject();
                    e.type = type;
                    if (params) {
                        e.bubbles = Boolean(params.bubbles);
                        e.cancelable = Boolean(params.cancelable);
                        e.detail = params.detail;
                    } else {
                        e.bubbles = false;
                        e.cancelable = false;
                        e.detail = void 0;
                    }
                    return e;
                };

                /* WEBPACK VAR INJECTION */
            }).call(exports, __webpack_require__(5));

            /***/
        },
        /* 5 */
        /***/function (module, exports) {

            var g;

            // This works in non-strict mode
            g = function () {
                return this;
            }();

            try {
                // This works if eval is allowed (see CSP)
                g = g || Function("return this")() || (1, eval)("this");
            } catch (e) {
                // This works if the window reference is available
                if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object") g = window;
            }

            // g can still be undefined, but nothing to do about it...
            // We return undefined, instead of nothing here, so it's
            // easier to handle this case. if(!global) { ...}

            module.exports = g;

            /***/
        },
        /* 6 */
        /***/function (module, exports, __webpack_require__) {

            "use strict";

            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.default = {
                /**
                 * slides scrolled at once
                 * @slidesToScroll {Number}
                 */
                slidesToScroll: 1,

                /**
                 * time in milliseconds for the animation of a valid slide attempt
                 * @slideSpeed {Number}
                 */
                slideSpeed: 300,

                /**
                 * time in milliseconds for the animation of the rewind after the last slide
                 * @rewindSpeed {Number}
                 */
                rewindSpeed: 600,

                /**
                 * time for the snapBack of the slider if the slide attempt was not valid
                 * @snapBackSpeed {Number}
                 */
                snapBackSpeed: 200,

                /**
                 * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
                 * cubic bezier easing functions: http://easings.net/de
                 * @ease {String}
                 */
                ease: 'ease',

                /**
                 * if slider reached the last slide, with next click the slider goes back to the startindex.
                 * use infinite or rewind, not both
                 * @rewind {Boolean}
                 */
                rewind: false,

                /**
                 * number of visible slides or false
                 * use infinite or rewind, not both
                 * @infinite {number}
                 */
                infinite: false,

                /**
                 * the slide index to show when the slider is initialized.
                 * @initialIndex {number}
                 */
                initialIndex: 0,

                /**
                 * class name for slider frame
                 * @classNameFrame {string}
                 */
                classNameFrame: 'js_frame',

                /**
                 * class name for slides container
                 * @classNameSlideContainer {string}
                 */
                classNameSlideContainer: 'js_slides',

                /**
                 * class name for slider prev control
                 * @classNamePrevCtrl {string}
                 */
                classNamePrevCtrl: 'js_prev',

                /**
                 * class name for slider next control
                 * @classNameNextCtrl {string}
                 */
                classNameNextCtrl: 'js_next',

                /**
                 * class name for current active slide
                 * if emptyString then no class is set
                 * @classNameActiveSlide {string}
                 */
                classNameActiveSlide: 'active',

                /**
                 * enables mouse events for swiping on desktop devices
                 * @enableMouseEvents {boolean}
                 */
                enableMouseEvents: false,

                /**
                 * window instance
                 * @window {object}
                 */
                window: typeof window !== 'undefined' ? window : null,

                /**
                 * If false, slides lory to the first slide on window resize.
                 * @rewindOnResize {boolean}
                 */
                rewindOnResize: true
            };

            /***/
        },
        /* 7 */
        /***/function (module, exports, __webpack_require__) {

            module.exports = __webpack_require__(0);

            /***/
        }]
        /******/)
    );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(112)(module)))

/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LoryAutoplay = function LoryAutoplay() {};

LoryAutoplay.prototype.init = function (slider, interval) {
	this.slider = slider;
	this.interval = interval;
	this.isPlaying = true;
	this.startAnimating(interval);
};

LoryAutoplay.prototype.destroy = function () {
	this.resetTimer.apply(this);
	this.isPlaying = false;
};

// begin animation (autoplay)
LoryAutoplay.prototype.startAnimating = function () {
	this.then = Date.now();
	this.animate.apply(this);
};

// animate (autoplay)
LoryAutoplay.prototype.animate = function () {
	var now = Date.now();
	var self = this;

	window.requestAnimationFrame(this.animate.bind(self));
	this.elapsed = now - this.then;

	if (this.elapsed > this.interval && this.isPlaying) {
		this.then = now - this.elapsed % this.interval;
		this.slider.next();
	}
};

// reset timer
LoryAutoplay.prototype.resetTimer = function () {
	var now = Date.now();
	this.elapsed = now - this.then;
	this.then = now - this.elapsed % this.interval;
};

module.exports = LoryAutoplay;

/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _VimeoVideo = __webpack_require__(126);

var _VimeoVideo2 = _interopRequireDefault(_VimeoVideo);

var _YoutubeVideo = __webpack_require__(127);

var _YoutubeVideo2 = _interopRequireDefault(_YoutubeVideo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var videoElement = null;
var contentElement = null;
var player = null;
var scrollTop = 0;

function handleCloseButtonClick(event) {
    closeVideo();
}

function handleLoad(event) {
    closeVideoElement();

    videoElement.classList.remove("case-study-video-opened");
    videoElement.classList.remove("case-study-video-loading");

    window.removeEventListener("load", handleLoad, false);
    window.addEventListener("scroll", handleScroll, false);
}

function handleOpenButtonClick(event) {
    scrollTop = document.documentElement.scrollTop;

    scrollToTop();
    openVideo();
}

function handleResize(event) {
    if (isMobile()) {
        closeVideoElement();
    } else if (videoElement.classList.contains("case-study-video-opened")) {
        openVideoElement();
    } else {
        closeVideoElement();
    }
}

function handleScroll(event) {
    if (isMobile()) {
        return;
    }

    var MIN_SCROLL = 50;

    if (document.documentElement.scrollTop - scrollTop > MIN_SCROLL && videoElement.classList.contains("case-study-video-opened")) {
        closeVideo();
        scrollTop = 0;
    }
}

function handleTransitionEnd(event) {
    if (event.target === contentElement && videoElement.classList.contains("case-study-video-opened")) {
        openVideoIframe();
    }
}

function handleVideoEnded() {
    closeVideo();
}

function handleVideoReady() {
    contentElement = videoElement.querySelector(".case-study-video-content-foreground");
    contentElement.addEventListener("transitionend", handleTransitionEnd, false);

    var openButtonElement = document.getElementById("play-button");
    openButtonElement.addEventListener("click", handleOpenButtonClick, false);

    var closeButtonElement = document.getElementById("close-button");
    closeButtonElement.addEventListener("click", handleCloseButtonClick, false);
}

function closeVideo() {
    closeVideoElement();

    videoElement.querySelector("iframe").classList.remove("opened");
    videoElement.classList.remove("case-study-video-opened");
    player.stop();
}

function closeVideoElement() {
    videoElement.style.minHeight = "";
}

function isMobile() {
    return window.matchMedia("(max-width: 767px)").matches;
}

function isTablet() {
    return window.matchMedia("(min-width: 768px) and (max-width: 1024px)").matches;
}

function openVideo() {
    openVideoElement();

    videoElement.classList.add("case-study-video-opened");
    player.play();

    if (isMobile()) {
        openVideoIframe();
    }
}

function openVideoIframe() {
    videoElement.querySelector("iframe").classList.add("opened");
}

function openVideoElement() {
    if (isMobile()) {
        videoElement.style.minHeight = "";
    } else if (isTablet()) {
        videoElement.style.minHeight = window.innerHeight - 60 + "px";
    } else {
        videoElement.style.minHeight = window.innerHeight - 90 + "px";
    }
}

function scrollToTop() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
}

function init() {
    videoElement = document.querySelector(".case-study-video");

    if (!videoElement) {
        return;
    }

    var youtubePlayerElement = videoElement.querySelector(".case-study-video__player--youtube");
    var vimeoPlayerElement = videoElement.querySelector(".case-study-video__player--vimeo");

    if (!(youtubePlayerElement || vimeoPlayerElement)) {
        return;
    }

    openVideoElement();

    var props = {
        handleVideoEnded: handleVideoEnded,
        handleVideoReady: handleVideoReady
    };

    if (youtubePlayerElement) {
        player = new _YoutubeVideo2.default(props);
        player.init(youtubePlayerElement.id);
    } else if (vimeoPlayerElement) {
        player = new _VimeoVideo2.default(props);
        player.init(vimeoPlayerElement.id);
    }

    window.addEventListener("load", handleLoad, false);
    window.addEventListener("resize", handleResize, false);
}

module.exports = {
    init: init
};

/***/ }),

/***/ 126:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VimeoVideo = function () {
    function VimeoVideo(props) {
        _classCallCheck(this, VimeoVideo);

        this._props = props || {};
        this._player = null;
        this._videoEnded = false;
    }

    _createClass(VimeoVideo, [{
        key: "init",
        value: function init(playerId) {
            var _this = this;

            var iframe = document.getElementById(playerId);
            this._player = new window.Vimeo.Player(iframe);

            this._player.ready().then(function () {
                if (_this._props.handleVideoReady) {
                    _this._props.handleVideoReady();
                }
            });

            this._player.on("pause", function (event) {
                if (event.percent === 1 && !_this._videoEnded) {
                    _this._videoEnded = true;

                    if (_this._props.handleVideoEnded) {
                        _this._props.handleVideoEnded();
                    }
                }
            });
        }
    }, {
        key: "play",
        value: function play() {
            if (this._player) {
                this._videoEnded = false;
                this._player.play();
            }
        }
    }, {
        key: "stop",
        value: function stop() {
            if (this._player) {
                this._videoEnded = true;
                this._player.unload();
            }
        }
    }]);

    return VimeoVideo;
}();

exports.default = VimeoVideo;

/***/ }),

/***/ 127:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var YoutubeVideo = function () {
    function YoutubeVideo(props) {
        _classCallCheck(this, YoutubeVideo);

        this._onPlayerReady = this._onPlayerReady.bind(this);
        this._onPlayerStateChange = this._onPlayerStateChange.bind(this);

        this._props = props || {};
        this._player = null;
    }

    _createClass(YoutubeVideo, [{
        key: "_onPlayerReady",
        value: function _onPlayerReady() {
            this._player.setPlaybackQuality("highres");

            if (this._props.handleVideoReady) {
                this._props.handleVideoReady();
            }
        }
    }, {
        key: "_onPlayerStateChange",
        value: function _onPlayerStateChange(event) {
            if (event.data === 0) {
                if (this._props.handleVideoEnded) {
                    this._props.handleVideoEnded();
                }
            }
        }
    }, {
        key: "init",
        value: function init(playerId) {
            var _this = this;

            var tag = document.createElement("script");
            tag.src = "https://www.youtube.com/iframe_api";

            var firstScriptTag = document.getElementsByTagName("script")[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

            window.onYouTubeIframeAPIReady = function () {
                _this._player = new YT.Player(playerId, {
                    videoId: playerId.replace("youtube-video-", ""),

                    events: {
                        "onReady": _this._onPlayerReady,
                        "onStateChange": _this._onPlayerStateChange
                    }
                });
            };
        }
    }, {
        key: "play",
        value: function play() {
            if (this._player) {
                this._player.playVideo();
            }
        }
    }, {
        key: "stop",
        value: function stop() {
            if (this._player) {
                this._player.stopVideo();
            }
        }
    }]);

    return YoutubeVideo;
}();

exports.default = YoutubeVideo;

/***/ }),

/***/ 128:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _coreClass = __webpack_require__(135);

Object.defineProperty(exports, 'Swiper', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_coreClass).default;
  }
});
Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_coreClass).default;
  }
});

var _virtual = __webpack_require__(202);

Object.defineProperty(exports, 'Virtual', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_virtual).default;
  }
});

var _keyboard = __webpack_require__(203);

Object.defineProperty(exports, 'Keyboard', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_keyboard).default;
  }
});

var _mousewheel = __webpack_require__(204);

Object.defineProperty(exports, 'Mousewheel', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_mousewheel).default;
  }
});

var _navigation = __webpack_require__(205);

Object.defineProperty(exports, 'Navigation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_navigation).default;
  }
});

var _pagination = __webpack_require__(206);

Object.defineProperty(exports, 'Pagination', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pagination).default;
  }
});

var _scrollbar = __webpack_require__(207);

Object.defineProperty(exports, 'Scrollbar', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scrollbar).default;
  }
});

var _parallax = __webpack_require__(208);

Object.defineProperty(exports, 'Parallax', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_parallax).default;
  }
});

var _zoom = __webpack_require__(209);

Object.defineProperty(exports, 'Zoom', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_zoom).default;
  }
});

var _lazy = __webpack_require__(210);

Object.defineProperty(exports, 'Lazy', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_lazy).default;
  }
});

var _controller = __webpack_require__(211);

Object.defineProperty(exports, 'Controller', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_controller).default;
  }
});

var _a11y = __webpack_require__(212);

Object.defineProperty(exports, 'A11y', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_a11y).default;
  }
});

var _history = __webpack_require__(213);

Object.defineProperty(exports, 'History', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_history).default;
  }
});

var _hashNavigation = __webpack_require__(214);

Object.defineProperty(exports, 'HashNavigation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_hashNavigation).default;
  }
});

var _autoplay = __webpack_require__(215);

Object.defineProperty(exports, 'Autoplay', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_autoplay).default;
  }
});

var _effectFade = __webpack_require__(216);

Object.defineProperty(exports, 'EffectFade', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_effectFade).default;
  }
});

var _effectCube = __webpack_require__(217);

Object.defineProperty(exports, 'EffectCube', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_effectCube).default;
  }
});

var _effectFlip = __webpack_require__(218);

Object.defineProperty(exports, 'EffectFlip', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_effectFlip).default;
  }
});

var _effectCoverflow = __webpack_require__(219);

Object.defineProperty(exports, 'EffectCoverflow', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_effectCoverflow).default;
  }
});

var _thumbs = __webpack_require__(220);

Object.defineProperty(exports, 'Thumbs', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_thumbs).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 129:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var View = function () {
    function View() {
        _classCallCheck(this, View);

        if (View._constructor) {
            throw new Error("Use View.getInstance() to get View's instance.");
        }

        this._onWindowRsize = this._onWindowRsize.bind(this);

        this._desktop = false;
        this._desktopMini = false;
        this._desktopSmall = false;
        this._desktopBase = false;
        this._phone = false;
        this._tablet = false;
        this._landscape = false;

        this._html = document.querySelector("html");

        window.addEventListener("resize", this._onWindowRsize, false);

        this._resize();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Public methods
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    _createClass(View, [{
        key: "isDesktop",
        value: function isDesktop() {
            return this._desktop;
        }
    }, {
        key: "isDesktopMini",
        value: function isDesktopMini() {
            return this._desktopMini;
        }
    }, {
        key: "isDesktopSmall",
        value: function isDesktopSmall() {
            return this._desktopSmall;
        }
    }, {
        key: "isDesktopBase",
        value: function isDesktopBase() {
            return this._desktopBase;
        }
    }, {
        key: "isLandscape",
        value: function isLandscape() {
            return this._landscape;
        }
    }, {
        key: "isMobile",
        value: function isMobile() {
            return this._phone || this._tablet;
        }
    }, {
        key: "isPhone",
        value: function isPhone() {
            return this._phone;
        }
    }, {
        key: "isPortrait",
        value: function isPortrait() {
            return !this._landscape;
        }
    }, {
        key: "isTablet",
        value: function isTablet() {
            return this._tablet;
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Private methods
        //
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }, {
        key: "_resize",
        value: function _resize() {
            this._desktop = window.matchMedia("(min-width: 1025px)").matches;
            this._desktopMini = window.matchMedia("(min-width: 1025px) and (max-width: 1279px)").matches;
            this._desktopSmall = window.matchMedia("(min-width: 1025px) and (max-width: 1440px)").matches;
            this._desktopBase = window.matchMedia("(min-width: 1280px)").matches;
            this._phone = window.matchMedia("(max-width: 767px)").matches;
            this._tablet = window.matchMedia("(min-width: 768px) and (max-width: 1024px)").matches;
            this._landscape = window.innerWidth >= window.innerHeight;

            var orientationChanged = !(this._landscape && this._html.classList.contains("landscape") || !this._landscape && this._html.classList.contains("portrait"));

            if (orientationChanged) {
                this._html.classList.remove("landscape");
                this._html.classList.remove("portrait");

                this._html.classList.add(this._landscape ? "landscape" : "portrait");
            }
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //
        //  Event listeners
        //
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }, {
        key: "_onWindowRsize",
        value: function _onWindowRsize(e) {
            this._resize();
        }
    }]);

    return View;
}();

View._constructor = true;
View._instance = null;

View.getInstance = function () {
    if (!View._instance) {
        View._constructor = false;
        View._instance = new View();
        View._constructor = true;
    }

    return View._instance;
};

exports.default = View;

/***/ }),

/***/ 130:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSupport = undefined;

var _ssrWindow = __webpack_require__(5);

var support;

function calcSupport() {
  var window = (0, _ssrWindow.getWindow)();
  var document = (0, _ssrWindow.getDocument)();
  return {
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
    observer: function checkObserver() {
      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
    }(),
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;

      try {
        var opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get: function get() {
            supportsPassive = true;
          }
        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!support) {
    support = calcSupport();
  }

  return support;
}

exports.getSupport = getSupport;

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var _importsLoaderGlobalWindowLory = __webpack_require__(122);

var toggleMouseEvent = __webpack_require__(114);
var footer = __webpack_require__(113);
var player, playBtn;
var common = __webpack_require__(83);

var LoryAutoplay = __webpack_require__(124);
var caseStudyVideo = __webpack_require__(125);

common.init();
toggleMouseEvent.init();
footer.init();
caseStudyVideo.init();

var slider = document.querySelector(".js_slider");

if (slider) {
    var lorySlider = (0, _importsLoaderGlobalWindowLory.lory)(slider, {
        infinite: 1,
        enableMouseEvents: true
    });

    var autoplay = new LoryAutoplay();
    var startAutoplay = autoplay.init.bind(autoplay, lorySlider, 3000);
    startAutoplay();

    slider.addEventListener("mouseout", function () {
        startAutoplay();
    });

    slider.addEventListener("mouseover", function () {
        autoplay.destroy();
    });
}

/***/ }),

/***/ 135:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

var _getSupport = __webpack_require__(130);

var _getDevice = __webpack_require__(137);

var _getBrowser = __webpack_require__(138);

var _resize = __webpack_require__(139);

var _resize2 = _interopRequireDefault(_resize);

var _observer = __webpack_require__(140);

var _observer2 = _interopRequireDefault(_observer);

var _modular = __webpack_require__(141);

var _modular2 = _interopRequireDefault(_modular);

var _eventsEmitter = __webpack_require__(142);

var _eventsEmitter2 = _interopRequireDefault(_eventsEmitter);

var _index = __webpack_require__(143);

var _index2 = _interopRequireDefault(_index);

var _index3 = __webpack_require__(153);

var _index4 = _interopRequireDefault(_index3);

var _index5 = __webpack_require__(159);

var _index6 = _interopRequireDefault(_index5);

var _index7 = __webpack_require__(163);

var _index8 = _interopRequireDefault(_index7);

var _index9 = __webpack_require__(171);

var _index10 = _interopRequireDefault(_index9);

var _index11 = __webpack_require__(175);

var _index12 = _interopRequireDefault(_index11);

var _index13 = __webpack_require__(178);

var _index14 = _interopRequireDefault(_index13);

var _index15 = __webpack_require__(184);

var _index16 = _interopRequireDefault(_index15);

var _index17 = __webpack_require__(191);

var _index18 = _interopRequireDefault(_index17);

var _index19 = __webpack_require__(194);

var _index20 = _interopRequireDefault(_index19);

var _index21 = __webpack_require__(197);

var _index22 = _interopRequireDefault(_index21);

var _index23 = __webpack_require__(200);

var _index24 = _interopRequireDefault(_index23);

var _defaults = __webpack_require__(201);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;
}

/* eslint no-param-reassign: "off" */

var prototypes = {
  modular: _modular2.default,
  eventsEmitter: _eventsEmitter2.default,
  update: _index2.default,
  translate: _index4.default,
  transition: _index6.default,
  slide: _index8.default,
  loop: _index10.default,
  grabCursor: _index12.default,
  manipulation: _index14.default,
  events: _index16.default,
  breakpoints: _index18.default,
  checkOverflow: _index24.default,
  classes: _index20.default,
  images: _index22.default
};
var extendedDefaults = {};

var Swiper = /*#__PURE__*/function () {
  function Swiper() {
    var el;
    var params;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      el = args[0];
      params = args[1];
    }

    if (!params) params = {};
    params = (0, _utils.extend)({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && (0, _dom2.default)(params.el).length > 1) {
      var swipers = [];
      (0, _dom2.default)(params.el).each(function (containerEl) {
        var newParams = (0, _utils.extend)({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    } // Swiper Instance


    var swiper = this;
    swiper.__swiper__ = true;
    swiper.support = (0, _getSupport.getSupport)();
    swiper.device = (0, _getDevice.getDevice)({
      userAgent: params.userAgent
    });
    swiper.browser = (0, _getBrowser.getBrowser)();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];

    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }

    Object.keys(swiper.modules).forEach(function (moduleName) {
      var module = swiper.modules[moduleName];

      if (module.params) {
        var moduleParamName = Object.keys(module.params)[0];
        var moduleParams = module.params[moduleParamName];
        if ((typeof moduleParams === 'undefined' ? 'undefined' : _typeof(moduleParams)) !== 'object' || moduleParams === null) return;

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (_typeof(params[moduleParamName]) === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
      }
    }); // Extend defaults with modules params

    var swiperParams = (0, _utils.extend)({}, _defaults2.default);
    swiper.useParams(swiperParams); // Extend defaults with passed params

    swiper.params = (0, _utils.extend)({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = (0, _utils.extend)({}, swiper.params);
    swiper.passedParams = (0, _utils.extend)({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(function (eventName) {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = _dom2.default; // Extend Swiper

    (0, _utils.extend)(swiper, {
      enabled: swiper.params.enabled,
      el: el,
      // Classes
      classNames: [],
      // Slides
      slides: (0, _dom2.default)(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal: function isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical: function isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        var desktop = ['mousedown', 'mousemove', 'mouseup'];

        if (swiper.support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }

        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: (0, _utils.now)(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }); // Install Modules

    swiper.useModules();
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance


    return swiper;
  }

  var _proto = Swiper.prototype;

  _proto.enable = function enable() {
    var swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;

    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    swiper.emit('enable');
  };

  _proto.disable = function disable() {
    var swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;

    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }

    swiper.emit('disable');
  };

  _proto.setProgress = function setProgress(progress, speed) {
    var swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    var min = swiper.minTranslate();
    var max = swiper.maxTranslate();
    var current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  };

  _proto.emitContainerClasses = function emitContainerClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    var classes = swiper.el.className.split(' ').filter(function (className) {
      return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', classes.join(' '));
  };

  _proto.getSlideClasses = function getSlideClasses(slideEl) {
    var swiper = this;
    return slideEl.className.split(' ').filter(function (className) {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  };

  _proto.emitSlidesClasses = function emitSlidesClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    var updates = [];
    swiper.slides.each(function (slideEl) {
      var classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl: slideEl,
        classNames: classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  };

  _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
    var swiper = this;
    var params = swiper.params,
        slides = swiper.slides,
        slidesGrid = swiper.slidesGrid,
        swiperSize = swiper.size,
        activeIndex = swiper.activeIndex;
    var spv = 1;

    if (params.centeredSlides) {
      var slideSize = slides[activeIndex].swiperSlideSize;
      var breakLoop;

      for (var i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }

      for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
        if (slides[_i] && !breakLoop) {
          slideSize += slides[_i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
        if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }

    return spv;
  };

  _proto.update = function update() {
    var swiper = this;
    if (!swiper || swiper.destroyed) return;
    var snapGrid = swiper.snapGrid,
        params = swiper.params; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    var translated;

    if (swiper.params.freeMode) {
      setTranslate();

      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (!translated) {
        setTranslate();
      }
    }

    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }

    swiper.emit('update');
  };

  _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }

    var swiper = this;
    var currentDirection = swiper.params.direction;

    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }

    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }

    swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(function (slideEl) {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  };

  _proto.mount = function mount(el) {
    var swiper = this;
    if (swiper.mounted) return true; // Find el

    var $el = (0, _dom2.default)(el || swiper.params.el);
    el = $el[0];

    if (!el) {
      return false;
    }

    el.swiper = swiper;

    var getWrapperSelector = function getWrapperSelector() {
      return "." + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
    };

    var getWrapper = function getWrapper() {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        var res = (0, _dom2.default)(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

        res.children = function (options) {
          return $el.children(options);
        };

        return res;
      }

      return $el.children(getWrapperSelector());
    }; // Find Wrapper


    var $wrapperEl = getWrapper();

    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      var document = (0, _ssrWindow.getDocument)();
      var wrapper = document.createElement('div');
      $wrapperEl = (0, _dom2.default)(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children("." + swiper.params.slideClass).each(function (slideEl) {
        $wrapperEl.append(slideEl);
      });
    }

    (0, _utils.extend)(swiper, {
      $el: $el,
      el: el,
      $wrapperEl: $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box'
    });
    return true;
  };

  _proto.init = function init(el) {
    var swiper = this;
    if (swiper.initialized) return swiper;
    var mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit'); // Set breakpoint

    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    } // Add Classes


    swiper.addClasses(); // Create loop

    if (swiper.params.loop) {
      swiper.loopCreate();
    } // Update size


    swiper.updateSize(); // Update slides

    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    } // Set Grab Cursor


    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    } // Slide To Initial Slide


    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    } // Attach events


    swiper.attachEvents(); // Init Flag

    swiper.initialized = true; // Emit

    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  };

  _proto.destroy = function destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }

    if (cleanStyles === void 0) {
      cleanStyles = true;
    }

    var swiper = this;
    var params = swiper.params,
        $el = swiper.$el,
        $wrapperEl = swiper.$wrapperEl,
        slides = swiper.slides;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy'); // Init Flag

    swiper.initialized = false; // Detach events

    swiper.detachEvents(); // Destroy loop

    if (params.loop) {
      swiper.loopDestroy();
    } // Cleanup styles


    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');

      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy'); // Detach emitter events

    Object.keys(swiper.eventsListeners).forEach(function (eventName) {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      (0, _utils.deleteProps)(swiper);
    }

    swiper.destroyed = true;
    return null;
  };

  Swiper.extendDefaults = function extendDefaults(newDefaults) {
    (0, _utils.extend)(extendedDefaults, newDefaults);
  };

  Swiper.installModule = function installModule(module) {
    if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
    var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + (0, _utils.now)();
    Swiper.prototype.modules[name] = module;
  };

  Swiper.use = function use(module) {
    if (Array.isArray(module)) {
      module.forEach(function (m) {
        return Swiper.installModule(m);
      });
      return Swiper;
    }

    Swiper.installModule(module);
    return Swiper;
  };

  _createClass(Swiper, null, [{
    key: "extendedDefaults",
    get: function get() {
      return extendedDefaults;
    }
  }, {
    key: "defaults",
    get: function get() {
      return _defaults2.default;
    }
  }]);

  return Swiper;
}();

Object.keys(prototypes).forEach(function (prototypeGroup) {
  Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([_resize2.default, _observer2.default]);
exports.default = Swiper;

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.width = exports.value = exports.val = exports.trigger = exports.transitionEnd = exports.transition = exports.transform = exports.touchstart = exports.touchmove = exports.touchend = exports.toggleClass = exports.text = exports.submit = exports.styles = exports.stop = exports.siblings = exports.show = exports.scrollTop = exports.scrollTo = exports.scrollLeft = exports.scroll = exports.resize = exports.removeData = exports.removeClass = exports.removeAttr = exports.remove = exports.prop = exports.prevAll = exports.prev = exports.prependTo = exports.prepend = exports.parents = exports.parent = exports.outerWidth = exports.outerHeight = exports.once = exports.on = exports.offset = exports.off = exports.nextAll = exports.next = exports.mouseup = exports.mouseover = exports.mouseout = exports.mousemove = exports.mouseleave = exports.mouseenter = exports.mousedown = exports.keyup = exports.keypress = exports.keydown = exports.is = exports.insertBefore = exports.insertAfter = exports.index = exports.html = exports.hide = exports.height = exports.hasClass = exports.focusout = exports.focusin = exports.focus = exports.find = exports.filter = exports.eq = exports.empty = exports.each = exports.detach = exports.dataset = exports.data = exports.css = exports.closest = exports.click = exports.children = exports.change = exports.blur = exports.attr = exports.appendTo = exports.append = exports.animationEnd = exports.animate = exports.addClass = exports.add = exports.$ = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**
                                                                                                                                                                                                                                                                   * Dom7 3.0.0
                                                                                                                                                                                                                                                                   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
                                                                                                                                                                                                                                                                   * https://framework7.io/docs/dom7.html
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Copyright 2020, Vladimir Kharlampidi
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Licensed under MIT
                                                                                                                                                                                                                                                                   *
                                                                                                                                                                                                                                                                   * Released on: November 9, 2020
                                                                                                                                                                                                                                                                   */


var _ssrWindow = __webpack_require__(5);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/* eslint-disable no-proto */
function makeReactive(obj) {
  var proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get: function get() {
      return proto;
    },
    set: function set(value) {
      proto.__proto__ = value;
    }
  });
}

var Dom7 = /*#__PURE__*/function (_Array) {
  _inheritsLoose(Dom7, _Array);

  function Dom7(items) {
    var _this;

    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }

  return Dom7;
}( /*#__PURE__*/_wrapNativeSuper(Array));

function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }

  var res = [];
  arr.forEach(function (el) {
    if (Array.isArray(el)) {
      res.push.apply(res, arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  var uniqueArray = [];

  for (var i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, function (match, group) {
    return group.toUpperCase();
  });
}

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  var a = [];
  var res = context.querySelectorAll(selector);

  for (var i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function $(selector, context) {
  var window = (0, _ssrWindow.getWindow)();
  var document = (0, _ssrWindow.getDocument)();
  var arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    var html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      var toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      var tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);
  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

$.fn = Dom7.prototype;

function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList;

    (_el$classList = el.classList).add.apply(_el$classList, classNames);
  });
  return this;
}

function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList2;

    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}

function toggleClass() {
  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    classes[_key3] = arguments[_key3];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    classNames.forEach(function (className) {
      el.classList.toggle(className);
    });
  });
}

function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  return arrayFilter(this, function (el) {
    return classNames.filter(function (className) {
      return el.classList.contains(className);
    }).length > 0;
  }).length > 0;
}

function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (var i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (var attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (var i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        for (var propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }

    return this;
  }

  return this;
}

function data(key, value) {
  var el;

  if (typeof value === 'undefined') {
    el = this[0];
    if (!el) return undefined; // Get value

    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }

    var dataKey = el.getAttribute("data-" + key);

    if (dataKey) {
      return dataKey;
    }

    return undefined;
  } // Set value


  for (var i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }

  return this;
}

function removeData(key) {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}

function dataset() {
  var el = this[0];
  if (!el) return undefined;
  var dataset = {}; // eslint-disable-line

  if (el.dataset) {
    for (var dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (var i = 0; i < el.attributes.length; i += 1) {
      var _attr = el.attributes[i];

      if (_attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(_attr.name.split('data-')[1])] = _attr.value;
      }
    }
  }

  for (var key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }

  return dataset;
}

function val(value) {
  if (typeof value === 'undefined') {
    // get value
    var el = this[0];
    if (!el) return undefined;

    if (el.multiple && el.nodeName.toLowerCase() === 'select') {
      var values = [];

      for (var i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }

      return values;
    }

    return el.value;
  } // set value


  for (var _i = 0; _i < this.length; _i += 1) {
    var _el = this[_i];

    if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {
      for (var j = 0; j < _el.options.length; j += 1) {
        _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;
      }
    } else {
      _el.value = value;
    }
  }

  return this;
}

function value(value) {
  return this.val(value);
}

function transform(transform) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition(duration) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
  }

  return this;
}

function on() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    var target = e.target;
    if (!target) return;
    var eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
      var _parents = $(target).parents(); // eslint-disable-line


      for (var k = 0; k < _parents.length; k += 1) {
        if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    var eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  var events = eventType.split(' ');
  var j;

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        var event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener: listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        var _event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

        el.dom7LiveListeners[_event].push({
          listener: listener,
          proxyListener: handleLiveEvent
        });

        el.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  var events = eventType.split(' ');

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      var handlers = void 0;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (var k = handlers.length - 1; k >= 0; k -= 1) {
          var handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function once() {
  var dom = this;

  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  var eventName = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventName = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  function onceHandler() {
    for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      eventArgs[_key8] = arguments[_key8];
    }

    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);

    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }

  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}

function trigger() {
  var window = (0, _ssrWindow.getWindow)();

  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  var events = args[0].split(' ');
  var eventData = args[1];

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];

      if (window.CustomEvent) {
        var evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function animationEnd(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('animationend', fireCallBack);
  }

  if (callback) {
    dom.on('animationend', fireCallBack);
  }

  return this;
}

function width() {
  var window = (0, _ssrWindow.getWindow)();

  if (this[0] === window) {
    return window.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}

function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles = this.styles();

      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function height() {
  var window = (0, _ssrWindow.getWindow)();

  if (this[0] === window) {
    return window.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}

function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles2 = this.styles();

      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    var window = (0, _ssrWindow.getWindow)();
    var document = (0, _ssrWindow.getDocument)();
    var el = this[0];
    var box = el.getBoundingClientRect();
    var body = document.body;
    var clientTop = el.clientTop || body.clientTop || 0;
    var clientLeft = el.clientLeft || body.clientLeft || 0;
    var scrollTop = el === window ? window.scrollY : el.scrollTop;
    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function hide() {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }

  return this;
}

function show() {
  var window = (0, _ssrWindow.getWindow)();

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.style.display === 'none') {
      el.style.display = '';
    }

    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }

  return this;
}

function styles() {
  var window = (0, _ssrWindow.getWindow)();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  var window = (0, _ssrWindow.getWindow)();
  var i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (var _prop in props) {
          this[i].style[_prop] = props[_prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach(function (el, index) {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  var result = arrayFilter(this, callback);
  return $(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  var window = (0, _ssrWindow.getWindow)();
  var document = (0, _ssrWindow.getDocument)();
  var el = this[0];
  var compareWith;
  var i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function index() {
  var child = this[0];
  var i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  var length = this.length;

  if (index > length - 1) {
    return $([]);
  }

  if (index < 0) {
    var returnIndex = length + index;
    if (returnIndex < 0) return $([]);
    return $([this[returnIndex]]);
  }

  return $([this[index]]);
}

function append() {
  var newChild;
  var document = (0, _ssrWindow.getDocument)();

  for (var k = 0; k < arguments.length; k += 1) {
    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

    for (var i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function appendTo(parent) {
  $(parent).append(this);
  return this;
}

function prepend(newChild) {
  var document = (0, _ssrWindow.getDocument)();
  var i;
  var j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}

function insertBefore(selector) {
  var before = $(selector);

  for (var i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (var j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}

function insertAfter(selector) {
  var after = $(selector);

  for (var i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (var j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }

      return $([]);
    }

    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
    return $([]);
  }

  return $([]);
}

function nextAll(selector) {
  var nextEls = [];
  var el = this[0];
  if (!el) return $([]);

  while (el.nextElementSibling) {
    var _next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if ($(_next).is(selector)) nextEls.push(_next);
    } else nextEls.push(_next);

    el = _next;
  }

  return $(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    var el = this[0];

    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }

      return $([]);
    }

    if (el.previousElementSibling) return $([el.previousElementSibling]);
    return $([]);
  }

  return $([]);
}

function prevAll(selector) {
  var prevEls = [];
  var el = this[0];
  if (!el) return $([]);

  while (el.previousElementSibling) {
    var _prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if ($(_prev).is(selector)) prevEls.push(_prev);
    } else prevEls.push(_prev);

    el = _prev;
  }

  return $(prevEls);
}

function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}

function parent(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return $(parents);
}

function parents(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var _parent = this[i].parentNode; // eslint-disable-line

    while (_parent) {
      if (selector) {
        if ($(_parent).is(selector)) parents.push(_parent);
      } else {
        parents.push(_parent);
      }

      _parent = _parent.parentNode;
    }
  }

  return $(parents);
}

function closest(selector) {
  var closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return $([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find(selector) {
  var foundElements = [];

  for (var i = 0; i < this.length; i += 1) {
    var found = this[i].querySelectorAll(selector);

    for (var j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return $(foundElements);
}

function children(selector) {
  var children = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var childNodes = this[i].children;

    for (var j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return $(children);
}

function remove() {
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

function detach() {
  return this.remove();
}

function add() {
  var dom = this;
  var i;
  var j;

  for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    els[_key10] = arguments[_key10];
  }

  for (i = 0; i < els.length; i += 1) {
    var toAdd = $(els[i]);

    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }

  return dom;
}

function empty() {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.nodeType === 1) {
      for (var j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }

      el.textContent = '';
    }
  }

  return this;
}

function scrollTo() {
  var window = (0, _ssrWindow.getWindow)();

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var left = args[0],
      top = args[1],
      duration = args[2],
      easing = args[3],
      callback = args[4];

  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    left = args[0];
    top = args[1];
    duration = args[2];
    callback = args[3];
    easing = args[4];
  }

  if (typeof easing === 'undefined') easing = 'swing';
  return this.each(function animate() {
    var el = this;
    var currentTop;
    var currentLeft;
    var maxTop;
    var maxLeft;
    var newTop;
    var newLeft;
    var scrollTop; // eslint-disable-line

    var scrollLeft; // eslint-disable-line

    var animateTop = top > 0 || top === 0;
    var animateLeft = left > 0 || left === 0;

    if (typeof easing === 'undefined') {
      easing = 'swing';
    }

    if (animateTop) {
      currentTop = el.scrollTop;

      if (!duration) {
        el.scrollTop = top;
      }
    }

    if (animateLeft) {
      currentLeft = el.scrollLeft;

      if (!duration) {
        el.scrollLeft = left;
      }
    }

    if (!duration) return;

    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }

    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }

    var startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;

    function render(time) {
      if (time === void 0) {
        time = new Date().getTime();
      }

      if (startTime === null) {
        startTime = time;
      }

      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      var done;
      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }

      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      window.requestAnimationFrame(render);
    }

    window.requestAnimationFrame(render);
  });
} // scrollTop(top, duration, easing, callback) {


function scrollTop() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var top = args[0],
      duration = args[1],
      easing = args[2],
      callback = args[3];

  if (args.length === 3 && typeof easing === 'function') {
    top = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }

  var dom = this;

  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }

  return dom.scrollTo(undefined, top, duration, easing, callback);
}

function scrollLeft() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  var left = args[0],
      duration = args[1],
      easing = args[2],
      callback = args[3];

  if (args.length === 3 && typeof easing === 'function') {
    left = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }

  var dom = this;

  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }

  return dom.scrollTo(left, undefined, duration, easing, callback);
}

function animate(initialProps, initialParams) {
  var window = (0, _ssrWindow.getWindow)();
  var els = this;
  var a = {
    props: _extends({}, initialProps),
    params: _extends({
      duration: 300,
      easing: 'swing' // or 'linear'

      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */

    }, initialParams),
    elements: els,
    animating: false,
    que: [],
    easingProgress: function easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }

      if (typeof easing === 'function') {
        return easing(progress);
      }

      return progress;
    },
    stop: function stop() {
      if (a.frameId) {
        window.cancelAnimationFrame(a.frameId);
      }

      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done: function done(complete) {
      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);

      if (a.que.length > 0) {
        var que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate: function animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }

      var elements = []; // Define & Cache Initials & Units

      a.elements.each(function (el, index) {
        var initialFullValue;
        var initialValue;
        var unit;
        var finalValue;
        var finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
        elements[index] = {
          container: el
        };
        Object.keys(props).forEach(function (prop) {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue: initialFullValue,
            initialValue: initialValue,
            unit: unit,
            finalValue: finalValue,
            finalFullValue: finalFullValue,
            currentValue: initialValue
          };
        });
      });
      var startTime = null;
      var time;
      var elementsDone = 0;
      var propsDone = 0;
      var done;
      var began = false;
      a.animating = true;

      function render() {
        time = new Date().getTime();
        var progress;
        var easeProgress; // let el;

        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }

        if (startTime === null) {
          startTime = time;
        }

        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }

        elements.forEach(function (element) {
          var el = element;
          if (done || el.done) return;
          Object.keys(props).forEach(function (prop) {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            var _el$prop = el[prop],
                initialValue = _el$prop.initialValue,
                finalValue = _el$prop.finalValue,
                unit = _el$prop.unit;
            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            var currentValue = el[prop].currentValue;

            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;

              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }

              if (elementsDone === elements.length) {
                done = true;
              }
            }

            if (done) {
              a.done(params.complete);
              return;
            }

            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return; // Then call

        a.frameId = window.requestAnimationFrame(render);
      }

      a.frameId = window.requestAnimationFrame(render);
      return a;
    }
  };

  if (a.elements.length === 0) {
    return els;
  }

  var animateInstance;

  for (var i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }

  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  var els = this;

  for (var i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

var noTrigger = 'resize scroll'.split(' ');

function shortcut(name) {
  function eventHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[0] === 'undefined') {
      for (var i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();else {
            $(this[i]).trigger(name);
          }
        }
      }

      return this;
    }

    return this.on.apply(this, [name].concat(args));
  }

  return eventHandler;
}

var click = shortcut('click');
var blur = shortcut('blur');
var focus = shortcut('focus');
var focusin = shortcut('focusin');
var focusout = shortcut('focusout');
var keyup = shortcut('keyup');
var keydown = shortcut('keydown');
var keypress = shortcut('keypress');
var submit = shortcut('submit');
var change = shortcut('change');
var mousedown = shortcut('mousedown');
var mousemove = shortcut('mousemove');
var mouseup = shortcut('mouseup');
var mouseenter = shortcut('mouseenter');
var mouseleave = shortcut('mouseleave');
var mouseout = shortcut('mouseout');
var mouseover = shortcut('mouseover');
var touchstart = shortcut('touchstart');
var touchend = shortcut('touchend');
var touchmove = shortcut('touchmove');
var resize = shortcut('resize');
var scroll = shortcut('scroll');

exports.default = $;
exports.$ = $;
exports.add = add;
exports.addClass = addClass;
exports.animate = animate;
exports.animationEnd = animationEnd;
exports.append = append;
exports.appendTo = appendTo;
exports.attr = attr;
exports.blur = blur;
exports.change = change;
exports.children = children;
exports.click = click;
exports.closest = closest;
exports.css = css;
exports.data = data;
exports.dataset = dataset;
exports.detach = detach;
exports.each = each;
exports.empty = empty;
exports.eq = eq;
exports.filter = filter;
exports.find = find;
exports.focus = focus;
exports.focusin = focusin;
exports.focusout = focusout;
exports.hasClass = hasClass;
exports.height = height;
exports.hide = hide;
exports.html = html;
exports.index = index;
exports.insertAfter = insertAfter;
exports.insertBefore = insertBefore;
exports.is = is;
exports.keydown = keydown;
exports.keypress = keypress;
exports.keyup = keyup;
exports.mousedown = mousedown;
exports.mouseenter = mouseenter;
exports.mouseleave = mouseleave;
exports.mousemove = mousemove;
exports.mouseout = mouseout;
exports.mouseover = mouseover;
exports.mouseup = mouseup;
exports.next = next;
exports.nextAll = nextAll;
exports.off = off;
exports.offset = offset;
exports.on = on;
exports.once = once;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.parent = parent;
exports.parents = parents;
exports.prepend = prepend;
exports.prependTo = prependTo;
exports.prev = prev;
exports.prevAll = prevAll;
exports.prop = prop;
exports.remove = remove;
exports.removeAttr = removeAttr;
exports.removeClass = removeClass;
exports.removeData = removeData;
exports.resize = resize;
exports.scroll = scroll;
exports.scrollLeft = scrollLeft;
exports.scrollTo = scrollTo;
exports.scrollTop = scrollTop;
exports.show = show;
exports.siblings = siblings;
exports.stop = stop;
exports.styles = styles;
exports.submit = submit;
exports.text = text;
exports.toggleClass = toggleClass;
exports.touchend = touchend;
exports.touchmove = touchmove;
exports.touchstart = touchstart;
exports.transform = transform;
exports.transition = transition;
exports.transitionEnd = transitionEnd;
exports.trigger = trigger;
exports.val = val;
exports.value = value;
exports.width = width;

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDevice = undefined;

var _ssrWindow = __webpack_require__(5);

var _getSupport = __webpack_require__(130);

var device;

function calcDevice(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      userAgent = _ref.userAgent;

  var support = (0, _getSupport.getSupport)();
  var window = (0, _ssrWindow.getWindow)();
  var platform = window.navigator.platform;
  var ua = userAgent || window.navigator.userAgent;
  var device = {
    ios: false,
    android: false
  };
  var screenWidth = window.screen.width;
  var screenHeight = window.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  var windows = platform === 'Win32';
  var macos = platform === 'MacIntel'; // iPadOs 13 fix

  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }

  if (!device) {
    device = calcDevice(overrides);
  }

  return device;
}

exports.getDevice = getDevice;

/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBrowser = undefined;

var _ssrWindow = __webpack_require__(5);

var browser;

function calcBrowser() {
  var window = (0, _ssrWindow.getWindow)();

  function isSafari() {
    var ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isEdge: !!window.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }

  return browser;
}

exports.getBrowser = getBrowser;

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _utils = __webpack_require__(1);

var supportsResizeObserver = function supportsResizeObserver() {
  var window = (0, _ssrWindow.getWindow)();
  return typeof window.ResizeObserver !== 'undefined';
};

exports.default = {
  name: 'resize',
  create: function create() {
    var swiper = this;
    (0, _utils.extend)(swiper, {
      resize: {
        observer: null,
        createObserver: function createObserver() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.resize.observer = new ResizeObserver(function (entries) {
            var width = swiper.width,
                height = swiper.height;
            var newWidth = width;
            var newHeight = height;
            entries.forEach(function (_ref) {
              var contentBoxSize = _ref.contentBoxSize,
                  contentRect = _ref.contentRect,
                  target = _ref.target;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });

            if (newWidth !== width || newHeight !== height) {
              swiper.resize.resizeHandler();
            }
          });
          swiper.resize.observer.observe(swiper.el);
        },
        removeObserver: function removeObserver() {
          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
            swiper.resize.observer.unobserve(swiper.el);
            swiper.resize.observer = null;
          }
        },
        resizeHandler: function resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler: function orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        }
      }
    });
  },
  on: {
    init: function init(swiper) {
      var window = (0, _ssrWindow.getWindow)();

      if (swiper.params.resizeObserver && supportsResizeObserver()) {
        swiper.resize.createObserver();
        return;
      } // Emit resize


      window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy: function destroy(swiper) {
      var window = (0, _ssrWindow.getWindow)();
      swiper.resize.removeObserver();
      window.removeEventListener('resize', swiper.resize.resizeHandler);
      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    }
  }
};

/***/ }),

/***/ 14:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @public
 * @type {Object}
 */

module.exports = {
	isBlendMode: function isBlendMode() {
		if ('CSS' in window && 'supports' in window.CSS) {
			return window.CSS.supports('mix-blend-mode', 'overlay');
		}
		return false;
	},

	isMac: function isMac() {
		return navigator.platform.toUpperCase().indexOf('MAC') > -1;
	},

	isSafari: function isSafari() {
		var ua = navigator.userAgent.toLowerCase();
		return ua.indexOf('safari') != -1 && ua.indexOf('chrome') < 0;
	},

	isAndroid: function isAndroid() {
		return navigator.userAgent.match(/Android/i);
	},

	isBlackBerry: function isBlackBerry() {
		return navigator.userAgent.match(/BlackBerry/i);
	},

	isiOS: function isiOS() {
		return navigator.userAgent.match(/iPhone|iPad|iPod/i) && !window.MSStream;
	},

	isOpera: function isOpera() {
		return navigator.userAgent.match(/Opera Mini/i);
	},

	isWindows: function isWindows() {
		return navigator.userAgent.match(/IEMobile/i);
	},

	isTouch: function isTouch() {
		return this.isAndroid() || this.isBlackBerry() || this.isiOS() || this.isOpera() || this.isWindows();
	}
};

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _utils = __webpack_require__(1);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Observer = {
  attach: function attach(target, options) {
    if (options === void 0) {
      options = {};
    }

    var window = (0, _ssrWindow.getWindow)();
    var swiper = this;
    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    var observer = new ObserverFunc(function (mutations) {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }

      var observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    swiper.observer.observers.push(observer);
  },
  init: function init() {
    var swiper = this;
    if (!swiper.support.observer || !swiper.params.observer) return;

    if (swiper.params.observeParents) {
      var containerParents = swiper.$el.parents();

      for (var i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    } // Observe container


    swiper.observer.attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    swiper.observer.attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.observer.observers.forEach(function (observer) {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  }
};
exports.default = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      observer: _extends({}, Observer, {
        observers: []
      })
    });
  },
  on: {
    init: function init(swiper) {
      swiper.observer.init();
    },
    destroy: function destroy(swiper) {
      swiper.observer.destroy();
    }
  }
};

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

exports.default = {
  useParams: function useParams(instanceParams) {
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        (0, _utils.extend)(instanceParams, module.params);
      }
    });
  },
  useModules: function useModules(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }

    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      } // Module create callback


      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
};

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable no-underscore-dangle */
exports.default = {
  on: function on(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once: function once(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler() {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny: function onAny(handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },
  offAny: function offAny(handler) {
    var self = this;
    if (!self.eventsAnyListeners) return self;
    var index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },
  off: function off(events, handler) {
    var self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit: function emit() {
    var self = this;
    if (!self.eventsListeners) return self;
    var events;
    var data;
    var context;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(function (eventHandler) {
          eventHandler.apply(context, [event].concat(data));
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

/***/ }),

/***/ 143:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _updateSize = __webpack_require__(144);

var _updateSize2 = _interopRequireDefault(_updateSize);

var _updateSlides = __webpack_require__(145);

var _updateSlides2 = _interopRequireDefault(_updateSlides);

var _updateAutoHeight = __webpack_require__(146);

var _updateAutoHeight2 = _interopRequireDefault(_updateAutoHeight);

var _updateSlidesOffset = __webpack_require__(147);

var _updateSlidesOffset2 = _interopRequireDefault(_updateSlidesOffset);

var _updateSlidesProgress = __webpack_require__(148);

var _updateSlidesProgress2 = _interopRequireDefault(_updateSlidesProgress);

var _updateProgress = __webpack_require__(149);

var _updateProgress2 = _interopRequireDefault(_updateProgress);

var _updateSlidesClasses = __webpack_require__(150);

var _updateSlidesClasses2 = _interopRequireDefault(_updateSlidesClasses);

var _updateActiveIndex = __webpack_require__(151);

var _updateActiveIndex2 = _interopRequireDefault(_updateActiveIndex);

var _updateClickedSlide = __webpack_require__(152);

var _updateClickedSlide2 = _interopRequireDefault(_updateClickedSlide);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  updateSize: _updateSize2.default,
  updateSlides: _updateSlides2.default,
  updateAutoHeight: _updateAutoHeight2.default,
  updateSlidesOffset: _updateSlidesOffset2.default,
  updateSlidesProgress: _updateSlidesProgress2.default,
  updateProgress: _updateProgress2.default,
  updateSlidesClasses: _updateSlidesClasses2.default,
  updateActiveIndex: _updateActiveIndex2.default,
  updateClickedSlide: _updateClickedSlide2.default
};

/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateSize;

var _utils = __webpack_require__(1);

function updateSize() {
  var swiper = this;
  var width;
  var height;
  var $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  (0, _utils.extend)(swiper, {
    width: width,
    height: height,
    size: swiper.isHorizontal() ? width : height
  });
}

/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateSlides;

var _utils = __webpack_require__(1);

function updateSlides() {
  var swiper = this;

  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }

  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }

  var params = swiper.params;
  var $wrapperEl = swiper.$wrapperEl,
      swiperSize = swiper.size,
      rtl = swiper.rtlTranslate,
      wrongRTL = swiper.wrongRTL;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  var slides = $wrapperEl.children("." + swiper.params.slideClass);
  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  var snapGrid = [];
  var slidesGrid = [];
  var slidesSizesGrid = [];
  var offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  var offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  var previousSnapGridLength = swiper.snapGrid.length;
  var previousSlidesGridLength = swiper.slidesGrid.length;
  var spaceBetween = params.spaceBetween;
  var slidePosition = -offsetBefore;
  var prevSlideSize = 0;
  var index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginBottom: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: '',
    marginTop: ''
  });
  var slidesNumberEvenToRows;

  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }

    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  } // Calc slides


  var slideSize;
  var slidesPerColumn = params.slidesPerColumn;
  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

  for (var i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    var slide = slides.eq(i);

    if (params.slidesPerColumn > 1) {
      // Set slides order
      var newSlideOrderIndex = void 0;
      var column = void 0;
      var row = void 0;

      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
        slide.css({
          '-webkit-box-ordinal-group': newSlideOrderIndex,
          '-moz-box-ordinal-group': newSlideOrderIndex,
          '-ms-flex-order': newSlideOrderIndex,
          '-webkit-order': newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - column * slidesPerColumn;

        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
          row += 1;

          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }

      slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : '');
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      var slideStyles = getComputedStyle(slide[0]);
      var currentTransform = slide[0].style.transform;
      var currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        var width = getDirectionPropertyValue(slideStyles, 'width');
        var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        var boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          var _slide$ = slide[0],
              clientWidth = _slide$.clientWidth,
              offsetWidth = _slide$.offsetWidth;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = slideSize + "px";
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  var newSlidesGrid;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: swiper.virtualSize + params.spaceBetween + "px"
    });
  }

  if (params.setWrapperSize) {
    var _$wrapperEl$css;

    $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
  }

  if (params.slidesPerColumn > 1) {
    var _$wrapperEl$css2;

    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));

    if (params.centeredSlides) {
      newSlidesGrid = [];

      for (var _i = 0; _i < snapGrid.length; _i += 1) {
        var slidesGridItem = snapGrid[_i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }

      snapGrid = newSlidesGrid;
    }
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    newSlidesGrid = [];

    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
      var _slidesGridItem = snapGrid[_i2];
      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(_slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    var _slides$filter$css;

    var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter(function (_, slideIndex) {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    var allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    var maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(function (snap) {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    var _allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    _allSlidesSize -= params.spaceBetween;

    if (_allSlidesSize < swiperSize) {
      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
      snapGrid.forEach(function (snap, snapIndex) {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach(function (snap, snapIndex) {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  (0, _utils.extend)(swiper, {
    slides: slides,
    snapGrid: snapGrid,
    slidesGrid: slidesGrid,
    slidesSizesGrid: slidesSizesGrid
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateAutoHeight;
function updateAutoHeight(speed) {
  var swiper = this;
  var activeSlides = [];
  var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  var newHeight = 0;
  var i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }

  var getSlideByIndex = function getSlideByIndex(index) {
    if (isVirtual) {
      return swiper.slides.filter(function (el) {
        return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
      })[0];
    }

    return swiper.slides.eq(index)[0];
  }; // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(function (slide) {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      var height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
}

/***/ }),

/***/ 147:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateSlidesOffset;
function updateSlidesOffset() {
  var swiper = this;
  var slides = swiper.slides;

  for (var i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

/***/ }),

/***/ 148:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateSlidesProgress;

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }

  var swiper = this;
  var params = swiper.params;
  var slides = swiper.slides,
      rtl = swiper.rtlTranslate;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  var offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (var i = 0; i < slides.length; i += 1) {
    var slide = slides[i];
    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
  }

  swiper.visibleSlides = (0, _dom2.default)(swiper.visibleSlides);
}

/***/ }),

/***/ 149:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateProgress;

var _utils = __webpack_require__(1);

function updateProgress(translate) {
  var swiper = this;

  if (typeof translate === 'undefined') {
    var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  var params = swiper.params;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  var progress = swiper.progress,
      isBeginning = swiper.isBeginning,
      isEnd = swiper.isEnd;
  var wasBeginning = isBeginning;
  var wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  (0, _utils.extend)(swiper, {
    progress: progress,
    isBeginning: isBeginning,
    isEnd: isEnd
  });
  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

/***/ }),

/***/ 15:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var normalizeHeaderName = __webpack_require__(56);
var AxiosError = __webpack_require__(2);
var transitionalDefaults = __webpack_require__(24);
var toFormData = __webpack_require__(25);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(26);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(26);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === 'multipart/form-data') {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? { 'files[]': data } : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: __webpack_require__(68)
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),

/***/ 150:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateSlidesClasses;
function updateSlidesClasses() {
  var swiper = this;
  var slides = swiper.slides,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex,
      realIndex = swiper.realIndex;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
  var activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}

/***/ }),

/***/ 151:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateActiveIndex;

var _utils = __webpack_require__(1);

function updateActiveIndex(newActiveIndex) {
  var swiper = this;
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  var slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      params = swiper.params,
      previousIndex = swiper.activeIndex,
      previousRealIndex = swiper.realIndex,
      previousSnapIndex = swiper.snapIndex;
  var activeIndex = newActiveIndex;
  var snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  (0, _utils.extend)(swiper, {
    snapIndex: snapIndex,
    realIndex: realIndex,
    previousIndex: previousIndex,
    activeIndex: activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

/***/ }),

/***/ 152:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateClickedSlide;

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function updateClickedSlide(e) {
  var swiper = this;
  var params = swiper.params;
  var slide = (0, _dom2.default)(e.target).closest("." + params.slideClass)[0];
  var slideFound = false;
  var slideIndex;

  if (slide) {
    for (var i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt((0, _dom2.default)(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

/***/ }),

/***/ 153:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getTranslate = __webpack_require__(154);

var _getTranslate2 = _interopRequireDefault(_getTranslate);

var _setTranslate = __webpack_require__(155);

var _setTranslate2 = _interopRequireDefault(_setTranslate);

var _minTranslate = __webpack_require__(156);

var _minTranslate2 = _interopRequireDefault(_minTranslate);

var _maxTranslate = __webpack_require__(157);

var _maxTranslate2 = _interopRequireDefault(_maxTranslate);

var _translateTo = __webpack_require__(158);

var _translateTo2 = _interopRequireDefault(_translateTo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  getTranslate: _getTranslate2.default,
  setTranslate: _setTranslate2.default,
  minTranslate: _minTranslate2.default,
  maxTranslate: _maxTranslate2.default,
  translateTo: _translateTo2.default
};

/***/ }),

/***/ 154:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getSwiperTranslate;

var _utils = __webpack_require__(1);

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }

  var swiper = this;
  var params = swiper.params,
      rtl = swiper.rtlTranslate,
      translate = swiper.translate,
      $wrapperEl = swiper.$wrapperEl;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  var currentTranslate = (0, _utils.getTranslate)($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

/***/ }),

/***/ 155:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setTranslate;
function setTranslate(translate, byController) {
  var swiper = this;
  var rtl = swiper.rtlTranslate,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      wrapperEl = swiper.wrapperEl,
      progress = swiper.progress;
  var x = 0;
  var y = 0;
  var z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

/***/ }),

/***/ 156:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = minTranslate;
function minTranslate() {
  return -this.snapGrid[0];
}

/***/ }),

/***/ 157:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = maxTranslate;
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

/***/ }),

/***/ 158:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = translateTo;
function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (translateBounds === void 0) {
    translateBounds = true;
  }

  var swiper = this;
  var params = swiper.params,
      wrapperEl = swiper.wrapperEl;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  var minTranslate = swiper.minTranslate();
  var maxTranslate = swiper.maxTranslate();
  var newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    var isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

/***/ }),

/***/ 159:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setTransition = __webpack_require__(160);

var _setTransition2 = _interopRequireDefault(_setTransition);

var _transitionStart = __webpack_require__(161);

var _transitionStart2 = _interopRequireDefault(_transitionStart);

var _transitionEnd = __webpack_require__(162);

var _transitionEnd2 = _interopRequireDefault(_transitionEnd);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  setTransition: _setTransition2.default,
  transitionStart: _transitionStart2.default,
  transitionEnd: _transitionEnd2.default
};

/***/ }),

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Handlers = __webpack_require__(7);
var viewport = __webpack_require__(20);
var googleAnalytics = __webpack_require__(3);
var popup = __webpack_require__(103);
var RequestEstimateForm = __webpack_require__(44);
var RequestAdviserForm = __webpack_require__(45);
var scrollBlocker = __webpack_require__(10);

/**
 * @private
 */
var isInit = false;
var DOM = {};
var handlers = new Handlers();
var _isShow = false;
var delay = 0;
var requestEstimateForm = new RequestEstimateForm();
var requestAdviserForm = new RequestAdviserForm();
var selectorHide = "";

/**
 * @public
 * @type {Object}
 */
module.exports = {
	init: function init() {
		!isInit && _init();
	},
	show: show,
	hide: hide,
	getDOM: getDOM,
	on: handlers.add.bind(handlers),
	off: handlers.remove.bind(handlers),
	isShow: function isShow() {
		return _isShow;
	}
};

/**
 * @private
 * @type {Function}
 */
function _init() {
	isInit = true;
	popup.init();
	setDOM();
	setSelectorHide();
	setDelay();
	requestEstimateForm.init(DOM.requestEstimate);
	requestAdviserForm.init(DOM.requestAdviser);
	initHandlers();
}

/**
 * @private
 * @type {Function}
 */
function setDOM() {
	DOM.requestEstimate = document.querySelector(".js-request_estimate");
	DOM.requestAdviser = document.querySelector(".js-request_estimate .js-request_success-adviser");
	DOM.requestEstimateContainer = DOM.requestEstimate.querySelector(".js-request_estimate_container");
}

/**
 * @private
 */
function setSelectorHide() {
	if (!_isShow) {
		if (viewport.isDesktop()) {
			selectorHide = "g-hidden";
			DOM.requestEstimate.classList.remove("g-hide");
		} else {
			selectorHide = "g-hide";
			DOM.requestEstimate.classList.remove("g-hidden");
		}

		DOM.requestEstimate.classList.add(selectorHide);
	}
}

/**
 * @private
 */
function setDelay() {
	delay = viewport.isMobile() ? 0 : 300;
}

/**
 * @private
 * @type {Function}
 */
function getDOM() {
	return DOM.requestEstimate;
}

/**
 * @private
 */
function initHandlers() {
	window.addEventListener('resize', onWinResize);

	popup.on("close", hide);

	if (DOM.requestEstimateContainer) {
		DOM.requestEstimateContainer.addEventListener("click", function (e) {
			if (e.target.classList.contains("js-request_estimate_container")) {
				hide();
			}
		});
	}

	requestAdviserForm.on('done', hide);

	var emailLink = document.querySelectorAll(".l-mail-link.b-request_estimate_mail_link");

	if (emailLink) {
		for (var i = 0; i < emailLink.length; i++) {
			var link = emailLink[i];
			link.addEventListener("click", sendGoogleAnalyticsEvent);
		}
	}
}

/**
 * @private
 */
function onWinResize() {
	setSelectorHide();
	setDelay();
}

/**
 * @private
 */
function sendGoogleAnalyticsEvent() {
	googleAnalytics.sendEvent({
		eventCategory: "request",
		eventAction: "email",
		eventLabel: "form"
	});
}

/**
 * @private
 */
function changeFormText(element) {
	var defaultTitle = "Request a Project Estimation";
	var defaultButton = "Send Request";

	if ((typeof element === "undefined" ? "undefined" : _typeof(element)) === "object") {
		_setFormTitle(element.dataset.estimateTitle ? element.dataset.estimateTitle : defaultTitle);
		_setFormButton(element.dataset.estimateButton ? element.dataset.estimateButton : defaultButton);
	} else {
		_setFormTitle(defaultTitle);
		_setFormButton(defaultButton);
	}
}

/**
 * @private
 */
function show(element) {
	if (!_isShow) {
		_isShow = true;
		DOM.requestEstimate.classList.remove(selectorHide);
		changeFormText(element);
		scrollBlocker.scrollOff();
		setTimeout(function () {
			handlers.call("beforeShow");
			DOM.requestEstimate.classList.add("active");
			requestEstimateForm.onShow();

			handlers.call("show");
		}, delay);
	}
}

/**
 * @private
 */
function hide() {
	if (_isShow) {
		_isShow = false;
		DOM.requestEstimate.classList.remove("active");
		requestAdviserForm.clearForm();
		setTimeout(function () {
			handlers.call("beforeHide");
			DOM.requestEstimate.classList.add(selectorHide);
			requestEstimateForm.onHide();
			handlers.call("hide");

			if (requestEstimateForm.isFormStepFirst()) {
				requestEstimateForm.setTitle("Request a Project Estimation");
				requestEstimateForm.hideResult();
			}
		}, delay);

		_gaq.push(["_trackEvent", "popupClose", "click"]);
	}
}

/**
 * @private
 */
function _setFormTitle(title) {
	DOM.requestEstimate.querySelector(".b-request_title span").innerHTML = title;
}

/**
 * @private
 */
function _setFormButton(value) {
	DOM.requestEstimate.querySelector(".js-request_submit input").value = value;
}

/***/ }),

/***/ 160:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setTransition;
function setTransition(duration, byController) {
  var swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

/***/ }),

/***/ 161:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transitionStart;
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var activeIndex = swiper.activeIndex,
      params = swiper.params,
      previousIndex = swiper.previousIndex;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }

    swiper.emit('slideChangeTransitionStart');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

/***/ }),

/***/ 162:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transitionEnd;
function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var activeIndex = swiper.activeIndex,
      previousIndex = swiper.previousIndex,
      params = swiper.params;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }

    swiper.emit('slideChangeTransitionEnd');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

/***/ }),

/***/ 163:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slideTo = __webpack_require__(164);

var _slideTo2 = _interopRequireDefault(_slideTo);

var _slideToLoop = __webpack_require__(165);

var _slideToLoop2 = _interopRequireDefault(_slideToLoop);

var _slideNext = __webpack_require__(166);

var _slideNext2 = _interopRequireDefault(_slideNext);

var _slidePrev = __webpack_require__(167);

var _slidePrev2 = _interopRequireDefault(_slidePrev);

var _slideReset = __webpack_require__(168);

var _slideReset2 = _interopRequireDefault(_slideReset);

var _slideToClosest = __webpack_require__(169);

var _slideToClosest2 = _interopRequireDefault(_slideToClosest);

var _slideToClickedSlide = __webpack_require__(170);

var _slideToClickedSlide2 = _interopRequireDefault(_slideToClickedSlide);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  slideTo: _slideTo2.default,
  slideToLoop: _slideToLoop2.default,
  slideNext: _slideNext2.default,
  slidePrev: _slidePrev2.default,
  slideReset: _slideReset2.default,
  slideToClosest: _slideToClosest2.default,
  slideToClickedSlide: _slideToClickedSlide2.default
};

/***/ }),

/***/ 164:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = slideTo;
function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + (typeof index === 'undefined' ? 'undefined' : _typeof(index)) + "] given.");
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    var indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    var isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  var swiper = this;
  var slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  var params = swiper.params,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      previousIndex = swiper.previousIndex,
      activeIndex = swiper.activeIndex,
      rtl = swiper.rtlTranslate,
      wrapperEl = swiper.wrapperEl,
      enabled = swiper.enabled;

  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }

  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  var translate = -snapGrid[snapIndex]; // Update progress

  swiper.updateProgress(translate); // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      var normalizedTranslate = -Math.floor(translate * 100);
      var normalizedGird = Math.floor(slidesGrid[i] * 100);
      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGird) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  var direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    var t = -translate;

    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

/***/ }),

/***/ 165:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slideToLoop;
function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ 166:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slideNext;
/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      enabled = swiper.enabled;
  if (!enabled) return swiper;
  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/***/ }),

/***/ 167:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slidePrev;
/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      rtlTranslate = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return swiper;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  var translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  var normalizedTranslate = normalize(translate);
  var normalizedSnapGrid = snapGrid.map(function (val) {
    return normalize(val);
  });
  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach(function (snap) {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }

  var prevIndex;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ 168:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slideReset;
/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/***/ }),

/***/ 169:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slideToClosest;
/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (threshold === void 0) {
    threshold = 0.5;
  }

  var swiper = this;
  var index = swiper.activeIndex;
  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    var currentSnap = swiper.snapGrid[snapIndex];
    var nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    var prevSnap = swiper.snapGrid[snapIndex - 1];
    var _currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

/***/ }),

/***/ 1699:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(123);
module.exports = __webpack_require__(1700);


/***/ }),

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ 170:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = slideToClickedSlide;

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function slideToClickedSlide() {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl;
  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  var slideToIndex = swiper.clickedIndex;
  var realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt((0, _dom2.default)(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
        (0, _utils.nextTick)(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
      (0, _utils.nextTick)(function () {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

/***/ }),

/***/ 1700:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(121);

__webpack_require__(1701);

__webpack_require__(133);

__webpack_require__(1702);

/***/ }),

/***/ 1701:
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 1702:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _three = __webpack_require__(1703);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function iosVersion() {
    var agent = navigator.userAgent;
    var iosVers = void 0;
    var dataVers = void 0;

    if (agent.search(/iPhone/) > 0) {

        if ((iosVers = agent.indexOf("OS")) !== -1) {
            dataVers = agent.substring(iosVers + 2, iosVers + 5);

            return parseFloat(dataVers);
        } else {
            return false;
        }
    } else {
        return false;
    }
}

var without3D = false;

var iosVer = iosVersion();

if (iosVer && iosVer < 13) {
    without3D = true;
}

if (!without3D) {

    window.THREE = THREE;

    __webpack_require__(1704);
    // require('./portfolio/burger-king/RGBELoader');
    //     require('./portfolio/burger-king/WebGL');
    // require('./portfolio/burger-king/CopyShader');
    // require('./portfolio/burger-king/FilmShader');
    // require('./portfolio/burger-king/EffectComposer');
    // require('./portfolio/burger-king/ShaderPass');
    // require('./portfolio/burger-king/RenderPass');
    // require('./portfolio/burger-king/FilmPass');
    __webpack_require__(1705);
    __webpack_require__(1711);
}
__webpack_require__(1712);

// const SlideRequestForm = require("./components/request_estimate/slide");
// const slideRequestForm = new SlideRequestForm();
// slideRequestForm.init(document.querySelector(".js-request_estimate-slide"));

/***/ }),

/***/ 1703:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// threejs.org/license
!function (t, e) {
  "object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).THREE = {});
}(undefined, function (t) {
  "use strict";
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) {
    return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
  }), void 0 === Math.sign && (Math.sign = function (t) {
    return t < 0 ? -1 : t > 0 ? 1 : +t;
  }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function get() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    } }), void 0 === Object.assign && (Object.assign = function (t) {
    if (null == t) throw new TypeError("Cannot convert undefined or null to object");for (var e = Object(t), n = 1; n < arguments.length; n++) {
      var r = arguments[n];if (null != r) for (var i in r) {
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
      }
    }return e;
  });var e = 100,
      n = 300,
      r = 301,
      i = 302,
      a = 303,
      o = 304,
      s = 306,
      c = 307,
      l = 1e3,
      u = 1001,
      h = 1002,
      d = 1003,
      p = 1004,
      f = 1005,
      m = 1006,
      v = 1007,
      g = 1008,
      y = 1009,
      x = 1012,
      _ = 1014,
      b = 1015,
      w = 1016,
      M = 1020,
      S = 1022,
      T = 1023,
      E = 1026,
      A = 1027,
      L = 33776,
      R = 33777,
      C = 33778,
      P = 33779,
      I = 35840,
      D = 35841,
      O = 35842,
      N = 35843,
      B = 37492,
      z = 37496,
      G = 2300,
      F = 2301,
      U = 2302,
      H = 2400,
      k = 2401,
      V = 2402,
      W = 2500,
      j = 2501,
      q = 3e3,
      X = 3001,
      Y = 3007,
      Z = 3002,
      J = 3004,
      Q = 3005,
      K = 3006,
      $ = 7680,
      tt = 35044,
      et = 35048,
      nt = "300 es";function rt() {}_extends(rt.prototype, { addEventListener: function addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});var n = this._listeners;void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }, hasEventListener: function hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;var n = this._listeners;return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }, removeEventListener: function removeEventListener(t, e) {
      if (void 0 !== this._listeners) {
        var n = this._listeners[t];if (void 0 !== n) {
          var r = n.indexOf(e);-1 !== r && n.splice(r, 1);
        }
      }
    }, dispatchEvent: function dispatchEvent(t) {
      if (void 0 !== this._listeners) {
        var e = this._listeners[t.type];if (void 0 !== e) {
          t.target = this;for (var n = e.slice(0), r = 0, i = n.length; r < i; r++) {
            n[r].call(this, t);
          }
        }
      }
    } });for (var it = [], at = 0; at < 256; at++) {
    it[at] = (at < 16 ? "0" : "") + at.toString(16);
  }var ot = 1234567,
      st = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function generateUUID() {
      var t = 4294967295 * Math.random() | 0,
          e = 4294967295 * Math.random() | 0,
          n = 4294967295 * Math.random() | 0,
          r = 4294967295 * Math.random() | 0;return (it[255 & t] + it[t >> 8 & 255] + it[t >> 16 & 255] + it[t >> 24 & 255] + "-" + it[255 & e] + it[e >> 8 & 255] + "-" + it[e >> 16 & 15 | 64] + it[e >> 24 & 255] + "-" + it[63 & n | 128] + it[n >> 8 & 255] + "-" + it[n >> 16 & 255] + it[n >> 24 & 255] + it[255 & r] + it[r >> 8 & 255] + it[r >> 16 & 255] + it[r >> 24 & 255]).toUpperCase();
    }, clamp: function clamp(t, e, n) {
      return Math.max(e, Math.min(n, t));
    }, euclideanModulo: function euclideanModulo(t, e) {
      return (t % e + e) % e;
    }, mapLinear: function mapLinear(t, e, n, r, i) {
      return r + (t - e) * (i - r) / (n - e);
    }, lerp: function lerp(t, e, n) {
      return (1 - n) * t + n * e;
    }, smoothstep: function smoothstep(t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
    }, smootherstep: function smootherstep(t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
    }, randInt: function randInt(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    }, randFloat: function randFloat(t, e) {
      return t + Math.random() * (e - t);
    }, randFloatSpread: function randFloatSpread(t) {
      return t * (.5 - Math.random());
    }, seededRandom: function seededRandom(t) {
      return void 0 !== t && (ot = t % 2147483647), ((ot = 16807 * ot % 2147483647) - 1) / 2147483646;
    }, degToRad: function degToRad(t) {
      return t * st.DEG2RAD;
    }, radToDeg: function radToDeg(t) {
      return t * st.RAD2DEG;
    }, isPowerOfTwo: function isPowerOfTwo(t) {
      return 0 == (t & t - 1) && 0 !== t;
    }, ceilPowerOfTwo: function ceilPowerOfTwo(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    }, floorPowerOfTwo: function floorPowerOfTwo(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }, setQuaternionFromProperEuler: function setQuaternionFromProperEuler(t, e, n, r, i) {
      var a = Math.cos,
          o = Math.sin,
          s = a(n / 2),
          c = o(n / 2),
          l = a((e + r) / 2),
          u = o((e + r) / 2),
          h = a((e - r) / 2),
          d = o((e - r) / 2),
          p = a((r - e) / 2),
          f = o((r - e) / 2);switch (i) {case "XYX":
          t.set(s * u, c * h, c * d, s * l);break;case "YZY":
          t.set(c * d, s * u, c * h, s * l);break;case "ZXZ":
          t.set(c * h, c * d, s * u, s * l);break;case "XZX":
          t.set(s * u, c * f, c * p, s * l);break;case "YXY":
          t.set(c * p, s * u, c * f, s * l);break;case "ZYZ":
          t.set(c * f, c * p, s * u, s * l);break;default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);}
    } };function ct(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
    }
  }function lt(t, e, n) {
    return e && ct(t.prototype, e), n && ct(t, n), t;
  }function ut(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }function ht(t) {
    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t;
  }var dt,
      pt = function () {
    function t(t, e) {
      void 0 === t && (t = 0), void 0 === e && (e = 0), Object.defineProperty(this, "isVector2", { value: !0 }), this.x = t, this.y = e;
    }var e = t.prototype;return e.set = function (t, e) {
      return this.x = t, this.y = e, this;
    }, e.setScalar = function (t) {
      return this.x = t, this.y = t, this;
    }, e.setX = function (t) {
      return this.x = t, this;
    }, e.setY = function (t) {
      return this.y = t, this;
    }, e.setComponent = function (t, e) {
      switch (t) {case 0:
          this.x = e;break;case 1:
          this.y = e;break;default:
          throw new Error("index is out of range: " + t);}return this;
    }, e.getComponent = function (t) {
      switch (t) {case 0:
          return this.x;case 1:
          return this.y;default:
          throw new Error("index is out of range: " + t);}
    }, e.clone = function () {
      return new this.constructor(this.x, this.y);
    }, e.copy = function (t) {
      return this.x = t.x, this.y = t.y, this;
    }, e.add = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    }, e.addScalar = function (t) {
      return this.x += t, this.y += t, this;
    }, e.addVectors = function (t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    }, e.addScaledVector = function (t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    }, e.sub = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    }, e.subScalar = function (t) {
      return this.x -= t, this.y -= t, this;
    }, e.subVectors = function (t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    }, e.multiply = function (t) {
      return this.x *= t.x, this.y *= t.y, this;
    }, e.multiplyScalar = function (t) {
      return this.x *= t, this.y *= t, this;
    }, e.divide = function (t) {
      return this.x /= t.x, this.y /= t.y, this;
    }, e.divideScalar = function (t) {
      return this.multiplyScalar(1 / t);
    }, e.applyMatrix3 = function (t) {
      var e = this.x,
          n = this.y,
          r = t.elements;return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this;
    }, e.min = function (t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    }, e.max = function (t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    }, e.clamp = function (t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    }, e.clampScalar = function (t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
    }, e.clampLength = function (t, e) {
      var n = this.length();return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }, e.floor = function () {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }, e.ceil = function () {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }, e.round = function () {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }, e.roundToZero = function () {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }, e.negate = function () {
      return this.x = -this.x, this.y = -this.y, this;
    }, e.dot = function (t) {
      return this.x * t.x + this.y * t.y;
    }, e.cross = function (t) {
      return this.x * t.y - this.y * t.x;
    }, e.lengthSq = function () {
      return this.x * this.x + this.y * this.y;
    }, e.length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, e.manhattanLength = function () {
      return Math.abs(this.x) + Math.abs(this.y);
    }, e.normalize = function () {
      return this.divideScalar(this.length() || 1);
    }, e.angle = function () {
      var t = Math.atan2(-this.y, -this.x) + Math.PI;return t;
    }, e.distanceTo = function (t) {
      return Math.sqrt(this.distanceToSquared(t));
    }, e.distanceToSquared = function (t) {
      var e = this.x - t.x,
          n = this.y - t.y;return e * e + n * n;
    }, e.manhattanDistanceTo = function (t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }, e.setLength = function (t) {
      return this.normalize().multiplyScalar(t);
    }, e.lerp = function (t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    }, e.lerpVectors = function (t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
    }, e.equals = function (t) {
      return t.x === this.x && t.y === this.y;
    }, e.fromArray = function (t, e) {
      return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this;
    }, e.toArray = function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
    }, e.fromBufferAttribute = function (t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
    }, e.rotateAround = function (t, e) {
      var n = Math.cos(e),
          r = Math.sin(e),
          i = this.x - t.x,
          a = this.y - t.y;return this.x = i * n - a * r + t.x, this.y = i * r + a * n + t.y, this;
    }, e.random = function () {
      return this.x = Math.random(), this.y = Math.random(), this;
    }, lt(t, [{ key: "width", get: function get() {
        return this.x;
      }, set: function set(t) {
        this.x = t;
      } }, { key: "height", get: function get() {
        return this.y;
      }, set: function set(t) {
        this.y = t;
      } }]), t;
  }(),
      ft = function () {
    function t() {
      Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }var e = t.prototype;return e.set = function (t, e, n, r, i, a, o, s, c) {
      var l = this.elements;return l[0] = t, l[1] = r, l[2] = o, l[3] = e, l[4] = i, l[5] = s, l[6] = n, l[7] = a, l[8] = c, this;
    }, e.identity = function () {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }, e.clone = function () {
      return new this.constructor().fromArray(this.elements);
    }, e.copy = function (t) {
      var e = this.elements,
          n = t.elements;return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
    }, e.extractBasis = function (t, e, n) {
      return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }, e.setFromMatrix4 = function (t) {
      var e = t.elements;return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
    }, e.multiply = function (t) {
      return this.multiplyMatrices(this, t);
    }, e.premultiply = function (t) {
      return this.multiplyMatrices(t, this);
    }, e.multiplyMatrices = function (t, e) {
      var n = t.elements,
          r = e.elements,
          i = this.elements,
          a = n[0],
          o = n[3],
          s = n[6],
          c = n[1],
          l = n[4],
          u = n[7],
          h = n[2],
          d = n[5],
          p = n[8],
          f = r[0],
          m = r[3],
          v = r[6],
          g = r[1],
          y = r[4],
          x = r[7],
          _ = r[2],
          b = r[5],
          w = r[8];return i[0] = a * f + o * g + s * _, i[3] = a * m + o * y + s * b, i[6] = a * v + o * x + s * w, i[1] = c * f + l * g + u * _, i[4] = c * m + l * y + u * b, i[7] = c * v + l * x + u * w, i[2] = h * f + d * g + p * _, i[5] = h * m + d * y + p * b, i[8] = h * v + d * x + p * w, this;
    }, e.multiplyScalar = function (t) {
      var e = this.elements;return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    }, e.determinant = function () {
      var t = this.elements,
          e = t[0],
          n = t[1],
          r = t[2],
          i = t[3],
          a = t[4],
          o = t[5],
          s = t[6],
          c = t[7],
          l = t[8];return e * a * l - e * o * c - n * i * l + n * o * s + r * i * c - r * a * s;
    }, e.getInverse = function (t, e) {
      void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");var n = t.elements,
          r = this.elements,
          i = n[0],
          a = n[1],
          o = n[2],
          s = n[3],
          c = n[4],
          l = n[5],
          u = n[6],
          h = n[7],
          d = n[8],
          p = d * c - l * h,
          f = l * u - d * s,
          m = h * s - c * u,
          v = i * p + a * f + o * m;if (0 === v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);var g = 1 / v;return r[0] = p * g, r[1] = (o * h - d * a) * g, r[2] = (l * a - o * c) * g, r[3] = f * g, r[4] = (d * i - o * u) * g, r[5] = (o * s - l * i) * g, r[6] = m * g, r[7] = (a * u - h * i) * g, r[8] = (c * i - a * s) * g, this;
    }, e.transpose = function () {
      var t,
          e = this.elements;return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
    }, e.getNormalMatrix = function (t) {
      return this.setFromMatrix4(t).getInverse(this).transpose();
    }, e.transposeIntoArray = function (t) {
      var e = this.elements;return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    }, e.setUvTransform = function (t, e, n, r, i, a, o) {
      var s = Math.cos(i),
          c = Math.sin(i);this.set(n * s, n * c, -n * (s * a + c * o) + a + t, -r * c, r * s, -r * (-c * a + s * o) + o + e, 0, 0, 1);
    }, e.scale = function (t, e) {
      var n = this.elements;return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this;
    }, e.rotate = function (t) {
      var e = Math.cos(t),
          n = Math.sin(t),
          r = this.elements,
          i = r[0],
          a = r[3],
          o = r[6],
          s = r[1],
          c = r[4],
          l = r[7];return r[0] = e * i + n * s, r[3] = e * a + n * c, r[6] = e * o + n * l, r[1] = -n * i + e * s, r[4] = -n * a + e * c, r[7] = -n * o + e * l, this;
    }, e.translate = function (t, e) {
      var n = this.elements;return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this;
    }, e.equals = function (t) {
      for (var e = this.elements, n = t.elements, r = 0; r < 9; r++) {
        if (e[r] !== n[r]) return !1;
      }return !0;
    }, e.fromArray = function (t, e) {
      void 0 === e && (e = 0);for (var n = 0; n < 9; n++) {
        this.elements[n] = t[n + e];
      }return this;
    }, e.toArray = function (t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0);var n = this.elements;return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
    }, t;
  }(),
      mt = { getDataURL: function getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;if ("undefined" == typeof HTMLCanvasElement) return t.src;var e;if (t instanceof HTMLCanvasElement) e = t;else {
        void 0 === dt && (dt = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), dt.width = t.width, dt.height = t.height;var n = dt.getContext("2d");t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = dt;
      }return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png");
    } },
      vt = 0;function gt(t, e, n, r, i, a, o, s, c, l) {
    Object.defineProperty(this, "id", { value: vt++ }), this.uuid = st.generateUUID(), this.name = "", this.image = void 0 !== t ? t : gt.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : gt.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : u, this.wrapT = void 0 !== r ? r : u, this.magFilter = void 0 !== i ? i : m, this.minFilter = void 0 !== a ? a : g, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== o ? o : T, this.internalFormat = null, this.type = void 0 !== s ? s : y, this.offset = new pt(0, 0), this.repeat = new pt(1, 1), this.center = new pt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ft(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : q, this.version = 0, this.onUpdate = null;
  }gt.DEFAULT_IMAGE = void 0, gt.DEFAULT_MAPPING = n, gt.prototype = _extends(Object.create(rt.prototype), { constructor: gt, isTexture: !0, updateMatrix: function updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }, clone: function clone() {
      return new this.constructor().copy(this);
    }, copy: function copy(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
    }, toJSON: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t;if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];var n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };if (void 0 !== this.image) {
        var r = this.image;if (void 0 === r.uuid && (r.uuid = st.generateUUID()), !e && void 0 === t.images[r.uuid]) {
          var i;if (Array.isArray(r)) {
            i = [];for (var a = 0, o = r.length; a < o; a++) {
              i.push(mt.getDataURL(r[a]));
            }
          } else i = mt.getDataURL(r);t.images[r.uuid] = { uuid: r.uuid, url: i };
        }n.image = r.uuid;
      }return e || (t.textures[this.uuid] = n), n;
    }, dispose: function dispose() {
      this.dispatchEvent({ type: "dispose" });
    }, transformUv: function transformUv(t) {
      if (this.mapping !== n) return t;if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {case l:
          t.x = t.x - Math.floor(t.x);break;case u:
          t.x = t.x < 0 ? 0 : 1;break;case h:
          1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);}if (t.y < 0 || t.y > 1) switch (this.wrapT) {case l:
          t.y = t.y - Math.floor(t.y);break;case u:
          t.y = t.y < 0 ? 0 : 1;break;case h:
          1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);}return this.flipY && (t.y = 1 - t.y), t;
    } }), Object.defineProperty(gt.prototype, "needsUpdate", { set: function set(t) {
      !0 === t && this.version++;
    } });var yt = function () {
    function t(t, e, n, r) {
      void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), Object.defineProperty(this, "isVector4", { value: !0 }), this.x = t, this.y = e, this.z = n, this.w = r;
    }var e = t.prototype;return e.set = function (t, e, n, r) {
      return this.x = t, this.y = e, this.z = n, this.w = r, this;
    }, e.setScalar = function (t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this;
    }, e.setX = function (t) {
      return this.x = t, this;
    }, e.setY = function (t) {
      return this.y = t, this;
    }, e.setZ = function (t) {
      return this.z = t, this;
    }, e.setW = function (t) {
      return this.w = t, this;
    }, e.setComponent = function (t, e) {
      switch (t) {case 0:
          this.x = e;break;case 1:
          this.y = e;break;case 2:
          this.z = e;break;case 3:
          this.w = e;break;default:
          throw new Error("index is out of range: " + t);}return this;
    }, e.getComponent = function (t) {
      switch (t) {case 0:
          return this.x;case 1:
          return this.y;case 2:
          return this.z;case 3:
          return this.w;default:
          throw new Error("index is out of range: " + t);}
    }, e.clone = function () {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }, e.copy = function (t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
    }, e.add = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    }, e.addScalar = function (t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    }, e.addVectors = function (t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    }, e.addScaledVector = function (t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    }, e.sub = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    }, e.subScalar = function (t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    }, e.subVectors = function (t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    }, e.multiplyScalar = function (t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    }, e.applyMatrix4 = function (t) {
      var e = this.x,
          n = this.y,
          r = this.z,
          i = this.w,
          a = t.elements;return this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i, this;
    }, e.divideScalar = function (t) {
      return this.multiplyScalar(1 / t);
    }, e.setAxisAngleFromQuaternion = function (t) {
      this.w = 2 * Math.acos(t.w);var e = Math.sqrt(1 - t.w * t.w);return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    }, e.setAxisAngleFromRotationMatrix = function (t) {
      var e,
          n,
          r,
          i,
          a = .01,
          o = .1,
          s = t.elements,
          c = s[0],
          l = s[4],
          u = s[8],
          h = s[1],
          d = s[5],
          p = s[9],
          f = s[2],
          m = s[6],
          v = s[10];if (Math.abs(l - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
        if (Math.abs(l + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(c + d + v - 3) < o) return this.set(1, 0, 0, 0), this;e = Math.PI;var g = (c + 1) / 2,
            y = (d + 1) / 2,
            x = (v + 1) / 2,
            _ = (l + h) / 4,
            b = (u + f) / 4,
            w = (p + m) / 4;return g > y && g > x ? g < a ? (n = 0, r = .707106781, i = .707106781) : (r = _ / (n = Math.sqrt(g)), i = b / n) : y > x ? y < a ? (n = .707106781, r = 0, i = .707106781) : (n = _ / (r = Math.sqrt(y)), i = w / r) : x < a ? (n = .707106781, r = .707106781, i = 0) : (n = b / (i = Math.sqrt(x)), r = w / i), this.set(n, r, i, e), this;
      }var M = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));return Math.abs(M) < .001 && (M = 1), this.x = (m - p) / M, this.y = (u - f) / M, this.z = (h - l) / M, this.w = Math.acos((c + d + v - 1) / 2), this;
    }, e.min = function (t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    }, e.max = function (t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    }, e.clamp = function (t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    }, e.clampScalar = function (t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
    }, e.clampLength = function (t, e) {
      var n = this.length();return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }, e.floor = function () {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }, e.ceil = function () {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }, e.round = function () {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }, e.roundToZero = function () {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }, e.negate = function () {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }, e.dot = function (t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }, e.lengthSq = function () {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }, e.length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }, e.manhattanLength = function () {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }, e.normalize = function () {
      return this.divideScalar(this.length() || 1);
    }, e.setLength = function (t) {
      return this.normalize().multiplyScalar(t);
    }, e.lerp = function (t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    }, e.lerpVectors = function (t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
    }, e.equals = function (t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    }, e.fromArray = function (t, e) {
      return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    }, e.toArray = function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    }, e.fromBufferAttribute = function (t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }, e.random = function () {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }, lt(t, [{ key: "width", get: function get() {
        return this.z;
      }, set: function set(t) {
        this.z = t;
      } }, { key: "height", get: function get() {
        return this.w;
      }, set: function set(t) {
        this.w = t;
      } }]), t;
  }();function xt(t, e, n) {
    this.width = t, this.height = e, this.scissor = new yt(0, 0, t, e), this.scissorTest = !1, this.viewport = new yt(0, 0, t, e), n = n || {}, this.texture = new gt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : m, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null;
  }function _t(t, e, n) {
    xt.call(this, t, e, n), this.samples = 4;
  }xt.prototype = _extends(Object.create(rt.prototype), { constructor: xt, isWebGLRenderTarget: !0, setSize: function setSize(t, e) {
      this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }, clone: function clone() {
      return new this.constructor().copy(this);
    }, copy: function copy(t) {
      return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    }, dispose: function dispose() {
      this.dispatchEvent({ type: "dispose" });
    } }), _t.prototype = _extends(Object.create(xt.prototype), { constructor: _t, isWebGLMultisampleRenderTarget: !0, copy: function copy(t) {
      return xt.prototype.copy.call(this, t), this.samples = t.samples, this;
    } });var bt = function () {
    function t(t, e, n, r) {
      void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = t, this._y = e, this._z = n, this._w = r;
    }t.slerp = function (t, e, n, r) {
      return n.copy(t).slerp(e, r);
    }, t.slerpFlat = function (t, e, n, r, i, a, o) {
      var s = n[r + 0],
          c = n[r + 1],
          l = n[r + 2],
          u = n[r + 3],
          h = i[a + 0],
          d = i[a + 1],
          p = i[a + 2],
          f = i[a + 3];if (u !== f || s !== h || c !== d || l !== p) {
        var m = 1 - o,
            v = s * h + c * d + l * p + u * f,
            g = v >= 0 ? 1 : -1,
            y = 1 - v * v;if (y > Number.EPSILON) {
          var x = Math.sqrt(y),
              _ = Math.atan2(x, v * g);m = Math.sin(m * _) / x, o = Math.sin(o * _) / x;
        }var b = o * g;if (s = s * m + h * b, c = c * m + d * b, l = l * m + p * b, u = u * m + f * b, m === 1 - o) {
          var w = 1 / Math.sqrt(s * s + c * c + l * l + u * u);s *= w, c *= w, l *= w, u *= w;
        }
      }t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u;
    }, t.multiplyQuaternionsFlat = function (t, e, n, r, i, a) {
      var o = n[r],
          s = n[r + 1],
          c = n[r + 2],
          l = n[r + 3],
          u = i[a],
          h = i[a + 1],
          d = i[a + 2],
          p = i[a + 3];return t[e] = o * p + l * u + s * d - c * h, t[e + 1] = s * p + l * h + c * u - o * d, t[e + 2] = c * p + l * d + o * h - s * u, t[e + 3] = l * p - o * u - s * h - c * d, t;
    };var e = t.prototype;return e.set = function (t, e, n, r) {
      return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this;
    }, e.clone = function () {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }, e.copy = function (t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
    }, e.setFromEuler = function (t, e) {
      if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");var n = t._x,
          r = t._y,
          i = t._z,
          a = t._order,
          o = Math.cos,
          s = Math.sin,
          c = o(n / 2),
          l = o(r / 2),
          u = o(i / 2),
          h = s(n / 2),
          d = s(r / 2),
          p = s(i / 2);switch (a) {case "XYZ":
          this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;break;case "YXZ":
          this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;break;case "ZXY":
          this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;break;case "ZYX":
          this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;break;case "YZX":
          this._x = h * l * u + c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u - h * d * p;break;case "XZY":
          this._x = h * l * u - c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u + h * d * p;break;default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);}return !1 !== e && this._onChangeCallback(), this;
    }, e.setFromAxisAngle = function (t, e) {
      var n = e / 2,
          r = Math.sin(n);return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
    }, e.setFromRotationMatrix = function (t) {
      var e = t.elements,
          n = e[0],
          r = e[4],
          i = e[8],
          a = e[1],
          o = e[5],
          s = e[9],
          c = e[2],
          l = e[6],
          u = e[10],
          h = n + o + u;if (h > 0) {
        var d = .5 / Math.sqrt(h + 1);this._w = .25 / d, this._x = (l - s) * d, this._y = (i - c) * d, this._z = (a - r) * d;
      } else if (n > o && n > u) {
        var p = 2 * Math.sqrt(1 + n - o - u);this._w = (l - s) / p, this._x = .25 * p, this._y = (r + a) / p, this._z = (i + c) / p;
      } else if (o > u) {
        var f = 2 * Math.sqrt(1 + o - n - u);this._w = (i - c) / f, this._x = (r + a) / f, this._y = .25 * f, this._z = (s + l) / f;
      } else {
        var m = 2 * Math.sqrt(1 + u - n - o);this._w = (a - r) / m, this._x = (i + c) / m, this._y = (s + l) / m, this._z = .25 * m;
      }return this._onChangeCallback(), this;
    }, e.setFromUnitVectors = function (t, e) {
      var n = t.dot(e) + 1;return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
    }, e.angleTo = function (t) {
      return 2 * Math.acos(Math.abs(st.clamp(this.dot(t), -1, 1)));
    }, e.rotateTowards = function (t, e) {
      var n = this.angleTo(t);if (0 === n) return this;var r = Math.min(1, e / n);return this.slerp(t, r), this;
    }, e.identity = function () {
      return this.set(0, 0, 0, 1);
    }, e.inverse = function () {
      return this.conjugate();
    }, e.conjugate = function () {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }, e.dot = function (t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }, e.lengthSq = function () {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }, e.length = function () {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }, e.normalize = function () {
      var t = this.length();return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
    }, e.multiply = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    }, e.premultiply = function (t) {
      return this.multiplyQuaternions(t, this);
    }, e.multiplyQuaternions = function (t, e) {
      var n = t._x,
          r = t._y,
          i = t._z,
          a = t._w,
          o = e._x,
          s = e._y,
          c = e._z,
          l = e._w;return this._x = n * l + a * o + r * c - i * s, this._y = r * l + a * s + i * o - n * c, this._z = i * l + a * c + n * s - r * o, this._w = a * l - n * o - r * s - i * c, this._onChangeCallback(), this;
    }, e.slerp = function (t, e) {
      if (0 === e) return this;if (1 === e) return this.copy(t);var n = this._x,
          r = this._y,
          i = this._z,
          a = this._w,
          o = a * t._w + n * t._x + r * t._y + i * t._z;if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this;var s = 1 - o * o;if (s <= Number.EPSILON) {
        var c = 1 - e;return this._w = c * a + e * this._w, this._x = c * n + e * this._x, this._y = c * r + e * this._y, this._z = c * i + e * this._z, this.normalize(), this._onChangeCallback(), this;
      }var l = Math.sqrt(s),
          u = Math.atan2(l, o),
          h = Math.sin((1 - e) * u) / l,
          d = Math.sin(e * u) / l;return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = i * h + this._z * d, this._onChangeCallback(), this;
    }, e.equals = function (t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    }, e.fromArray = function (t, e) {
      return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
    }, e.toArray = function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    }, e.fromBufferAttribute = function (t, e) {
      return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
    }, e._onChange = function (t) {
      return this._onChangeCallback = t, this;
    }, e._onChangeCallback = function () {}, lt(t, [{ key: "x", get: function get() {
        return this._x;
      }, set: function set(t) {
        this._x = t, this._onChangeCallback();
      } }, { key: "y", get: function get() {
        return this._y;
      }, set: function set(t) {
        this._y = t, this._onChangeCallback();
      } }, { key: "z", get: function get() {
        return this._z;
      }, set: function set(t) {
        this._z = t, this._onChangeCallback();
      } }, { key: "w", get: function get() {
        return this._w;
      }, set: function set(t) {
        this._w = t, this._onChangeCallback();
      } }]), t;
  }(),
      wt = function () {
    function t(t, e, n) {
      void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), Object.defineProperty(this, "isVector3", { value: !0 }), this.x = t, this.y = e, this.z = n;
    }var e = t.prototype;return e.set = function (t, e, n) {
      return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this;
    }, e.setScalar = function (t) {
      return this.x = t, this.y = t, this.z = t, this;
    }, e.setX = function (t) {
      return this.x = t, this;
    }, e.setY = function (t) {
      return this.y = t, this;
    }, e.setZ = function (t) {
      return this.z = t, this;
    }, e.setComponent = function (t, e) {
      switch (t) {case 0:
          this.x = e;break;case 1:
          this.y = e;break;case 2:
          this.z = e;break;default:
          throw new Error("index is out of range: " + t);}return this;
    }, e.getComponent = function (t) {
      switch (t) {case 0:
          return this.x;case 1:
          return this.y;case 2:
          return this.z;default:
          throw new Error("index is out of range: " + t);}
    }, e.clone = function () {
      return new this.constructor(this.x, this.y, this.z);
    }, e.copy = function (t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }, e.add = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    }, e.addScalar = function (t) {
      return this.x += t, this.y += t, this.z += t, this;
    }, e.addVectors = function (t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    }, e.addScaledVector = function (t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    }, e.sub = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    }, e.subScalar = function (t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    }, e.subVectors = function (t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    }, e.multiply = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    }, e.multiplyScalar = function (t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    }, e.multiplyVectors = function (t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    }, e.applyEuler = function (t) {
      return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(St.setFromEuler(t));
    }, e.applyAxisAngle = function (t, e) {
      return this.applyQuaternion(St.setFromAxisAngle(t, e));
    }, e.applyMatrix3 = function (t) {
      var e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements;return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this;
    }, e.applyNormalMatrix = function (t) {
      return this.applyMatrix3(t).normalize();
    }, e.applyMatrix4 = function (t) {
      var e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements,
          a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a, this;
    }, e.applyQuaternion = function (t) {
      var e = this.x,
          n = this.y,
          r = this.z,
          i = t.x,
          a = t.y,
          o = t.z,
          s = t.w,
          c = s * e + a * r - o * n,
          l = s * n + o * e - i * r,
          u = s * r + i * n - a * e,
          h = -i * e - a * n - o * r;return this.x = c * s + h * -i + l * -o - u * -a, this.y = l * s + h * -a + u * -i - c * -o, this.z = u * s + h * -o + c * -a - l * -i, this;
    }, e.project = function (t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
    }, e.unproject = function (t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
    }, e.transformDirection = function (t) {
      var e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements;return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize();
    }, e.divide = function (t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    }, e.divideScalar = function (t) {
      return this.multiplyScalar(1 / t);
    }, e.min = function (t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    }, e.max = function (t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    }, e.clamp = function (t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    }, e.clampScalar = function (t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
    }, e.clampLength = function (t, e) {
      var n = this.length();return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }, e.floor = function () {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }, e.ceil = function () {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }, e.round = function () {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }, e.roundToZero = function () {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }, e.negate = function () {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }, e.dot = function (t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }, e.lengthSq = function () {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }, e.length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }, e.manhattanLength = function () {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }, e.normalize = function () {
      return this.divideScalar(this.length() || 1);
    }, e.setLength = function (t) {
      return this.normalize().multiplyScalar(t);
    }, e.lerp = function (t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    }, e.lerpVectors = function (t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
    }, e.cross = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
    }, e.crossVectors = function (t, e) {
      var n = t.x,
          r = t.y,
          i = t.z,
          a = e.x,
          o = e.y,
          s = e.z;return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this;
    }, e.projectOnVector = function (t) {
      var e = t.lengthSq();if (0 === e) return this.set(0, 0, 0);var n = t.dot(this) / e;return this.copy(t).multiplyScalar(n);
    }, e.projectOnPlane = function (t) {
      return Mt.copy(this).projectOnVector(t), this.sub(Mt);
    }, e.reflect = function (t) {
      return this.sub(Mt.copy(t).multiplyScalar(2 * this.dot(t)));
    }, e.angleTo = function (t) {
      var e = Math.sqrt(this.lengthSq() * t.lengthSq());if (0 === e) return Math.PI / 2;var n = this.dot(t) / e;return Math.acos(st.clamp(n, -1, 1));
    }, e.distanceTo = function (t) {
      return Math.sqrt(this.distanceToSquared(t));
    }, e.distanceToSquared = function (t) {
      var e = this.x - t.x,
          n = this.y - t.y,
          r = this.z - t.z;return e * e + n * n + r * r;
    }, e.manhattanDistanceTo = function (t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    }, e.setFromSpherical = function (t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }, e.setFromSphericalCoords = function (t, e, n) {
      var r = Math.sin(e) * t;return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this;
    }, e.setFromCylindrical = function (t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }, e.setFromCylindricalCoords = function (t, e, n) {
      return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
    }, e.setFromMatrixPosition = function (t) {
      var e = t.elements;return this.x = e[12], this.y = e[13], this.z = e[14], this;
    }, e.setFromMatrixScale = function (t) {
      var e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          r = this.setFromMatrixColumn(t, 2).length();return this.x = e, this.y = n, this.z = r, this;
    }, e.setFromMatrixColumn = function (t, e) {
      return this.fromArray(t.elements, 4 * e);
    }, e.setFromMatrix3Column = function (t, e) {
      return this.fromArray(t.elements, 3 * e);
    }, e.equals = function (t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }, e.fromArray = function (t, e) {
      return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    }, e.toArray = function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    }, e.fromBufferAttribute = function (t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }, e.random = function () {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }, t;
  }(),
      Mt = new wt(),
      St = new bt(),
      Tt = function () {
    function t(t, e) {
      Object.defineProperty(this, "isBox3", { value: !0 }), this.min = void 0 !== t ? t : new wt(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new wt(-1 / 0, -1 / 0, -1 / 0);
    }var e = t.prototype;return e.set = function (t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }, e.setFromArray = function (t) {
      for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
        var l = t[s],
            u = t[s + 1],
            h = t[s + 2];l < e && (e = l), u < n && (n = u), h < r && (r = h), l > i && (i = l), u > a && (a = u), h > o && (o = h);
      }return this.min.set(e, n, r), this.max.set(i, a, o), this;
    }, e.setFromBufferAttribute = function (t) {
      for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = t.count; s < c; s++) {
        var l = t.getX(s),
            u = t.getY(s),
            h = t.getZ(s);l < e && (e = l), u < n && (n = u), h < r && (r = h), l > i && (i = l), u > a && (a = u), h > o && (o = h);
      }return this.min.set(e, n, r), this.max.set(i, a, o), this;
    }, e.setFromPoints = function (t) {
      this.makeEmpty();for (var e = 0, n = t.length; e < n; e++) {
        this.expandByPoint(t[e]);
      }return this;
    }, e.setFromCenterAndSize = function (t, e) {
      var n = Lt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }, e.setFromObject = function (t) {
      return this.makeEmpty(), this.expandByObject(t);
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }, e.makeEmpty = function () {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }, e.isEmpty = function () {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }, e.getCenter = function (t) {
      return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new wt()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
    }, e.getSize = function (t) {
      return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new wt()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }, e.expandByPoint = function (t) {
      return this.min.min(t), this.max.max(t), this;
    }, e.expandByVector = function (t) {
      return this.min.sub(t), this.max.add(t), this;
    }, e.expandByScalar = function (t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }, e.expandByObject = function (t) {
      t.updateWorldMatrix(!1, !1);var e = t.geometry;void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Rt.copy(e.boundingBox), Rt.applyMatrix4(t.matrixWorld), this.union(Rt));for (var n = t.children, r = 0, i = n.length; r < i; r++) {
        this.expandByObject(n[r]);
      }return this;
    }, e.containsPoint = function (t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    }, e.containsBox = function (t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    }, e.getParameter = function (t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new wt()), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
    }, e.intersectsBox = function (t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    }, e.intersectsSphere = function (t) {
      return this.clampPoint(t.center, Lt), Lt.distanceToSquared(t.center) <= t.radius * t.radius;
    }, e.intersectsPlane = function (t) {
      var e, n;return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
    }, e.intersectsTriangle = function (t) {
      if (this.isEmpty()) return !1;this.getCenter(Bt), zt.subVectors(this.max, Bt), Ct.subVectors(t.a, Bt), Pt.subVectors(t.b, Bt), It.subVectors(t.c, Bt), Dt.subVectors(Pt, Ct), Ot.subVectors(It, Pt), Nt.subVectors(Ct, It);var e = [0, -Dt.z, Dt.y, 0, -Ot.z, Ot.y, 0, -Nt.z, Nt.y, Dt.z, 0, -Dt.x, Ot.z, 0, -Ot.x, Nt.z, 0, -Nt.x, -Dt.y, Dt.x, 0, -Ot.y, Ot.x, 0, -Nt.y, Nt.x, 0];return !!Et(e, Ct, Pt, It, zt) && !!Et(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Ct, Pt, It, zt) && (Gt.crossVectors(Dt, Ot), Et(e = [Gt.x, Gt.y, Gt.z], Ct, Pt, It, zt));
    }, e.clampPoint = function (t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new wt()), e.copy(t).clamp(this.min, this.max);
    }, e.distanceToPoint = function (t) {
      return Lt.copy(t).clamp(this.min, this.max).sub(t).length();
    }, e.getBoundingSphere = function (t) {
      return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Lt).length(), t;
    }, e.intersect = function (t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }, e.union = function (t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }, e.applyMatrix4 = function (t) {
      return this.isEmpty() || (At[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), At[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), At[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), At[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), At[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), At[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), At[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), At[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(At)), this;
    }, e.translate = function (t) {
      return this.min.add(t), this.max.add(t), this;
    }, e.equals = function (t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }, t;
  }();function Et(t, e, n, r, i) {
    for (var a = 0, o = t.length - 3; a <= o; a += 3) {
      Ft.fromArray(t, a);var s = i.x * Math.abs(Ft.x) + i.y * Math.abs(Ft.y) + i.z * Math.abs(Ft.z),
          c = e.dot(Ft),
          l = n.dot(Ft),
          u = r.dot(Ft);if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > s) return !1;
    }return !0;
  }var At = [new wt(), new wt(), new wt(), new wt(), new wt(), new wt(), new wt(), new wt()],
      Lt = new wt(),
      Rt = new Tt(),
      Ct = new wt(),
      Pt = new wt(),
      It = new wt(),
      Dt = new wt(),
      Ot = new wt(),
      Nt = new wt(),
      Bt = new wt(),
      zt = new wt(),
      Gt = new wt(),
      Ft = new wt(),
      Ut = new Tt(),
      Ht = function () {
    function t(t, e) {
      this.center = void 0 !== t ? t : new wt(), this.radius = void 0 !== e ? e : -1;
    }var e = t.prototype;return e.set = function (t, e) {
      return this.center.copy(t), this.radius = e, this;
    }, e.setFromPoints = function (t, e) {
      var n = this.center;void 0 !== e ? n.copy(e) : Ut.setFromPoints(t).getCenter(n);for (var r = 0, i = 0, a = t.length; i < a; i++) {
        r = Math.max(r, n.distanceToSquared(t[i]));
      }return this.radius = Math.sqrt(r), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    }, e.isEmpty = function () {
      return this.radius < 0;
    }, e.makeEmpty = function () {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }, e.containsPoint = function (t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }, e.distanceToPoint = function (t) {
      return t.distanceTo(this.center) - this.radius;
    }, e.intersectsSphere = function (t) {
      var e = this.radius + t.radius;return t.center.distanceToSquared(this.center) <= e * e;
    }, e.intersectsBox = function (t) {
      return t.intersectsSphere(this);
    }, e.intersectsPlane = function (t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }, e.clampPoint = function (t, e) {
      var n = this.center.distanceToSquared(t);return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new wt()), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    }, e.getBoundingBox = function (t) {
      return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Tt()), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }, e.applyMatrix4 = function (t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }, e.translate = function (t) {
      return this.center.add(t), this;
    }, e.equals = function (t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }, t;
  }(),
      kt = new wt(),
      Vt = new wt(),
      Wt = new wt(),
      jt = new wt(),
      qt = new wt(),
      Xt = new wt(),
      Yt = new wt(),
      Zt = function () {
    function t(t, e) {
      this.origin = void 0 !== t ? t : new wt(), this.direction = void 0 !== e ? e : new wt(0, 0, -1);
    }var e = t.prototype;return e.set = function (t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }, e.at = function (t, e) {
      return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new wt()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
    }, e.lookAt = function (t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }, e.recast = function (t) {
      return this.origin.copy(this.at(t, kt)), this;
    }, e.closestPointToPoint = function (t, e) {
      void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new wt()), e.subVectors(t, this.origin);var n = e.dot(this.direction);return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
    }, e.distanceToPoint = function (t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }, e.distanceSqToPoint = function (t) {
      var e = kt.subVectors(t, this.origin).dot(this.direction);return e < 0 ? this.origin.distanceToSquared(t) : (kt.copy(this.direction).multiplyScalar(e).add(this.origin), kt.distanceToSquared(t));
    }, e.distanceSqToSegment = function (t, e, n, r) {
      Vt.copy(t).add(e).multiplyScalar(.5), Wt.copy(e).sub(t).normalize(), jt.copy(this.origin).sub(Vt);var i,
          a,
          o,
          s,
          c = .5 * t.distanceTo(e),
          l = -this.direction.dot(Wt),
          u = jt.dot(this.direction),
          h = -jt.dot(Wt),
          d = jt.lengthSq(),
          p = Math.abs(1 - l * l);if (p > 0) {
        if (a = l * u - h, s = c * p, (i = l * h - u) >= 0) {
          if (a >= -s) {
            if (a <= s) {
              var f = 1 / p;o = (i *= f) * (i + l * (a *= f) + 2 * u) + a * (l * i + a + 2 * h) + d;
            } else a = c, o = -(i = Math.max(0, -(l * a + u))) * i + a * (a + 2 * h) + d;
          } else a = -c, o = -(i = Math.max(0, -(l * a + u))) * i + a * (a + 2 * h) + d;
        } else a <= -s ? o = -(i = Math.max(0, -(-l * c + u))) * i + (a = i > 0 ? -c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d : a <= s ? (i = 0, o = (a = Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d) : o = -(i = Math.max(0, -(l * c + u))) * i + (a = i > 0 ? c : Math.min(Math.max(-c, -h), c)) * (a + 2 * h) + d;
      } else a = l > 0 ? -c : c, o = -(i = Math.max(0, -(l * a + u))) * i + a * (a + 2 * h) + d;return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(Wt).multiplyScalar(a).add(Vt), o;
    }, e.intersectSphere = function (t, e) {
      kt.subVectors(t.center, this.origin);var n = kt.dot(this.direction),
          r = kt.dot(kt) - n * n,
          i = t.radius * t.radius;if (r > i) return null;var a = Math.sqrt(i - r),
          o = n - a,
          s = n + a;return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e);
    }, e.intersectsSphere = function (t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }, e.distanceToPlane = function (t) {
      var e = t.normal.dot(this.direction);if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;var n = -(this.origin.dot(t.normal) + t.constant) / e;return n >= 0 ? n : null;
    }, e.intersectPlane = function (t, e) {
      var n = this.distanceToPlane(t);return null === n ? null : this.at(n, e);
    }, e.intersectsPlane = function (t) {
      var e = t.distanceToPoint(this.origin);return 0 === e || t.normal.dot(this.direction) * e < 0;
    }, e.intersectBox = function (t, e) {
      var n,
          r,
          i,
          a,
          o,
          s,
          c = 1 / this.direction.x,
          l = 1 / this.direction.y,
          u = 1 / this.direction.z,
          h = this.origin;return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), l >= 0 ? (i = (t.min.y - h.y) * l, a = (t.max.y - h.y) * l) : (i = (t.max.y - h.y) * l, a = (t.min.y - h.y) * l), n > a || i > r ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), u >= 0 ? (o = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e)));
    }, e.intersectsBox = function (t) {
      return null !== this.intersectBox(t, kt);
    }, e.intersectTriangle = function (t, e, n, r, i) {
      qt.subVectors(e, t), Xt.subVectors(n, t), Yt.crossVectors(qt, Xt);var a,
          o = this.direction.dot(Yt);if (o > 0) {
        if (r) return null;a = 1;
      } else {
        if (!(o < 0)) return null;a = -1, o = -o;
      }jt.subVectors(this.origin, t);var s = a * this.direction.dot(Xt.crossVectors(jt, Xt));if (s < 0) return null;var c = a * this.direction.dot(qt.cross(jt));if (c < 0) return null;if (s + c > o) return null;var l = -a * jt.dot(Yt);return l < 0 ? null : this.at(l / o, i);
    }, e.applyMatrix4 = function (t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    }, e.equals = function (t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }, t;
  }(),
      Jt = function () {
    function t() {
      Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }var e = t.prototype;return e.set = function (t, e, n, r, i, a, o, s, c, l, u, h, d, p, f, m) {
      var v = this.elements;return v[0] = t, v[4] = e, v[8] = n, v[12] = r, v[1] = i, v[5] = a, v[9] = o, v[13] = s, v[2] = c, v[6] = l, v[10] = u, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this;
    }, e.identity = function () {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }, e.clone = function () {
      return new t().fromArray(this.elements);
    }, e.copy = function (t) {
      var e = this.elements,
          n = t.elements;return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
    }, e.copyPosition = function (t) {
      var e = this.elements,
          n = t.elements;return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
    }, e.extractBasis = function (t, e, n) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }, e.makeBasis = function (t, e, n) {
      return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
    }, e.extractRotation = function (t) {
      var e = this.elements,
          n = t.elements,
          r = 1 / Qt.setFromMatrixColumn(t, 0).length(),
          i = 1 / Qt.setFromMatrixColumn(t, 1).length(),
          a = 1 / Qt.setFromMatrixColumn(t, 2).length();return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }, e.makeRotationFromEuler = function (t) {
      t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var e = this.elements,
          n = t.x,
          r = t.y,
          i = t.z,
          a = Math.cos(n),
          o = Math.sin(n),
          s = Math.cos(r),
          c = Math.sin(r),
          l = Math.cos(i),
          u = Math.sin(i);if ("XYZ" === t.order) {
        var h = a * l,
            d = a * u,
            p = o * l,
            f = o * u;e[0] = s * l, e[4] = -s * u, e[8] = c, e[1] = d + p * c, e[5] = h - f * c, e[9] = -o * s, e[2] = f - h * c, e[6] = p + d * c, e[10] = a * s;
      } else if ("YXZ" === t.order) {
        var m = s * l,
            v = s * u,
            g = c * l,
            y = c * u;e[0] = m + y * o, e[4] = g * o - v, e[8] = a * c, e[1] = a * u, e[5] = a * l, e[9] = -o, e[2] = v * o - g, e[6] = y + m * o, e[10] = a * s;
      } else if ("ZXY" === t.order) {
        var x = s * l,
            _ = s * u,
            b = c * l,
            w = c * u;e[0] = x - w * o, e[4] = -a * u, e[8] = b + _ * o, e[1] = _ + b * o, e[5] = a * l, e[9] = w - x * o, e[2] = -a * c, e[6] = o, e[10] = a * s;
      } else if ("ZYX" === t.order) {
        var M = a * l,
            S = a * u,
            T = o * l,
            E = o * u;e[0] = s * l, e[4] = T * c - S, e[8] = M * c + E, e[1] = s * u, e[5] = E * c + M, e[9] = S * c - T, e[2] = -c, e[6] = o * s, e[10] = a * s;
      } else if ("YZX" === t.order) {
        var A = a * s,
            L = a * c,
            R = o * s,
            C = o * c;e[0] = s * l, e[4] = C - A * u, e[8] = R * u + L, e[1] = u, e[5] = a * l, e[9] = -o * l, e[2] = -c * l, e[6] = L * u + R, e[10] = A - C * u;
      } else if ("XZY" === t.order) {
        var P = a * s,
            I = a * c,
            D = o * s,
            O = o * c;e[0] = s * l, e[4] = -u, e[8] = c * l, e[1] = P * u + O, e[5] = a * l, e[9] = I * u - D, e[2] = D * u - I, e[6] = o * l, e[10] = O * u + P;
      }return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }, e.makeRotationFromQuaternion = function (t) {
      return this.compose($t, t, te);
    }, e.lookAt = function (t, e, n) {
      var r = this.elements;return re.subVectors(t, e), 0 === re.lengthSq() && (re.z = 1), re.normalize(), ee.crossVectors(n, re), 0 === ee.lengthSq() && (1 === Math.abs(n.z) ? re.x += 1e-4 : re.z += 1e-4, re.normalize(), ee.crossVectors(n, re)), ee.normalize(), ne.crossVectors(re, ee), r[0] = ee.x, r[4] = ne.x, r[8] = re.x, r[1] = ee.y, r[5] = ne.y, r[9] = re.y, r[2] = ee.z, r[6] = ne.z, r[10] = re.z, this;
    }, e.multiply = function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    }, e.premultiply = function (t) {
      return this.multiplyMatrices(t, this);
    }, e.multiplyMatrices = function (t, e) {
      var n = t.elements,
          r = e.elements,
          i = this.elements,
          a = n[0],
          o = n[4],
          s = n[8],
          c = n[12],
          l = n[1],
          u = n[5],
          h = n[9],
          d = n[13],
          p = n[2],
          f = n[6],
          m = n[10],
          v = n[14],
          g = n[3],
          y = n[7],
          x = n[11],
          _ = n[15],
          b = r[0],
          w = r[4],
          M = r[8],
          S = r[12],
          T = r[1],
          E = r[5],
          A = r[9],
          L = r[13],
          R = r[2],
          C = r[6],
          P = r[10],
          I = r[14],
          D = r[3],
          O = r[7],
          N = r[11],
          B = r[15];return i[0] = a * b + o * T + s * R + c * D, i[4] = a * w + o * E + s * C + c * O, i[8] = a * M + o * A + s * P + c * N, i[12] = a * S + o * L + s * I + c * B, i[1] = l * b + u * T + h * R + d * D, i[5] = l * w + u * E + h * C + d * O, i[9] = l * M + u * A + h * P + d * N, i[13] = l * S + u * L + h * I + d * B, i[2] = p * b + f * T + m * R + v * D, i[6] = p * w + f * E + m * C + v * O, i[10] = p * M + f * A + m * P + v * N, i[14] = p * S + f * L + m * I + v * B, i[3] = g * b + y * T + x * R + _ * D, i[7] = g * w + y * E + x * C + _ * O, i[11] = g * M + y * A + x * P + _ * N, i[15] = g * S + y * L + x * I + _ * B, this;
    }, e.multiplyScalar = function (t) {
      var e = this.elements;return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    }, e.determinant = function () {
      var t = this.elements,
          e = t[0],
          n = t[4],
          r = t[8],
          i = t[12],
          a = t[1],
          o = t[5],
          s = t[9],
          c = t[13],
          l = t[2],
          u = t[6],
          h = t[10],
          d = t[14];return t[3] * (+i * s * u - r * c * u - i * o * h + n * c * h + r * o * d - n * s * d) + t[7] * (+e * s * d - e * c * h + i * a * h - r * a * d + r * c * l - i * s * l) + t[11] * (+e * c * u - e * o * d - i * a * u + n * a * d + i * o * l - n * c * l) + t[15] * (-r * o * l - e * s * u + e * o * h + r * a * u - n * a * h + n * s * l);
    }, e.transpose = function () {
      var t,
          e = this.elements;return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
    }, e.setPosition = function (t, e, n) {
      var r = this.elements;return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this;
    }, e.getInverse = function (t, e) {
      void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");var n = this.elements,
          r = t.elements,
          i = r[0],
          a = r[1],
          o = r[2],
          s = r[3],
          c = r[4],
          l = r[5],
          u = r[6],
          h = r[7],
          d = r[8],
          p = r[9],
          f = r[10],
          m = r[11],
          v = r[12],
          g = r[13],
          y = r[14],
          x = r[15],
          _ = p * y * h - g * f * h + g * u * m - l * y * m - p * u * x + l * f * x,
          b = v * f * h - d * y * h - v * u * m + c * y * m + d * u * x - c * f * x,
          w = d * g * h - v * p * h + v * l * m - c * g * m - d * l * x + c * p * x,
          M = v * p * u - d * g * u - v * l * f + c * g * f + d * l * y - c * p * y,
          S = i * _ + a * b + o * w + s * M;if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);var T = 1 / S;return n[0] = _ * T, n[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * x - a * f * x) * T, n[2] = (l * y * s - g * u * s + g * o * h - a * y * h - l * o * x + a * u * x) * T, n[3] = (p * u * s - l * f * s - p * o * h + a * f * h + l * o * m - a * u * m) * T, n[4] = b * T, n[5] = (d * y * s - v * f * s + v * o * m - i * y * m - d * o * x + i * f * x) * T, n[6] = (v * u * s - c * y * s - v * o * h + i * y * h + c * o * x - i * u * x) * T, n[7] = (c * f * s - d * u * s + d * o * h - i * f * h - c * o * m + i * u * m) * T, n[8] = w * T, n[9] = (v * p * s - d * g * s - v * a * m + i * g * m + d * a * x - i * p * x) * T, n[10] = (c * g * s - v * l * s + v * a * h - i * g * h - c * a * x + i * l * x) * T, n[11] = (d * l * s - c * p * s - d * a * h + i * p * h + c * a * m - i * l * m) * T, n[12] = M * T, n[13] = (d * g * o - v * p * o + v * a * f - i * g * f - d * a * y + i * p * y) * T, n[14] = (v * l * o - c * g * o - v * a * u + i * g * u + c * a * y - i * l * y) * T, n[15] = (c * p * o - d * l * o + d * a * u - i * p * u - c * a * f + i * l * f) * T, this;
    }, e.scale = function (t) {
      var e = this.elements,
          n = t.x,
          r = t.y,
          i = t.z;return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this;
    }, e.getMaxScaleOnAxis = function () {
      var t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];return Math.sqrt(Math.max(e, n, r));
    }, e.makeTranslation = function (t, e, n) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    }, e.makeRotationX = function (t) {
      var e = Math.cos(t),
          n = Math.sin(t);return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }, e.makeRotationY = function (t) {
      var e = Math.cos(t),
          n = Math.sin(t);return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }, e.makeRotationZ = function (t) {
      var e = Math.cos(t),
          n = Math.sin(t);return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }, e.makeRotationAxis = function (t, e) {
      var n = Math.cos(e),
          r = Math.sin(e),
          i = 1 - n,
          a = t.x,
          o = t.y,
          s = t.z,
          c = i * a,
          l = i * o;return this.set(c * a + n, c * o - r * s, c * s + r * o, 0, c * o + r * s, l * o + n, l * s - r * a, 0, c * s - r * o, l * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this;
    }, e.makeScale = function (t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }, e.makeShear = function (t, e, n) {
      return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    }, e.compose = function (t, e, n) {
      var r = this.elements,
          i = e._x,
          a = e._y,
          o = e._z,
          s = e._w,
          c = i + i,
          l = a + a,
          u = o + o,
          h = i * c,
          d = i * l,
          p = i * u,
          f = a * l,
          m = a * u,
          v = o * u,
          g = s * c,
          y = s * l,
          x = s * u,
          _ = n.x,
          b = n.y,
          w = n.z;return r[0] = (1 - (f + v)) * _, r[1] = (d + x) * _, r[2] = (p - y) * _, r[3] = 0, r[4] = (d - x) * b, r[5] = (1 - (h + v)) * b, r[6] = (m + g) * b, r[7] = 0, r[8] = (p + y) * w, r[9] = (m - g) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this;
    }, e.decompose = function (t, e, n) {
      var r = this.elements,
          i = Qt.set(r[0], r[1], r[2]).length(),
          a = Qt.set(r[4], r[5], r[6]).length(),
          o = Qt.set(r[8], r[9], r[10]).length();this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Kt.copy(this);var s = 1 / i,
          c = 1 / a,
          l = 1 / o;return Kt.elements[0] *= s, Kt.elements[1] *= s, Kt.elements[2] *= s, Kt.elements[4] *= c, Kt.elements[5] *= c, Kt.elements[6] *= c, Kt.elements[8] *= l, Kt.elements[9] *= l, Kt.elements[10] *= l, e.setFromRotationMatrix(Kt), n.x = i, n.y = a, n.z = o, this;
    }, e.makePerspective = function (t, e, n, r, i, a) {
      void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");var o = this.elements,
          s = 2 * i / (e - t),
          c = 2 * i / (n - r),
          l = (e + t) / (e - t),
          u = (n + r) / (n - r),
          h = -(a + i) / (a - i),
          d = -2 * a * i / (a - i);return o[0] = s, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
    }, e.makeOrthographic = function (t, e, n, r, i, a) {
      var o = this.elements,
          s = 1 / (e - t),
          c = 1 / (n - r),
          l = 1 / (a - i),
          u = (e + t) * s,
          h = (n + r) * c,
          d = (a + i) * l;return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
    }, e.equals = function (t) {
      for (var e = this.elements, n = t.elements, r = 0; r < 16; r++) {
        if (e[r] !== n[r]) return !1;
      }return !0;
    }, e.fromArray = function (t, e) {
      void 0 === e && (e = 0);for (var n = 0; n < 16; n++) {
        this.elements[n] = t[n + e];
      }return this;
    }, e.toArray = function (t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0);var n = this.elements;return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
    }, t;
  }(),
      Qt = new wt(),
      Kt = new Jt(),
      $t = new wt(0, 0, 0),
      te = new wt(1, 1, 1),
      ee = new wt(),
      ne = new wt(),
      re = new wt(),
      ie = function () {
    function t(e, n, r, i) {
      void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === i && (i = t.DefaultOrder), Object.defineProperty(this, "isEuler", { value: !0 }), this._x = e, this._y = n, this._z = r, this._order = i;
    }var e = t.prototype;return e.set = function (t, e, n, r) {
      return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this;
    }, e.clone = function () {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }, e.copy = function (t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
    }, e.setFromRotationMatrix = function (t, e, n) {
      var r = st.clamp,
          i = t.elements,
          a = i[0],
          o = i[4],
          s = i[8],
          c = i[1],
          l = i[5],
          u = i[9],
          h = i[2],
          d = i[6],
          p = i[10];switch (e = e || this._order) {case "XYZ":
          this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, l), this._z = 0);break;case "YXZ":
          this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, a), this._z = 0);break;case "ZXY":
          this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(c, a));break;case "ZYX":
          this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, l));break;case "YZX":
          this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p));break;case "XZY":
          this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0);break;default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);}return this._order = e, !1 !== n && this._onChangeCallback(), this;
    }, e.setFromQuaternion = function (t, e, n) {
      return ae.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ae, e, n);
    }, e.setFromVector3 = function (t, e) {
      return this.set(t.x, t.y, t.z, e || this._order);
    }, e.reorder = function (t) {
      return oe.setFromEuler(this), this.setFromQuaternion(oe, t);
    }, e.equals = function (t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    }, e.fromArray = function (t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
    }, e.toArray = function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    }, e.toVector3 = function (t) {
      return t ? t.set(this._x, this._y, this._z) : new wt(this._x, this._y, this._z);
    }, e._onChange = function (t) {
      return this._onChangeCallback = t, this;
    }, e._onChangeCallback = function () {}, lt(t, [{ key: "x", get: function get() {
        return this._x;
      }, set: function set(t) {
        this._x = t, this._onChangeCallback();
      } }, { key: "y", get: function get() {
        return this._y;
      }, set: function set(t) {
        this._y = t, this._onChangeCallback();
      } }, { key: "z", get: function get() {
        return this._z;
      }, set: function set(t) {
        this._z = t, this._onChangeCallback();
      } }, { key: "order", get: function get() {
        return this._order;
      }, set: function set(t) {
        this._order = t, this._onChangeCallback();
      } }]), t;
  }();ie.DefaultOrder = "XYZ", ie.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];var ae = new Jt(),
      oe = new bt(),
      se = function () {
    function t() {
      this.mask = 1;
    }var e = t.prototype;return e.set = function (t) {
      this.mask = 1 << t | 0;
    }, e.enable = function (t) {
      this.mask |= 1 << t | 0;
    }, e.enableAll = function () {
      this.mask = -1;
    }, e.toggle = function (t) {
      this.mask ^= 1 << t | 0;
    }, e.disable = function (t) {
      this.mask &= ~(1 << t | 0);
    }, e.disableAll = function () {
      this.mask = 0;
    }, e.test = function (t) {
      return 0 != (this.mask & t.mask);
    }, t;
  }(),
      ce = 0,
      le = new wt(),
      ue = new bt(),
      he = new Jt(),
      de = new wt(),
      pe = new wt(),
      fe = new wt(),
      me = new bt(),
      ve = new wt(1, 0, 0),
      ge = new wt(0, 1, 0),
      ye = new wt(0, 0, 1),
      xe = { type: "added" },
      _e = { type: "removed" };function be() {
    Object.defineProperty(this, "id", { value: ce++ }), this.uuid = st.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = be.DefaultUp.clone();var t = new wt(),
        e = new ie(),
        n = new bt(),
        r = new wt(1, 1, 1);e._onChange(function () {
      n.setFromEuler(e, !1);
    }), n._onChange(function () {
      e.setFromQuaternion(n, void 0, !1);
    }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new Jt() }, normalMatrix: { value: new ft() } }), this.matrix = new Jt(), this.matrixWorld = new Jt(), this.matrixAutoUpdate = be.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new se(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
  }be.DefaultUp = new wt(0, 1, 0), be.DefaultMatrixAutoUpdate = !0, be.prototype = _extends(Object.create(rt.prototype), { constructor: be, isObject3D: !0, onBeforeRender: function onBeforeRender() {}, onAfterRender: function onAfterRender() {}, applyMatrix4: function applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }, applyQuaternion: function applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }, setRotationFromAxisAngle: function setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }, setRotationFromEuler: function setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }, setRotationFromMatrix: function setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }, setRotationFromQuaternion: function setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }, rotateOnAxis: function rotateOnAxis(t, e) {
      return ue.setFromAxisAngle(t, e), this.quaternion.multiply(ue), this;
    }, rotateOnWorldAxis: function rotateOnWorldAxis(t, e) {
      return ue.setFromAxisAngle(t, e), this.quaternion.premultiply(ue), this;
    }, rotateX: function rotateX(t) {
      return this.rotateOnAxis(ve, t);
    }, rotateY: function rotateY(t) {
      return this.rotateOnAxis(ge, t);
    }, rotateZ: function rotateZ(t) {
      return this.rotateOnAxis(ye, t);
    }, translateOnAxis: function translateOnAxis(t, e) {
      return le.copy(t).applyQuaternion(this.quaternion), this.position.add(le.multiplyScalar(e)), this;
    }, translateX: function translateX(t) {
      return this.translateOnAxis(ve, t);
    }, translateY: function translateY(t) {
      return this.translateOnAxis(ge, t);
    }, translateZ: function translateZ(t) {
      return this.translateOnAxis(ye, t);
    }, localToWorld: function localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld);
    }, worldToLocal: function worldToLocal(t) {
      return t.applyMatrix4(he.getInverse(this.matrixWorld));
    }, lookAt: function lookAt(t, e, n) {
      t.isVector3 ? de.copy(t) : de.set(t, e, n);var r = this.parent;this.updateWorldMatrix(!0, !1), pe.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? he.lookAt(pe, de, this.up) : he.lookAt(de, pe, this.up), this.quaternion.setFromRotationMatrix(he), r && (he.extractRotation(r.matrixWorld), ue.setFromRotationMatrix(he), this.quaternion.premultiply(ue.inverse()));
    }, add: function add(t) {
      if (arguments.length > 1) {
        for (var e = 0; e < arguments.length; e++) {
          this.add(arguments[e]);
        }return this;
      }return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(xe)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
    }, remove: function remove(t) {
      if (arguments.length > 1) {
        for (var e = 0; e < arguments.length; e++) {
          this.remove(arguments[e]);
        }return this;
      }var n = this.children.indexOf(t);return -1 !== n && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent(_e)), this;
    }, clear: function clear() {
      for (var t = 0; t < this.children.length; t++) {
        var e = this.children[t];e.parent = null, e.dispatchEvent(_e);
      }return this.children.length = 0, this;
    }, attach: function attach(t) {
      return this.updateWorldMatrix(!0, !1), he.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), he.multiply(t.parent.matrixWorld)), t.applyMatrix4(he), t.updateWorldMatrix(!1, !1), this.add(t), this;
    }, getObjectById: function getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }, getObjectByName: function getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }, getObjectByProperty: function getObjectByProperty(t, e) {
      if (this[t] === e) return this;for (var n = 0, r = this.children.length; n < r; n++) {
        var i = this.children[n].getObjectByProperty(t, e);if (void 0 !== i) return i;
      }
    }, getWorldPosition: function getWorldPosition(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new wt()), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
    }, getWorldQuaternion: function getWorldQuaternion(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new bt()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pe, t, fe), t;
    }, getWorldScale: function getWorldScale(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new wt()), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pe, me, t), t;
    }, getWorldDirection: function getWorldDirection(t) {
      void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new wt()), this.updateWorldMatrix(!0, !1);var e = this.matrixWorld.elements;return t.set(e[8], e[9], e[10]).normalize();
    }, raycast: function raycast() {}, traverse: function traverse(t) {
      t(this);for (var e = this.children, n = 0, r = e.length; n < r; n++) {
        e[n].traverse(t);
      }
    }, traverseVisible: function traverseVisible(t) {
      if (!1 !== this.visible) {
        t(this);for (var e = this.children, n = 0, r = e.length; n < r; n++) {
          e[n].traverseVisible(t);
        }
      }
    }, traverseAncestors: function traverseAncestors(t) {
      var e = this.parent;null !== e && (t(e), e.traverseAncestors(t));
    }, updateMatrix: function updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    }, updateMatrixWorld: function updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);for (var e = this.children, n = 0, r = e.length; n < r; n++) {
        e[n].updateMatrixWorld(t);
      }
    }, updateWorldMatrix: function updateWorldMatrix(t, e) {
      var n = this.parent;if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (var r = this.children, i = 0, a = r.length; i < a; i++) {
        r[i].updateWorldMatrix(!1, !0);
      }
    }, toJSON: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t,
          n = {};e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });var r = {};function i(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
        r.geometry = i(t.geometries, this.geometry);var a = this.geometry.parameters;if (void 0 !== a && void 0 !== a.shapes) {
          var o = a.shapes;if (Array.isArray(o)) for (var s = 0, c = o.length; s < c; s++) {
            var l = o[s];i(t.shapes, l);
          } else i(t.shapes, o);
        }
      }if (void 0 !== this.material) if (Array.isArray(this.material)) {
        for (var u = [], h = 0, d = this.material.length; h < d; h++) {
          u.push(i(t.materials, this.material[h]));
        }r.material = u;
      } else r.material = i(t.materials, this.material);if (this.children.length > 0) {
        r.children = [];for (var p = 0; p < this.children.length; p++) {
          r.children.push(this.children[p].toJSON(t).object);
        }
      }if (e) {
        var f = x(t.geometries),
            m = x(t.materials),
            v = x(t.textures),
            g = x(t.images),
            y = x(t.shapes);f.length > 0 && (n.geometries = f), m.length > 0 && (n.materials = m), v.length > 0 && (n.textures = v), g.length > 0 && (n.images = g), y.length > 0 && (n.shapes = y);
      }return n.object = r, n;function x(t) {
        var e = [];for (var n in t) {
          var r = t[n];delete r.metadata, e.push(r);
        }return e;
      }
    }, clone: function clone(t) {
      return new this.constructor().copy(this, t);
    }, copy: function copy(t, e) {
      if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var n = 0; n < t.children.length; n++) {
        var r = t.children[n];this.add(r.clone());
      }return this;
    } });var we = new wt(),
      Me = new wt(),
      Se = new ft(),
      Te = function () {
    function t(t, e) {
      Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = void 0 !== t ? t : new wt(1, 0, 0), this.constant = void 0 !== e ? e : 0;
    }var e = t.prototype;return e.set = function (t, e) {
      return this.normal.copy(t), this.constant = e, this;
    }, e.setComponents = function (t, e, n, r) {
      return this.normal.set(t, e, n), this.constant = r, this;
    }, e.setFromNormalAndCoplanarPoint = function (t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    }, e.setFromCoplanarPoints = function (t, e, n) {
      var r = we.subVectors(n, e).cross(Me.subVectors(t, e)).normalize();return this.setFromNormalAndCoplanarPoint(r, t), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    }, e.normalize = function () {
      var t = 1 / this.normal.length();return this.normal.multiplyScalar(t), this.constant *= t, this;
    }, e.negate = function () {
      return this.constant *= -1, this.normal.negate(), this;
    }, e.distanceToPoint = function (t) {
      return this.normal.dot(t) + this.constant;
    }, e.distanceToSphere = function (t) {
      return this.distanceToPoint(t.center) - t.radius;
    }, e.projectPoint = function (t, e) {
      return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new wt()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    }, e.intersectLine = function (t, e) {
      void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new wt());var n = t.delta(we),
          r = this.normal.dot(n);if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;var i = -(t.start.dot(this.normal) + this.constant) / r;return i < 0 || i > 1 ? void 0 : e.copy(n).multiplyScalar(i).add(t.start);
    }, e.intersectsLine = function (t) {
      var e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);return e < 0 && n > 0 || n < 0 && e > 0;
    }, e.intersectsBox = function (t) {
      return t.intersectsPlane(this);
    }, e.intersectsSphere = function (t) {
      return t.intersectsPlane(this);
    }, e.coplanarPoint = function (t) {
      return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new wt()), t.copy(this.normal).multiplyScalar(-this.constant);
    }, e.applyMatrix4 = function (t, e) {
      var n = e || Se.getNormalMatrix(t),
          r = this.coplanarPoint(we).applyMatrix4(t),
          i = this.normal.applyMatrix3(n).normalize();return this.constant = -r.dot(i), this;
    }, e.translate = function (t) {
      return this.constant -= t.dot(this.normal), this;
    }, e.equals = function (t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }, t;
  }(),
      Ee = new wt(),
      Ae = new wt(),
      Le = new wt(),
      Re = new wt(),
      Ce = new wt(),
      Pe = new wt(),
      Ie = new wt(),
      De = new wt(),
      Oe = new wt(),
      Ne = new wt(),
      Be = function () {
    function t(t, e, n) {
      this.a = void 0 !== t ? t : new wt(), this.b = void 0 !== e ? e : new wt(), this.c = void 0 !== n ? n : new wt();
    }t.getNormal = function (t, e, n, r) {
      void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new wt()), r.subVectors(n, e), Ee.subVectors(t, e), r.cross(Ee);var i = r.lengthSq();return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
    }, t.getBarycoord = function (t, e, n, r, i) {
      Ee.subVectors(r, e), Ae.subVectors(n, e), Le.subVectors(t, e);var a = Ee.dot(Ee),
          o = Ee.dot(Ae),
          s = Ee.dot(Le),
          c = Ae.dot(Ae),
          l = Ae.dot(Le),
          u = a * c - o * o;if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new wt()), 0 === u) return i.set(-2, -1, -1);var h = 1 / u,
          d = (c * s - o * l) * h,
          p = (a * l - o * s) * h;return i.set(1 - d - p, p, d);
    }, t.containsPoint = function (t, e, n, r) {
      return this.getBarycoord(t, e, n, r, Re), Re.x >= 0 && Re.y >= 0 && Re.x + Re.y <= 1;
    }, t.getUV = function (t, e, n, r, i, a, o, s) {
      return this.getBarycoord(t, e, n, r, Re), s.set(0, 0), s.addScaledVector(i, Re.x), s.addScaledVector(a, Re.y), s.addScaledVector(o, Re.z), s;
    }, t.isFrontFacing = function (t, e, n, r) {
      return Ee.subVectors(n, e), Ae.subVectors(t, e), Ee.cross(Ae).dot(r) < 0;
    };var e = t.prototype;return e.set = function (t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }, e.setFromPointsAndIndices = function (t, e, n, r) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }, e.getArea = function () {
      return Ee.subVectors(this.c, this.b), Ae.subVectors(this.a, this.b), .5 * Ee.cross(Ae).length();
    }, e.getMidpoint = function (t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new wt()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }, e.getNormal = function (e) {
      return t.getNormal(this.a, this.b, this.c, e);
    }, e.getPlane = function (t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Te()), t.setFromCoplanarPoints(this.a, this.b, this.c);
    }, e.getBarycoord = function (e, n) {
      return t.getBarycoord(e, this.a, this.b, this.c, n);
    }, e.getUV = function (e, n, r, i, a) {
      return t.getUV(e, this.a, this.b, this.c, n, r, i, a);
    }, e.containsPoint = function (e) {
      return t.containsPoint(e, this.a, this.b, this.c);
    }, e.isFrontFacing = function (e) {
      return t.isFrontFacing(this.a, this.b, this.c, e);
    }, e.intersectsBox = function (t) {
      return t.intersectsTriangle(this);
    }, e.closestPointToPoint = function (t, e) {
      void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new wt());var n,
          r,
          i = this.a,
          a = this.b,
          o = this.c;Ce.subVectors(a, i), Pe.subVectors(o, i), De.subVectors(t, i);var s = Ce.dot(De),
          c = Pe.dot(De);if (s <= 0 && c <= 0) return e.copy(i);Oe.subVectors(t, a);var l = Ce.dot(Oe),
          u = Pe.dot(Oe);if (l >= 0 && u <= l) return e.copy(a);var h = s * u - l * c;if (h <= 0 && s >= 0 && l <= 0) return n = s / (s - l), e.copy(i).addScaledVector(Ce, n);Ne.subVectors(t, o);var d = Ce.dot(Ne),
          p = Pe.dot(Ne);if (p >= 0 && d <= p) return e.copy(o);var f = d * c - s * p;if (f <= 0 && c >= 0 && p <= 0) return r = c / (c - p), e.copy(i).addScaledVector(Pe, r);var m = l * p - d * u;if (m <= 0 && u - l >= 0 && d - p >= 0) return Ie.subVectors(o, a), r = (u - l) / (u - l + (d - p)), e.copy(a).addScaledVector(Ie, r);var v = 1 / (m + f + h);return n = f * v, r = h * v, e.copy(i).addScaledVector(Ce, n).addScaledVector(Pe, r);
    }, e.equals = function (t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }, t;
  }(),
      ze = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 },
      Ge = { h: 0, s: 0, l: 0 },
      Fe = { h: 0, s: 0, l: 0 };function Ue(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t;
  }function He(t) {
    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4);
  }function ke(t) {
    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055;
  }var Ve = function () {
    function t(t, e, n) {
      return Object.defineProperty(this, "isColor", { value: !0 }), void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
    }var e = t.prototype;return e.set = function (t) {
      return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
    }, e.setScalar = function (t) {
      return this.r = t, this.g = t, this.b = t, this;
    }, e.setHex = function (t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this;
    }, e.setRGB = function (t, e, n) {
      return this.r = t, this.g = e, this.b = n, this;
    }, e.setHSL = function (t, e, n) {
      if (t = st.euclideanModulo(t, 1), e = st.clamp(e, 0, 1), n = st.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;else {
        var r = n <= .5 ? n * (1 + e) : n + e - n * e,
            i = 2 * n - r;this.r = Ue(i, r, t + 1 / 3), this.g = Ue(i, r, t), this.b = Ue(i, r, t - 1 / 3);
      }return this;
    }, e.setStyle = function (t) {
      function e(e) {
        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
      }var n;if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
        var r,
            i = n[1],
            a = n[2];switch (i) {case "rgb":case "rgba":
            if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;break;case "hsl":case "hsla":
            if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
              var o = parseFloat(r[1]) / 360,
                  s = parseInt(r[2], 10) / 100,
                  c = parseInt(r[3], 10) / 100;return e(r[5]), this.setHSL(o, s, c);
            }}
      } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
        var l = n[1],
            u = l.length;if (3 === u) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;if (6 === u) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this;
      }return t && t.length > 0 ? this.setColorName(t) : this;
    }, e.setColorName = function (t) {
      var e = ze[t];return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
    }, e.clone = function () {
      return new this.constructor(this.r, this.g, this.b);
    }, e.copy = function (t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this;
    }, e.copyGammaToLinear = function (t, e) {
      return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
    }, e.copyLinearToGamma = function (t, e) {
      void 0 === e && (e = 2);var n = e > 0 ? 1 / e : 1;return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this;
    }, e.convertGammaToLinear = function (t) {
      return this.copyGammaToLinear(this, t), this;
    }, e.convertLinearToGamma = function (t) {
      return this.copyLinearToGamma(this, t), this;
    }, e.copySRGBToLinear = function (t) {
      return this.r = He(t.r), this.g = He(t.g), this.b = He(t.b), this;
    }, e.copyLinearToSRGB = function (t) {
      return this.r = ke(t.r), this.g = ke(t.g), this.b = ke(t.b), this;
    }, e.convertSRGBToLinear = function () {
      return this.copySRGBToLinear(this), this;
    }, e.convertLinearToSRGB = function () {
      return this.copyLinearToSRGB(this), this;
    }, e.getHex = function () {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    }, e.getHexString = function () {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }, e.getHSL = function (t) {
      void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 });var e,
          n,
          r = this.r,
          i = this.g,
          a = this.b,
          o = Math.max(r, i, a),
          s = Math.min(r, i, a),
          c = (s + o) / 2;if (s === o) e = 0, n = 0;else {
        var l = o - s;switch (n = c <= .5 ? l / (o + s) : l / (2 - o - s), o) {case r:
            e = (i - a) / l + (i < a ? 6 : 0);break;case i:
            e = (a - r) / l + 2;break;case a:
            e = (r - i) / l + 4;}e /= 6;
      }return t.h = e, t.s = n, t.l = c, t;
    }, e.getStyle = function () {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    }, e.offsetHSL = function (t, e, n) {
      return this.getHSL(Ge), Ge.h += t, Ge.s += e, Ge.l += n, this.setHSL(Ge.h, Ge.s, Ge.l), this;
    }, e.add = function (t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this;
    }, e.addColors = function (t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
    }, e.addScalar = function (t) {
      return this.r += t, this.g += t, this.b += t, this;
    }, e.sub = function (t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    }, e.multiply = function (t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    }, e.multiplyScalar = function (t) {
      return this.r *= t, this.g *= t, this.b *= t, this;
    }, e.lerp = function (t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
    }, e.lerpHSL = function (t, e) {
      this.getHSL(Ge), t.getHSL(Fe);var n = st.lerp(Ge.h, Fe.h, e),
          r = st.lerp(Ge.s, Fe.s, e),
          i = st.lerp(Ge.l, Fe.l, e);return this.setHSL(n, r, i), this;
    }, e.equals = function (t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }, e.fromArray = function (t, e) {
      return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
    }, e.toArray = function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
    }, e.fromBufferAttribute = function (t, e) {
      return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }, e.toJSON = function () {
      return this.getHex();
    }, t;
  }();Ve.NAMES = ze, Ve.prototype.r = 1, Ve.prototype.g = 1, Ve.prototype.b = 1;var We = function () {
    function t(t, e, n, r, i, a) {
      this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new wt(), this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new Ve(), this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== a ? a : 0;
    }var e = t.prototype;return e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;for (var e = 0, n = t.vertexNormals.length; e < n; e++) {
        this.vertexNormals[e] = t.vertexNormals[e].clone();
      }for (var r = 0, i = t.vertexColors.length; r < i; r++) {
        this.vertexColors[r] = t.vertexColors[r].clone();
      }return this;
    }, t;
  }(),
      je = 0;function qe() {
    Object.defineProperty(this, "id", { value: je++ }), this.uuid = st.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = e, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = $, this.stencilZFail = $, this.stencilZPass = $, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
  }function Xe(t) {
    qe.call(this), this.type = "MeshBasicMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t);
  }qe.prototype = _extends(Object.create(rt.prototype), { constructor: qe, isMaterial: !0, onBeforeCompile: function onBeforeCompile() {}, customProgramCacheKey: function customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }, setValues: function setValues(t) {
      if (void 0 !== t) for (var e in t) {
        var n = t[e];if (void 0 !== n) {
          if ("shading" !== e) {
            var r = this[e];void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
          } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
        } else console.warn("THREE.Material: '" + e + "' parameter is undefined.");
      }
    }, toJSON: function toJSON(t) {
      var e = void 0 === t || "string" == typeof t;e && (t = { textures: {}, images: {} });var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };function r(t) {
        var e = [];for (var n in t) {
          var r = t[n];delete r.metadata, e.push(r);
        }return e;
      }if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
        var i = r(t.textures),
            a = r(t.images);i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a);
      }return n;
    }, clone: function clone() {
      return new this.constructor().copy(this);
    }, copy: function copy(t) {
      this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;var e = t.clippingPlanes,
          n = null;if (null !== e) {
        var r = e.length;n = new Array(r);for (var i = 0; i !== r; ++i) {
          n[i] = e[i].clone();
        }
      }return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
    }, dispose: function dispose() {
      this.dispatchEvent({ type: "dispose" });
    } }), Object.defineProperty(qe.prototype, "needsUpdate", { set: function set(t) {
      !0 === t && this.version++;
    } }), Xe.prototype = Object.create(qe.prototype), Xe.prototype.constructor = Xe, Xe.prototype.isMeshBasicMaterial = !0, Xe.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
  };var Ye = new wt(),
      Ze = new pt();function Je(t, e, n) {
    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = tt, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }function Qe(t, e, n) {
    Je.call(this, new Int8Array(t), e, n);
  }function Ke(t, e, n) {
    Je.call(this, new Uint8Array(t), e, n);
  }function $e(t, e, n) {
    Je.call(this, new Uint8ClampedArray(t), e, n);
  }function tn(t, e, n) {
    Je.call(this, new Int16Array(t), e, n);
  }function en(t, e, n) {
    Je.call(this, new Uint16Array(t), e, n);
  }function nn(t, e, n) {
    Je.call(this, new Int32Array(t), e, n);
  }function rn(t, e, n) {
    Je.call(this, new Uint32Array(t), e, n);
  }function an(t, e, n) {
    Je.call(this, new Float32Array(t), e, n);
  }function on(t, e, n) {
    Je.call(this, new Float64Array(t), e, n);
  }Object.defineProperty(Je.prototype, "needsUpdate", { set: function set(t) {
      !0 === t && this.version++;
    } }), _extends(Je.prototype, { isBufferAttribute: !0, onUploadCallback: function onUploadCallback() {}, setUsage: function setUsage(t) {
      return this.usage = t, this;
    }, copy: function copy(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
    }, copyAt: function copyAt(t, e, n) {
      t *= this.itemSize, n *= e.itemSize;for (var r = 0, i = this.itemSize; r < i; r++) {
        this.array[t + r] = e.array[n + r];
      }return this;
    }, copyArray: function copyArray(t) {
      return this.array.set(t), this;
    }, copyColorsArray: function copyColorsArray(t) {
      for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
        var a = t[r];void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), a = new Ve()), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b;
      }return this;
    }, copyVector2sArray: function copyVector2sArray(t) {
      for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
        var a = t[r];void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new pt()), e[n++] = a.x, e[n++] = a.y;
      }return this;
    }, copyVector3sArray: function copyVector3sArray(t) {
      for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
        var a = t[r];void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new wt()), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z;
      }return this;
    }, copyVector4sArray: function copyVector4sArray(t) {
      for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
        var a = t[r];void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new yt()), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z, e[n++] = a.w;
      }return this;
    }, applyMatrix3: function applyMatrix3(t) {
      if (2 === this.itemSize) for (var e = 0, n = this.count; e < n; e++) {
        Ze.fromBufferAttribute(this, e), Ze.applyMatrix3(t), this.setXY(e, Ze.x, Ze.y);
      } else if (3 === this.itemSize) for (var r = 0, i = this.count; r < i; r++) {
        Ye.fromBufferAttribute(this, r), Ye.applyMatrix3(t), this.setXYZ(r, Ye.x, Ye.y, Ye.z);
      }return this;
    }, applyMatrix4: function applyMatrix4(t) {
      for (var e = 0, n = this.count; e < n; e++) {
        Ye.x = this.getX(e), Ye.y = this.getY(e), Ye.z = this.getZ(e), Ye.applyMatrix4(t), this.setXYZ(e, Ye.x, Ye.y, Ye.z);
      }return this;
    }, applyNormalMatrix: function applyNormalMatrix(t) {
      for (var e = 0, n = this.count; e < n; e++) {
        Ye.x = this.getX(e), Ye.y = this.getY(e), Ye.z = this.getZ(e), Ye.applyNormalMatrix(t), this.setXYZ(e, Ye.x, Ye.y, Ye.z);
      }return this;
    }, transformDirection: function transformDirection(t) {
      for (var e = 0, n = this.count; e < n; e++) {
        Ye.x = this.getX(e), Ye.y = this.getY(e), Ye.z = this.getZ(e), Ye.transformDirection(t), this.setXYZ(e, Ye.x, Ye.y, Ye.z);
      }return this;
    }, set: function set(t, e) {
      return void 0 === e && (e = 0), this.array.set(t, e), this;
    }, getX: function getX(t) {
      return this.array[t * this.itemSize];
    }, setX: function setX(t, e) {
      return this.array[t * this.itemSize] = e, this;
    }, getY: function getY(t) {
      return this.array[t * this.itemSize + 1];
    }, setY: function setY(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    }, getZ: function getZ(t) {
      return this.array[t * this.itemSize + 2];
    }, setZ: function setZ(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    }, getW: function getW(t) {
      return this.array[t * this.itemSize + 3];
    }, setW: function setW(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    }, setXY: function setXY(t, e, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
    }, setXYZ: function setXYZ(t, e, n, r) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this;
    }, setXYZW: function setXYZW(t, e, n, r, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this;
    }, onUpload: function onUpload(t) {
      return this.onUploadCallback = t, this;
    }, clone: function clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }, toJSON: function toJSON() {
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
    } }), Qe.prototype = Object.create(Je.prototype), Qe.prototype.constructor = Qe, Ke.prototype = Object.create(Je.prototype), Ke.prototype.constructor = Ke, $e.prototype = Object.create(Je.prototype), $e.prototype.constructor = $e, tn.prototype = Object.create(Je.prototype), tn.prototype.constructor = tn, en.prototype = Object.create(Je.prototype), en.prototype.constructor = en, nn.prototype = Object.create(Je.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(Je.prototype), rn.prototype.constructor = rn, an.prototype = Object.create(Je.prototype), an.prototype.constructor = an, on.prototype = Object.create(Je.prototype), on.prototype.constructor = on;var sn = function () {
    function t() {
      this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
    }var e = t.prototype;return e.computeGroups = function (t) {
      var e,
          n,
          r = [],
          i = void 0,
          a = t.faces;for (n = 0; n < a.length; n++) {
        var o = a[n];o.materialIndex !== i && (i = o.materialIndex, void 0 !== e && (e.count = 3 * n - e.start, r.push(e)), e = { start: 3 * n, materialIndex: i });
      }void 0 !== e && (e.count = 3 * n - e.start, r.push(e)), this.groups = r;
    }, e.fromGeometry = function (t) {
      var e,
          n = t.faces,
          r = t.vertices,
          i = t.faceVertexUvs,
          a = i[0] && i[0].length > 0,
          o = i[1] && i[1].length > 0,
          s = t.morphTargets,
          c = s.length;if (c > 0) {
        e = [];for (var l = 0; l < c; l++) {
          e[l] = { name: s[l].name, data: [] };
        }this.morphTargets.position = e;
      }var u,
          h = t.morphNormals,
          d = h.length;if (d > 0) {
        u = [];for (var p = 0; p < d; p++) {
          u[p] = { name: h[p].name, data: [] };
        }this.morphTargets.normal = u;
      }var f = t.skinIndices,
          m = t.skinWeights,
          v = f.length === r.length,
          g = m.length === r.length;r.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for (var y = 0; y < n.length; y++) {
        var x = n[y];this.vertices.push(r[x.a], r[x.b], r[x.c]);var _ = x.vertexNormals;if (3 === _.length) this.normals.push(_[0], _[1], _[2]);else {
          var b = x.normal;this.normals.push(b, b, b);
        }var w = x.vertexColors;if (3 === w.length) this.colors.push(w[0], w[1], w[2]);else {
          var M = x.color;this.colors.push(M, M, M);
        }if (!0 === a) {
          var S = i[0][y];void 0 !== S ? this.uvs.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", y), this.uvs.push(new pt(), new pt(), new pt()));
        }if (!0 === o) {
          var T = i[1][y];void 0 !== T ? this.uvs2.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", y), this.uvs2.push(new pt(), new pt(), new pt()));
        }for (var E = 0; E < c; E++) {
          var A = s[E].vertices;e[E].data.push(A[x.a], A[x.b], A[x.c]);
        }for (var L = 0; L < d; L++) {
          var R = h[L].vertexNormals[y];u[L].data.push(R.a, R.b, R.c);
        }v && this.skinIndices.push(f[x.a], f[x.b], f[x.c]), g && this.skinWeights.push(m[x.a], m[x.b], m[x.c]);
      }return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this;
    }, t;
  }();function cn(t) {
    if (0 === t.length) return -1 / 0;for (var e = t[0], n = 1, r = t.length; n < r; ++n) {
      t[n] > e && (e = t[n]);
    }return e;
  }var ln = 1,
      un = new Jt(),
      hn = new be(),
      dn = new wt(),
      pn = new Tt(),
      fn = new Tt(),
      mn = new wt();function vn() {
    Object.defineProperty(this, "id", { value: ln += 2 }), this.uuid = st.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }vn.prototype = _extends(Object.create(rt.prototype), { constructor: vn, isBufferGeometry: !0, getIndex: function getIndex() {
      return this.index;
    }, setIndex: function setIndex(t) {
      return Array.isArray(t) ? this.index = new (cn(t) > 65535 ? rn : en)(t, 1) : this.index = t, this;
    }, getAttribute: function getAttribute(t) {
      return this.attributes[t];
    }, setAttribute: function setAttribute(t, e) {
      return this.attributes[t] = e, this;
    }, deleteAttribute: function deleteAttribute(t) {
      return delete this.attributes[t], this;
    }, addGroup: function addGroup(t, e, n) {
      this.groups.push({ start: t, count: e, materialIndex: void 0 !== n ? n : 0 });
    }, clearGroups: function clearGroups() {
      this.groups = [];
    }, setDrawRange: function setDrawRange(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    }, applyMatrix4: function applyMatrix4(t) {
      var e = this.attributes.position;void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);var n = this.attributes.normal;if (void 0 !== n) {
        var r = new ft().getNormalMatrix(t);n.applyNormalMatrix(r), n.needsUpdate = !0;
      }var i = this.attributes.tangent;return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }, rotateX: function rotateX(t) {
      return un.makeRotationX(t), this.applyMatrix4(un), this;
    }, rotateY: function rotateY(t) {
      return un.makeRotationY(t), this.applyMatrix4(un), this;
    }, rotateZ: function rotateZ(t) {
      return un.makeRotationZ(t), this.applyMatrix4(un), this;
    }, translate: function translate(t, e, n) {
      return un.makeTranslation(t, e, n), this.applyMatrix4(un), this;
    }, scale: function scale(t, e, n) {
      return un.makeScale(t, e, n), this.applyMatrix4(un), this;
    }, lookAt: function lookAt(t) {
      return hn.lookAt(t), hn.updateMatrix(), this.applyMatrix4(hn.matrix), this;
    }, center: function center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(dn).negate(), this.translate(dn.x, dn.y, dn.z), this;
    }, setFromObject: function setFromObject(t) {
      var e = t.geometry;if (t.isPoints || t.isLine) {
        var n = new an(3 * e.vertices.length, 3),
            r = new an(3 * e.colors.length, 3);if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
          var i = new an(e.lineDistances.length, 1);this.setAttribute("lineDistance", i.copyArray(e.lineDistances));
        }null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone());
      } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);return this;
    }, setFromPoints: function setFromPoints(t) {
      for (var e = [], n = 0, r = t.length; n < r; n++) {
        var i = t[n];e.push(i.x, i.y, i.z || 0);
      }return this.setAttribute("position", new an(e, 3)), this;
    }, updateFromObject: function updateFromObject(t) {
      var e = t.geometry;if (t.isMesh) {
        var n = e.__directGeometry;if (!0 === e.elementsNeedUpdate && (n = void 0, e.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(e);n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n;
      }if (!0 === e.verticesNeedUpdate) {
        var r = this.attributes.position;void 0 !== r && (r.copyVector3sArray(e.vertices), r.needsUpdate = !0), e.verticesNeedUpdate = !1;
      }if (!0 === e.normalsNeedUpdate) {
        var i = this.attributes.normal;void 0 !== i && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1;
      }if (!0 === e.colorsNeedUpdate) {
        var a = this.attributes.color;void 0 !== a && (a.copyColorsArray(e.colors), a.needsUpdate = !0), e.colorsNeedUpdate = !1;
      }if (e.uvsNeedUpdate) {
        var o = this.attributes.uv;void 0 !== o && (o.copyVector2sArray(e.uvs), o.needsUpdate = !0), e.uvsNeedUpdate = !1;
      }if (e.lineDistancesNeedUpdate) {
        var s = this.attributes.lineDistance;void 0 !== s && (s.copyArray(e.lineDistances), s.needsUpdate = !0), e.lineDistancesNeedUpdate = !1;
      }return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
    }, fromGeometry: function fromGeometry(t) {
      return t.__directGeometry = new sn().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
    }, fromDirectGeometry: function fromDirectGeometry(t) {
      var e = new Float32Array(3 * t.vertices.length);if (this.setAttribute("position", new Je(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
        var n = new Float32Array(3 * t.normals.length);this.setAttribute("normal", new Je(n, 3).copyVector3sArray(t.normals));
      }if (t.colors.length > 0) {
        var r = new Float32Array(3 * t.colors.length);this.setAttribute("color", new Je(r, 3).copyColorsArray(t.colors));
      }if (t.uvs.length > 0) {
        var i = new Float32Array(2 * t.uvs.length);this.setAttribute("uv", new Je(i, 2).copyVector2sArray(t.uvs));
      }if (t.uvs2.length > 0) {
        var a = new Float32Array(2 * t.uvs2.length);this.setAttribute("uv2", new Je(a, 2).copyVector2sArray(t.uvs2));
      }for (var o in this.groups = t.groups, t.morphTargets) {
        for (var s = [], c = t.morphTargets[o], l = 0, u = c.length; l < u; l++) {
          var h = c[l],
              d = new an(3 * h.data.length, 3);d.name = h.name, s.push(d.copyVector3sArray(h.data));
        }this.morphAttributes[o] = s;
      }if (t.skinIndices.length > 0) {
        var p = new an(4 * t.skinIndices.length, 4);this.setAttribute("skinIndex", p.copyVector4sArray(t.skinIndices));
      }if (t.skinWeights.length > 0) {
        var f = new an(4 * t.skinWeights.length, 4);this.setAttribute("skinWeight", f.copyVector4sArray(t.skinWeights));
      }return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this;
    }, computeBoundingBox: function computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Tt());var t = this.attributes.position,
          e = this.morphAttributes.position;if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new wt(-1 / 0, -1 / 0, -1 / 0), new wt(1 / 0, 1 / 0, 1 / 0));if (void 0 !== t) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (var n = 0, r = e.length; n < r; n++) {
          var i = e[n];pn.setFromBufferAttribute(i), this.morphTargetsRelative ? (mn.addVectors(this.boundingBox.min, pn.min), this.boundingBox.expandByPoint(mn), mn.addVectors(this.boundingBox.max, pn.max), this.boundingBox.expandByPoint(mn)) : (this.boundingBox.expandByPoint(pn.min), this.boundingBox.expandByPoint(pn.max));
        }
      } else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }, computeBoundingSphere: function computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Ht());var t = this.attributes.position,
          e = this.morphAttributes.position;if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new wt(), 1 / 0);if (t) {
        var n = this.boundingSphere.center;if (pn.setFromBufferAttribute(t), e) for (var r = 0, i = e.length; r < i; r++) {
          var a = e[r];fn.setFromBufferAttribute(a), this.morphTargetsRelative ? (mn.addVectors(pn.min, fn.min), pn.expandByPoint(mn), mn.addVectors(pn.max, fn.max), pn.expandByPoint(mn)) : (pn.expandByPoint(fn.min), pn.expandByPoint(fn.max));
        }pn.getCenter(n);for (var o = 0, s = 0, c = t.count; s < c; s++) {
          mn.fromBufferAttribute(t, s), o = Math.max(o, n.distanceToSquared(mn));
        }if (e) for (var l = 0, u = e.length; l < u; l++) {
          for (var h = e[l], d = this.morphTargetsRelative, p = 0, f = h.count; p < f; p++) {
            mn.fromBufferAttribute(h, p), d && (dn.fromBufferAttribute(t, p), mn.add(dn)), o = Math.max(o, n.distanceToSquared(mn));
          }
        }this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }, computeFaceNormals: function computeFaceNormals() {}, computeVertexNormals: function computeVertexNormals() {
      var t = this.index,
          e = this.getAttribute("position");if (void 0 !== e) {
        var n = this.getAttribute("normal");if (void 0 === n) n = new Je(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);else for (var r = 0, i = n.count; r < i; r++) {
          n.setXYZ(r, 0, 0, 0);
        }var a = new wt(),
            o = new wt(),
            s = new wt(),
            c = new wt(),
            l = new wt(),
            u = new wt(),
            h = new wt(),
            d = new wt();if (t) for (var p = 0, f = t.count; p < f; p += 3) {
          var m = t.getX(p + 0),
              v = t.getX(p + 1),
              g = t.getX(p + 2);a.fromBufferAttribute(e, m), o.fromBufferAttribute(e, v), s.fromBufferAttribute(e, g), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), c.fromBufferAttribute(n, m), l.fromBufferAttribute(n, v), u.fromBufferAttribute(n, g), c.add(h), l.add(h), u.add(h), n.setXYZ(m, c.x, c.y, c.z), n.setXYZ(v, l.x, l.y, l.z), n.setXYZ(g, u.x, u.y, u.z);
        } else for (var y = 0, x = e.count; y < x; y += 3) {
          a.fromBufferAttribute(e, y + 0), o.fromBufferAttribute(e, y + 1), s.fromBufferAttribute(e, y + 2), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), n.setXYZ(y + 0, h.x, h.y, h.z), n.setXYZ(y + 1, h.x, h.y, h.z), n.setXYZ(y + 2, h.x, h.y, h.z);
        }this.normalizeNormals(), n.needsUpdate = !0;
      }
    }, merge: function merge(t, e) {
      if (t && t.isBufferGeometry) {
        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));var n = this.attributes;for (var r in n) {
          if (void 0 !== t.attributes[r]) for (var i = n[r].array, a = t.attributes[r], o = a.array, s = a.itemSize * e, c = Math.min(o.length, i.length - s), l = 0, u = s; l < c; l++, u++) {
            i[u] = o[l];
          }
        }return this;
      }console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
    }, normalizeNormals: function normalizeNormals() {
      for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) {
        mn.fromBufferAttribute(t, e), mn.normalize(), t.setXYZ(e, mn.x, mn.y, mn.z);
      }
    }, toNonIndexed: function toNonIndexed() {
      function t(t, e) {
        for (var n = t.array, r = t.itemSize, i = t.normalized, a = new n.constructor(e.length * r), o = 0, s = 0, c = 0, l = e.length; c < l; c++) {
          o = e[c] * r;for (var u = 0; u < r; u++) {
            a[s++] = n[o++];
          }
        }return new Je(a, r, i);
      }if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;var e = new vn(),
          n = this.index.array,
          r = this.attributes;for (var i in r) {
        var a = t(r[i], n);e.setAttribute(i, a);
      }var o = this.morphAttributes;for (var s in o) {
        for (var c = [], l = o[s], u = 0, h = l.length; u < h; u++) {
          var d = t(l[u], n);c.push(d);
        }e.morphAttributes[s] = c;
      }e.morphTargetsRelative = this.morphTargetsRelative;for (var p = this.groups, f = 0, m = p.length; f < m; f++) {
        var v = p[f];e.addGroup(v.start, v.count, v.materialIndex);
      }return e;
    }, toJSON: function toJSON() {
      var t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
        var e = this.parameters;for (var n in e) {
          void 0 !== e[n] && (t[n] = e[n]);
        }return t;
      }t.data = { attributes: {} };var r = this.index;null !== r && (t.data.index = { type: r.array.constructor.name, array: Array.prototype.slice.call(r.array) });var i = this.attributes;for (var a in i) {
        var o = i[a],
            s = o.toJSON(t.data);"" !== o.name && (s.name = o.name), t.data.attributes[a] = s;
      }var c = {},
          l = !1;for (var u in this.morphAttributes) {
        for (var h = this.morphAttributes[u], d = [], p = 0, f = h.length; p < f; p++) {
          var m = h[p],
              v = m.toJSON(t.data);"" !== m.name && (v.name = m.name), d.push(v);
        }d.length > 0 && (c[u] = d, l = !0);
      }l && (t.data.morphAttributes = c, t.data.morphTargetsRelative = this.morphTargetsRelative);var g = this.groups;g.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(g)));var y = this.boundingSphere;return null !== y && (t.data.boundingSphere = { center: y.center.toArray(), radius: y.radius }), t;
    }, clone: function clone() {
      return new vn().copy(this);
    }, copy: function copy(t) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;var e = {};this.name = t.name;var n = t.index;null !== n && this.setIndex(n.clone(e));var r = t.attributes;for (var i in r) {
        var a = r[i];this.setAttribute(i, a.clone(e));
      }var o = t.morphAttributes;for (var s in o) {
        for (var c = [], l = o[s], u = 0, h = l.length; u < h; u++) {
          c.push(l[u].clone(e));
        }this.morphAttributes[s] = c;
      }this.morphTargetsRelative = t.morphTargetsRelative;for (var d = t.groups, p = 0, f = d.length; p < f; p++) {
        var m = d[p];this.addGroup(m.start, m.count, m.materialIndex);
      }var v = t.boundingBox;null !== v && (this.boundingBox = v.clone());var g = t.boundingSphere;return null !== g && (this.boundingSphere = g.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
    }, dispose: function dispose() {
      this.dispatchEvent({ type: "dispose" });
    } });var gn = new Jt(),
      yn = new Zt(),
      xn = new Ht(),
      _n = new wt(),
      bn = new wt(),
      wn = new wt(),
      Mn = new wt(),
      Sn = new wt(),
      Tn = new wt(),
      En = new wt(),
      An = new wt(),
      Ln = new wt(),
      Rn = new pt(),
      Cn = new pt(),
      Pn = new pt(),
      In = new wt(),
      Dn = new wt();function On(t, e) {
    be.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new vn(), this.material = void 0 !== e ? e : new Xe(), this.updateMorphTargets();
  }function Nn(t, e, n, r, i, a, o, s) {
    if (null === (1 === e.side ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, 2 !== e.side, s))) return null;Dn.copy(s), Dn.applyMatrix4(t.matrixWorld);var c = n.ray.origin.distanceTo(Dn);return c < n.near || c > n.far ? null : { distance: c, point: Dn.clone(), object: t };
  }function Bn(t, e, n, r, i, a, o, s, c, l, u, h) {
    _n.fromBufferAttribute(i, l), bn.fromBufferAttribute(i, u), wn.fromBufferAttribute(i, h);var d = t.morphTargetInfluences;if (e.morphTargets && a && d) {
      En.set(0, 0, 0), An.set(0, 0, 0), Ln.set(0, 0, 0);for (var p = 0, f = a.length; p < f; p++) {
        var m = d[p],
            v = a[p];0 !== m && (Mn.fromBufferAttribute(v, l), Sn.fromBufferAttribute(v, u), Tn.fromBufferAttribute(v, h), o ? (En.addScaledVector(Mn, m), An.addScaledVector(Sn, m), Ln.addScaledVector(Tn, m)) : (En.addScaledVector(Mn.sub(_n), m), An.addScaledVector(Sn.sub(bn), m), Ln.addScaledVector(Tn.sub(wn), m)));
      }_n.add(En), bn.add(An), wn.add(Ln);
    }t.isSkinnedMesh && (t.boneTransform(l, _n), t.boneTransform(u, bn), t.boneTransform(h, wn));var g = Nn(t, e, n, r, _n, bn, wn, In);if (g) {
      s && (Rn.fromBufferAttribute(s, l), Cn.fromBufferAttribute(s, u), Pn.fromBufferAttribute(s, h), g.uv = Be.getUV(In, _n, bn, wn, Rn, Cn, Pn, new pt())), c && (Rn.fromBufferAttribute(c, l), Cn.fromBufferAttribute(c, u), Pn.fromBufferAttribute(c, h), g.uv2 = Be.getUV(In, _n, bn, wn, Rn, Cn, Pn, new pt()));var y = new We(l, u, h);Be.getNormal(_n, bn, wn, y.normal), g.face = y;
    }return g;
  }On.prototype = _extends(Object.create(be.prototype), { constructor: On, isMesh: !0, copy: function copy(t) {
      return be.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = _extends({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
    }, updateMorphTargets: function updateMorphTargets() {
      var t = this.geometry;if (t.isBufferGeometry) {
        var e = t.morphAttributes,
            n = Object.keys(e);if (n.length > 0) {
          var r = e[n[0]];if (void 0 !== r) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};for (var i = 0, a = r.length; i < a; i++) {
              var o = r[i].name || String(i);this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i;
            }
          }
        }
      } else {
        var s = t.morphTargets;void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }, raycast: function raycast(t, e) {
      var n,
          r = this.geometry,
          i = this.material,
          a = this.matrixWorld;if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), xn.copy(r.boundingSphere), xn.applyMatrix4(a), !1 !== t.ray.intersectsSphere(xn) && (gn.getInverse(a), yn.copy(t.ray).applyMatrix4(gn), null === r.boundingBox || !1 !== yn.intersectsBox(r.boundingBox)))) if (r.isBufferGeometry) {
        var o = r.index,
            s = r.attributes.position,
            c = r.morphAttributes.position,
            l = r.morphTargetsRelative,
            u = r.attributes.uv,
            h = r.attributes.uv2,
            d = r.groups,
            p = r.drawRange;if (null !== o) {
          if (Array.isArray(i)) for (var f = 0, m = d.length; f < m; f++) {
            for (var v = d[f], g = i[v.materialIndex], y = Math.max(v.start, p.start), x = Math.min(v.start + v.count, p.start + p.count); y < x; y += 3) {
              var _ = o.getX(y),
                  b = o.getX(y + 1),
                  w = o.getX(y + 2);(n = Bn(this, g, t, yn, s, c, l, u, h, _, b, w)) && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = v.materialIndex, e.push(n));
            }
          } else for (var M = Math.max(0, p.start), S = Math.min(o.count, p.start + p.count); M < S; M += 3) {
            var T = o.getX(M),
                E = o.getX(M + 1),
                A = o.getX(M + 2);(n = Bn(this, i, t, yn, s, c, l, u, h, T, E, A)) && (n.faceIndex = Math.floor(M / 3), e.push(n));
          }
        } else if (void 0 !== s) if (Array.isArray(i)) for (var L = 0, R = d.length; L < R; L++) {
          for (var C = d[L], P = i[C.materialIndex], I = Math.max(C.start, p.start), D = Math.min(C.start + C.count, p.start + p.count); I < D; I += 3) {
            (n = Bn(this, P, t, yn, s, c, l, u, h, I, I + 1, I + 2)) && (n.faceIndex = Math.floor(I / 3), n.face.materialIndex = C.materialIndex, e.push(n));
          }
        } else for (var O = Math.max(0, p.start), N = Math.min(s.count, p.start + p.count); O < N; O += 3) {
          (n = Bn(this, i, t, yn, s, c, l, u, h, O, O + 1, O + 2)) && (n.faceIndex = Math.floor(O / 3), e.push(n));
        }
      } else if (r.isGeometry) {
        var B,
            z = Array.isArray(i),
            G = r.vertices,
            F = r.faces,
            U = r.faceVertexUvs[0];U.length > 0 && (B = U);for (var H = 0, k = F.length; H < k; H++) {
          var V = F[H],
              W = z ? i[V.materialIndex] : i;if (void 0 !== W) {
            var j = G[V.a],
                q = G[V.b],
                X = G[V.c];if (n = Nn(this, W, t, yn, j, q, X, In)) {
              if (B && B[H]) {
                var Y = B[H];Rn.copy(Y[0]), Cn.copy(Y[1]), Pn.copy(Y[2]), n.uv = Be.getUV(In, j, q, X, Rn, Cn, Pn, new pt());
              }n.face = V, n.faceIndex = H, e.push(n);
            }
          }
        }
      }
    } });var zn = function (t) {
    function e(e, n, r, i, a, o) {
      var s;void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === i && (i = 1), void 0 === a && (a = 1), void 0 === o && (o = 1), (s = t.call(this) || this).type = "BoxBufferGeometry", s.parameters = { width: e, height: n, depth: r, widthSegments: i, heightSegments: a, depthSegments: o };var c = ht(s);i = Math.floor(i), a = Math.floor(a), o = Math.floor(o);var l = [],
          u = [],
          h = [],
          d = [],
          p = 0,
          f = 0;function m(t, e, n, r, i, a, o, s, m, v, g) {
        for (var y = a / m, x = o / v, _ = a / 2, b = o / 2, w = s / 2, M = m + 1, S = v + 1, T = 0, E = 0, A = new wt(), L = 0; L < S; L++) {
          for (var R = L * x - b, C = 0; C < M; C++) {
            var P = C * y - _;A[t] = P * r, A[e] = R * i, A[n] = w, u.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = s > 0 ? 1 : -1, h.push(A.x, A.y, A.z), d.push(C / m), d.push(1 - L / v), T += 1;
          }
        }for (var I = 0; I < v; I++) {
          for (var D = 0; D < m; D++) {
            var O = p + D + M * I,
                N = p + D + M * (I + 1),
                B = p + (D + 1) + M * (I + 1),
                z = p + (D + 1) + M * I;l.push(O, N, z), l.push(N, B, z), E += 6;
          }
        }c.addGroup(f, E, g), f += E, p += T;
      }return m("z", "y", "x", -1, -1, r, n, e, o, a, 0), m("z", "y", "x", 1, -1, r, n, -e, o, a, 1), m("x", "z", "y", 1, 1, e, r, n, i, o, 2), m("x", "z", "y", 1, -1, e, r, -n, i, o, 3), m("x", "y", "z", 1, -1, e, n, r, i, a, 4), m("x", "y", "z", -1, -1, e, n, -r, i, a, 5), s.setIndex(l), s.setAttribute("position", new an(u, 3)), s.setAttribute("normal", new an(h, 3)), s.setAttribute("uv", new an(d, 2)), s;
    }return ut(e, t), e;
  }(vn);function Gn(t) {
    var e = {};for (var n in t) {
      for (var r in e[n] = {}, t[n]) {
        var i = t[n][r];i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i;
      }
    }return e;
  }function Fn(t) {
    for (var e = {}, n = 0; n < t.length; n++) {
      var r = Gn(t[n]);for (var i in r) {
        e[i] = r[i];
      }
    }return e;
  }var Un = { clone: Gn, merge: Fn };function Hn(t) {
    qe.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
  }function kn() {
    be.call(this), this.type = "Camera", this.matrixWorldInverse = new Jt(), this.projectionMatrix = new Jt(), this.projectionMatrixInverse = new Jt();
  }function Vn(t, e, n, r) {
    kn.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }Hn.prototype = Object.create(qe.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isShaderMaterial = !0, Hn.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Gn(t.uniforms), this.defines = _extends({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = _extends({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }, Hn.prototype.toJSON = function (t) {
    var e = qe.prototype.toJSON.call(this, t);for (var n in e.glslVersion = this.glslVersion, e.uniforms = {}, this.uniforms) {
      var r = this.uniforms[n].value;r && r.isTexture ? e.uniforms[n] = { type: "t", value: r.toJSON(t).uuid } : r && r.isColor ? e.uniforms[n] = { type: "c", value: r.getHex() } : r && r.isVector2 ? e.uniforms[n] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? e.uniforms[n] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? e.uniforms[n] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? e.uniforms[n] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? e.uniforms[n] = { type: "m4", value: r.toArray() } : e.uniforms[n] = { value: r };
    }Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;var i = {};for (var a in this.extensions) {
      !0 === this.extensions[a] && (i[a] = !0);
    }return Object.keys(i).length > 0 && (e.extensions = i), e;
  }, kn.prototype = _extends(Object.create(be.prototype), { constructor: kn, isCamera: !0, copy: function copy(t, e) {
      return be.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    }, getWorldDirection: function getWorldDirection(t) {
      void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new wt()), this.updateWorldMatrix(!0, !1);var e = this.matrixWorld.elements;return t.set(-e[8], -e[9], -e[10]).normalize();
    }, updateMatrixWorld: function updateMatrixWorld(t) {
      be.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
    }, updateWorldMatrix: function updateWorldMatrix(t, e) {
      be.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
    }, clone: function clone() {
      return new this.constructor().copy(this);
    } }), Vn.prototype = _extends(Object.create(kn.prototype), { constructor: Vn, isPerspectiveCamera: !0, copy: function copy(t, e) {
      return kn.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : _extends({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    }, setFocalLength: function setFocalLength(t) {
      var e = .5 * this.getFilmHeight() / t;this.fov = 2 * st.RAD2DEG * Math.atan(e), this.updateProjectionMatrix();
    }, getFocalLength: function getFocalLength() {
      var t = Math.tan(.5 * st.DEG2RAD * this.fov);return .5 * this.getFilmHeight() / t;
    }, getEffectiveFOV: function getEffectiveFOV() {
      return 2 * st.RAD2DEG * Math.atan(Math.tan(.5 * st.DEG2RAD * this.fov) / this.zoom);
    }, getFilmWidth: function getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }, getFilmHeight: function getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }, setViewOffset: function setViewOffset(t, e, n, r, i, a) {
      this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix();
    }, clearViewOffset: function clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }, updateProjectionMatrix: function updateProjectionMatrix() {
      var t = this.near,
          e = t * Math.tan(.5 * st.DEG2RAD * this.fov) / this.zoom,
          n = 2 * e,
          r = this.aspect * n,
          i = -.5 * r,
          a = this.view;if (null !== this.view && this.view.enabled) {
        var o = a.fullWidth,
            s = a.fullHeight;i += a.offsetX * r / o, e -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s;
      }var c = this.filmOffset;0 !== c && (i += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    }, toJSON: function toJSON(t) {
      var e = be.prototype.toJSON.call(this, t);return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = _extends({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
    } });var Wn = 90;function jn(t, e, n) {
    if (be.call(this), this.type = "CubeCamera", !0 === n.isWebGLCubeRenderTarget) {
      this.renderTarget = n;var r = new Vn(Wn, 1, t, e);r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new wt(1, 0, 0)), this.add(r);var i = new Vn(Wn, 1, t, e);i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new wt(-1, 0, 0)), this.add(i);var a = new Vn(Wn, 1, t, e);a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new wt(0, 1, 0)), this.add(a);var o = new Vn(Wn, 1, t, e);o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new wt(0, -1, 0)), this.add(o);var s = new Vn(Wn, 1, t, e);s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new wt(0, 0, 1)), this.add(s);var c = new Vn(Wn, 1, t, e);c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new wt(0, 0, -1)), this.add(c), this.update = function (t, e) {
        null === this.parent && this.updateMatrixWorld();var l = t.xr.enabled,
            u = t.getRenderTarget();t.xr.enabled = !1;var h = n.texture.generateMipmaps;n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, s), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l;
      };
    } else console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
  }function qn(t, e, n, i, a, o, s, c, l, u) {
    t = void 0 !== t ? t : [], e = void 0 !== e ? e : r, s = void 0 !== s ? s : S, gt.call(this, t, e, n, i, a, o, s, c, l, u), this.flipY = !1, this._needsFlipEnvMap = !0;
  }function Xn(t, e, n) {
    Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), xt.call(this, t, t, e), e = e || {}, this.texture = new qn(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1;
  }function Yn(t, e, n, r, i, a, o, s, c, l, u, h) {
    gt.call(this, null, a, o, s, c, l, r, i, u, h), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = void 0 !== c ? c : d, this.minFilter = void 0 !== l ? l : d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
  }jn.prototype = Object.create(be.prototype), jn.prototype.constructor = jn, qn.prototype = Object.create(gt.prototype), qn.prototype.constructor = qn, qn.prototype.isCubeTexture = !0, Object.defineProperty(qn.prototype, "images", { get: function get() {
      return this.image;
    }, set: function set(t) {
      this.image = t;
    } }), Xn.prototype = Object.create(xt.prototype), Xn.prototype.constructor = Xn, Xn.prototype.isWebGLCubeRenderTarget = !0, Xn.prototype.fromEquirectangularTexture = function (t, e) {
    this.texture.type = e.type, this.texture.format = T, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;var n = { tEquirect: { value: null } },
        r = "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
        i = "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
        a = new zn(5, 5, 5),
        o = new Hn({ name: "CubemapFromEquirect", uniforms: Gn(n), vertexShader: r, fragmentShader: i, side: 1, blending: 0 });o.uniforms.tEquirect.value = e;var s = new On(a, o),
        c = e.minFilter;return e.minFilter === g && (e.minFilter = m), new jn(1, 10, this).update(t, s), e.minFilter = c, s.geometry.dispose(), s.material.dispose(), this;
  }, Xn.prototype.clear = function (t, e, n, r) {
    for (var i = t.getRenderTarget(), a = 0; a < 6; a++) {
      t.setRenderTarget(this, a), t.clear(e, n, r);
    }t.setRenderTarget(i);
  }, Yn.prototype = Object.create(gt.prototype), Yn.prototype.constructor = Yn, Yn.prototype.isDataTexture = !0;var Zn = new Ht(),
      Jn = new wt(),
      Qn = function () {
    function t(t, e, n, r, i, a) {
      this.planes = [void 0 !== t ? t : new Te(), void 0 !== e ? e : new Te(), void 0 !== n ? n : new Te(), void 0 !== r ? r : new Te(), void 0 !== i ? i : new Te(), void 0 !== a ? a : new Te()];
    }var e = t.prototype;return e.set = function (t, e, n, r, i, a) {
      var o = this.planes;return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      for (var e = this.planes, n = 0; n < 6; n++) {
        e[n].copy(t.planes[n]);
      }return this;
    }, e.setFromProjectionMatrix = function (t) {
      var e = this.planes,
          n = t.elements,
          r = n[0],
          i = n[1],
          a = n[2],
          o = n[3],
          s = n[4],
          c = n[5],
          l = n[6],
          u = n[7],
          h = n[8],
          d = n[9],
          p = n[10],
          f = n[11],
          m = n[12],
          v = n[13],
          g = n[14],
          y = n[15];return e[0].setComponents(o - r, u - s, f - h, y - m).normalize(), e[1].setComponents(o + r, u + s, f + h, y + m).normalize(), e[2].setComponents(o + i, u + c, f + d, y + v).normalize(), e[3].setComponents(o - i, u - c, f - d, y - v).normalize(), e[4].setComponents(o - a, u - l, f - p, y - g).normalize(), e[5].setComponents(o + a, u + l, f + p, y + g).normalize(), this;
    }, e.intersectsObject = function (t) {
      var e = t.geometry;return null === e.boundingSphere && e.computeBoundingSphere(), Zn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Zn);
    }, e.intersectsSprite = function (t) {
      return Zn.center.set(0, 0, 0), Zn.radius = .7071067811865476, Zn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Zn);
    }, e.intersectsSphere = function (t) {
      for (var e = this.planes, n = t.center, r = -t.radius, i = 0; i < 6; i++) {
        if (e[i].distanceToPoint(n) < r) return !1;
      }return !0;
    }, e.intersectsBox = function (t) {
      for (var e = this.planes, n = 0; n < 6; n++) {
        var r = e[n];if (Jn.x = r.normal.x > 0 ? t.max.x : t.min.x, Jn.y = r.normal.y > 0 ? t.max.y : t.min.y, Jn.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Jn) < 0) return !1;
      }return !0;
    }, e.containsPoint = function (t) {
      for (var e = this.planes, n = 0; n < 6; n++) {
        if (e[n].distanceToPoint(t) < 0) return !1;
      }return !0;
    }, t;
  }();function Kn() {
    var t = null,
        e = !1,
        n = null,
        r = null;function i(e, a) {
      n(e, a), r = t.requestAnimationFrame(i);
    }return { start: function start() {
        !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0);
      }, stop: function stop() {
        t.cancelAnimationFrame(r), e = !1;
      }, setAnimationLoop: function setAnimationLoop(t) {
        n = t;
      }, setContext: function setContext(e) {
        t = e;
      } };
  }function $n(t, e) {
    var n = e.isWebGL2,
        r = new WeakMap();return { get: function get(t) {
        return t.isInterleavedBufferAttribute && (t = t.data), r.get(t);
      }, remove: function remove(e) {
        e.isInterleavedBufferAttribute && (e = e.data);var n = r.get(e);n && (t.deleteBuffer(n.buffer), r.delete(e));
      }, update: function update(e, i) {
        if (e.isGLBufferAttribute) {
          var a = r.get(e);(!a || a.version < e.version) && r.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version });
        } else {
          e.isInterleavedBufferAttribute && (e = e.data);var o = r.get(e);void 0 === o ? r.set(e, function (e, n) {
            var r = e.array,
                i = e.usage,
                a = t.createBuffer();t.bindBuffer(n, a), t.bufferData(n, r, i), e.onUploadCallback();var o = 5126;return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : r instanceof Uint8Array && (o = 5121), { buffer: a, type: o, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version };
          }(e, i)) : o.version < e.version && (!function (e, r, i) {
            var a = r.array,
                o = r.updateRange;t.bindBuffer(i, e), -1 === o.count ? t.bufferSubData(i, 0, a) : (n ? t.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : t.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1);
          }(o.buffer, e, i), o.version = e.version);
        }
      } };
  }var tr = function (t) {
    function e(e, n, r, i) {
      var a;(a = t.call(this) || this).type = "PlaneBufferGeometry", a.parameters = { width: e, height: n, widthSegments: r, heightSegments: i };for (var o = (e = e || 1) / 2, s = (n = n || 1) / 2, c = Math.floor(r) || 1, l = Math.floor(i) || 1, u = c + 1, h = l + 1, d = e / c, p = n / l, f = [], m = [], v = [], g = [], y = 0; y < h; y++) {
        for (var x = y * p - s, _ = 0; _ < u; _++) {
          var b = _ * d - o;m.push(b, -x, 0), v.push(0, 0, 1), g.push(_ / c), g.push(1 - y / l);
        }
      }for (var w = 0; w < l; w++) {
        for (var M = 0; M < c; M++) {
          var S = M + u * w,
              T = M + u * (w + 1),
              E = M + 1 + u * (w + 1),
              A = M + 1 + u * w;f.push(S, T, A), f.push(T, E, A);
        }
      }return a.setIndex(f), a.setAttribute("position", new an(m, 3)), a.setAttribute("normal", new an(v, 3)), a.setAttribute("uv", new an(g, 2)), a;
    }return ut(e, t), e;
  }(vn),
      er = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" },
      nr = { common: { diffuse: { value: new Ve(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ft() }, uv2Transform: { value: new ft() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new pt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ve(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Ve(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ft() } }, sprite: { diffuse: { value: new Ve(15658734) }, opacity: { value: 1 }, center: { value: new pt(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ft() } } },
      rr = { basic: { uniforms: Fn([nr.common, nr.specularmap, nr.envmap, nr.aomap, nr.lightmap, nr.fog]), vertexShader: er.meshbasic_vert, fragmentShader: er.meshbasic_frag }, lambert: { uniforms: Fn([nr.common, nr.specularmap, nr.envmap, nr.aomap, nr.lightmap, nr.emissivemap, nr.fog, nr.lights, { emissive: { value: new Ve(0) } }]), vertexShader: er.meshlambert_vert, fragmentShader: er.meshlambert_frag }, phong: { uniforms: Fn([nr.common, nr.specularmap, nr.envmap, nr.aomap, nr.lightmap, nr.emissivemap, nr.bumpmap, nr.normalmap, nr.displacementmap, nr.fog, nr.lights, { emissive: { value: new Ve(0) }, specular: { value: new Ve(1118481) }, shininess: { value: 30 } }]), vertexShader: er.meshphong_vert, fragmentShader: er.meshphong_frag }, standard: { uniforms: Fn([nr.common, nr.envmap, nr.aomap, nr.lightmap, nr.emissivemap, nr.bumpmap, nr.normalmap, nr.displacementmap, nr.roughnessmap, nr.metalnessmap, nr.fog, nr.lights, { emissive: { value: new Ve(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: er.meshphysical_vert, fragmentShader: er.meshphysical_frag }, toon: { uniforms: Fn([nr.common, nr.aomap, nr.lightmap, nr.emissivemap, nr.bumpmap, nr.normalmap, nr.displacementmap, nr.gradientmap, nr.fog, nr.lights, { emissive: { value: new Ve(0) } }]), vertexShader: er.meshtoon_vert, fragmentShader: er.meshtoon_frag }, matcap: { uniforms: Fn([nr.common, nr.bumpmap, nr.normalmap, nr.displacementmap, nr.fog, { matcap: { value: null } }]), vertexShader: er.meshmatcap_vert, fragmentShader: er.meshmatcap_frag }, points: { uniforms: Fn([nr.points, nr.fog]), vertexShader: er.points_vert, fragmentShader: er.points_frag }, dashed: { uniforms: Fn([nr.common, nr.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: er.linedashed_vert, fragmentShader: er.linedashed_frag }, depth: { uniforms: Fn([nr.common, nr.displacementmap]), vertexShader: er.depth_vert, fragmentShader: er.depth_frag }, normal: { uniforms: Fn([nr.common, nr.bumpmap, nr.normalmap, nr.displacementmap, { opacity: { value: 1 } }]), vertexShader: er.normal_vert, fragmentShader: er.normal_frag }, sprite: { uniforms: Fn([nr.sprite, nr.fog]), vertexShader: er.sprite_vert, fragmentShader: er.sprite_frag }, background: { uniforms: { uvTransform: { value: new ft() }, t2D: { value: null } }, vertexShader: er.background_vert, fragmentShader: er.background_frag }, cube: { uniforms: Fn([nr.envmap, { opacity: { value: 1 } }]), vertexShader: er.cube_vert, fragmentShader: er.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: er.equirect_vert, fragmentShader: er.equirect_frag }, distanceRGBA: { uniforms: Fn([nr.common, nr.displacementmap, { referencePosition: { value: new wt() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: er.distanceRGBA_vert, fragmentShader: er.distanceRGBA_frag }, shadow: { uniforms: Fn([nr.lights, nr.fog, { color: { value: new Ve(0) }, opacity: { value: 1 } }]), vertexShader: er.shadow_vert, fragmentShader: er.shadow_frag } };function ir(t, e, n, r, i) {
    var a,
        o,
        c = new Ve(0),
        l = 0,
        u = null,
        h = 0,
        d = null;function p(t, e) {
      n.buffers.color.setClear(t.r, t.g, t.b, e, i);
    }return { getClearColor: function getClearColor() {
        return c;
      }, setClearColor: function setClearColor(t, e) {
        c.set(t), p(c, l = void 0 !== e ? e : 1);
      }, getClearAlpha: function getClearAlpha() {
        return l;
      }, setClearAlpha: function setClearAlpha(t) {
        p(c, l = t);
      }, render: function render(n, i, f, m) {
        var v = !0 === i.isScene ? i.background : null;v && v.isTexture && (v = e.get(v));var g = t.xr,
            y = g.getSession && g.getSession();y && "additive" === y.environmentBlendMode && (v = null), null === v ? p(c, l) : v && v.isColor && (p(v, 1), m = !0), (t.autoClear || m) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), v && (v.isCubeTexture || v.isWebGLCubeRenderTarget || v.mapping === s) ? (void 0 === o && ((o = new On(new zn(1, 1, 1), new Hn({ name: "BackgroundCubeMaterial", uniforms: Gn(rr.cube.uniforms), vertexShader: rr.cube.vertexShader, fragmentShader: rr.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (t, e, n) {
          this.matrixWorld.copyPosition(n.matrixWorld);
        }, Object.defineProperty(o.material, "envMap", { get: function get() {
            return this.uniforms.envMap.value;
          } }), r.update(o)), v.isWebGLCubeRenderTarget && (v = v.texture), o.material.uniforms.envMap.value = v, o.material.uniforms.flipEnvMap.value = v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1, u === v && h === v.version && d === t.toneMapping || (o.material.needsUpdate = !0, u = v, h = v.version, d = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : v && v.isTexture && (void 0 === a && ((a = new On(new tr(2, 2), new Hn({ name: "BackgroundMaterial", uniforms: Gn(rr.background.uniforms), vertexShader: rr.background.vertexShader, fragmentShader: rr.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", { get: function get() {
            return this.uniforms.t2D.value;
          } }), r.update(a)), a.material.uniforms.t2D.value = v, !0 === v.matrixAutoUpdate && v.updateMatrix(), a.material.uniforms.uvTransform.value.copy(v.matrix), u === v && h === v.version && d === t.toneMapping || (a.material.needsUpdate = !0, u = v, h = v.version, d = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null));
      } };
  }function ar(t, e, n, r) {
    var i = t.getParameter(34921),
        a = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = r.isWebGL2 || null !== a,
        s = {},
        c = d(null),
        l = c;function u(e) {
      return r.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e);
    }function h(e) {
      return r.isWebGL2 ? t.deleteVertexArray(e) : a.deleteVertexArrayOES(e);
    }function d(t) {
      for (var e = [], n = [], r = [], a = 0; a < i; a++) {
        e[a] = 0, n[a] = 0, r[a] = 0;
      }return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: r, object: t, attributes: {}, index: null };
    }function p() {
      for (var t = l.newAttributes, e = 0, n = t.length; e < n; e++) {
        t[e] = 0;
      }
    }function f(t) {
      m(t, 0);
    }function m(n, i) {
      var a = l.newAttributes,
          o = l.enabledAttributes,
          s = l.attributeDivisors;(a[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), s[n] !== i) && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i);
    }function v() {
      for (var e = l.newAttributes, n = l.enabledAttributes, r = 0, i = n.length; r < i; r++) {
        n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0);
      }
    }function g(e, n, i, a, o, s) {
      !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, a, o, s) : t.vertexAttribIPointer(e, n, i, o, s);
    }function y() {
      x(), l !== c && u((l = c).object);
    }function x() {
      c.geometry = null, c.program = null, c.wireframe = !1;
    }return { setup: function setup(i, c, h, y, x) {
        var _ = !1;if (o) {
          var b = function (e, n, i) {
            var o = !0 === i.wireframe,
                c = s[e.id];void 0 === c && (c = {}, s[e.id] = c);var l = c[n.id];void 0 === l && (l = {}, c[n.id] = l);var u = l[o];void 0 === u && (u = d(r.isWebGL2 ? t.createVertexArray() : a.createVertexArrayOES()), l[o] = u);return u;
          }(y, h, c);l !== b && u((l = b).object), (_ = function (t, e) {
            var n = l.attributes,
                r = t.attributes;if (Object.keys(n).length !== Object.keys(r).length) return !0;for (var i in r) {
              var a = n[i],
                  o = r[i];if (void 0 === a) return !0;if (a.attribute !== o) return !0;if (a.data !== o.data) return !0;
            }return l.index !== e;
          }(y, x)) && function (t, e) {
            var n = {},
                r = t.attributes;for (var i in r) {
              var a = r[i],
                  o = {};o.attribute = a, a.data && (o.data = a.data), n[i] = o;
            }l.attributes = n, l.index = e;
          }(y, x);
        } else {
          var w = !0 === c.wireframe;l.geometry === y.id && l.program === h.id && l.wireframe === w || (l.geometry = y.id, l.program = h.id, l.wireframe = w, _ = !0);
        }!0 === i.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (!function (i, a, o, s) {
          if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;p();var c = s.attributes,
              l = o.getAttributes(),
              u = a.defaultAttributeValues;for (var h in l) {
            var d = l[h];if (d >= 0) {
              var y = c[h];if (void 0 !== y) {
                var x = y.normalized,
                    _ = y.itemSize,
                    b = n.get(y);if (void 0 === b) continue;var w = b.buffer,
                    M = b.type,
                    S = b.bytesPerElement;if (y.isInterleavedBufferAttribute) {
                  var T = y.data,
                      E = T.stride,
                      A = y.offset;T && T.isInstancedInterleavedBuffer ? (m(d, T.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = T.meshPerAttribute * T.count)) : f(d), t.bindBuffer(34962, w), g(d, _, M, x, E * S, A * S);
                } else y.isInstancedBufferAttribute ? (m(d, y.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = y.meshPerAttribute * y.count)) : f(d), t.bindBuffer(34962, w), g(d, _, M, x, 0, 0);
              } else if ("instanceMatrix" === h) {
                var L = n.get(i.instanceMatrix);if (void 0 === L) continue;var R = L.buffer,
                    C = L.type;m(d + 0, 1), m(d + 1, 1), m(d + 2, 1), m(d + 3, 1), t.bindBuffer(34962, R), t.vertexAttribPointer(d + 0, 4, C, !1, 64, 0), t.vertexAttribPointer(d + 1, 4, C, !1, 64, 16), t.vertexAttribPointer(d + 2, 4, C, !1, 64, 32), t.vertexAttribPointer(d + 3, 4, C, !1, 64, 48);
              } else if ("instanceColor" === h) {
                var P = n.get(i.instanceColor);if (void 0 === P) continue;var I = P.buffer,
                    D = P.type;m(d, 1), t.bindBuffer(34962, I), t.vertexAttribPointer(d, 3, D, !1, 12, 0);
              } else if (void 0 !== u) {
                var O = u[h];if (void 0 !== O) switch (O.length) {case 2:
                    t.vertexAttrib2fv(d, O);break;case 3:
                    t.vertexAttrib3fv(d, O);break;case 4:
                    t.vertexAttrib4fv(d, O);break;default:
                    t.vertexAttrib1fv(d, O);}
              }
            }
          }v();
        }(i, c, h, y), null !== x && t.bindBuffer(34963, n.get(x).buffer));
      }, reset: y, resetDefaultState: x, dispose: function dispose() {
        for (var t in y(), s) {
          var e = s[t];for (var n in e) {
            var r = e[n];for (var i in r) {
              h(r[i].object), delete r[i];
            }delete e[n];
          }delete s[t];
        }
      }, releaseStatesOfGeometry: function releaseStatesOfGeometry(t) {
        if (void 0 !== s[t.id]) {
          var e = s[t.id];for (var n in e) {
            var r = e[n];for (var i in r) {
              h(r[i].object), delete r[i];
            }delete e[n];
          }delete s[t.id];
        }
      }, releaseStatesOfProgram: function releaseStatesOfProgram(t) {
        for (var e in s) {
          var n = s[e];if (void 0 !== n[t.id]) {
            var r = n[t.id];for (var i in r) {
              h(r[i].object), delete r[i];
            }delete n[t.id];
          }
        }
      }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: v };
  }function or(t, e, n, r) {
    var i,
        a = r.isWebGL2;this.setMode = function (t) {
      i = t;
    }, this.render = function (e, r) {
      t.drawArrays(i, e, r), n.update(r, i, 1);
    }, this.renderInstances = function (r, o, s) {
      if (0 !== s) {
        var c, l;if (a) c = t, l = "drawArraysInstanced";else if (l = "drawArraysInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[l](i, r, o, s), n.update(o, i, s);
      }
    };
  }function sr(t, e, n) {
    var r;function i(e) {
      if ("highp" === e) {
        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";e = "mediump";
      }return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
        o = void 0 !== n.precision ? n.precision : "highp",
        s = i(o);s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);var c = !0 === n.logarithmicDepthBuffer,
        l = t.getParameter(34930),
        u = t.getParameter(35660),
        h = t.getParameter(3379),
        d = t.getParameter(34076),
        p = t.getParameter(34921),
        f = t.getParameter(36347),
        m = t.getParameter(36348),
        v = t.getParameter(36349),
        g = u > 0,
        y = a || !!e.get("OES_texture_float");return { isWebGL2: a, getMaxAnisotropy: function getMaxAnisotropy() {
        if (void 0 !== r) return r;var n = e.get("EXT_texture_filter_anisotropic");return r = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      }, getMaxPrecision: i, precision: o, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: u, maxTextureSize: h, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: v, vertexTextures: g, floatFragmentTextures: y, floatVertexTextures: g && y, maxSamples: a ? t.getParameter(36183) : 0 };
  }function cr(t) {
    var e = this,
        n = null,
        r = 0,
        i = !1,
        a = !1,
        o = new Te(),
        s = new ft(),
        c = { value: null, needsUpdate: !1 };function l() {
      c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
    }function u(t, n, r, i) {
      var a = null !== t ? t.length : 0,
          l = null;if (0 !== a) {
        if (l = c.value, !0 !== i || null === l) {
          var u = r + 4 * a,
              h = n.matrixWorldInverse;s.getNormalMatrix(h), (null === l || l.length < u) && (l = new Float32Array(u));for (var d = 0, p = r; d !== a; ++d, p += 4) {
            o.copy(t[d]).applyMatrix4(h, s), o.normal.toArray(l, p), l[p + 3] = o.constant;
          }
        }c.value = l, c.needsUpdate = !0;
      }return e.numPlanes = a, e.numIntersection = 0, l;
    }this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, a) {
      var o = 0 !== t.length || e || 0 !== r || i;return i = e, n = u(t, a, 0), r = t.length, o;
    }, this.beginShadows = function () {
      a = !0, u(null);
    }, this.endShadows = function () {
      a = !1, l();
    }, this.setState = function (e, o, s) {
      var h = e.clippingPlanes,
          d = e.clipIntersection,
          p = e.clipShadows,
          f = t.get(e);if (!i || null === h || 0 === h.length || a && !p) a ? u(null) : l();else {
        var m = a ? 0 : r,
            v = 4 * m,
            g = f.clippingState || null;c.value = g, g = u(h, o, v, s);for (var y = 0; y !== v; ++y) {
          g[y] = n[y];
        }f.clippingState = g, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += m;
      }
    };
  }function lr(t) {
    var e = new WeakMap();function n(t, e) {
      return e === a ? t.mapping = r : e === o && (t.mapping = i), t;
    }function s(t) {
      var n = t.target;n.removeEventListener("dispose", s);var r = e.get(n);void 0 !== r && (e.delete(n), r.dispose());
    }return { get: function get(r) {
        if (r && r.isTexture) {
          var i = r.mapping;if (i === a || i === o) {
            if (e.has(r)) return n(e.get(r).texture, r.mapping);var c = r.image;if (c && c.height > 0) {
              var l = t.getRenderList(),
                  u = t.getRenderTarget(),
                  h = t.getRenderState(),
                  d = new Xn(c.height / 2);return d.fromEquirectangularTexture(t, r), e.set(r, d), t.setRenderTarget(u), t.setRenderList(l), t.setRenderState(h), r.addEventListener("dispose", s), n(d.texture, r.mapping);
            }return null;
          }
        }return r;
      }, dispose: function dispose() {
        e = new WeakMap();
      } };
  }function ur(t) {
    var e = {};return { has: function has(n) {
        if (void 0 !== e[n]) return null !== e[n];var r;switch (n) {case "WEBGL_depth_texture":
            r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");break;case "EXT_texture_filter_anisotropic":
            r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case "WEBGL_compressed_texture_s3tc":
            r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case "WEBGL_compressed_texture_pvrtc":
            r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:
            r = t.getExtension(n);}return e[n] = r, null !== r;
      }, get: function get(t) {
        return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e[t];
      } };
  }function hr(t, e, n, r) {
    var i = new WeakMap(),
        a = new WeakMap();function o(t) {
      var s = t.target,
          c = i.get(s);for (var l in null !== c.index && e.remove(c.index), c.attributes) {
        e.remove(c.attributes[l]);
      }s.removeEventListener("dispose", o), i.delete(s);var u = a.get(c);u && (e.remove(u), a.delete(c)), r.releaseStatesOfGeometry(c), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--;
    }function s(t) {
      var n = [],
          r = t.index,
          i = t.attributes.position,
          o = 0;if (null !== r) {
        var s = r.array;o = r.version;for (var c = 0, l = s.length; c < l; c += 3) {
          var u = s[c + 0],
              h = s[c + 1],
              d = s[c + 2];n.push(u, h, h, d, d, u);
        }
      } else {
        var p = i.array;o = i.version;for (var f = 0, m = p.length / 3 - 1; f < m; f += 3) {
          var v = f + 0,
              g = f + 1,
              y = f + 2;n.push(v, g, g, y, y, v);
        }
      }var x = new (cn(n) > 65535 ? rn : en)(n, 1);x.version = o;var _ = a.get(t);_ && e.remove(_), a.set(t, x);
    }return { get: function get(t, e) {
        var r = i.get(e);return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = new vn().setFromObject(t)), r = e._bufferGeometry), i.set(e, r), n.memory.geometries++, r);
      }, update: function update(t) {
        var n = t.attributes;for (var r in n) {
          e.update(n[r], 34962);
        }var i = t.morphAttributes;for (var a in i) {
          for (var o = i[a], s = 0, c = o.length; s < c; s++) {
            e.update(o[s], 34962);
          }
        }
      }, getWireframeAttribute: function getWireframeAttribute(t) {
        var e = a.get(t);if (e) {
          var n = t.index;null !== n && e.version < n.version && s(t);
        } else s(t);return a.get(t);
      } };
  }function dr(t, e, n, r) {
    var i,
        a,
        o,
        s = r.isWebGL2;this.setMode = function (t) {
      i = t;
    }, this.setIndex = function (t) {
      a = t.type, o = t.bytesPerElement;
    }, this.render = function (e, r) {
      t.drawElements(i, r, a, e * o), n.update(r, i, 1);
    }, this.renderInstances = function (r, c, l) {
      if (0 !== l) {
        var u, h;if (s) u = t, h = "drawElementsInstanced";else if (h = "drawElementsInstancedANGLE", null === (u = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](i, c, a, r * o, l), n.update(c, i, l);
      }
    };
  }function pr(t) {
    var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function reset() {
        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
      }, update: function update(t, n, r) {
        switch (e.calls++, n) {case 4:
            e.triangles += r * (t / 3);break;case 1:
            e.lines += r * (t / 2);break;case 3:
            e.lines += r * (t - 1);break;case 2:
            e.lines += r * t;break;case 0:
            e.points += r * t;break;default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);}
      } };
  }function fr(t, e) {
    return t[0] - e[0];
  }function mr(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }function vr(t) {
    for (var e = {}, n = new Float32Array(8), r = [], i = 0; i < 8; i++) {
      r[i] = [i, 0];
    }return { update: function update(i, a, o, s) {
        var c = i.morphTargetInfluences,
            l = void 0 === c ? 0 : c.length,
            u = e[a.id];if (void 0 === u) {
          u = [];for (var h = 0; h < l; h++) {
            u[h] = [h, 0];
          }e[a.id] = u;
        }for (var d = 0; d < l; d++) {
          var p = u[d];p[0] = d, p[1] = c[d];
        }u.sort(mr);for (var f = 0; f < 8; f++) {
          f < l && u[f][1] ? (r[f][0] = u[f][0], r[f][1] = u[f][1]) : (r[f][0] = Number.MAX_SAFE_INTEGER, r[f][1] = 0);
        }r.sort(fr);for (var m = o.morphTargets && a.morphAttributes.position, v = o.morphNormals && a.morphAttributes.normal, g = 0, y = 0; y < 8; y++) {
          var x = r[y],
              _ = x[0],
              b = x[1];_ !== Number.MAX_SAFE_INTEGER && b ? (m && a.getAttribute("morphTarget" + y) !== m[_] && a.setAttribute("morphTarget" + y, m[_]), v && a.getAttribute("morphNormal" + y) !== v[_] && a.setAttribute("morphNormal" + y, v[_]), n[y] = b, g += b) : (m && void 0 !== a.getAttribute("morphTarget" + y) && a.deleteAttribute("morphTarget" + y), v && void 0 !== a.getAttribute("morphNormal" + y) && a.deleteAttribute("morphNormal" + y), n[y] = 0);
        }var w = a.morphTargetsRelative ? 1 : 1 - g;s.getUniforms().setValue(t, "morphTargetBaseInfluence", w), s.getUniforms().setValue(t, "morphTargetInfluences", n);
      } };
  }function gr(t, e, n, r) {
    var i = new WeakMap();return { update: function update(t) {
        var a = r.render.frame,
            o = t.geometry,
            s = e.get(t, o);return i.get(s) !== a && (o.isGeometry && s.updateFromObject(t), e.update(s), i.set(s, a)), t.isInstancedMesh && (n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), s;
      }, dispose: function dispose() {
        i = new WeakMap();
      } };
  }function yr(t, e, n, r) {
    gt.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: r || 1 }, this.magFilter = d, this.minFilter = d, this.wrapR = u, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
  }function xr(t, e, n, r) {
    gt.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: r || 1 }, this.magFilter = d, this.minFilter = d, this.wrapR = u, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
  }rr.physical = { uniforms: Fn([rr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new pt(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Ve(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: er.meshphysical_vert, fragmentShader: er.meshphysical_frag }, yr.prototype = Object.create(gt.prototype), yr.prototype.constructor = yr, yr.prototype.isDataTexture2DArray = !0, xr.prototype = Object.create(gt.prototype), xr.prototype.constructor = xr, xr.prototype.isDataTexture3D = !0;var _r = new gt(),
      br = new yr(),
      wr = new xr(),
      Mr = new qn(),
      Sr = [],
      Tr = [],
      Er = new Float32Array(16),
      Ar = new Float32Array(9),
      Lr = new Float32Array(4);function Rr(t, e, n) {
    var r = t[0];if (r <= 0 || r > 0) return t;var i = e * n,
        a = Sr[i];if (void 0 === a && (a = new Float32Array(i), Sr[i] = a), 0 !== e) {
      r.toArray(a, 0);for (var o = 1, s = 0; o !== e; ++o) {
        s += n, t[o].toArray(a, s);
      }
    }return a;
  }function Cr(t, e) {
    if (t.length !== e.length) return !1;for (var n = 0, r = t.length; n < r; n++) {
      if (t[n] !== e[n]) return !1;
    }return !0;
  }function Pr(t, e) {
    for (var n = 0, r = e.length; n < r; n++) {
      t[n] = e[n];
    }
  }function Ir(t, e) {
    var n = Tr[e];void 0 === n && (n = new Int32Array(e), Tr[e] = n);for (var r = 0; r !== e; ++r) {
      n[r] = t.allocateTextureUnit();
    }return n;
  }function Dr(t, e) {
    var n = this.cache;n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
  }function Or(t, e) {
    var n = this.cache;if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);else {
      if (Cr(n, e)) return;t.uniform2fv(this.addr, e), Pr(n, e);
    }
  }function Nr(t, e) {
    var n = this.cache;if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);else {
      if (Cr(n, e)) return;t.uniform3fv(this.addr, e), Pr(n, e);
    }
  }function Br(t, e) {
    var n = this.cache;if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);else {
      if (Cr(n, e)) return;t.uniform4fv(this.addr, e), Pr(n, e);
    }
  }function zr(t, e) {
    var n = this.cache,
        r = e.elements;if (void 0 === r) {
      if (Cr(n, e)) return;t.uniformMatrix2fv(this.addr, !1, e), Pr(n, e);
    } else {
      if (Cr(n, r)) return;Lr.set(r), t.uniformMatrix2fv(this.addr, !1, Lr), Pr(n, r);
    }
  }function Gr(t, e) {
    var n = this.cache,
        r = e.elements;if (void 0 === r) {
      if (Cr(n, e)) return;t.uniformMatrix3fv(this.addr, !1, e), Pr(n, e);
    } else {
      if (Cr(n, r)) return;Ar.set(r), t.uniformMatrix3fv(this.addr, !1, Ar), Pr(n, r);
    }
  }function Fr(t, e) {
    var n = this.cache,
        r = e.elements;if (void 0 === r) {
      if (Cr(n, e)) return;t.uniformMatrix4fv(this.addr, !1, e), Pr(n, e);
    } else {
      if (Cr(n, r)) return;Er.set(r), t.uniformMatrix4fv(this.addr, !1, Er), Pr(n, r);
    }
  }function Ur(t, e, n) {
    var r = this.cache,
        i = n.allocateTextureUnit();r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || _r, i);
  }function Hr(t, e, n) {
    var r = this.cache,
        i = n.allocateTextureUnit();r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || br, i);
  }function kr(t, e, n) {
    var r = this.cache,
        i = n.allocateTextureUnit();r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || wr, i);
  }function Vr(t, e, n) {
    var r = this.cache,
        i = n.allocateTextureUnit();r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || Mr, i);
  }function Wr(t, e) {
    var n = this.cache;n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
  }function jr(t, e) {
    var n = this.cache;Cr(n, e) || (t.uniform2iv(this.addr, e), Pr(n, e));
  }function qr(t, e) {
    var n = this.cache;Cr(n, e) || (t.uniform3iv(this.addr, e), Pr(n, e));
  }function Xr(t, e) {
    var n = this.cache;Cr(n, e) || (t.uniform4iv(this.addr, e), Pr(n, e));
  }function Yr(t, e) {
    var n = this.cache;n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
  }function Zr(t, e) {
    t.uniform1fv(this.addr, e);
  }function Jr(t, e) {
    t.uniform1iv(this.addr, e);
  }function Qr(t, e) {
    t.uniform2iv(this.addr, e);
  }function Kr(t, e) {
    t.uniform3iv(this.addr, e);
  }function $r(t, e) {
    t.uniform4iv(this.addr, e);
  }function ti(t, e) {
    var n = Rr(e, this.size, 2);t.uniform2fv(this.addr, n);
  }function ei(t, e) {
    var n = Rr(e, this.size, 3);t.uniform3fv(this.addr, n);
  }function ni(t, e) {
    var n = Rr(e, this.size, 4);t.uniform4fv(this.addr, n);
  }function ri(t, e) {
    var n = Rr(e, this.size, 4);t.uniformMatrix2fv(this.addr, !1, n);
  }function ii(t, e) {
    var n = Rr(e, this.size, 9);t.uniformMatrix3fv(this.addr, !1, n);
  }function ai(t, e) {
    var n = Rr(e, this.size, 16);t.uniformMatrix4fv(this.addr, !1, n);
  }function oi(t, e, n) {
    var r = e.length,
        i = Ir(n, r);t.uniform1iv(this.addr, i);for (var a = 0; a !== r; ++a) {
      n.safeSetTexture2D(e[a] || _r, i[a]);
    }
  }function si(t, e, n) {
    var r = e.length,
        i = Ir(n, r);t.uniform1iv(this.addr, i);for (var a = 0; a !== r; ++a) {
      n.safeSetTextureCube(e[a] || Mr, i[a]);
    }
  }function ci(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
      switch (t) {case 5126:
          return Dr;case 35664:
          return Or;case 35665:
          return Nr;case 35666:
          return Br;case 35674:
          return zr;case 35675:
          return Gr;case 35676:
          return Fr;case 5124:case 35670:
          return Wr;case 35667:case 35671:
          return jr;case 35668:case 35672:
          return qr;case 35669:case 35673:
          return Xr;case 5125:
          return Yr;case 35678:case 36198:case 36298:case 36306:case 35682:
          return Ur;case 35679:case 36299:case 36307:
          return kr;case 35680:case 36300:case 36308:case 36293:
          return Vr;case 36289:case 36303:case 36311:case 36292:
          return Hr;}
    }(e.type);
  }function li(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
      switch (t) {case 5126:
          return Zr;case 35664:
          return ti;case 35665:
          return ei;case 35666:
          return ni;case 35674:
          return ri;case 35675:
          return ii;case 35676:
          return ai;case 5124:case 35670:
          return Jr;case 35667:case 35671:
          return Qr;case 35668:case 35672:
          return Kr;case 35669:case 35673:
          return $r;case 35678:case 36198:case 36298:case 36306:case 35682:
          return oi;case 35680:case 36300:case 36308:case 36293:
          return si;}
    }(e.type);
  }function ui(t) {
    this.id = t, this.seq = [], this.map = {};
  }li.prototype.updateCache = function (t) {
    var e = this.cache;t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Pr(e, t);
  }, ui.prototype.setValue = function (t, e, n) {
    for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
      var o = r[i];o.setValue(t, e[o.id], n);
    }
  };var hi = /([\w\d_]+)(\])?(\[|\.)?/g;function di(t, e) {
    t.seq.push(e), t.map[e.id] = e;
  }function pi(t, e, n) {
    var r = t.name,
        i = r.length;for (hi.lastIndex = 0;;) {
      var a = hi.exec(r),
          o = hi.lastIndex,
          s = a[1],
          c = "]" === a[2],
          l = a[3];if (c && (s |= 0), void 0 === l || "[" === l && o + 2 === i) {
        di(n, void 0 === l ? new ci(s, t, e) : new li(s, t, e));break;
      }var u = n.map[s];void 0 === u && di(n, u = new ui(s)), n = u;
    }
  }function fi(t, e) {
    this.seq = [], this.map = {};for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
      var i = t.getActiveUniform(e, r);pi(i, t.getUniformLocation(e, i.name), this);
    }
  }function mi(t, e, n) {
    var r = t.createShader(e);return t.shaderSource(r, n), t.compileShader(r), r;
  }fi.prototype.setValue = function (t, e, n, r) {
    var i = this.map[e];void 0 !== i && i.setValue(t, n, r);
  }, fi.prototype.setOptional = function (t, e, n) {
    var r = e[n];void 0 !== r && this.setValue(t, n, r);
  }, fi.upload = function (t, e, n, r) {
    for (var i = 0, a = e.length; i !== a; ++i) {
      var o = e[i],
          s = n[o.id];!1 !== s.needsUpdate && o.setValue(t, s.value, r);
    }
  }, fi.seqWithValue = function (t, e) {
    for (var n = [], r = 0, i = t.length; r !== i; ++r) {
      var a = t[r];a.id in e && n.push(a);
    }return n;
  };var vi = 0;function gi(t) {
    switch (t) {case q:
        return ["Linear", "( value )"];case X:
        return ["sRGB", "( value )"];case Z:
        return ["RGBE", "( value )"];case J:
        return ["RGBM", "( value, 7.0 )"];case Q:
        return ["RGBM", "( value, 16.0 )"];case K:
        return ["RGBD", "( value, 256.0 )"];case Y:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];case 3003:
        return ["LogLuv", "( value )"];default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];}
  }function yi(t, e, n) {
    var r = t.getShaderParameter(e, 35713),
        i = t.getShaderInfoLog(e).trim();return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function (t) {
      for (var e = t.split("\n"), n = 0; n < e.length; n++) {
        e[n] = n + 1 + ": " + e[n];
      }return e.join("\n");
    }(t.getShaderSource(e));
  }function xi(t, e) {
    var n = gi(e);return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
  }function _i(t, e) {
    var n;switch (e) {case 1:
        n = "Linear";break;case 2:
        n = "Reinhard";break;case 3:
        n = "OptimizedCineon";break;case 4:
        n = "ACESFilmic";break;case 5:
        n = "Custom";break;default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";}return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
  }function bi(t) {
    return "" !== t;
  }function wi(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }function Mi(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
  }var Si = /^[ \t]*#include +<([\w\d./]+)>/gm;function Ti(t) {
    return t.replace(Si, Ei);
  }function Ei(t, e) {
    var n = er[e];if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");return Ti(n);
  }var Ai = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      Li = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ri(t) {
    return t.replace(Li, Pi).replace(Ai, Ci);
  }function Ci(t, e, n, r) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Pi(t, e, n, r);
  }function Pi(t, e, n, r) {
    for (var i = "", a = parseInt(e); a < parseInt(n); a++) {
      i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
    }return i;
  }function Ii(t) {
    var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
  }function Di(t, e, n, a) {
    var o,
        l,
        u,
        h,
        d,
        p = t.getContext(),
        f = n.defines,
        m = n.vertexShader,
        v = n.fragmentShader,
        g = function (t) {
      var e = "SHADOWMAP_TYPE_BASIC";return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
    }(n),
        y = function (t) {
      var e = "ENVMAP_TYPE_CUBE";if (t.envMap) switch (t.envMapMode) {case r:case i:
          e = "ENVMAP_TYPE_CUBE";break;case s:case c:
          e = "ENVMAP_TYPE_CUBE_UV";}return e;
    }(n),
        x = function (t) {
      var e = "ENVMAP_MODE_REFLECTION";if (t.envMap) switch (t.envMapMode) {case i:case c:
          e = "ENVMAP_MODE_REFRACTION";}return e;
    }(n),
        _ = function (t) {
      var e = "ENVMAP_BLENDING_NONE";if (t.envMap) switch (t.combine) {case 0:
          e = "ENVMAP_BLENDING_MULTIPLY";break;case 1:
          e = "ENVMAP_BLENDING_MIX";break;case 2:
          e = "ENVMAP_BLENDING_ADD";}return e;
    }(n),
        b = t.gammaFactor > 0 ? t.gammaFactor : 1,
        w = n.isWebGL2 ? "" : function (t) {
      return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(bi).join("\n");
    }(n),
        M = function (t) {
      var e = [];for (var n in t) {
        var r = t[n];!1 !== r && e.push("#define " + n + " " + r);
      }return e.join("\n");
    }(f),
        S = p.createProgram(),
        T = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";n.isRawShaderMaterial ? ((o = [M].filter(bi).join("\n")).length > 0 && (o += "\n"), (l = [w, M].filter(bi).join("\n")).length > 0 && (l += "\n")) : (o = [Ii(n), "#define SHADER_NAME " + n.shaderName, M, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + b, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + x : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + g : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(bi).join("\n"), l = [w, Ii(n), "#define SHADER_NAME " + n.shaderName, M, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + b, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + y : "", n.envMap ? "#define " + x : "", n.envMap ? "#define " + _ : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + g : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? er.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? _i("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", er.encodings_pars_fragment, n.map ? xi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? xi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? xi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? xi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? xi("lightMapTexelToLinear", n.lightMapEncoding) : "", (u = "linearToOutputTexel", h = n.outputEncoding, d = gi(h), "vec4 " + u + "( vec4 value ) { return LinearTo" + d[0] + d[1] + "; }"), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(bi).join("\n")), m = Mi(m = wi(m = Ti(m), n), n), v = Mi(v = wi(v = Ti(v), n), n), m = Ri(m), v = Ri(v), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (T = "#version 300 es\n", o = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + o, l = ["#define varying in", n.glslVersion === nt ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === nt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + l);var E,
        A,
        L = T + l + v,
        R = mi(p, 35633, T + o + m),
        C = mi(p, 35632, L);if (p.attachShader(S, R), p.attachShader(S, C), void 0 !== n.index0AttributeName ? p.bindAttribLocation(S, 0, n.index0AttributeName) : !0 === n.morphTargets && p.bindAttribLocation(S, 0, "position"), p.linkProgram(S), t.debug.checkShaderErrors) {
      var P = p.getProgramInfoLog(S).trim(),
          I = p.getShaderInfoLog(R).trim(),
          D = p.getShaderInfoLog(C).trim(),
          O = !0,
          N = !0;if (!1 === p.getProgramParameter(S, 35714)) {
        O = !1;var B = yi(p, R, "vertex"),
            z = yi(p, C, "fragment");console.error("THREE.WebGLProgram: shader error: ", p.getError(), "35715", p.getProgramParameter(S, 35715), "gl.getProgramInfoLog", P, B, z);
      } else "" !== P ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P) : "" !== I && "" !== D || (N = !1);N && (this.diagnostics = { runnable: O, programLog: P, vertexShader: { log: I, prefix: o }, fragmentShader: { log: D, prefix: l } });
    }return p.deleteShader(R), p.deleteShader(C), this.getUniforms = function () {
      return void 0 === E && (E = new fi(p, S)), E;
    }, this.getAttributes = function () {
      return void 0 === A && (A = function (t, e) {
        for (var n = {}, r = t.getProgramParameter(e, 35721), i = 0; i < r; i++) {
          var a = t.getActiveAttrib(e, i).name;n[a] = t.getAttribLocation(e, a);
        }return n;
      }(p, S)), A;
    }, this.destroy = function () {
      a.releaseStatesOfProgram(this), p.deleteProgram(S), this.program = void 0;
    }, this.name = n.shaderName, this.id = vi++, this.cacheKey = e, this.usedTimes = 1, this.program = S, this.vertexShader = R, this.fragmentShader = C, this;
  }function Oi(t, e, n, r, i, a) {
    var o = [],
        l = r.isWebGL2,
        u = r.logarithmicDepthBuffer,
        h = r.floatVertexTextures,
        d = r.maxVertexUniforms,
        p = r.vertexTextures,
        f = r.precision,
        m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
        v = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];function g(t) {
      var e;return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = q, e;
    }return { getParameters: function getParameters(i, o, v, y, x) {
        var _,
            b,
            w = y.fog,
            M = i.isMeshStandardMaterial ? y.environment : null,
            S = e.get(i.envMap || M),
            T = m[i.type],
            E = x.isSkinnedMesh ? function (t) {
          var e = t.skeleton.bones;if (h) return 1024;var n = d,
              r = Math.floor((n - 20) / 4),
              i = Math.min(r, e.length);return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i;
        }(x) : 0;if (null !== i.precision && (f = r.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", f, "instead."), T) {
          var A = rr[T];_ = A.vertexShader, b = A.fragmentShader;
        } else _ = i.vertexShader, b = i.fragmentShader;var L = t.getRenderTarget();return { isWebGL2: l, shaderID: T, shaderName: i.type, vertexShader: _, fragmentShader: b, defines: i.defines, isRawShaderMaterial: !0 === i.isRawShaderMaterial, glslVersion: i.glslVersion, precision: f, instancing: !0 === x.isInstancedMesh, instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor, supportsVertexTextures: p, outputEncoding: null !== L ? g(L.texture) : t.outputEncoding, map: !!i.map, mapEncoding: g(i.map), matcap: !!i.matcap, matcapEncoding: g(i.matcap), envMap: !!S, envMapMode: S && S.mapping, envMapEncoding: g(S), envMapCubeUV: !!S && (S.mapping === s || S.mapping === c), lightMap: !!i.lightMap, lightMapEncoding: g(i.lightMap), aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: g(i.emissiveMap), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, objectSpaceNormalMap: 1 === i.normalMapType, tangentSpaceNormalMap: 0 === i.normalMapType, clearcoatMap: !!i.clearcoatMap, clearcoatRoughnessMap: !!i.clearcoatRoughnessMap, clearcoatNormalMap: !!i.clearcoatNormalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, sheen: !!i.sheen, transmissionMap: !!i.transmissionMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap), uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap), fog: !!w, useFog: i.fog, fogExp2: w && w.isFogExp2, flatShading: i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: u, skinning: i.skinning && E > 0, maxBones: E, useVertexTexture: h, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: i.dithering, shadowMapEnabled: t.shadowMap.enabled && v.length > 0, shadowMapType: t.shadowMap.type, toneMapping: i.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: 2 === i.side, flipSided: 1 === i.side, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: l || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"), customProgramCacheKey: i.customProgramCacheKey() };
      }, getProgramCacheKey: function getProgramCacheKey(e) {
        var n = [];if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (var r in e.defines) {
          n.push(r), n.push(e.defines[r]);
        }if (!1 === e.isRawShaderMaterial) {
          for (var i = 0; i < v.length; i++) {
            n.push(e[v[i]]);
          }n.push(t.outputEncoding), n.push(t.gammaFactor);
        }return n.push(e.customProgramCacheKey), n.join();
      }, getUniforms: function getUniforms(t) {
        var e,
            n = m[t.type];if (n) {
          var r = rr[n];e = Un.clone(r.uniforms);
        } else e = t.uniforms;return e;
      }, acquireProgram: function acquireProgram(e, n) {
        for (var r, a = 0, s = o.length; a < s; a++) {
          var c = o[a];if (c.cacheKey === n) {
            ++(r = c).usedTimes;break;
          }
        }return void 0 === r && (r = new Di(t, n, e, i), o.push(r)), r;
      }, releaseProgram: function releaseProgram(t) {
        if (0 == --t.usedTimes) {
          var e = o.indexOf(t);o[e] = o[o.length - 1], o.pop(), t.destroy();
        }
      }, programs: o };
  }function Ni() {
    var t = new WeakMap();return { get: function get(e) {
        var n = t.get(e);return void 0 === n && (n = {}, t.set(e, n)), n;
      }, remove: function remove(e) {
        t.delete(e);
      }, update: function update(e, n, r) {
        t.get(e)[n] = r;
      }, dispose: function dispose() {
        t = new WeakMap();
      } };
  }function Bi(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
  }function zi(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
  }function Gi(t) {
    var e = [],
        n = 0,
        r = [],
        i = [],
        a = { id: -1 };function o(r, i, o, s, c, l) {
      var u = e[n],
          h = t.get(o);return void 0 === u ? (u = { id: r.id, object: r, geometry: i, material: o, program: h.program || a, groupOrder: s, renderOrder: r.renderOrder, z: c, group: l }, e[n] = u) : (u.id = r.id, u.object = r, u.geometry = i, u.material = o, u.program = h.program || a, u.groupOrder = s, u.renderOrder = r.renderOrder, u.z = c, u.group = l), n++, u;
    }return { opaque: r, transparent: i, init: function init() {
        n = 0, r.length = 0, i.length = 0;
      }, push: function push(t, e, n, a, s, c) {
        var l = o(t, e, n, a, s, c);(!0 === n.transparent ? i : r).push(l);
      }, unshift: function unshift(t, e, n, a, s, c) {
        var l = o(t, e, n, a, s, c);(!0 === n.transparent ? i : r).unshift(l);
      }, finish: function finish() {
        for (var t = n, r = e.length; t < r; t++) {
          var i = e[t];if (null === i.id) break;i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null;
        }
      }, sort: function sort(t, e) {
        r.length > 1 && r.sort(t || Bi), i.length > 1 && i.sort(e || zi);
      } };
  }function Fi(t) {
    var e = new WeakMap();return { get: function get(n, r) {
        var i,
            a = e.get(n);return void 0 === a ? (i = new Gi(t), e.set(n, new WeakMap()), e.get(n).set(r, i)) : void 0 === (i = a.get(r)) && (i = new Gi(t), a.set(r, i)), i;
      }, dispose: function dispose() {
        e = new WeakMap();
      } };
  }function Ui() {
    var t = {};return { get: function get(e) {
        if (void 0 !== t[e.id]) return t[e.id];var n;switch (e.type) {case "DirectionalLight":
            n = { direction: new wt(), color: new Ve() };break;case "SpotLight":
            n = { position: new wt(), direction: new wt(), color: new Ve(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };break;case "PointLight":
            n = { position: new wt(), color: new Ve(), distance: 0, decay: 0 };break;case "HemisphereLight":
            n = { direction: new wt(), skyColor: new Ve(), groundColor: new Ve() };break;case "RectAreaLight":
            n = { color: new Ve(), position: new wt(), halfWidth: new wt(), halfHeight: new wt() };}return t[e.id] = n, n;
      } };
  }var Hi = 0;function ki(t, e) {
    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
  }function Vi(t, e) {
    for (var n, r = new Ui(), i = (n = {}, { get: function get(t) {
        if (void 0 !== n[t.id]) return n[t.id];var e;switch (t.type) {case "DirectionalLight":case "SpotLight":
            e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pt() };break;case "PointLight":
            e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };}return n[t.id] = e, e;
      } }), a = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, o = 0; o < 9; o++) {
      a.probe.push(new wt());
    }var s = new wt(),
        c = new Jt(),
        l = new Jt();return { setup: function setup(n, o, u) {
        for (var h = 0, d = 0, p = 0, f = 0; f < 9; f++) {
          a.probe[f].set(0, 0, 0);
        }var m = 0,
            v = 0,
            g = 0,
            y = 0,
            x = 0,
            _ = 0,
            b = 0,
            w = 0,
            M = u.matrixWorldInverse;n.sort(ki);for (var S = 0, T = n.length; S < T; S++) {
          var E = n[S],
              A = E.color,
              L = E.intensity,
              R = E.distance,
              C = E.shadow && E.shadow.map ? E.shadow.map.texture : null;if (E.isAmbientLight) h += A.r * L, d += A.g * L, p += A.b * L;else if (E.isLightProbe) for (var P = 0; P < 9; P++) {
            a.probe[P].addScaledVector(E.sh.coefficients[P], L);
          } else if (E.isDirectionalLight) {
            var I = r.get(E);if (I.color.copy(E.color).multiplyScalar(E.intensity), I.direction.setFromMatrixPosition(E.matrixWorld), s.setFromMatrixPosition(E.target.matrixWorld), I.direction.sub(s), I.direction.transformDirection(M), E.castShadow) {
              var D = E.shadow,
                  O = i.get(E);O.shadowBias = D.bias, O.shadowNormalBias = D.normalBias, O.shadowRadius = D.radius, O.shadowMapSize = D.mapSize, a.directionalShadow[m] = O, a.directionalShadowMap[m] = C, a.directionalShadowMatrix[m] = E.shadow.matrix, _++;
            }a.directional[m] = I, m++;
          } else if (E.isSpotLight) {
            var N = r.get(E);if (N.position.setFromMatrixPosition(E.matrixWorld), N.position.applyMatrix4(M), N.color.copy(A).multiplyScalar(L), N.distance = R, N.direction.setFromMatrixPosition(E.matrixWorld), s.setFromMatrixPosition(E.target.matrixWorld), N.direction.sub(s), N.direction.transformDirection(M), N.coneCos = Math.cos(E.angle), N.penumbraCos = Math.cos(E.angle * (1 - E.penumbra)), N.decay = E.decay, E.castShadow) {
              var B = E.shadow,
                  z = i.get(E);z.shadowBias = B.bias, z.shadowNormalBias = B.normalBias, z.shadowRadius = B.radius, z.shadowMapSize = B.mapSize, a.spotShadow[g] = z, a.spotShadowMap[g] = C, a.spotShadowMatrix[g] = E.shadow.matrix, w++;
            }a.spot[g] = N, g++;
          } else if (E.isRectAreaLight) {
            var G = r.get(E);G.color.copy(A).multiplyScalar(L), G.position.setFromMatrixPosition(E.matrixWorld), G.position.applyMatrix4(M), l.identity(), c.copy(E.matrixWorld), c.premultiply(M), l.extractRotation(c), G.halfWidth.set(.5 * E.width, 0, 0), G.halfHeight.set(0, .5 * E.height, 0), G.halfWidth.applyMatrix4(l), G.halfHeight.applyMatrix4(l), a.rectArea[y] = G, y++;
          } else if (E.isPointLight) {
            var F = r.get(E);if (F.position.setFromMatrixPosition(E.matrixWorld), F.position.applyMatrix4(M), F.color.copy(E.color).multiplyScalar(E.intensity), F.distance = E.distance, F.decay = E.decay, E.castShadow) {
              var U = E.shadow,
                  H = i.get(E);H.shadowBias = U.bias, H.shadowNormalBias = U.normalBias, H.shadowRadius = U.radius, H.shadowMapSize = U.mapSize, H.shadowCameraNear = U.camera.near, H.shadowCameraFar = U.camera.far, a.pointShadow[v] = H, a.pointShadowMap[v] = C, a.pointShadowMatrix[v] = E.shadow.matrix, b++;
            }a.point[v] = F, v++;
          } else if (E.isHemisphereLight) {
            var k = r.get(E);k.direction.setFromMatrixPosition(E.matrixWorld), k.direction.transformDirection(M), k.direction.normalize(), k.skyColor.copy(E.color).multiplyScalar(L), k.groundColor.copy(E.groundColor).multiplyScalar(L), a.hemi[x] = k, x++;
          }
        }y > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (a.rectAreaLTC1 = nr.LTC_FLOAT_1, a.rectAreaLTC2 = nr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (a.rectAreaLTC1 = nr.LTC_HALF_1, a.rectAreaLTC2 = nr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), a.ambient[0] = h, a.ambient[1] = d, a.ambient[2] = p;var V = a.hash;V.directionalLength === m && V.pointLength === v && V.spotLength === g && V.rectAreaLength === y && V.hemiLength === x && V.numDirectionalShadows === _ && V.numPointShadows === b && V.numSpotShadows === w || (a.directional.length = m, a.spot.length = g, a.rectArea.length = y, a.point.length = v, a.hemi.length = x, a.directionalShadow.length = _, a.directionalShadowMap.length = _, a.pointShadow.length = b, a.pointShadowMap.length = b, a.spotShadow.length = w, a.spotShadowMap.length = w, a.directionalShadowMatrix.length = _, a.pointShadowMatrix.length = b, a.spotShadowMatrix.length = w, V.directionalLength = m, V.pointLength = v, V.spotLength = g, V.rectAreaLength = y, V.hemiLength = x, V.numDirectionalShadows = _, V.numPointShadows = b, V.numSpotShadows = w, a.version = Hi++);
      }, state: a };
  }function Wi(t, e) {
    var n = new Vi(t, e),
        r = [],
        i = [];return { init: function init() {
        r.length = 0, i.length = 0;
      }, state: { lightsArray: r, shadowsArray: i, lights: n }, setupLights: function setupLights(t) {
        n.setup(r, i, t);
      }, pushLight: function pushLight(t) {
        r.push(t);
      }, pushShadow: function pushShadow(t) {
        i.push(t);
      } };
  }function ji(t, e) {
    var n = new WeakMap();return { get: function get(r, i) {
        var a;return !1 === n.has(r) ? (a = new Wi(t, e), n.set(r, new WeakMap()), n.get(r).set(i, a)) : !1 === n.get(r).has(i) ? (a = new Wi(t, e), n.get(r).set(i, a)) : a = n.get(r).get(i), a;
      }, dispose: function dispose() {
        n = new WeakMap();
      } };
  }function qi(t) {
    qe.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t);
  }function Xi(t) {
    qe.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new wt(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t);
  }qi.prototype = Object.create(qe.prototype), qi.prototype.constructor = qi, qi.prototype.isMeshDepthMaterial = !0, qi.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }, Xi.prototype = Object.create(qe.prototype), Xi.prototype.constructor = Xi, Xi.prototype.isMeshDistanceMaterial = !0, Xi.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  };function Yi(t, e, n) {
    var r = new Qn(),
        i = new pt(),
        a = new pt(),
        o = new yt(),
        s = [],
        c = [],
        l = {},
        u = { 0: 1, 1: 0, 2: 2 },
        h = new Hn({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new pt() }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }),
        p = h.clone();p.defines.HORIZONAL_PASS = 1;var f = new vn();f.setAttribute("position", new Je(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));var v = new On(f, h),
        g = this;function y(n, r) {
      var i = e.update(v);h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, h, v, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, p, v, null);
    }function x(t, e, n) {
      var r = t << 0 | e << 1 | n << 2,
          i = s[r];return void 0 === i && (i = new qi({ depthPacking: 3201, morphTargets: t, skinning: e }), s[r] = i), i;
    }function _(t, e, n) {
      var r = t << 0 | e << 1 | n << 2,
          i = c[r];return void 0 === i && (i = new Xi({ morphTargets: t, skinning: e }), c[r] = i), i;
    }function b(e, n, r, i, a, o, s) {
      var c = null,
          h = x,
          d = e.customDepthMaterial;if (!0 === i.isPointLight && (h = _, d = e.customDistanceMaterial), void 0 === d) {
        var p = !1;!0 === r.morphTargets && (p = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);var f = !1;!0 === e.isSkinnedMesh && (!0 === r.skinning ? f = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), c = h(p, f, !0 === e.isInstancedMesh);
      } else c = d;if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
        var m = c.uuid,
            v = r.uuid,
            g = l[m];void 0 === g && (g = {}, l[m] = g);var y = g[v];void 0 === y && (y = c.clone(), g[v] = y), c = y;
      }return c.visible = r.visible, c.wireframe = r.wireframe, c.side = 3 === s ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : u[r.side], c.clipShadows = r.clipShadows, c.clippingPlanes = r.clippingPlanes, c.clipIntersection = r.clipIntersection, c.wireframeLinewidth = r.wireframeLinewidth, c.linewidth = r.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = a, c.farDistance = o), c;
    }function w(n, i, a, o, s) {
      if (!1 !== n.visible) {
        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || r.intersectsObject(n))) {
          n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);var c = e.update(n),
              l = n.material;if (Array.isArray(l)) for (var u = c.groups, h = 0, d = u.length; h < d; h++) {
            var p = u[h],
                f = l[p.materialIndex];if (f && f.visible) {
              var m = b(n, c, f, o, a.near, a.far, s);t.renderBufferDirect(a, null, c, m, n, p);
            }
          } else if (l.visible) {
            var v = b(n, c, l, o, a.near, a.far, s);t.renderBufferDirect(a, null, c, v, n, null);
          }
        }for (var g = n.children, y = 0, x = g.length; y < x; y++) {
          w(g[y], i, a, o, s);
        }
      }
    }this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, s, c) {
      if (!1 !== g.enabled && (!1 !== g.autoUpdate || !1 !== g.needsUpdate) && 0 !== e.length) {
        var l = t.getRenderTarget(),
            u = t.getActiveCubeFace(),
            h = t.getActiveMipmapLevel(),
            p = t.state;p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);for (var f = 0, v = e.length; f < v; f++) {
          var x = e[f],
              _ = x.shadow;if (void 0 !== _) {
            if (!1 !== _.autoUpdate || !1 !== _.needsUpdate) {
              i.copy(_.mapSize);var b = _.getFrameExtents();if (i.multiply(b), a.copy(_.mapSize), (i.x > n || i.y > n) && (i.x > n && (a.x = Math.floor(n / b.x), i.x = a.x * b.x, _.mapSize.x = a.x), i.y > n && (a.y = Math.floor(n / b.y), i.y = a.y * b.y, _.mapSize.y = a.y)), null === _.map && !_.isPointLightShadow && 3 === this.type) {
                var M = { minFilter: m, magFilter: m, format: T };_.map = new xt(i.x, i.y, M), _.map.texture.name = x.name + ".shadowMap", _.mapPass = new xt(i.x, i.y, M), _.camera.updateProjectionMatrix();
              }if (null === _.map) {
                var S = { minFilter: d, magFilter: d, format: T };_.map = new xt(i.x, i.y, S), _.map.texture.name = x.name + ".shadowMap", _.camera.updateProjectionMatrix();
              }t.setRenderTarget(_.map), t.clear();for (var E = _.getViewportCount(), A = 0; A < E; A++) {
                var L = _.getViewport(A);o.set(a.x * L.x, a.y * L.y, a.x * L.z, a.y * L.w), p.viewport(o), _.updateMatrices(x, A), r = _.getFrustum(), w(s, c, _.camera, x, this.type);
              }_.isPointLightShadow || 3 !== this.type || y(_, c), _.needsUpdate = !1;
            }
          } else console.warn("THREE.WebGLShadowMap:", x, "has no shadow.");
        }g.needsUpdate = !1, t.setRenderTarget(l, u, h);
      }
    };
  }function Zi(t, n, r) {
    var i,
        a,
        o = r.isWebGL2;var s = new function () {
      var e = !1,
          n = new yt(),
          r = null,
          i = new yt(0, 0, 0, 0);return { setMask: function setMask(n) {
          r === n || e || (t.colorMask(n, n, n, n), r = n);
        }, setLocked: function setLocked(t) {
          e = t;
        }, setClear: function setClear(e, r, a, o, s) {
          !0 === s && (e *= o, r *= o, a *= o), n.set(e, r, a, o), !1 === i.equals(n) && (t.clearColor(e, r, a, o), i.copy(n));
        }, reset: function reset() {
          e = !1, r = null, i.set(-1, 0, 0, 0);
        } };
    }(),
        c = new function () {
      var e = !1,
          n = null,
          r = null,
          i = null;return { setTest: function setTest(t) {
          t ? B(2929) : z(2929);
        }, setMask: function setMask(r) {
          n === r || e || (t.depthMask(r), n = r);
        }, setFunc: function setFunc(e) {
          if (r !== e) {
            if (e) switch (e) {case 0:
                t.depthFunc(512);break;case 1:
                t.depthFunc(519);break;case 2:
                t.depthFunc(513);break;case 3:
                t.depthFunc(515);break;case 4:
                t.depthFunc(514);break;case 5:
                t.depthFunc(518);break;case 6:
                t.depthFunc(516);break;case 7:
                t.depthFunc(517);break;default:
                t.depthFunc(515);} else t.depthFunc(515);r = e;
          }
        }, setLocked: function setLocked(t) {
          e = t;
        }, setClear: function setClear(e) {
          i !== e && (t.clearDepth(e), i = e);
        }, reset: function reset() {
          e = !1, n = null, r = null, i = null;
        } };
    }(),
        l = new function () {
      var e = !1,
          n = null,
          r = null,
          i = null,
          a = null,
          o = null,
          s = null,
          c = null,
          l = null;return { setTest: function setTest(t) {
          e || (t ? B(2960) : z(2960));
        }, setMask: function setMask(r) {
          n === r || e || (t.stencilMask(r), n = r);
        }, setFunc: function setFunc(e, n, o) {
          r === e && i === n && a === o || (t.stencilFunc(e, n, o), r = e, i = n, a = o);
        }, setOp: function setOp(e, n, r) {
          o === e && s === n && c === r || (t.stencilOp(e, n, r), o = e, s = n, c = r);
        }, setLocked: function setLocked(t) {
          e = t;
        }, setClear: function setClear(e) {
          l !== e && (t.clearStencil(e), l = e);
        }, reset: function reset() {
          e = !1, n = null, r = null, i = null, a = null, o = null, s = null, c = null, l = null;
        } };
    }(),
        u = {},
        h = null,
        d = null,
        p = null,
        f = null,
        m = null,
        v = null,
        g = null,
        y = null,
        x = null,
        _ = !1,
        b = null,
        w = null,
        M = null,
        S = null,
        T = null,
        E = t.getParameter(35661),
        A = !1,
        L = 0,
        R = t.getParameter(7938);-1 !== R.indexOf("WebGL") ? (L = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1]), A = L >= 1) : -1 !== R.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1]), A = L >= 2);var C = null,
        P = {},
        I = new yt(),
        D = new yt();function O(e, n, r) {
      var i = new Uint8Array(4),
          a = t.createTexture();t.bindTexture(e, a), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);for (var o = 0; o < r; o++) {
        t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
      }return a;
    }var N = {};function B(e) {
      !0 !== u[e] && (t.enable(e), u[e] = !0);
    }function z(e) {
      !1 !== u[e] && (t.disable(e), u[e] = !1);
    }N[3553] = O(3553, 3553, 1), N[34067] = O(34067, 34069, 6), s.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), B(2929), c.setFunc(3), k(!1), V(1), B(2884), H(0);var G = ((i = {})[100] = 32774, i[101] = 32778, i[102] = 32779, i);if (o) G[103] = 32775, G[104] = 32776;else {
      var F = n.get("EXT_blend_minmax");null !== F && (G[103] = F.MIN_EXT, G[104] = F.MAX_EXT);
    }var U = ((a = {})[200] = 0, a[201] = 1, a[202] = 768, a[204] = 770, a[210] = 776, a[208] = 774, a[206] = 772, a[203] = 769, a[205] = 771, a[209] = 775, a[207] = 773, a);function H(n, r, i, a, o, s, c, l) {
      if (0 !== n) {
        if (d || (B(3042), d = !0), 5 === n) o = o || r, s = s || i, c = c || a, r === f && o === g || (t.blendEquationSeparate(G[r], G[o]), f = r, g = o), i === m && a === v && s === y && c === x || (t.blendFuncSeparate(U[i], U[a], U[s], U[c]), m = i, v = a, y = s, x = c), p = n, _ = null;else if (n !== p || l !== _) {
          if (f === e && g === e || (t.blendEquation(32774), f = e, g = e), l) switch (n) {case 1:
              t.blendFuncSeparate(1, 771, 1, 771);break;case 2:
              t.blendFunc(1, 1);break;case 3:
              t.blendFuncSeparate(0, 0, 769, 771);break;case 4:
              t.blendFuncSeparate(0, 768, 0, 770);break;default:
              console.error("THREE.WebGLState: Invalid blending: ", n);} else switch (n) {case 1:
              t.blendFuncSeparate(770, 771, 1, 771);break;case 2:
              t.blendFunc(770, 1);break;case 3:
              t.blendFunc(0, 769);break;case 4:
              t.blendFunc(0, 768);break;default:
              console.error("THREE.WebGLState: Invalid blending: ", n);}m = null, v = null, y = null, x = null, p = n, _ = l;
        }
      } else d && (z(3042), d = !1);
    }function k(e) {
      b !== e && (e ? t.frontFace(2304) : t.frontFace(2305), b = e);
    }function V(e) {
      0 !== e ? (B(2884), e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : z(2884), w = e;
    }function W(e, n, r) {
      e ? (B(32823), S === n && T === r || (t.polygonOffset(n, r), S = n, T = r)) : z(32823);
    }function j(e) {
      void 0 === e && (e = 33984 + E - 1), C !== e && (t.activeTexture(e), C = e);
    }return { buffers: { color: s, depth: c, stencil: l }, enable: B, disable: z, useProgram: function useProgram(e) {
        return h !== e && (t.useProgram(e), h = e, !0);
      }, setBlending: H, setMaterial: function setMaterial(t, e) {
        2 === t.side ? z(2884) : B(2884);var n = 1 === t.side;e && (n = !n), k(n), 1 === t.blending && !1 === t.transparent ? H(0) : H(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), c.setFunc(t.depthFunc), c.setTest(t.depthTest), c.setMask(t.depthWrite), s.setMask(t.colorWrite);var r = t.stencilWrite;l.setTest(r), r && (l.setMask(t.stencilWriteMask), l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
      }, setFlipSided: k, setCullFace: V, setLineWidth: function setLineWidth(e) {
        e !== M && (A && t.lineWidth(e), M = e);
      }, setPolygonOffset: W, setScissorTest: function setScissorTest(t) {
        t ? B(3089) : z(3089);
      }, activeTexture: j, bindTexture: function bindTexture(e, n) {
        null === C && j();var r = P[C];void 0 === r && (r = { type: void 0, texture: void 0 }, P[C] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || N[e]), r.type = e, r.texture = n);
      }, unbindTexture: function unbindTexture() {
        var e = P[C];void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0);
      }, compressedTexImage2D: function compressedTexImage2D() {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, texImage2D: function texImage2D() {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, texImage3D: function texImage3D() {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      }, scissor: function scissor(e) {
        !1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), I.copy(e));
      }, viewport: function viewport(e) {
        !1 === D.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), D.copy(e));
      }, reset: function reset() {
        u = {}, C = null, P = {}, h = null, p = null, b = null, w = null, s.reset(), c.reset(), l.reset();
      } };
  }function Ji(t, e, n, r, i, a, o) {
    var s,
        c,
        l,
        h = i.isWebGL2,
        v = i.maxTextures,
        g = i.maxCubemapSize,
        y = i.maxTextureSize,
        L = i.maxSamples,
        R = new WeakMap(),
        C = !1;try {
      C = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (t) {}function P(t, e) {
      return C ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }function I(t, e, n, r) {
      var i = 1;if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
          var a = e ? st.floorPowerOfTwo : Math.floor,
              o = a(i * t.width),
              s = a(i * t.height);void 0 === l && (l = P(o, s));var c = n ? P(o, s) : l;return c.width = o, c.height = s, c.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), c;
        }return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
      }return t;
    }function D(t) {
      return st.isPowerOfTwo(t.width) && st.isPowerOfTwo(t.height);
    }function O(t, e) {
      return t.generateMipmaps && e && t.minFilter !== d && t.minFilter !== m;
    }function N(e, n, i, a) {
      t.generateMipmap(e), r.get(n).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E;
    }function B(n, r, i) {
      if (!1 === h) return r;if (null !== n) {
        if (void 0 !== t[n]) return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
      }var a = r;return 6403 === r && (5126 === i && (a = 33326), 5131 === i && (a = 33325), 5121 === i && (a = 33321)), 6407 === r && (5126 === i && (a = 34837), 5131 === i && (a = 34843), 5121 === i && (a = 32849)), 6408 === r && (5126 === i && (a = 34836), 5131 === i && (a = 34842), 5121 === i && (a = 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || e.get("EXT_color_buffer_float"), a;
    }function z(t) {
      return t === d || t === p || t === f ? 9728 : 9729;
    }function G(e) {
      var n = e.target;n.removeEventListener("dispose", G), function (e) {
        var n = r.get(e);if (void 0 === n.__webglInit) return;t.deleteTexture(n.__webglTexture), r.remove(e);
      }(n), n.isVideoTexture && R.delete(n), o.memory.textures--;
    }function F(e) {
      var n = e.target;n.removeEventListener("dispose", F), function (e) {
        var n = r.get(e),
            i = r.get(e.texture);if (!e) return;void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture);e.depthTexture && e.depthTexture.dispose();if (e.isWebGLCubeRenderTarget) for (var a = 0; a < 6; a++) {
          t.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
        } else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);r.remove(e.texture), r.remove(e);
      }(n), o.memory.textures--;
    }var U = 0;function H(t, e) {
      var i = r.get(t);if (t.isVideoTexture && function (t) {
        var e = o.render.frame;R.get(t) !== e && (R.set(t, e), t.update());
      }(t), t.version > 0 && i.__version !== t.version) {
        var a = t.image;if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else {
          if (!1 !== a.complete) return void X(i, t, e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        }
      }n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture);
    }function k(e, i) {
      var o = r.get(e);e.version > 0 && o.__version !== e.version ? function (e, r, i) {
        if (6 !== r.image.length) return;q(e, r), n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY);for (var o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture), s = r.image[0] && r.image[0].isDataTexture, c = [], l = 0; l < 6; l++) {
          c[l] = o || s ? s ? r.image[l].image : r.image[l] : I(r.image[l], !1, !0, g);
        }var u,
            d = c[0],
            p = D(d) || h,
            f = a.convert(r.format),
            m = a.convert(r.type),
            v = B(r.internalFormat, f, m);if (j(34067, r, p), o) {
          for (var y = 0; y < 6; y++) {
            u = c[y].mipmaps;for (var x = 0; x < u.length; x++) {
              var _ = u[x];r.format !== T && r.format !== S ? null !== f ? n.compressedTexImage2D(34069 + y, x, v, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + y, x, v, _.width, _.height, 0, f, m, _.data);
            }
          }e.__maxMipLevel = u.length - 1;
        } else {
          u = r.mipmaps;for (var b = 0; b < 6; b++) {
            if (s) {
              n.texImage2D(34069 + b, 0, v, c[b].width, c[b].height, 0, f, m, c[b].data);for (var w = 0; w < u.length; w++) {
                var M = u[w].image[b].image;n.texImage2D(34069 + b, w + 1, v, M.width, M.height, 0, f, m, M.data);
              }
            } else {
              n.texImage2D(34069 + b, 0, v, f, m, c[b]);for (var E = 0; E < u.length; E++) {
                var A = u[E];n.texImage2D(34069 + b, E + 1, v, f, m, A.image[b]);
              }
            }
          }e.__maxMipLevel = u.length;
        }O(r, p) && N(34067, r, d.width, d.height);e.__version = r.version, r.onUpdate && r.onUpdate(r);
      }(o, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture));
    }var V = ((s = {})[1e3] = 10497, s[1001] = 33071, s[1002] = 33648, s),
        W = ((c = {})[1003] = 9728, c[1004] = 9984, c[1005] = 9986, c[1006] = 9729, c[1007] = 9985, c[1008] = 9987, c);function j(n, a, o) {
      o ? (t.texParameteri(n, 10242, V[a.wrapS]), t.texParameteri(n, 10243, V[a.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, V[a.wrapR]), t.texParameteri(n, 10240, W[a.magFilter]), t.texParameteri(n, 10241, W[a.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), a.wrapS === u && a.wrapT === u || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, z(a.magFilter)), t.texParameteri(n, 10241, z(a.minFilter)), a.minFilter !== d && a.minFilter !== m && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));var s = e.get("EXT_texture_filter_anisotropic");if (s) {
        if (a.type === b && null === e.get("OES_texture_float_linear")) return;if (a.type === w && null === (h || e.get("OES_texture_half_float_linear"))) return;(a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy);
      }
    }function q(e, n) {
      void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", G), e.__webglTexture = t.createTexture(), o.memory.textures++);
    }function X(e, r, i) {
      var o = 3553;r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), q(e, r), n.activeTexture(33984 + i), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment);var s,
          c = function (t) {
        return !h && (t.wrapS !== u || t.wrapT !== u || t.minFilter !== d && t.minFilter !== m);
      }(r) && !1 === D(r.image),
          l = I(r.image, c, !1, y),
          p = D(l) || h,
          f = a.convert(r.format),
          v = a.convert(r.type),
          g = B(r.internalFormat, f, v);j(o, r, p);var w = r.mipmaps;if (r.isDepthTexture) g = 6402, h ? g = r.type === b ? 36012 : r.type === _ ? 33190 : r.type === M ? 35056 : 33189 : r.type === b && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === E && 6402 === g && r.type !== x && r.type !== _ && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = x, v = a.convert(r.type)), r.format === A && 6402 === g && (g = 34041, r.type !== M && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = M, v = a.convert(r.type))), n.texImage2D(3553, 0, g, l.width, l.height, 0, f, v, null);else if (r.isDataTexture) {
        if (w.length > 0 && p) {
          for (var L = 0, R = w.length; L < R; L++) {
            s = w[L], n.texImage2D(3553, L, g, s.width, s.height, 0, f, v, s.data);
          }r.generateMipmaps = !1, e.__maxMipLevel = w.length - 1;
        } else n.texImage2D(3553, 0, g, l.width, l.height, 0, f, v, l.data), e.__maxMipLevel = 0;
      } else if (r.isCompressedTexture) {
        for (var C = 0, P = w.length; C < P; C++) {
          s = w[C], r.format !== T && r.format !== S ? null !== f ? n.compressedTexImage2D(3553, C, g, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, C, g, s.width, s.height, 0, f, v, s.data);
        }e.__maxMipLevel = w.length - 1;
      } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, g, l.width, l.height, l.depth, 0, f, v, l.data), e.__maxMipLevel = 0;else if (r.isDataTexture3D) n.texImage3D(32879, 0, g, l.width, l.height, l.depth, 0, f, v, l.data), e.__maxMipLevel = 0;else if (w.length > 0 && p) {
        for (var z = 0, G = w.length; z < G; z++) {
          s = w[z], n.texImage2D(3553, z, g, f, v, s);
        }r.generateMipmaps = !1, e.__maxMipLevel = w.length - 1;
      } else n.texImage2D(3553, 0, g, f, v, l), e.__maxMipLevel = 0;O(r, p) && N(o, r, l.width, l.height), e.__version = r.version, r.onUpdate && r.onUpdate(r);
    }function Y(e, i, o, s) {
      var c = a.convert(i.texture.format),
          l = a.convert(i.texture.type),
          u = B(i.texture.internalFormat, c, l);n.texImage2D(s, 0, u, i.width, i.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, s, r.get(i.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }function Z(e, n, r) {
      if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
        var i = 33189;if (r) {
          var o = n.depthTexture;o && o.isDepthTexture && (o.type === b ? i = 36012 : o.type === _ && (i = 33190));var s = Q(n);t.renderbufferStorageMultisample(36161, s, i, n.width, n.height);
        } else t.renderbufferStorage(36161, i, n.width, n.height);t.framebufferRenderbuffer(36160, 36096, 36161, e);
      } else if (n.depthBuffer && n.stencilBuffer) {
        if (r) {
          var c = Q(n);t.renderbufferStorageMultisample(36161, c, 35056, n.width, n.height);
        } else t.renderbufferStorage(36161, 34041, n.width, n.height);t.framebufferRenderbuffer(36160, 33306, 36161, e);
      } else {
        var l = a.convert(n.texture.format),
            u = a.convert(n.texture.type),
            h = B(n.texture.internalFormat, l, u);if (r) {
          var d = Q(n);t.renderbufferStorageMultisample(36161, d, h, n.width, n.height);
        } else t.renderbufferStorage(36161, h, n.width, n.height);
      }t.bindRenderbuffer(36161, null);
    }function J(e) {
      var n = r.get(e),
          i = !0 === e.isWebGLCubeRenderTarget;if (e.depthTexture) {
        if (i) throw new Error("target.depthTexture not supported in Cube render targets");!function (e, n) {
          if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), H(n.depthTexture, 0);var i = r.get(n.depthTexture).__webglTexture;if (n.depthTexture.format === E) t.framebufferTexture2D(36160, 36096, 3553, i, 0);else {
            if (n.depthTexture.format !== A) throw new Error("Unknown depthTexture format");t.framebufferTexture2D(36160, 33306, 3553, i, 0);
          }
        }(n.__webglFramebuffer, e);
      } else if (i) {
        n.__webglDepthbuffer = [];for (var a = 0; a < 6; a++) {
          t.bindFramebuffer(36160, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = t.createRenderbuffer(), Z(n.__webglDepthbuffer[a], e, !1);
        }
      } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), Z(n.__webglDepthbuffer, e, !1);t.bindFramebuffer(36160, null);
    }function Q(t) {
      return h && t.isWebGLMultisampleRenderTarget ? Math.min(L, t.samples) : 0;
    }var K = !1,
        $ = !1;this.allocateTextureUnit = function () {
      var t = U;return t >= v && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + v), U += 1, t;
    }, this.resetTextureUnits = function () {
      U = 0;
    }, this.setTexture2D = H, this.setTexture2DArray = function (t, e) {
      var i = r.get(t);t.version > 0 && i.__version !== t.version ? X(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture));
    }, this.setTexture3D = function (t, e) {
      var i = r.get(t);t.version > 0 && i.__version !== t.version ? X(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture));
    }, this.setTextureCube = k, this.setupRenderTarget = function (e) {
      var i = r.get(e),
          s = r.get(e.texture);e.addEventListener("dispose", F), s.__webglTexture = t.createTexture(), o.memory.textures++;var c = !0 === e.isWebGLCubeRenderTarget,
          l = !0 === e.isWebGLMultisampleRenderTarget,
          u = D(e) || h;if (!h || e.texture.format !== S || e.texture.type !== b && e.texture.type !== w || (e.texture.format = T, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c) {
        i.__webglFramebuffer = [];for (var d = 0; d < 6; d++) {
          i.__webglFramebuffer[d] = t.createFramebuffer();
        }
      } else if (i.__webglFramebuffer = t.createFramebuffer(), l) if (h) {
        i.__webglMultisampledFramebuffer = t.createFramebuffer(), i.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, i.__webglColorRenderbuffer);var p = a.convert(e.texture.format),
            f = a.convert(e.texture.type),
            m = B(e.texture.internalFormat, p, f),
            v = Q(e);t.renderbufferStorageMultisample(36161, v, m, e.width, e.height), t.bindFramebuffer(36160, i.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (i.__webglDepthRenderbuffer = t.createRenderbuffer(), Z(i.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null);
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if (c) {
        n.bindTexture(34067, s.__webglTexture), j(34067, e.texture, u);for (var g = 0; g < 6; g++) {
          Y(i.__webglFramebuffer[g], e, 36064, 34069 + g);
        }O(e.texture, u) && N(34067, e.texture, e.width, e.height), n.bindTexture(34067, null);
      } else n.bindTexture(3553, s.__webglTexture), j(3553, e.texture, u), Y(i.__webglFramebuffer, e, 36064, 3553), O(e.texture, u) && N(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);e.depthBuffer && J(e);
    }, this.updateRenderTargetMipmap = function (t) {
      var e = t.texture;if (O(e, D(t) || h)) {
        var i = t.isWebGLCubeRenderTarget ? 34067 : 3553,
            a = r.get(e).__webglTexture;n.bindTexture(i, a), N(i, e, t.width, t.height), n.bindTexture(i, null);
      }
    }, this.updateMultisampleRenderTarget = function (e) {
      if (e.isWebGLMultisampleRenderTarget) if (h) {
        var n = r.get(e);t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);var i = e.width,
            a = e.height,
            o = 16384;e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024), t.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    }, this.safeSetTexture2D = function (t, e) {
      t && t.isWebGLRenderTarget && (!1 === K && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), K = !0), t = t.texture), H(t, e);
    }, this.safeSetTextureCube = function (t, e) {
      t && t.isWebGLCubeRenderTarget && (!1 === $ && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), $ = !0), t = t.texture), k(t, e);
    };
  }function Qi(t, e, n) {
    var r = n.isWebGL2;return { convert: function convert(t) {
        var n;if (t === y) return 5121;if (1017 === t) return 32819;if (1018 === t) return 32820;if (1019 === t) return 33635;if (1010 === t) return 5120;if (1011 === t) return 5122;if (t === x) return 5123;if (1013 === t) return 5124;if (t === _) return 5125;if (t === b) return 5126;if (t === w) return r ? 5131 : null !== (n = e.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;if (1021 === t) return 6406;if (t === S) return 6407;if (t === T) return 6408;if (1024 === t) return 6409;if (1025 === t) return 6410;if (t === E) return 6402;if (t === A) return 34041;if (1028 === t) return 6403;if (1029 === t) return 36244;if (1030 === t) return 33319;if (1031 === t) return 33320;if (1032 === t) return 36248;if (1033 === t) return 36249;if (t === L || t === R || t === C || t === P) {
          if (null === (n = e.get("WEBGL_compressed_texture_s3tc"))) return null;if (t === L) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if (t === R) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if (t === C) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if (t === P) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }if (t === I || t === D || t === O || t === N) {
          if (null === (n = e.get("WEBGL_compressed_texture_pvrtc"))) return null;if (t === I) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if (t === D) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if (t === O) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if (t === N) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }if (36196 === t) return null !== (n = e.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;if ((t === B || t === z) && null !== (n = e.get("WEBGL_compressed_texture_etc"))) {
          if (t === B) return n.COMPRESSED_RGB8_ETC2;if (t === z) return n.COMPRESSED_RGBA8_ETC2_EAC;
        }return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? null !== (n = e.get("WEBGL_compressed_texture_astc")) ? t : null : 36492 === t ? null !== (n = e.get("EXT_texture_compression_bptc")) ? t : null : t === M ? r ? 34042 : null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0;
      } };
  }function Ki(t) {
    Vn.call(this), this.cameras = t || [];
  }function $i() {
    be.call(this), this.type = "Group";
  }function ta() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }function ea(t, e) {
    var n = this,
        r = null,
        i = 1,
        a = null,
        o = "local-floor",
        s = null,
        c = [],
        l = new Map(),
        u = new Vn();u.layers.enable(1), u.viewport = new yt();var h = new Vn();h.layers.enable(2), h.viewport = new yt();var d = [u, h],
        p = new Ki();p.layers.enable(1), p.layers.enable(2);var f = null,
        m = null;function v(t) {
      var e = l.get(t.inputSource);e && e.dispatchEvent({ type: t.type, data: t.inputSource });
    }function g() {
      l.forEach(function (t, e) {
        t.disconnect(e);
      }), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), S.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" });
    }function y(t) {
      a = t, S.setContext(r), S.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
    }function x(t) {
      for (var e = r.inputSources, n = 0; n < c.length; n++) {
        l.set(e[n], c[n]);
      }for (var i = 0; i < t.removed.length; i++) {
        var a = t.removed[i],
            o = l.get(a);o && (o.dispatchEvent({ type: "disconnected", data: a }), l.delete(a));
      }for (var s = 0; s < t.added.length; s++) {
        var u = t.added[s],
            h = l.get(u);h && h.dispatchEvent({ type: "connected", data: u });
      }
    }this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
      var e = c[t];return void 0 === e && (e = new ta(), c[t] = e), e.getTargetRaySpace();
    }, this.getControllerGrip = function (t) {
      var e = c[t];return void 0 === e && (e = new ta(), c[t] = e), e.getGripSpace();
    }, this.getHand = function (t) {
      var e = c[t];return void 0 === e && (e = new ta(), c[t] = e), e.getHandSpace();
    }, this.setFramebufferScaleFactor = function (t) {
      i = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function (t) {
      o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function () {
      return a;
    }, this.getSession = function () {
      return r;
    }, this.setSession = function (t) {
      if (null !== (r = t)) {
        r.addEventListener("select", v), r.addEventListener("selectstart", v), r.addEventListener("selectend", v), r.addEventListener("squeeze", v), r.addEventListener("squeezestart", v), r.addEventListener("squeezeend", v), r.addEventListener("end", g);var n = e.getContextAttributes();!0 !== n.xrCompatible && e.makeXRCompatible();var a = { antialias: n.antialias, alpha: n.alpha, depth: n.depth, stencil: n.stencil, framebufferScaleFactor: i },
            s = new XRWebGLLayer(r, e, a);r.updateRenderState({ baseLayer: s }), r.requestReferenceSpace(o).then(y), r.addEventListener("inputsourceschange", x);
      }
    };var _ = new wt(),
        b = new wt();function w(t, e) {
      null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld);
    }this.getCamera = function (t) {
      p.near = h.near = u.near = t.near, p.far = h.far = u.far = t.far, f === p.near && m === p.far || (r.updateRenderState({ depthNear: p.near, depthFar: p.far }), f = p.near, m = p.far);var e = t.parent,
          n = p.cameras;w(p, e);for (var i = 0; i < n.length; i++) {
        w(n[i], e);
      }t.matrixWorld.copy(p.matrixWorld);for (var a = t.children, o = 0, s = a.length; o < s; o++) {
        a[o].updateMatrixWorld(!0);
      }return 2 === n.length ? function (t, e, n) {
        _.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld);var r = _.distanceTo(b),
            i = e.projectionMatrix.elements,
            a = n.projectionMatrix.elements,
            o = i[14] / (i[10] - 1),
            s = i[14] / (i[10] + 1),
            c = (i[9] + 1) / i[5],
            l = (i[9] - 1) / i[5],
            u = (i[8] - 1) / i[0],
            h = (a[8] + 1) / a[0],
            d = o * u,
            p = o * h,
            f = r / (-u + h),
            m = f * -u;e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);var v = o + f,
            g = s + f,
            y = d - m,
            x = p + (r - m),
            w = c * s / g * v,
            M = l * s / g * v;t.projectionMatrix.makePerspective(y, x, w, M, v, g);
      }(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix), p;
    };var M = null;var S = new Kn();S.setAnimationLoop(function (e, n) {
      if (null !== (s = n.getViewerPose(a))) {
        var i = s.views,
            o = r.renderState.baseLayer;t.setFramebuffer(o.framebuffer);var l = !1;i.length !== p.cameras.length && (p.cameras.length = 0, l = !0);for (var u = 0; u < i.length; u++) {
          var h = i[u],
              f = o.getViewport(h),
              m = d[u];m.matrix.fromArray(h.transform.matrix), m.projectionMatrix.fromArray(h.projectionMatrix), m.viewport.set(f.x, f.y, f.width, f.height), 0 === u && p.matrix.copy(m.matrix), !0 === l && p.cameras.push(m);
        }
      }for (var v = r.inputSources, g = 0; g < c.length; g++) {
        var y = c[g],
            x = v[g];y.update(x, n, a);
      }M && M(e, n);
    }), this.setAnimationLoop = function (t) {
      M = t;
    }, this.dispose = function () {};
  }function na(t) {
    function e(e, n) {
      e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);var r,
          i,
          a = t.get(n).envMap;if (a) {
        e.envMap.value = a, e.flipEnvMap.value = a.isCubeTexture && a._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;var o = t.get(a).__maxMipLevel;void 0 !== o && (e.maxMipLevel.value = o);
      }n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? i = n.aoMap : n.lightMap && (i = n.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uv2Transform.value.copy(i.matrix));
    }function n(e, n) {
      e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
    }return { refreshFogUniforms: function refreshFogUniforms(t, e) {
        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density);
      }, refreshMaterialUniforms: function refreshMaterialUniforms(t, r, i, a) {
        r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function (t, e) {
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
        }(t, r)) : r.isMeshToonMaterial ? (e(t, r), function (t, e) {
          e.gradientMap && (t.gradientMap.value = e.gradientMap);e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function (t, e) {
          t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function (t, e) {
          n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap);
        }(t, r) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function (t, e) {
          e.matcap && (t.matcap.value = e.matcap);e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance;
        }(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function (t, e) {
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        }(t, r)) : r.isLineBasicMaterial ? (function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity;
        }(t, r), r.isLineDashedMaterial && function (t, e) {
          t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale;
        }(t, r)) : r.isPointsMaterial ? function (t, e, n, r) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map);e.alphaMap && (t.alphaMap.value = e.alphaMap);var i;e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix));
        }(t, r, i, a) : r.isSpriteMaterial ? function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);e.alphaMap && (t.alphaMap.value = e.alphaMap);var n;e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix));
        }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
      } };
  }function ra(t) {
    var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        n = void 0 !== t.context ? t.context : null,
        r = void 0 !== t.alpha && t.alpha,
        i = void 0 === t.depth || t.depth,
        a = void 0 === t.stencil || t.stencil,
        o = void 0 !== t.antialias && t.antialias,
        s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        l = void 0 !== t.powerPreference ? t.powerPreference : "default",
        u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
        h = null,
        d = null;this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = q, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;var p = this,
        f = !1,
        m = null,
        v = 0,
        g = 0,
        x = null,
        _ = null,
        M = -1,
        S = null,
        E = null,
        A = new yt(),
        L = new yt(),
        R = null,
        C = e.width,
        P = e.height,
        I = 1,
        D = null,
        O = null,
        N = new yt(0, 0, C, P),
        B = new yt(0, 0, C, P),
        z = !1,
        G = new Qn(),
        F = !1,
        U = !1,
        H = new Jt(),
        k = new wt(),
        V = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };function W() {
      return null === x ? I : 1;
    }var j,
        X,
        Y,
        Z,
        J,
        Q,
        K,
        $,
        tt,
        et,
        nt,
        rt,
        it,
        at,
        ot,
        ct,
        lt,
        ut,
        ht,
        dt,
        ft,
        mt = n;function vt(t, n) {
      for (var r = 0; r < t.length; r++) {
        var i = t[r],
            a = e.getContext(i, n);if (null !== a) return a;
      }return null;
    }try {
      var gt = { alpha: r, depth: i, stencil: a, antialias: o, premultipliedAlpha: s, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: u };if (e.addEventListener("webglcontextlost", St, !1), e.addEventListener("webglcontextrestored", Tt, !1), null === mt) {
        var xt = ["webgl2", "webgl", "experimental-webgl"];if (!0 === p.isWebGL1Renderer && xt.shift(), null === (mt = vt(xt, gt))) throw vt(xt) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }void 0 === mt.getShaderPrecisionFormat && (mt.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (t) {
      throw console.error("THREE.WebGLRenderer: " + t.message), t;
    }function _t() {
      j = new ur(mt), !1 === (X = new sr(mt, j, t)).isWebGL2 && (j.get("WEBGL_depth_texture"), j.get("OES_texture_float"), j.get("OES_texture_half_float"), j.get("OES_texture_half_float_linear"), j.get("OES_standard_derivatives"), j.get("OES_element_index_uint"), j.get("OES_vertex_array_object"), j.get("ANGLE_instanced_arrays")), j.get("OES_texture_float_linear"), dt = new Qi(mt, j, X), (Y = new Zi(mt, j, X)).scissor(L.copy(B).multiplyScalar(I).floor()), Y.viewport(A.copy(N).multiplyScalar(I).floor()), Z = new pr(mt), J = new Ni(), Q = new Ji(mt, j, Y, J, X, dt, Z), K = new lr(p), $ = new $n(mt, X), ft = new ar(mt, j, $, X), tt = new hr(mt, $, Z, ft), et = new gr(mt, tt, $, Z), lt = new vr(mt), ot = new cr(J), nt = new Oi(p, K, j, X, ft, ot), rt = new na(J), it = new Fi(J), at = new ji(j, X), ct = new ir(p, K, Y, et, s), ut = new or(mt, j, Z, X), ht = new dr(mt, j, Z, X), Z.programs = nt.programs, p.capabilities = X, p.extensions = j, p.properties = J, p.renderLists = it, p.state = Y, p.info = Z;
    }_t();var bt = new ea(p, mt);this.xr = bt;var Mt = new Yi(p, et, X.maxTextureSize);function St(t) {
      t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f = !0;
    }function Tt() {
      console.log("THREE.WebGLRenderer: Context Restored."), f = !1, _t();
    }function Et(t) {
      var e = t.target;e.removeEventListener("dispose", Et), function (t) {
        At(t), J.remove(t);
      }(e);
    }function At(t) {
      var e = J.get(t).program;void 0 !== e && nt.releaseProgram(e);
    }this.shadowMap = Mt, this.getContext = function () {
      return mt;
    }, this.getContextAttributes = function () {
      return mt.getContextAttributes();
    }, this.forceContextLoss = function () {
      var t = j.get("WEBGL_lose_context");t && t.loseContext();
    }, this.forceContextRestore = function () {
      var t = j.get("WEBGL_lose_context");t && t.restoreContext();
    }, this.getPixelRatio = function () {
      return I;
    }, this.setPixelRatio = function (t) {
      void 0 !== t && (I = t, this.setSize(C, P, !1));
    }, this.getSize = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new pt()), t.set(C, P);
    }, this.setSize = function (t, n, r) {
      bt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (C = t, P = n, e.width = Math.floor(t * I), e.height = Math.floor(n * I), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n));
    }, this.getDrawingBufferSize = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new pt()), t.set(C * I, P * I).floor();
    }, this.setDrawingBufferSize = function (t, n, r) {
      C = t, P = n, I = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n);
    }, this.getCurrentViewport = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new yt()), t.copy(A);
    }, this.getViewport = function (t) {
      return t.copy(N);
    }, this.setViewport = function (t, e, n, r) {
      t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, r), Y.viewport(A.copy(N).multiplyScalar(I).floor());
    }, this.getScissor = function (t) {
      return t.copy(B);
    }, this.setScissor = function (t, e, n, r) {
      t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, r), Y.scissor(L.copy(B).multiplyScalar(I).floor());
    }, this.getScissorTest = function () {
      return z;
    }, this.setScissorTest = function (t) {
      Y.setScissorTest(z = t);
    }, this.setOpaqueSort = function (t) {
      D = t;
    }, this.setTransparentSort = function (t) {
      O = t;
    }, this.getClearColor = function () {
      return ct.getClearColor();
    }, this.setClearColor = function () {
      ct.setClearColor.apply(ct, arguments);
    }, this.getClearAlpha = function () {
      return ct.getClearAlpha();
    }, this.setClearAlpha = function () {
      ct.setClearAlpha.apply(ct, arguments);
    }, this.clear = function (t, e, n) {
      var r = 0;(void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), mt.clear(r);
    }, this.clearColor = function () {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }, this.dispose = function () {
      e.removeEventListener("webglcontextlost", St, !1), e.removeEventListener("webglcontextrestored", Tt, !1), it.dispose(), at.dispose(), J.dispose(), K.dispose(), et.dispose(), ft.dispose(), bt.dispose(), Rt.stop();
    }, this.renderBufferImmediate = function (t, e) {
      ft.initAttributes();var n = J.get(t);t.hasPositions && !n.position && (n.position = mt.createBuffer()), t.hasNormals && !n.normal && (n.normal = mt.createBuffer()), t.hasUvs && !n.uv && (n.uv = mt.createBuffer()), t.hasColors && !n.color && (n.color = mt.createBuffer());var r = e.getAttributes();t.hasPositions && (mt.bindBuffer(34962, n.position), mt.bufferData(34962, t.positionArray, 35048), ft.enableAttribute(r.position), mt.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (mt.bindBuffer(34962, n.normal), mt.bufferData(34962, t.normalArray, 35048), ft.enableAttribute(r.normal), mt.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (mt.bindBuffer(34962, n.uv), mt.bufferData(34962, t.uvArray, 35048), ft.enableAttribute(r.uv), mt.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (mt.bindBuffer(34962, n.color), mt.bufferData(34962, t.colorArray, 35048), ft.enableAttribute(r.color), mt.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), ft.disableUnusedAttributes(), mt.drawArrays(4, 0, t.count), t.count = 0;
    }, this.renderBufferDirect = function (t, e, n, r, i, a) {
      null === e && (e = V);var o = i.isMesh && i.matrixWorld.determinant() < 0,
          s = Ot(t, e, r, i);Y.setMaterial(r, o);var c = n.index,
          l = n.attributes.position;if (null === c) {
        if (void 0 === l || 0 === l.count) return;
      } else if (0 === c.count) return;var u,
          h = 1;!0 === r.wireframe && (c = tt.getWireframeAttribute(n), h = 2), (r.morphTargets || r.morphNormals) && lt.update(i, n, r, s), ft.setup(i, r, s, n, c);var d = ut;null !== c && (u = $.get(c), (d = ht).setIndex(u));var p = null !== c ? c.count : l.count,
          f = n.drawRange.start * h,
          m = n.drawRange.count * h,
          v = null !== a ? a.start * h : 0,
          g = null !== a ? a.count * h : 1 / 0,
          y = Math.max(f, v),
          x = Math.min(p, f + m, v + g) - 1,
          _ = Math.max(0, x - y + 1);if (0 !== _) {
        if (i.isMesh) !0 === r.wireframe ? (Y.setLineWidth(r.wireframeLinewidth * W()), d.setMode(1)) : d.setMode(4);else if (i.isLine) {
          var b = r.linewidth;void 0 === b && (b = 1), Y.setLineWidth(b * W()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3);
        } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);if (i.isInstancedMesh) d.renderInstances(y, _, i.count);else if (n.isInstancedBufferGeometry) {
          var w = Math.min(n.instanceCount, n._maxInstanceCount);d.renderInstances(y, _, w);
        } else d.render(y, _);
      }
    }, this.compile = function (t, e) {
      (d = at.get(t, e)).init(), t.traverseVisible(function (t) {
        t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t));
      }), d.setupLights(e);var n = new WeakMap();t.traverse(function (e) {
        var r = e.material;if (r) if (Array.isArray(r)) for (var i = 0; i < r.length; i++) {
          var a = r[i];!1 === n.has(a) && (Dt(a, t, e), n.set(a));
        } else !1 === n.has(r) && (Dt(r, t, e), n.set(r));
      });
    };var Lt = null;var Rt = new Kn();function Ct(t, e, n, r) {
      if (!1 !== t.visible) {
        if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder;else if (t.isLOD) !0 === t.autoUpdate && t.update(e);else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);else if (t.isSprite) {
          if (!t.frustumCulled || G.intersectsSprite(t)) {
            r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);var i = et.update(t),
                a = t.material;a.visible && h.push(t, i, a, n, k.z, null);
          }
        } else if (t.isImmediateRenderObject) r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H), h.push(t, null, t.material, n, k.z, null);else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Z.render.frame && (t.skeleton.update(), t.skeleton.frame = Z.render.frame), !t.frustumCulled || G.intersectsObject(t))) {
          r && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);var o = et.update(t),
              s = t.material;if (Array.isArray(s)) for (var c = o.groups, l = 0, u = c.length; l < u; l++) {
            var p = c[l],
                f = s[p.materialIndex];f && f.visible && h.push(t, o, f, n, k.z, p);
          } else s.visible && h.push(t, o, s, n, k.z, null);
        }for (var m = t.children, v = 0, g = m.length; v < g; v++) {
          Ct(m[v], e, n, r);
        }
      }
    }function Pt(t, e, n) {
      for (var r = !0 === e.isScene ? e.overrideMaterial : null, i = 0, a = t.length; i < a; i++) {
        var o = t[i],
            s = o.object,
            c = o.geometry,
            l = null === r ? o.material : r,
            u = o.group;if (n.isArrayCamera) {
          E = n;for (var h = n.cameras, p = 0, f = h.length; p < f; p++) {
            var m = h[p];s.layers.test(m.layers) && (Y.viewport(A.copy(m.viewport)), d.setupLights(m), It(s, e, m, c, l, u));
          }
        } else E = null, It(s, e, n, c, l, u);
      }
    }function It(t, e, n, r, i, a) {
      if (t.onBeforeRender(p, e, n, r, i, a), d = at.get(e, E || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
        var o = Ot(n, e, i, t);Y.setMaterial(i), ft.reset(), function (t, e) {
          t.render(function (t) {
            p.renderBufferImmediate(t, e);
          });
        }(t, o);
      } else p.renderBufferDirect(n, e, r, i, t, a);t.onAfterRender(p, e, n, r, i, a), d = at.get(e, E || n);
    }function Dt(t, e, n) {
      !0 !== e.isScene && (e = V);var r = J.get(t),
          i = d.state.lights,
          a = d.state.shadowsArray,
          o = i.state.version,
          s = nt.getParameters(t, i.state, a, e, n),
          c = nt.getProgramCacheKey(s),
          l = r.program,
          u = !0;if (void 0 === l) t.addEventListener("dispose", Et);else if (l.cacheKey !== c) At(t);else if (r.lightsStateVersion !== o) u = !1;else {
        if (void 0 !== s.shaderID) {
          var h = t.isMeshStandardMaterial ? e.environment : null;return void (r.envMap = K.get(t.envMap || h));
        }u = !1;
      }u && (s.uniforms = nt.getUniforms(t), t.onBeforeCompile(s, p), l = nt.acquireProgram(s, c), r.program = l, r.uniforms = s.uniforms, r.outputEncoding = s.outputEncoding);var f = r.uniforms;(t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = ot.numPlanes, r.numIntersection = ot.numIntersection, f.clippingPlanes = ot.uniform), r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = K.get(t.envMap || r.environment), r.needsLights = function (t) {
        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights;
      }(t), r.lightsStateVersion = o, r.needsLights && (f.ambientLightColor.value = i.state.ambient, f.lightProbe.value = i.state.probe, f.directionalLights.value = i.state.directional, f.directionalLightShadows.value = i.state.directionalShadow, f.spotLights.value = i.state.spot, f.spotLightShadows.value = i.state.spotShadow, f.rectAreaLights.value = i.state.rectArea, f.ltc_1.value = i.state.rectAreaLTC1, f.ltc_2.value = i.state.rectAreaLTC2, f.pointLights.value = i.state.point, f.pointLightShadows.value = i.state.pointShadow, f.hemisphereLights.value = i.state.hemi, f.directionalShadowMap.value = i.state.directionalShadowMap, f.directionalShadowMatrix.value = i.state.directionalShadowMatrix, f.spotShadowMap.value = i.state.spotShadowMap, f.spotShadowMatrix.value = i.state.spotShadowMatrix, f.pointShadowMap.value = i.state.pointShadowMap, f.pointShadowMatrix.value = i.state.pointShadowMatrix);var m = r.program.getUniforms(),
          v = fi.seqWithValue(m.seq, f);r.uniformsList = v;
    }function Ot(t, e, n, r) {
      !0 !== e.isScene && (e = V), Q.resetTextureUnits();var i = e.fog,
          a = n.isMeshStandardMaterial ? e.environment : null,
          o = null === x ? p.outputEncoding : x.texture.encoding,
          s = K.get(n.envMap || a),
          c = J.get(n),
          l = d.state.lights;if (!0 === F && (!0 === U || t !== S)) {
        var u = t === S && n.id === M;ot.setState(n, t, u);
      }n.version === c.__version ? n.fog && c.fog !== i || c.environment !== a || c.needsLights && c.lightsStateVersion !== l.state.version ? Dt(n, e, r) : void 0 === c.numClippingPlanes || c.numClippingPlanes === ot.numPlanes && c.numIntersection === ot.numIntersection ? (c.outputEncoding !== o || c.envMap !== s) && Dt(n, e, r) : Dt(n, e, r) : (Dt(n, e, r), c.__version = n.version);var h,
          f,
          m = !1,
          v = !1,
          g = !1,
          y = c.program,
          _ = y.getUniforms(),
          w = c.uniforms;if (Y.useProgram(y.program) && (m = !0, v = !0, g = !0), n.id !== M && (M = n.id, v = !0), m || S !== t) {
        if (_.setValue(mt, "projectionMatrix", t.projectionMatrix), X.logarithmicDepthBuffer && _.setValue(mt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), S !== t && (S = t, v = !0, g = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
          var E = _.map.cameraPosition;void 0 !== E && E.setValue(mt, k.setFromMatrixPosition(t.matrixWorld));
        }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && _.setValue(mt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && _.setValue(mt, "viewMatrix", t.matrixWorldInverse);
      }if (n.skinning) {
        _.setOptional(mt, r, "bindMatrix"), _.setOptional(mt, r, "bindMatrixInverse");var A = r.skeleton;if (A) {
          var L = A.bones;if (X.floatVertexTextures) {
            if (void 0 === A.boneTexture) {
              var R = Math.sqrt(4 * L.length);R = st.ceilPowerOfTwo(R), R = Math.max(R, 4);var C = new Float32Array(R * R * 4);C.set(A.boneMatrices);var D = new Yn(C, R, R, T, b);A.boneMatrices = C, A.boneTexture = D, A.boneTextureSize = R;
            }_.setValue(mt, "boneTexture", A.boneTexture, Q), _.setValue(mt, "boneTextureSize", A.boneTextureSize);
          } else _.setOptional(mt, A, "boneMatrices");
        }
      }return (v || c.receiveShadow !== r.receiveShadow) && (c.receiveShadow = r.receiveShadow, _.setValue(mt, "receiveShadow", r.receiveShadow)), v && (_.setValue(mt, "toneMappingExposure", p.toneMappingExposure), c.needsLights && (f = g, (h = w).ambientLightColor.needsUpdate = f, h.lightProbe.needsUpdate = f, h.directionalLights.needsUpdate = f, h.directionalLightShadows.needsUpdate = f, h.pointLights.needsUpdate = f, h.pointLightShadows.needsUpdate = f, h.spotLights.needsUpdate = f, h.spotLightShadows.needsUpdate = f, h.rectAreaLights.needsUpdate = f, h.hemisphereLights.needsUpdate = f), i && n.fog && rt.refreshFogUniforms(w, i), rt.refreshMaterialUniforms(w, n, I, P), fi.upload(mt, c.uniformsList, w, Q)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (fi.upload(mt, c.uniformsList, w, Q), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && _.setValue(mt, "center", r.center), _.setValue(mt, "modelViewMatrix", r.modelViewMatrix), _.setValue(mt, "normalMatrix", r.normalMatrix), _.setValue(mt, "modelMatrix", r.matrixWorld), y;
    }Rt.setAnimationLoop(function (t) {
      bt.isPresenting || Lt && Lt(t);
    }), "undefined" != typeof window && Rt.setContext(window), this.setAnimationLoop = function (t) {
      Lt = t, bt.setAnimationLoop(t), null === t ? Rt.stop() : Rt.start();
    }, this.render = function (t, e) {
      var n, r;if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), void 0 === e || !0 === e.isCamera) {
        if (!0 !== f) {
          ft.resetDefaultState(), M = -1, S = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === bt.enabled && !0 === bt.isPresenting && (e = bt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(p, t, e, n || x), (d = at.get(t, e)).init(), H.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), G.setFromProjectionMatrix(H), U = this.localClippingEnabled, F = ot.init(this.clippingPlanes, U, e), (h = it.get(t, e)).init(), Ct(t, e, 0, p.sortObjects), h.finish(), !0 === p.sortObjects && h.sort(D, O), !0 === F && ot.beginShadows();var i = d.state.shadowsArray;Mt.render(i, t, e), d.setupLights(e), !0 === F && ot.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), ct.render(h, t, e, r);var a = h.opaque,
              o = h.transparent;a.length > 0 && Pt(a, t, e), o.length > 0 && Pt(o, t, e), !0 === t.isScene && t.onAfterRender(p, t, e), null !== x && (Q.updateRenderTargetMipmap(x), Q.updateMultisampleRenderTarget(x)), Y.buffers.depth.setTest(!0), Y.buffers.depth.setMask(!0), Y.buffers.color.setMask(!0), Y.setPolygonOffset(!1), h = null, d = null;
        }
      } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    }, this.setFramebuffer = function (t) {
      m !== t && null === x && mt.bindFramebuffer(36160, t), m = t;
    }, this.getActiveCubeFace = function () {
      return v;
    }, this.getActiveMipmapLevel = function () {
      return g;
    }, this.getRenderList = function () {
      return h;
    }, this.setRenderList = function (t) {
      h = t;
    }, this.getRenderState = function () {
      return d;
    }, this.setRenderState = function (t) {
      d = t;
    }, this.getRenderTarget = function () {
      return x;
    }, this.setRenderTarget = function (t, e, n) {
      void 0 === e && (e = 0), void 0 === n && (n = 0), x = t, v = e, g = n, t && void 0 === J.get(t).__webglFramebuffer && Q.setupRenderTarget(t);var r = m,
          i = !1;if (t) {
        var a = J.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget ? (r = a[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? J.get(t).__webglMultisampledFramebuffer : a, A.copy(t.viewport), L.copy(t.scissor), R = t.scissorTest;
      } else A.copy(N).multiplyScalar(I).floor(), L.copy(B).multiplyScalar(I).floor(), R = z;if (_ !== r && (mt.bindFramebuffer(36160, r), _ = r), Y.viewport(A), Y.scissor(L), Y.setScissorTest(R), i) {
        var o = J.get(t.texture);mt.framebufferTexture2D(36160, 36064, 34069 + e, o.__webglTexture, n);
      }
    }, this.readRenderTargetPixels = function (t, e, n, r, i, a, o) {
      if (t && t.isWebGLRenderTarget) {
        var s = J.get(t).__webglFramebuffer;if (t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
          var c = !1;s !== _ && (mt.bindFramebuffer(36160, s), c = !0);try {
            var l = t.texture,
                u = l.format,
                h = l.type;if (u !== T && dt.convert(u) !== mt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if (!(h === y || dt.convert(h) === mt.getParameter(35738) || h === b && (X.isWebGL2 || j.get("OES_texture_float") || j.get("WEBGL_color_buffer_float")) || h === w && (X.isWebGL2 ? j.get("EXT_color_buffer_float") : j.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053 === mt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && mt.readPixels(e, n, r, i, dt.convert(u), dt.convert(h), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          } finally {
            c && mt.bindFramebuffer(36160, _);
          }
        }
      } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    }, this.copyFramebufferToTexture = function (t, e, n) {
      void 0 === n && (n = 0);var r = Math.pow(2, -n),
          i = Math.floor(e.image.width * r),
          a = Math.floor(e.image.height * r),
          o = dt.convert(e.format);Q.setTexture2D(e, 0), mt.copyTexImage2D(3553, n, o, t.x, t.y, i, a, 0), Y.unbindTexture();
    }, this.copyTextureToTexture = function (t, e, n, r) {
      void 0 === r && (r = 0);var i = e.image.width,
          a = e.image.height,
          o = dt.convert(n.format),
          s = dt.convert(n.type);Q.setTexture2D(n, 0), mt.pixelStorei(37440, n.flipY), mt.pixelStorei(37441, n.premultiplyAlpha), mt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? mt.texSubImage2D(3553, r, t.x, t.y, i, a, o, s, e.image.data) : e.isCompressedTexture ? mt.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : mt.texSubImage2D(3553, r, t.x, t.y, o, s, e.image), 0 === r && n.generateMipmaps && mt.generateMipmap(3553), Y.unbindTexture();
    }, this.initTexture = function (t) {
      Q.setTexture2D(t, 0), Y.unbindTexture();
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }function ia(t) {
    ra.call(this, t);
  }Ki.prototype = _extends(Object.create(Vn.prototype), { constructor: Ki, isArrayCamera: !0 }), $i.prototype = _extends(Object.create(be.prototype), { constructor: $i, isGroup: !0 }), _extends(ta.prototype, { constructor: ta, getHandSpace: function getHandSpace() {
      if (null === this._hand && (this._hand = new $i(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand)) for (var t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
        var e = new $i();e.matrixAutoUpdate = !1, e.visible = !1, this._hand.joints.push(e), this._hand.add(e);
      }return this._hand;
    }, getTargetRaySpace: function getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new $i(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay;
    }, getGripSpace: function getGripSpace() {
      return null === this._grip && (this._grip = new $i(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip;
    }, dispatchEvent: function dispatchEvent(t) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
    }, disconnect: function disconnect(t) {
      return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
    }, update: function update(t, e, n) {
      var r = null,
          i = null,
          a = null,
          o = this._targetRay,
          s = this._grip,
          c = this._hand;if (t) if (c && t.hand) {
        a = !0;for (var l = 0; l <= window.XRHand.LITTLE_PHALANX_TIP; l++) {
          if (t.hand[l]) {
            var u = e.getJointPose(t.hand[l], n),
                h = c.joints[l];null !== u && (h.matrix.fromArray(u.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.jointRadius = u.radius), h.visible = null !== u;var d = c.joints[window.XRHand.INDEX_PHALANX_TIP],
                p = c.joints[window.XRHand.THUMB_PHALANX_TIP],
                f = d.position.distanceTo(p.position);c.inputState.pinching && f > .025 ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && f <= .015 && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }));
          }
        }
      } else null !== o && null !== (r = e.getPose(t.targetRaySpace, n)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale)), null !== s && t.gripSpace && null !== (i = e.getPose(t.gripSpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale));return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== c && (c.visible = null !== a), this;
    } }), _extends(ea.prototype, rt.prototype), ia.prototype = _extends(Object.create(ra.prototype), { constructor: ia, isWebGL1Renderer: !0 });var aa = function () {
    function t(t, e) {
      Object.defineProperty(this, "isFogExp2", { value: !0 }), this.name = "", this.color = new Ve(t), this.density = void 0 !== e ? e : 25e-5;
    }var e = t.prototype;return e.clone = function () {
      return new t(this.color, this.density);
    }, e.toJSON = function () {
      return { type: "FogExp2", color: this.color.getHex(), density: this.density };
    }, t;
  }(),
      oa = function () {
    function t(t, e, n) {
      Object.defineProperty(this, "isFog", { value: !0 }), this.name = "", this.color = new Ve(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3;
    }var e = t.prototype;return e.clone = function () {
      return new t(this.color, this.near, this.far);
    }, e.toJSON = function () {
      return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
    }, t;
  }(),
      sa = function (t) {
    function e() {
      var e;return e = t.call(this) || this, Object.defineProperty(ht(e), "isScene", { value: !0 }), e.type = "Scene", e.background = null, e.environment = null, e.fog = null, e.overrideMaterial = null, e.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: ht(e) })), e;
    }ut(e, t);var n = e.prototype;return n.copy = function (e, n) {
      return t.prototype.copy.call(this, e, n), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
    }, n.toJSON = function (e) {
      var n = t.prototype.toJSON.call(this, e);return null !== this.background && (n.object.background = this.background.toJSON(e)), null !== this.environment && (n.object.environment = this.environment.toJSON(e)), null !== this.fog && (n.object.fog = this.fog.toJSON()), n;
    }, e;
  }(be);function ca(t, e) {
    this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = tt, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = st.generateUUID();
  }Object.defineProperty(ca.prototype, "needsUpdate", { set: function set(t) {
      !0 === t && this.version++;
    } }), _extends(ca.prototype, { isInterleavedBuffer: !0, onUploadCallback: function onUploadCallback() {}, setUsage: function setUsage(t) {
      return this.usage = t, this;
    }, copy: function copy(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
    }, copyAt: function copyAt(t, e, n) {
      t *= this.stride, n *= e.stride;for (var r = 0, i = this.stride; r < i; r++) {
        this.array[t + r] = e.array[n + r];
      }return this;
    }, set: function set(t, e) {
      return void 0 === e && (e = 0), this.array.set(t, e), this;
    }, clone: function clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = st.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);var e = new ca(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);return e.setUsage(this.usage), e;
    }, onUpload: function onUpload(t) {
      return this.onUploadCallback = t, this;
    }, toJSON: function toJSON(t) {
      return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = st.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    } });var la,
      ua = new wt();function ha(t, e, n, r) {
    this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r;
  }function da(t) {
    qe.call(this), this.type = "SpriteMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t);
  }Object.defineProperties(ha.prototype, { count: { get: function get() {
        return this.data.count;
      } }, array: { get: function get() {
        return this.data.array;
      } }, needsUpdate: { set: function set(t) {
        this.data.needsUpdate = t;
      } } }), _extends(ha.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function applyMatrix4(t) {
      for (var e = 0, n = this.data.count; e < n; e++) {
        ua.x = this.getX(e), ua.y = this.getY(e), ua.z = this.getZ(e), ua.applyMatrix4(t), this.setXYZ(e, ua.x, ua.y, ua.z);
      }return this;
    }, setX: function setX(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    }, setY: function setY(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    }, setZ: function setZ(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    }, setW: function setW(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    }, getX: function getX(t) {
      return this.data.array[t * this.data.stride + this.offset];
    }, getY: function getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    }, getZ: function getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    }, getW: function getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    }, setXY: function setXY(t, e, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
    }, setXYZ: function setXYZ(t, e, n, r) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this;
    }, setXYZW: function setXYZW(t, e, n, r, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this;
    }, clone: function clone(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");for (var e = [], n = 0; n < this.count; n++) {
          for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) {
            e.push(this.data.array[r + i]);
          }
        }return new Je(new this.array.constructor(e), this.itemSize, this.normalized);
      }return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ha(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }, toJSON: function toJSON(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");for (var e = [], n = 0; n < this.count; n++) {
          for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) {
            e.push(this.data.array[r + i]);
          }
        }return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized };
      }return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    } }), da.prototype = Object.create(qe.prototype), da.prototype.constructor = da, da.prototype.isSpriteMaterial = !0, da.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
  };var pa = new wt(),
      fa = new wt(),
      ma = new wt(),
      va = new pt(),
      ga = new pt(),
      ya = new Jt(),
      xa = new wt(),
      _a = new wt(),
      ba = new wt(),
      wa = new pt(),
      Ma = new pt(),
      Sa = new pt();function Ta(t) {
    if (be.call(this), this.type = "Sprite", void 0 === la) {
      la = new vn();var e = new ca(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);la.setIndex([0, 1, 2, 0, 2, 3]), la.setAttribute("position", new ha(e, 3, 0, !1)), la.setAttribute("uv", new ha(e, 2, 3, !1));
    }this.geometry = la, this.material = void 0 !== t ? t : new da(), this.center = new pt(.5, .5);
  }function Ea(t, e, n, r, i, a) {
    va.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (ga.x = a * va.x - i * va.y, ga.y = i * va.x + a * va.y) : ga.copy(va), t.copy(e), t.x += ga.x, t.y += ga.y, t.applyMatrix4(ya);
  }Ta.prototype = _extends(Object.create(be.prototype), { constructor: Ta, isSprite: !0, raycast: function raycast(t, e) {
      null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), fa.setFromMatrixScale(this.matrixWorld), ya.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ma.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && fa.multiplyScalar(-ma.z);var n,
          r,
          i = this.material.rotation;0 !== i && (r = Math.cos(i), n = Math.sin(i));var a = this.center;Ea(xa.set(-.5, -.5, 0), ma, a, fa, n, r), Ea(_a.set(.5, -.5, 0), ma, a, fa, n, r), Ea(ba.set(.5, .5, 0), ma, a, fa, n, r), wa.set(0, 0), Ma.set(1, 0), Sa.set(1, 1);var o = t.ray.intersectTriangle(xa, _a, ba, !1, pa);if (null !== o || (Ea(_a.set(-.5, .5, 0), ma, a, fa, n, r), Ma.set(0, 1), null !== (o = t.ray.intersectTriangle(xa, ba, _a, !1, pa)))) {
        var s = t.ray.origin.distanceTo(pa);s < t.near || s > t.far || e.push({ distance: s, point: pa.clone(), uv: Be.getUV(pa, xa, _a, ba, wa, Ma, Sa, new pt()), face: null, object: this });
      }
    }, copy: function copy(t) {
      return be.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this;
    } });var Aa,
      La,
      Ra,
      Ca,
      Pa,
      Ia = new wt(),
      Da = new wt();function Oa() {
    be.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0;
  }function Na(t, e) {
    t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), On.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Jt(), this.bindMatrixInverse = new Jt();
  }Oa.prototype = _extends(Object.create(be.prototype), { constructor: Oa, isLOD: !0, copy: function copy(t) {
      be.prototype.copy.call(this, t, !1);for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
        var i = e[n];this.addLevel(i.object.clone(), i.distance);
      }return this.autoUpdate = t.autoUpdate, this;
    }, addLevel: function addLevel(t, e) {
      void 0 === e && (e = 0), e = Math.abs(e);var n,
          r = this.levels;for (n = 0; n < r.length && !(e < r[n].distance); n++) {}return r.splice(n, 0, { distance: e, object: t }), this.add(t), this;
    }, getCurrentLevel: function getCurrentLevel() {
      return this._currentLevel;
    }, getObjectForDistance: function getObjectForDistance(t) {
      var e = this.levels;if (e.length > 0) {
        var n, r;for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++) {}return e[n - 1].object;
      }return null;
    }, raycast: function raycast(t, e) {
      if (this.levels.length > 0) {
        Ia.setFromMatrixPosition(this.matrixWorld);var n = t.ray.origin.distanceTo(Ia);this.getObjectForDistance(n).raycast(t, e);
      }
    }, update: function update(t) {
      var e = this.levels;if (e.length > 1) {
        Ia.setFromMatrixPosition(t.matrixWorld), Da.setFromMatrixPosition(this.matrixWorld);var n,
            r,
            i = Ia.distanceTo(Da) / t.zoom;for (e[0].object.visible = !0, n = 1, r = e.length; n < r && i >= e[n].distance; n++) {
          e[n - 1].object.visible = !1, e[n].object.visible = !0;
        }for (this._currentLevel = n - 1; n < r; n++) {
          e[n].object.visible = !1;
        }
      }
    }, toJSON: function toJSON(t) {
      var e = be.prototype.toJSON.call(this, t);!1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
        var a = n[r];e.object.levels.push({ object: a.object.uuid, distance: a.distance });
      }return e;
    } }), Na.prototype = _extends(Object.create(On.prototype), { constructor: Na, isSkinnedMesh: !0, copy: function copy(t) {
      return On.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
    }, bind: function bind(t, e) {
      this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
    }, pose: function pose() {
      this.skeleton.pose();
    }, normalizeSkinWeights: function normalizeSkinWeights() {
      for (var t = new yt(), e = this.geometry.attributes.skinWeight, n = 0, r = e.count; n < r; n++) {
        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);var i = 1 / t.manhattanLength();i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    }, updateMatrixWorld: function updateMatrixWorld(t) {
      On.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }, boneTransform: (Aa = new wt(), La = new yt(), Ra = new yt(), Ca = new wt(), Pa = new Jt(), function (t, e) {
      var n = this.skeleton,
          r = this.geometry;La.fromBufferAttribute(r.attributes.skinIndex, t), Ra.fromBufferAttribute(r.attributes.skinWeight, t), Aa.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);for (var i = 0; i < 4; i++) {
        var a = Ra.getComponent(i);if (0 !== a) {
          var o = La.getComponent(i);Pa.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), e.addScaledVector(Ca.copy(Aa).applyMatrix4(Pa), a);
        }
      }return e.applyMatrix4(this.bindMatrixInverse);
    }) });var Ba = new Jt(),
      za = new Jt();function Ga(t, e) {
    if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();else if (this.bones.length === e.length) this.boneInverses = e.slice(0);else {
      console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];for (var n = 0, r = this.bones.length; n < r; n++) {
        this.boneInverses.push(new Jt());
      }
    }
  }function Fa() {
    be.call(this), this.type = "Bone";
  }_extends(Ga.prototype, { calculateInverses: function calculateInverses() {
      this.boneInverses = [];for (var t = 0, e = this.bones.length; t < e; t++) {
        var n = new Jt();this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n);
      }
    }, pose: function pose() {
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var n = this.bones[t];n && n.matrixWorld.getInverse(this.boneInverses[t]);
      }for (var r = 0, i = this.bones.length; r < i; r++) {
        var a = this.bones[r];a && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale));
      }
    }, update: function update() {
      for (var t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = t.length; i < a; i++) {
        var o = t[i] ? t[i].matrixWorld : za;Ba.multiplyMatrices(o, e[i]), Ba.toArray(n, 16 * i);
      }void 0 !== r && (r.needsUpdate = !0);
    }, clone: function clone() {
      return new Ga(this.bones, this.boneInverses);
    }, getBoneByName: function getBoneByName(t) {
      for (var e = 0, n = this.bones.length; e < n; e++) {
        var r = this.bones[e];if (r.name === t) return r;
      }
    }, dispose: function dispose() {
      this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0);
    } }), Fa.prototype = _extends(Object.create(be.prototype), { constructor: Fa, isBone: !0 });var Ua = new Jt(),
      Ha = new Jt(),
      ka = [],
      Va = new On();function Wa(t, e, n) {
    On.call(this, t, e), this.instanceMatrix = new Je(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1;
  }function ja(t) {
    qe.call(this), this.type = "LineBasicMaterial", this.color = new Ve(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t);
  }Wa.prototype = _extends(Object.create(On.prototype), { constructor: Wa, isInstancedMesh: !0, copy: function copy(t) {
      return On.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this;
    }, setColorAt: function setColorAt(t, e) {
      null === this.instanceColor && (this.instanceColor = new Je(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
    }, getMatrixAt: function getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t);
    }, raycast: function raycast(t, e) {
      var n = this.matrixWorld,
          r = this.count;if (Va.geometry = this.geometry, Va.material = this.material, void 0 !== Va.material) for (var i = 0; i < r; i++) {
        this.getMatrixAt(i, Ua), Ha.multiplyMatrices(n, Ua), Va.matrixWorld = Ha, Va.raycast(t, ka);for (var a = 0, o = ka.length; a < o; a++) {
          var s = ka[a];s.instanceId = i, s.object = this, e.push(s);
        }ka.length = 0;
      }
    }, setMatrixAt: function setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t);
    }, updateMorphTargets: function updateMorphTargets() {} }), ja.prototype = Object.create(qe.prototype), ja.prototype.constructor = ja, ja.prototype.isLineBasicMaterial = !0, ja.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this;
  };var qa = new wt(),
      Xa = new wt(),
      Ya = new Jt(),
      Za = new Zt(),
      Ja = new Ht();function Qa(t, e, n) {
    1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), be.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new vn(), this.material = void 0 !== e ? e : new ja(), this.updateMorphTargets();
  }Qa.prototype = _extends(Object.create(be.prototype), { constructor: Qa, isLine: !0, copy: function copy(t) {
      return be.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
    }, computeLineDistances: function computeLineDistances() {
      var t = this.geometry;if (t.isBufferGeometry) {
        if (null === t.index) {
          for (var e = t.attributes.position, n = [0], r = 1, i = e.count; r < i; r++) {
            qa.fromBufferAttribute(e, r - 1), Xa.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += qa.distanceTo(Xa);
          }t.setAttribute("lineDistance", new an(n, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      } else if (t.isGeometry) {
        var a = t.vertices,
            o = t.lineDistances;o[0] = 0;for (var s = 1, c = a.length; s < c; s++) {
          o[s] = o[s - 1], o[s] += a[s - 1].distanceTo(a[s]);
        }
      }return this;
    }, raycast: function raycast(t, e) {
      var n = this.geometry,
          r = this.matrixWorld,
          i = t.params.Line.threshold;if (null === n.boundingSphere && n.computeBoundingSphere(), Ja.copy(n.boundingSphere), Ja.applyMatrix4(r), Ja.radius += i, !1 !== t.ray.intersectsSphere(Ja)) {
        Ya.getInverse(r), Za.copy(t.ray).applyMatrix4(Ya);var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            s = new wt(),
            c = new wt(),
            l = new wt(),
            u = new wt(),
            h = this.isLineSegments ? 2 : 1;if (n.isBufferGeometry) {
          var d = n.index,
              p = n.attributes.position;if (null !== d) for (var f = d.array, m = 0, v = f.length - 1; m < v; m += h) {
            var g = f[m],
                y = f[m + 1];if (s.fromBufferAttribute(p, g), c.fromBufferAttribute(p, y), !(Za.distanceSqToSegment(s, c, u, l) > o)) {
              u.applyMatrix4(this.matrixWorld);var x = t.ray.origin.distanceTo(u);x < t.near || x > t.far || e.push({ distance: x, point: l.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this });
            }
          } else for (var _ = 0, b = p.count - 1; _ < b; _ += h) {
            if (s.fromBufferAttribute(p, _), c.fromBufferAttribute(p, _ + 1), !(Za.distanceSqToSegment(s, c, u, l) > o)) {
              u.applyMatrix4(this.matrixWorld);var w = t.ray.origin.distanceTo(u);w < t.near || w > t.far || e.push({ distance: w, point: l.clone().applyMatrix4(this.matrixWorld), index: _, face: null, faceIndex: null, object: this });
            }
          }
        } else if (n.isGeometry) for (var M = n.vertices, S = M.length, T = 0; T < S - 1; T += h) {
          if (!(Za.distanceSqToSegment(M[T], M[T + 1], u, l) > o)) {
            u.applyMatrix4(this.matrixWorld);var E = t.ray.origin.distanceTo(u);E < t.near || E > t.far || e.push({ distance: E, point: l.clone().applyMatrix4(this.matrixWorld), index: T, face: null, faceIndex: null, object: this });
          }
        }
      }
    }, updateMorphTargets: function updateMorphTargets() {
      var t = this.geometry;if (t.isBufferGeometry) {
        var e = t.morphAttributes,
            n = Object.keys(e);if (n.length > 0) {
          var r = e[n[0]];if (void 0 !== r) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};for (var i = 0, a = r.length; i < a; i++) {
              var o = r[i].name || String(i);this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i;
            }
          }
        }
      } else {
        var s = t.morphTargets;void 0 !== s && s.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    } });var Ka = new wt(),
      $a = new wt();function to(t, e) {
    Qa.call(this, t, e), this.type = "LineSegments";
  }function eo(t, e) {
    Qa.call(this, t, e), this.type = "LineLoop";
  }function no(t) {
    qe.call(this), this.type = "PointsMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t);
  }to.prototype = _extends(Object.create(Qa.prototype), { constructor: to, isLineSegments: !0, computeLineDistances: function computeLineDistances() {
      var t = this.geometry;if (t.isBufferGeometry) {
        if (null === t.index) {
          for (var e = t.attributes.position, n = [], r = 0, i = e.count; r < i; r += 2) {
            Ka.fromBufferAttribute(e, r), $a.fromBufferAttribute(e, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Ka.distanceTo($a);
          }t.setAttribute("lineDistance", new an(n, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      } else if (t.isGeometry) for (var a = t.vertices, o = t.lineDistances, s = 0, c = a.length; s < c; s += 2) {
        Ka.copy(a[s]), $a.copy(a[s + 1]), o[s] = 0 === s ? 0 : o[s - 1], o[s + 1] = o[s] + Ka.distanceTo($a);
      }return this;
    } }), eo.prototype = _extends(Object.create(Qa.prototype), { constructor: eo, isLineLoop: !0 }), no.prototype = Object.create(qe.prototype), no.prototype.constructor = no, no.prototype.isPointsMaterial = !0, no.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
  };var ro = new Jt(),
      io = new Zt(),
      ao = new Ht(),
      oo = new wt();function so(t, e) {
    be.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new vn(), this.material = void 0 !== e ? e : new no(), this.updateMorphTargets();
  }function co(t, e, n, r, i, a, o) {
    var s = io.distanceSqToPoint(t);if (s < n) {
      var c = new wt();io.closestPointToPoint(t, c), c.applyMatrix4(r);var l = i.ray.origin.distanceTo(c);if (l < i.near || l > i.far) return;a.push({ distance: l, distanceToRay: Math.sqrt(s), point: c, index: e, face: null, object: o });
    }
  }function lo(t, e, n, r, i, a, o, s, c) {
    gt.call(this, t, e, n, r, i, a, o, s, c), this.format = void 0 !== o ? o : S, this.minFilter = void 0 !== a ? a : m, this.magFilter = void 0 !== i ? i : m, this.generateMipmaps = !1;var l = this;"requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() {
      l.needsUpdate = !0, t.requestVideoFrameCallback(e);
    });
  }function uo(t, e, n, r, i, a, o, s, c, l, u, h) {
    gt.call(this, null, a, o, s, c, l, r, i, u, h), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
  }function ho(t, e, n, r, i, a, o, s, c) {
    gt.call(this, t, e, n, r, i, a, o, s, c), this.needsUpdate = !0;
  }function po(t, e, n, r, i, a, o, s, c, l) {
    if ((l = void 0 !== l ? l : E) !== E && l !== A) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0 === n && l === E && (n = x), void 0 === n && l === A && (n = M), gt.call(this, null, r, i, a, o, s, l, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : d, this.minFilter = void 0 !== s ? s : d, this.flipY = !1, this.generateMipmaps = !1;
  }so.prototype = _extends(Object.create(be.prototype), { constructor: so, isPoints: !0, copy: function copy(t) {
      return be.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
    }, raycast: function raycast(t, e) {
      var n = this.geometry,
          r = this.matrixWorld,
          i = t.params.Points.threshold;if (null === n.boundingSphere && n.computeBoundingSphere(), ao.copy(n.boundingSphere), ao.applyMatrix4(r), ao.radius += i, !1 !== t.ray.intersectsSphere(ao)) {
        ro.getInverse(r), io.copy(t.ray).applyMatrix4(ro);var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a;if (n.isBufferGeometry) {
          var s = n.index,
              c = n.attributes.position;if (null !== s) for (var l = s.array, u = 0, h = l.length; u < h; u++) {
            var d = l[u];oo.fromBufferAttribute(c, d), co(oo, d, o, r, t, e, this);
          } else for (var p = 0, f = c.count; p < f; p++) {
            oo.fromBufferAttribute(c, p), co(oo, p, o, r, t, e, this);
          }
        } else for (var m = n.vertices, v = 0, g = m.length; v < g; v++) {
          co(m[v], v, o, r, t, e, this);
        }
      }
    }, updateMorphTargets: function updateMorphTargets() {
      var t = this.geometry;if (t.isBufferGeometry) {
        var e = t.morphAttributes,
            n = Object.keys(e);if (n.length > 0) {
          var r = e[n[0]];if (void 0 !== r) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};for (var i = 0, a = r.length; i < a; i++) {
              var o = r[i].name || String(i);this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i;
            }
          }
        }
      } else {
        var s = t.morphTargets;void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    } }), lo.prototype = _extends(Object.create(gt.prototype), { constructor: lo, clone: function clone() {
      return new this.constructor(this.image).copy(this);
    }, isVideoTexture: !0, update: function update() {
      var t = this.image;!1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    } }), uo.prototype = Object.create(gt.prototype), uo.prototype.constructor = uo, uo.prototype.isCompressedTexture = !0, ho.prototype = Object.create(gt.prototype), ho.prototype.constructor = ho, ho.prototype.isCanvasTexture = !0, po.prototype = Object.create(gt.prototype), po.prototype.constructor = po, po.prototype.isDepthTexture = !0;var fo = 0,
      mo = new Jt(),
      vo = new be(),
      go = new wt();function yo() {
    Object.defineProperty(this, "id", { value: fo += 2 }), this.uuid = st.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
  }yo.prototype = _extends(Object.create(rt.prototype), { constructor: yo, isGeometry: !0, applyMatrix4: function applyMatrix4(t) {
      for (var e = new ft().getNormalMatrix(t), n = 0, r = this.vertices.length; n < r; n++) {
        this.vertices[n].applyMatrix4(t);
      }for (var i = 0, a = this.faces.length; i < a; i++) {
        var o = this.faces[i];o.normal.applyMatrix3(e).normalize();for (var s = 0, c = o.vertexNormals.length; s < c; s++) {
          o.vertexNormals[s].applyMatrix3(e).normalize();
        }
      }return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
    }, rotateX: function rotateX(t) {
      return mo.makeRotationX(t), this.applyMatrix4(mo), this;
    }, rotateY: function rotateY(t) {
      return mo.makeRotationY(t), this.applyMatrix4(mo), this;
    }, rotateZ: function rotateZ(t) {
      return mo.makeRotationZ(t), this.applyMatrix4(mo), this;
    }, translate: function translate(t, e, n) {
      return mo.makeTranslation(t, e, n), this.applyMatrix4(mo), this;
    }, scale: function scale(t, e, n) {
      return mo.makeScale(t, e, n), this.applyMatrix4(mo), this;
    }, lookAt: function lookAt(t) {
      return vo.lookAt(t), vo.updateMatrix(), this.applyMatrix4(vo.matrix), this;
    }, fromBufferGeometry: function fromBufferGeometry(t) {
      var e = this,
          n = null !== t.index ? t.index : void 0,
          r = t.attributes;if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;var i = r.position,
          a = r.normal,
          o = r.color,
          s = r.uv,
          c = r.uv2;void 0 !== c && (this.faceVertexUvs[1] = []);for (var l = 0; l < i.count; l++) {
        e.vertices.push(new wt().fromBufferAttribute(i, l)), void 0 !== o && e.colors.push(new Ve().fromBufferAttribute(o, l));
      }function u(t, n, r, i) {
        var l = void 0 === o ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()],
            u = void 0 === a ? [] : [new wt().fromBufferAttribute(a, t), new wt().fromBufferAttribute(a, n), new wt().fromBufferAttribute(a, r)],
            h = new We(t, n, r, u, l, i);e.faces.push(h), void 0 !== s && e.faceVertexUvs[0].push([new pt().fromBufferAttribute(s, t), new pt().fromBufferAttribute(s, n), new pt().fromBufferAttribute(s, r)]), void 0 !== c && e.faceVertexUvs[1].push([new pt().fromBufferAttribute(c, t), new pt().fromBufferAttribute(c, n), new pt().fromBufferAttribute(c, r)]);
      }var h = t.groups;if (h.length > 0) for (var d = 0; d < h.length; d++) {
        for (var p = h[d], f = p.start, m = f, v = f + p.count; m < v; m += 3) {
          void 0 !== n ? u(n.getX(m), n.getX(m + 1), n.getX(m + 2), p.materialIndex) : u(m, m + 1, m + 2, p.materialIndex);
        }
      } else if (void 0 !== n) for (var g = 0; g < n.count; g += 3) {
        u(n.getX(g), n.getX(g + 1), n.getX(g + 2));
      } else for (var y = 0; y < i.count; y += 3) {
        u(y, y + 1, y + 2);
      }return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this;
    }, center: function center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(go).negate(), this.translate(go.x, go.y, go.z), this;
    }, normalize: function normalize() {
      this.computeBoundingSphere();var t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          n = 0 === e ? 1 : 1 / e,
          r = new Jt();return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(r), this;
    }, computeFaceNormals: function computeFaceNormals() {
      for (var t = new wt(), e = new wt(), n = 0, r = this.faces.length; n < r; n++) {
        var i = this.faces[n],
            a = this.vertices[i.a],
            o = this.vertices[i.b],
            s = this.vertices[i.c];t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), i.normal.copy(t);
      }
    }, computeVertexNormals: function computeVertexNormals(t) {
      void 0 === t && (t = !0);for (var e = new Array(this.vertices.length), n = 0, r = this.vertices.length; n < r; n++) {
        e[n] = new wt();
      }if (t) for (var i = new wt(), a = new wt(), o = 0, s = this.faces.length; o < s; o++) {
        var c = this.faces[o],
            l = this.vertices[c.a],
            u = this.vertices[c.b],
            h = this.vertices[c.c];i.subVectors(h, u), a.subVectors(l, u), i.cross(a), e[c.a].add(i), e[c.b].add(i), e[c.c].add(i);
      } else {
        this.computeFaceNormals();for (var d = 0, p = this.faces.length; d < p; d++) {
          var f = this.faces[d];e[f.a].add(f.normal), e[f.b].add(f.normal), e[f.c].add(f.normal);
        }
      }for (var m = 0, v = this.vertices.length; m < v; m++) {
        e[m].normalize();
      }for (var g = 0, y = this.faces.length; g < y; g++) {
        var x = this.faces[g],
            _ = x.vertexNormals;3 === _.length ? (_[0].copy(e[x.a]), _[1].copy(e[x.b]), _[2].copy(e[x.c])) : (_[0] = e[x.a].clone(), _[1] = e[x.b].clone(), _[2] = e[x.c].clone());
      }this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }, computeFlatVertexNormals: function computeFlatVertexNormals() {
      this.computeFaceNormals();for (var t = 0, e = this.faces.length; t < e; t++) {
        var n = this.faces[t],
            r = n.vertexNormals;3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone());
      }this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }, computeMorphNormals: function computeMorphNormals() {
      for (var t = 0, e = this.faces.length; t < e; t++) {
        var n = this.faces[t];n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);for (var r = 0, i = n.vertexNormals.length; r < i; r++) {
          n.__originalVertexNormals[r] ? n.__originalVertexNormals[r].copy(n.vertexNormals[r]) : n.__originalVertexNormals[r] = n.vertexNormals[r].clone();
        }
      }var a = new yo();a.faces = this.faces;for (var o = 0, s = this.morphTargets.length; o < s; o++) {
        if (!this.morphNormals[o]) {
          this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [];for (var c = this.morphNormals[o].faceNormals, l = this.morphNormals[o].vertexNormals, u = 0, h = this.faces.length; u < h; u++) {
            var d = new wt(),
                p = { a: new wt(), b: new wt(), c: new wt() };c.push(d), l.push(p);
          }
        }var f = this.morphNormals[o];a.vertices = this.morphTargets[o].vertices, a.computeFaceNormals(), a.computeVertexNormals();for (var m = 0, v = this.faces.length; m < v; m++) {
          var g = this.faces[m],
              y = f.faceNormals[m],
              x = f.vertexNormals[m];y.copy(g.normal), x.a.copy(g.vertexNormals[0]), x.b.copy(g.vertexNormals[1]), x.c.copy(g.vertexNormals[2]);
        }
      }for (var _ = 0, b = this.faces.length; _ < b; _++) {
        var w = this.faces[_];w.normal = w.__originalFaceNormal, w.vertexNormals = w.__originalVertexNormals;
      }
    }, computeBoundingBox: function computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new Tt()), this.boundingBox.setFromPoints(this.vertices);
    }, computeBoundingSphere: function computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new Ht()), this.boundingSphere.setFromPoints(this.vertices);
    }, merge: function merge(t, e, n) {
      if (t && t.isGeometry) {
        var r,
            i = this.vertices.length,
            a = this.vertices,
            o = t.vertices,
            s = this.faces,
            c = t.faces,
            l = this.colors,
            u = t.colors;void 0 === n && (n = 0), void 0 !== e && (r = new ft().getNormalMatrix(e));for (var h = 0, d = o.length; h < d; h++) {
          var p = o[h].clone();void 0 !== e && p.applyMatrix4(e), a.push(p);
        }for (var f = 0, m = u.length; f < m; f++) {
          l.push(u[f].clone());
        }for (var v = 0, g = c.length; v < g; v++) {
          var y = c[v],
              x = void 0,
              _ = void 0,
              b = y.vertexNormals,
              w = y.vertexColors,
              M = new We(y.a + i, y.b + i, y.c + i);M.normal.copy(y.normal), void 0 !== r && M.normal.applyMatrix3(r).normalize();for (var S = 0, T = b.length; S < T; S++) {
            x = b[S].clone(), void 0 !== r && x.applyMatrix3(r).normalize(), M.vertexNormals.push(x);
          }M.color.copy(y.color);for (var E = 0, A = w.length; E < A; E++) {
            _ = w[E], M.vertexColors.push(_.clone());
          }M.materialIndex = y.materialIndex + n, s.push(M);
        }for (var L = 0, R = t.faceVertexUvs.length; L < R; L++) {
          var C = t.faceVertexUvs[L];void 0 === this.faceVertexUvs[L] && (this.faceVertexUvs[L] = []);for (var P = 0, I = C.length; P < I; P++) {
            for (var D = C[P], O = [], N = 0, B = D.length; N < B; N++) {
              O.push(D[N].clone());
            }this.faceVertexUvs[L].push(O);
          }
        }
      } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
    }, mergeMesh: function mergeMesh(t) {
      t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
    }, mergeVertices: function mergeVertices() {
      for (var t = {}, e = [], n = [], r = Math.pow(10, 4), i = 0, a = this.vertices.length; i < a; i++) {
        var o = this.vertices[i],
            s = Math.round(o.x * r) + "_" + Math.round(o.y * r) + "_" + Math.round(o.z * r);void 0 === t[s] ? (t[s] = i, e.push(this.vertices[i]), n[i] = e.length - 1) : n[i] = n[t[s]];
      }for (var c = [], l = 0, u = this.faces.length; l < u; l++) {
        var h = this.faces[l];h.a = n[h.a], h.b = n[h.b], h.c = n[h.c];for (var d = [h.a, h.b, h.c], p = 0; p < 3; p++) {
          if (d[p] === d[(p + 1) % 3]) {
            c.push(l);break;
          }
        }
      }for (var f = c.length - 1; f >= 0; f--) {
        var m = c[f];this.faces.splice(m, 1);for (var v = 0, g = this.faceVertexUvs.length; v < g; v++) {
          this.faceVertexUvs[v].splice(m, 1);
        }
      }var y = this.vertices.length - e.length;return this.vertices = e, y;
    }, setFromPoints: function setFromPoints(t) {
      this.vertices = [];for (var e = 0, n = t.length; e < n; e++) {
        var r = t[e];this.vertices.push(new wt(r.x, r.y, r.z || 0));
      }return this;
    }, sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {
      for (var t = this.faces, e = t.length, n = 0; n < e; n++) {
        t[n]._id = n;
      }t.sort(function (t, e) {
        return t.materialIndex - e.materialIndex;
      });var r,
          i,
          a = this.faceVertexUvs[0],
          o = this.faceVertexUvs[1];a && a.length === e && (r = []), o && o.length === e && (i = []);for (var s = 0; s < e; s++) {
        var c = t[s]._id;r && r.push(a[c]), i && i.push(o[c]);
      }r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i);
    }, toJSON: function toJSON() {
      var t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
        var e = this.parameters;for (var n in e) {
          void 0 !== e[n] && (t[n] = e[n]);
        }return t;
      }for (var r = [], i = 0; i < this.vertices.length; i++) {
        var a = this.vertices[i];r.push(a.x, a.y, a.z);
      }for (var o = [], s = [], c = {}, l = [], u = {}, h = [], d = {}, p = 0; p < this.faces.length; p++) {
        var f = this.faces[p],
            m = void 0 !== this.faceVertexUvs[0][p],
            v = f.normal.length() > 0,
            g = f.vertexNormals.length > 0,
            y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
            x = f.vertexColors.length > 0,
            _ = 0;if (_ = S(_, 0, 0), _ = S(_, 1, !0), _ = S(_, 2, !1), _ = S(_, 3, m), _ = S(_, 4, v), _ = S(_, 5, g), _ = S(_, 6, y), _ = S(_, 7, x), o.push(_), o.push(f.a, f.b, f.c), o.push(f.materialIndex), m) {
          var b = this.faceVertexUvs[0][p];o.push(A(b[0]), A(b[1]), A(b[2]));
        }if (v && o.push(T(f.normal)), g) {
          var w = f.vertexNormals;o.push(T(w[0]), T(w[1]), T(w[2]));
        }if (y && o.push(E(f.color)), x) {
          var M = f.vertexColors;o.push(E(M[0]), E(M[1]), E(M[2]));
        }
      }function S(t, e, n) {
        return n ? t | 1 << e : t & ~(1 << e);
      }function T(t) {
        var e = t.x.toString() + t.y.toString() + t.z.toString();return void 0 !== c[e] || (c[e] = s.length / 3, s.push(t.x, t.y, t.z)), c[e];
      }function E(t) {
        var e = t.r.toString() + t.g.toString() + t.b.toString();return void 0 !== u[e] || (u[e] = l.length, l.push(t.getHex())), u[e];
      }function A(t) {
        var e = t.x.toString() + t.y.toString();return void 0 !== d[e] || (d[e] = h.length / 2, h.push(t.x, t.y)), d[e];
      }return t.data = {}, t.data.vertices = r, t.data.normals = s, l.length > 0 && (t.data.colors = l), h.length > 0 && (t.data.uvs = [h]), t.data.faces = o, t;
    }, clone: function clone() {
      return new yo().copy(this);
    }, copy: function copy(t) {
      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;for (var e = t.vertices, n = 0, r = e.length; n < r; n++) {
        this.vertices.push(e[n].clone());
      }for (var i = t.colors, a = 0, o = i.length; a < o; a++) {
        this.colors.push(i[a].clone());
      }for (var s = t.faces, c = 0, l = s.length; c < l; c++) {
        this.faces.push(s[c].clone());
      }for (var u = 0, h = t.faceVertexUvs.length; u < h; u++) {
        var d = t.faceVertexUvs[u];void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);for (var p = 0, f = d.length; p < f; p++) {
          for (var m = d[p], v = [], g = 0, y = m.length; g < y; g++) {
            var x = m[g];v.push(x.clone());
          }this.faceVertexUvs[u].push(v);
        }
      }for (var _ = t.morphTargets, b = 0, w = _.length; b < w; b++) {
        var M = {};if (M.name = _[b].name, void 0 !== _[b].vertices) {
          M.vertices = [];for (var S = 0, T = _[b].vertices.length; S < T; S++) {
            M.vertices.push(_[b].vertices[S].clone());
          }
        }if (void 0 !== _[b].normals) {
          M.normals = [];for (var E = 0, A = _[b].normals.length; E < A; E++) {
            M.normals.push(_[b].normals[E].clone());
          }
        }this.morphTargets.push(M);
      }for (var L = t.morphNormals, R = 0, C = L.length; R < C; R++) {
        var P = {};if (void 0 !== L[R].vertexNormals) {
          P.vertexNormals = [];for (var I = 0, D = L[R].vertexNormals.length; I < D; I++) {
            var O = L[R].vertexNormals[I],
                N = {};N.a = O.a.clone(), N.b = O.b.clone(), N.c = O.c.clone(), P.vertexNormals.push(N);
          }
        }if (void 0 !== L[R].faceNormals) {
          P.faceNormals = [];for (var B = 0, z = L[R].faceNormals.length; B < z; B++) {
            P.faceNormals.push(L[R].faceNormals[B].clone());
          }
        }this.morphNormals.push(P);
      }for (var G = t.skinWeights, F = 0, U = G.length; F < U; F++) {
        this.skinWeights.push(G[F].clone());
      }for (var H = t.skinIndices, k = 0, V = H.length; k < V; k++) {
        this.skinIndices.push(H[k].clone());
      }for (var W = t.lineDistances, j = 0, q = W.length; j < q; j++) {
        this.lineDistances.push(W[j]);
      }var X = t.boundingBox;null !== X && (this.boundingBox = X.clone());var Y = t.boundingSphere;return null !== Y && (this.boundingSphere = Y.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
    }, dispose: function dispose() {
      this.dispatchEvent({ type: "dispose" });
    } });var xo = function (t) {
    function e(e, n, r, i, a, o) {
      var s;return (s = t.call(this) || this).type = "BoxGeometry", s.parameters = { width: e, height: n, depth: r, widthSegments: i, heightSegments: a, depthSegments: o }, s.fromBufferGeometry(new zn(e, n, r, i, a, o)), s.mergeVertices(), s;
    }return ut(e, t), e;
  }(yo),
      _o = function (t) {
    function e(e, n, r, i) {
      var a;(a = t.call(this) || this).type = "CircleBufferGeometry", a.parameters = { radius: e, segments: n, thetaStart: r, thetaLength: i }, e = e || 1, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI;var o = [],
          s = [],
          c = [],
          l = [],
          u = new wt(),
          h = new pt();s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5);for (var d = 0, p = 3; d <= n; d++, p += 3) {
        var f = r + d / n * i;u.x = e * Math.cos(f), u.y = e * Math.sin(f), s.push(u.x, u.y, u.z), c.push(0, 0, 1), h.x = (s[p] / e + 1) / 2, h.y = (s[p + 1] / e + 1) / 2, l.push(h.x, h.y);
      }for (var m = 1; m <= n; m++) {
        o.push(m, m + 1, 0);
      }return a.setIndex(o), a.setAttribute("position", new an(s, 3)), a.setAttribute("normal", new an(c, 3)), a.setAttribute("uv", new an(l, 2)), a;
    }return ut(e, t), e;
  }(vn),
      bo = function (t) {
    function e(e, n, r, i) {
      var a;return (a = t.call(this) || this).type = "CircleGeometry", a.parameters = { radius: e, segments: n, thetaStart: r, thetaLength: i }, a.fromBufferGeometry(new _o(e, n, r, i)), a.mergeVertices(), a;
    }return ut(e, t), e;
  }(yo),
      wo = function (t) {
    function e(e, n, r, i, a, o, s, c) {
      var l;(l = t.call(this) || this).type = "CylinderBufferGeometry", l.parameters = { radiusTop: e, radiusBottom: n, height: r, radialSegments: i, heightSegments: a, openEnded: o, thetaStart: s, thetaLength: c };var u = ht(l);e = void 0 !== e ? e : 1, n = void 0 !== n ? n : 1, r = r || 1, i = Math.floor(i) || 8, a = Math.floor(a) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, c = void 0 !== c ? c : 2 * Math.PI;var h = [],
          d = [],
          p = [],
          f = [],
          m = 0,
          v = [],
          g = r / 2,
          y = 0;function x(t) {
        for (var r = m, a = new pt(), o = new wt(), l = 0, v = !0 === t ? e : n, x = !0 === t ? 1 : -1, _ = 1; _ <= i; _++) {
          d.push(0, g * x, 0), p.push(0, x, 0), f.push(.5, .5), m++;
        }for (var b = m, w = 0; w <= i; w++) {
          var M = w / i * c + s,
              S = Math.cos(M),
              T = Math.sin(M);o.x = v * T, o.y = g * x, o.z = v * S, d.push(o.x, o.y, o.z), p.push(0, x, 0), a.x = .5 * S + .5, a.y = .5 * T * x + .5, f.push(a.x, a.y), m++;
        }for (var E = 0; E < i; E++) {
          var A = r + E,
              L = b + E;!0 === t ? h.push(L, L + 1, A) : h.push(L + 1, L, A), l += 3;
        }u.addGroup(y, l, !0 === t ? 1 : 2), y += l;
      }return function () {
        for (var t = new wt(), o = new wt(), l = 0, x = (n - e) / r, _ = 0; _ <= a; _++) {
          for (var b = [], w = _ / a, M = w * (n - e) + e, S = 0; S <= i; S++) {
            var T = S / i,
                E = T * c + s,
                A = Math.sin(E),
                L = Math.cos(E);o.x = M * A, o.y = -w * r + g, o.z = M * L, d.push(o.x, o.y, o.z), t.set(A, x, L).normalize(), p.push(t.x, t.y, t.z), f.push(T, 1 - w), b.push(m++);
          }v.push(b);
        }for (var R = 0; R < i; R++) {
          for (var C = 0; C < a; C++) {
            var P = v[C][R],
                I = v[C + 1][R],
                D = v[C + 1][R + 1],
                O = v[C][R + 1];h.push(P, I, O), h.push(I, D, O), l += 6;
          }
        }u.addGroup(y, l, 0), y += l;
      }(), !1 === o && (e > 0 && x(!0), n > 0 && x(!1)), l.setIndex(h), l.setAttribute("position", new an(d, 3)), l.setAttribute("normal", new an(p, 3)), l.setAttribute("uv", new an(f, 2)), l;
    }return ut(e, t), e;
  }(vn),
      Mo = function (t) {
    function e(e, n, r, i, a, o, s, c) {
      var l;return (l = t.call(this) || this).type = "CylinderGeometry", l.parameters = { radiusTop: e, radiusBottom: n, height: r, radialSegments: i, heightSegments: a, openEnded: o, thetaStart: s, thetaLength: c }, l.fromBufferGeometry(new wo(e, n, r, i, a, o, s, c)), l.mergeVertices(), l;
    }return ut(e, t), e;
  }(yo),
      So = function (t) {
    function e(e, n, r, i, a, o, s) {
      var c;return (c = t.call(this, 0, e, n, r, i, a, o, s) || this).type = "ConeGeometry", c.parameters = { radius: e, height: n, radialSegments: r, heightSegments: i, openEnded: a, thetaStart: o, thetaLength: s }, c;
    }return ut(e, t), e;
  }(Mo),
      To = function (t) {
    function e(e, n, r, i, a, o, s) {
      var c;return (c = t.call(this, 0, e, n, r, i, a, o, s) || this).type = "ConeBufferGeometry", c.parameters = { radius: e, height: n, radialSegments: r, heightSegments: i, openEnded: a, thetaStart: o, thetaLength: s }, c;
    }return ut(e, t), e;
  }(wo),
      Eo = function (t) {
    function e(e, n, r, i) {
      var a;(a = t.call(this) || this).type = "PolyhedronBufferGeometry", a.parameters = { vertices: e, indices: n, radius: r, detail: i }, r = r || 1;var o = [],
          s = [];function c(t, e, n, r) {
        for (var i = r + 1, a = [], o = 0; o <= i; o++) {
          a[o] = [];for (var s = t.clone().lerp(n, o / i), c = e.clone().lerp(n, o / i), u = i - o, h = 0; h <= u; h++) {
            a[o][h] = 0 === h && o === i ? s : s.clone().lerp(c, h / u);
          }
        }for (var d = 0; d < i; d++) {
          for (var p = 0; p < 2 * (i - d) - 1; p++) {
            var f = Math.floor(p / 2);p % 2 == 0 ? (l(a[d][f + 1]), l(a[d + 1][f]), l(a[d][f])) : (l(a[d][f + 1]), l(a[d + 1][f + 1]), l(a[d + 1][f]));
          }
        }
      }function l(t) {
        o.push(t.x, t.y, t.z);
      }function u(t, n) {
        var r = 3 * t;n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2];
      }function h(t, e, n, r) {
        r < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = r / 2 / Math.PI + .5);
      }function d(t) {
        return Math.atan2(t.z, -t.x);
      }function p(t) {
        return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
      }return function (t) {
        for (var e = new wt(), r = new wt(), i = new wt(), a = 0; a < n.length; a += 3) {
          u(n[a + 0], e), u(n[a + 1], r), u(n[a + 2], i), c(e, r, i, t);
        }
      }(i = i || 0), function (t) {
        for (var e = new wt(), n = 0; n < o.length; n += 3) {
          e.x = o[n + 0], e.y = o[n + 1], e.z = o[n + 2], e.normalize().multiplyScalar(t), o[n + 0] = e.x, o[n + 1] = e.y, o[n + 2] = e.z;
        }
      }(r), function () {
        for (var t = new wt(), e = 0; e < o.length; e += 3) {
          t.x = o[e + 0], t.y = o[e + 1], t.z = o[e + 2];var n = d(t) / 2 / Math.PI + .5,
              r = p(t) / Math.PI + .5;s.push(n, 1 - r);
        }(function () {
          for (var t = new wt(), e = new wt(), n = new wt(), r = new wt(), i = new pt(), a = new pt(), c = new pt(), l = 0, u = 0; l < o.length; l += 9, u += 6) {
            t.set(o[l + 0], o[l + 1], o[l + 2]), e.set(o[l + 3], o[l + 4], o[l + 5]), n.set(o[l + 6], o[l + 7], o[l + 8]), i.set(s[u + 0], s[u + 1]), a.set(s[u + 2], s[u + 3]), c.set(s[u + 4], s[u + 5]), r.copy(t).add(e).add(n).divideScalar(3);var p = d(r);h(i, u + 0, t, p), h(a, u + 2, e, p), h(c, u + 4, n, p);
          }
        })(), function () {
          for (var t = 0; t < s.length; t += 6) {
            var e = s[t + 0],
                n = s[t + 2],
                r = s[t + 4],
                i = Math.max(e, n, r),
                a = Math.min(e, n, r);i > .9 && a < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), r < .2 && (s[t + 4] += 1));
          }
        }();
      }(), a.setAttribute("position", new an(o, 3)), a.setAttribute("normal", new an(o.slice(), 3)), a.setAttribute("uv", new an(s, 2)), 0 === i ? a.computeVertexNormals() : a.normalizeNormals(), a;
    }return ut(e, t), e;
  }(vn),
      Ao = function (t) {
    function e(e, n) {
      var r,
          i = (1 + Math.sqrt(5)) / 2,
          a = 1 / i,
          o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -a, -i, 0, -a, i, 0, a, -i, 0, a, i, -a, -i, 0, -a, i, 0, a, -i, 0, a, i, 0, -i, 0, -a, i, 0, -a, -i, 0, a, i, 0, a];return (r = t.call(this, o, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, n) || this).type = "DodecahedronBufferGeometry", r.parameters = { radius: e, detail: n }, r;
    }return ut(e, t), e;
  }(Eo),
      Lo = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "DodecahedronGeometry", r.parameters = { radius: e, detail: n }, r.fromBufferGeometry(new Ao(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e;
  }(yo),
      Ro = new wt(),
      Co = new wt(),
      Po = new wt(),
      Io = new Be(),
      Do = function (t) {
    function e(e, n) {
      var r;(r = t.call(this) || this).type = "EdgesGeometry", r.parameters = { thresholdAngle: n }, n = void 0 !== n ? n : 1, e.isGeometry && (e = new vn().fromGeometry(e));for (var i = Math.pow(10, 4), a = Math.cos(st.DEG2RAD * n), o = e.getIndex(), s = e.getAttribute("position"), c = o ? o.count : s.count, l = [0, 0, 0], u = ["a", "b", "c"], h = new Array(3), d = {}, p = [], f = 0; f < c; f += 3) {
        o ? (l[0] = o.getX(f), l[1] = o.getX(f + 1), l[2] = o.getX(f + 2)) : (l[0] = f, l[1] = f + 1, l[2] = f + 2);var m = Io.a,
            v = Io.b,
            g = Io.c;if (m.fromBufferAttribute(s, l[0]), v.fromBufferAttribute(s, l[1]), g.fromBufferAttribute(s, l[2]), Io.getNormal(Po), h[0] = Math.round(m.x * i) + "," + Math.round(m.y * i) + "," + Math.round(m.z * i), h[1] = Math.round(v.x * i) + "," + Math.round(v.y * i) + "," + Math.round(v.z * i), h[2] = Math.round(g.x * i) + "," + Math.round(g.y * i) + "," + Math.round(g.z * i), h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0]) for (var y = 0; y < 3; y++) {
          var x = (y + 1) % 3,
              _ = h[y],
              b = h[x],
              w = Io[u[y]],
              M = Io[u[x]],
              S = _ + "_" + b,
              T = b + "_" + _;T in d && d[T] ? (Po.dot(d[T].normal) <= a && (p.push(w.x, w.y, w.z), p.push(M.x, M.y, M.z)), d[T] = null) : S in d || (d[S] = { index0: l[y], index1: l[x], normal: Po.clone() });
        }
      }for (var E in d) {
        if (d[E]) {
          var A = d[E],
              L = A.index0,
              R = A.index1;Ro.fromBufferAttribute(s, L), Co.fromBufferAttribute(s, R), p.push(Ro.x, Ro.y, Ro.z), p.push(Co.x, Co.y, Co.z);
        }
      }return r.setAttribute("position", new an(p, 3)), r;
    }return ut(e, t), e;
  }(vn),
      Oo = function Oo(t, e, n) {
    n = n || 2;var r,
        i,
        a,
        o,
        s,
        c,
        l,
        u = e && e.length,
        h = u ? e[0] * n : t.length,
        d = No(t, 0, h, n, !0),
        p = [];if (!d || d.next === d.prev) return p;if (u && (d = function (t, e, n, r) {
      var i,
          a,
          o,
          s = [];for (i = 0, a = e.length; i < a; i++) {
        (o = No(t, e[i] * r, i < a - 1 ? e[i + 1] * r : t.length, r, !1)) === o.next && (o.steiner = !0), s.push(qo(o));
      }for (s.sort(ko), i = 0; i < s.length; i++) {
        Vo(s[i], n), n = Bo(n, n.next);
      }return n;
    }(t, e, d, n)), t.length > 80 * n) {
      r = a = t[0], i = o = t[1];for (var f = n; f < h; f += n) {
        (s = t[f]) < r && (r = s), (c = t[f + 1]) < i && (i = c), s > a && (a = s), c > o && (o = c);
      }l = 0 !== (l = Math.max(a - r, o - i)) ? 1 / l : 0;
    }return zo(d, p, n, r, i, l), p;
  };function No(t, e, n, r, i) {
    var a, o;if (i === function (t, e, n, r) {
      for (var i = 0, a = e, o = n - r; a < n; a += r) {
        i += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
      }return i;
    }(t, e, n, r) > 0) for (a = e; a < n; a += r) {
      o = ns(a, t[a], t[a + 1], o);
    } else for (a = n - r; a >= e; a -= r) {
      o = ns(a, t[a], t[a + 1], o);
    }return o && Jo(o, o.next) && (rs(o), o = o.next), o;
  }function Bo(t, e) {
    if (!t) return t;e || (e = t);var n,
        r = t;do {
      if (n = !1, r.steiner || !Jo(r, r.next) && 0 !== Zo(r.prev, r, r.next)) r = r.next;else {
        if (rs(r), (r = e = r.prev) === r.next) break;n = !0;
      }
    } while (n || r !== e);return e;
  }function zo(t, e, n, r, i, a, o) {
    if (t) {
      !o && a && function (t, e, n, r) {
        var i = t;do {
          null === i.z && (i.z = jo(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
        } while (i !== t);i.prevZ.nextZ = null, i.prevZ = null, function (t) {
          var e,
              n,
              r,
              i,
              a,
              o,
              s,
              c,
              l = 1;do {
            for (n = t, t = null, a = null, o = 0; n;) {
              for (o++, r = n, s = 0, e = 0; e < l && (s++, r = r.nextZ); e++) {}for (c = l; s > 0 || c > 0 && r;) {
                0 !== s && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, c--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;
              }n = r;
            }a.nextZ = null, l *= 2;
          } while (o > 1);
        }(i);
      }(t, r, i, a);for (var s, c, l = t; t.prev !== t.next;) {
        if (s = t.prev, c = t.next, a ? Fo(t, r, i, a) : Go(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), rs(t), t = c.next, l = c.next;else if ((t = c) === l) {
          o ? 1 === o ? zo(t = Uo(Bo(t), e, n), e, n, r, i, a, 2) : 2 === o && Ho(t, e, n, r, i, a) : zo(Bo(t), e, n, r, i, a, 1);break;
        }
      }
    }
  }function Go(t) {
    var e = t.prev,
        n = t,
        r = t.next;if (Zo(e, n, r) >= 0) return !1;for (var i = t.next.next; i !== t.prev;) {
      if (Xo(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Zo(i.prev, i, i.next) >= 0) return !1;i = i.next;
    }return !0;
  }function Fo(t, e, n, r) {
    var i = t.prev,
        a = t,
        o = t.next;if (Zo(i, a, o) >= 0) return !1;for (var s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, c = i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, l = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, h = jo(s, c, e, n, r), d = jo(l, u, e, n, r), p = t.prevZ, f = t.nextZ; p && p.z >= h && f && f.z <= d;) {
      if (p !== t.prev && p !== t.next && Xo(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && Zo(p.prev, p, p.next) >= 0) return !1;if (p = p.prevZ, f !== t.prev && f !== t.next && Xo(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && Zo(f.prev, f, f.next) >= 0) return !1;f = f.nextZ;
    }for (; p && p.z >= h;) {
      if (p !== t.prev && p !== t.next && Xo(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && Zo(p.prev, p, p.next) >= 0) return !1;p = p.prevZ;
    }for (; f && f.z <= d;) {
      if (f !== t.prev && f !== t.next && Xo(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && Zo(f.prev, f, f.next) >= 0) return !1;f = f.nextZ;
    }return !0;
  }function Uo(t, e, n) {
    var r = t;do {
      var i = r.prev,
          a = r.next.next;!Jo(i, a) && Qo(i, r, r.next, a) && ts(i, a) && ts(a, i) && (e.push(i.i / n), e.push(r.i / n), e.push(a.i / n), rs(r), rs(r.next), r = t = a), r = r.next;
    } while (r !== t);return Bo(r);
  }function Ho(t, e, n, r, i, a) {
    var o = t;do {
      for (var s = o.next.next; s !== o.prev;) {
        if (o.i !== s.i && Yo(o, s)) {
          var c = es(o, s);return o = Bo(o, o.next), c = Bo(c, c.next), zo(o, e, n, r, i, a), void zo(c, e, n, r, i, a);
        }s = s.next;
      }o = o.next;
    } while (o !== t);
  }function ko(t, e) {
    return t.x - e.x;
  }function Vo(t, e) {
    if (e = function (t, e) {
      var n,
          r = e,
          i = t.x,
          a = t.y,
          o = -1 / 0;do {
        if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
          var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);if (s <= i && s > o) {
            if (o = s, s === i) {
              if (a === r.y) return r;if (a === r.next.y) return r.next;
            }n = r.x < r.next.x ? r : r.next;
          }
        }r = r.next;
      } while (r !== e);if (!n) return null;if (i === o) return n;var c,
          l = n,
          u = n.x,
          h = n.y,
          d = 1 / 0;r = n;do {
        i >= r.x && r.x >= u && i !== r.x && Xo(a < h ? i : o, a, u, h, a < h ? o : i, a, r.x, r.y) && (c = Math.abs(a - r.y) / (i - r.x), ts(r, t) && (c < d || c === d && (r.x > n.x || r.x === n.x && Wo(n, r))) && (n = r, d = c)), r = r.next;
      } while (r !== l);return n;
    }(t, e)) {
      var n = es(e, t);Bo(e, e.next), Bo(n, n.next);
    }
  }function Wo(t, e) {
    return Zo(t.prev, t, e.prev) < 0 && Zo(e.next, t, t.next) < 0;
  }function jo(t, e, n, r, i) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
  }function qo(t) {
    var e = t,
        n = t;do {
      (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
    } while (e !== t);return n;
  }function Xo(t, e, n, r, i, a, o, s) {
    return (i - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (r - s) - (n - o) * (e - s) >= 0 && (n - o) * (a - s) - (i - o) * (r - s) >= 0;
  }function Yo(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
      var n = t;do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Qo(n, n.next, t, e)) return !0;n = n.next;
      } while (n !== t);return !1;
    }(t, e) && (ts(t, e) && ts(e, t) && function (t, e) {
      var n = t,
          r = !1,
          i = (t.x + e.x) / 2,
          a = (t.y + e.y) / 2;do {
        n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next;
      } while (n !== t);return r;
    }(t, e) && (Zo(t.prev, t, e.prev) || Zo(t, e.prev, e)) || Jo(t, e) && Zo(t.prev, t, t.next) > 0 && Zo(e.prev, e, e.next) > 0);
  }function Zo(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
  }function Jo(t, e) {
    return t.x === e.x && t.y === e.y;
  }function Qo(t, e, n, r) {
    var i = $o(Zo(t, e, n)),
        a = $o(Zo(t, e, r)),
        o = $o(Zo(n, r, t)),
        s = $o(Zo(n, r, e));return i !== a && o !== s || !(0 !== i || !Ko(t, n, e)) || !(0 !== a || !Ko(t, r, e)) || !(0 !== o || !Ko(n, t, r)) || !(0 !== s || !Ko(n, e, r));
  }function Ko(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
  }function $o(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }function ts(t, e) {
    return Zo(t.prev, t, t.next) < 0 ? Zo(t, e, t.next) >= 0 && Zo(t, t.prev, e) >= 0 : Zo(t, e, t.prev) < 0 || Zo(t, t.next, e) < 0;
  }function es(t, e) {
    var n = new is(t.i, t.x, t.y),
        r = new is(e.i, e.x, e.y),
        i = t.next,
        a = e.prev;return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r;
  }function ns(t, e, n, r) {
    var i = new is(t, e, n);return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;
  }function rs(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }function is(t, e, n) {
    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
  }var as = { area: function area(t) {
      for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++) {
        n += t[r].x * t[i].y - t[i].x * t[r].y;
      }return .5 * n;
    }, isClockWise: function isClockWise(t) {
      return as.area(t) < 0;
    }, triangulateShape: function triangulateShape(t, e) {
      var n = [],
          r = [],
          i = [];os(t), ss(n, t);var a = t.length;e.forEach(os);for (var o = 0; o < e.length; o++) {
        r.push(a), a += e[o].length, ss(n, e[o]);
      }for (var s = Oo(n, r), c = 0; c < s.length; c += 3) {
        i.push(s.slice(c, c + 3));
      }return i;
    } };function os(t) {
    var e = t.length;e > 2 && t[e - 1].equals(t[0]) && t.pop();
  }function ss(t, e) {
    for (var n = 0; n < e.length; n++) {
      t.push(e[n].x), t.push(e[n].y);
    }
  }var cs = function (t) {
    function e(e, n) {
      var r;(r = t.call(this) || this).type = "ExtrudeBufferGeometry", r.parameters = { shapes: e, options: n }, e = Array.isArray(e) ? e : [e];for (var i = ht(r), a = [], o = [], s = 0, c = e.length; s < c; s++) {
        l(e[s]);
      }function l(t) {
        var e = [],
            r = void 0 !== n.curveSegments ? n.curveSegments : 12,
            s = void 0 !== n.steps ? n.steps : 1,
            c = void 0 !== n.depth ? n.depth : 100,
            l = void 0 === n.bevelEnabled || n.bevelEnabled,
            u = void 0 !== n.bevelThickness ? n.bevelThickness : 6,
            h = void 0 !== n.bevelSize ? n.bevelSize : u - 2,
            d = void 0 !== n.bevelOffset ? n.bevelOffset : 0,
            p = void 0 !== n.bevelSegments ? n.bevelSegments : 3,
            f = n.extrudePath,
            m = void 0 !== n.UVGenerator ? n.UVGenerator : ls;void 0 !== n.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = n.amount);var v,
            g,
            y,
            x,
            _,
            b = !1;f && (v = f.getSpacedPoints(s), b = !0, l = !1, g = f.computeFrenetFrames(s, !1), y = new wt(), x = new wt(), _ = new wt()), l || (p = 0, u = 0, h = 0, d = 0);var w = t.extractPoints(r),
            M = w.shape,
            S = w.holes;if (!as.isClockWise(M)) {
          M = M.reverse();for (var T = 0, E = S.length; T < E; T++) {
            var A = S[T];as.isClockWise(A) && (S[T] = A.reverse());
          }
        }for (var L = as.triangulateShape(M, S), R = M, C = 0, P = S.length; C < P; C++) {
          var I = S[C];M = M.concat(I);
        }function D(t, e, n) {
          return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t);
        }var O = M.length,
            N = L.length;function B(t, e, n) {
          var r,
              i,
              a,
              o = t.x - e.x,
              s = t.y - e.y,
              c = n.x - t.x,
              l = n.y - t.y,
              u = o * o + s * s,
              h = o * l - s * c;if (Math.abs(h) > Number.EPSILON) {
            var d = Math.sqrt(u),
                p = Math.sqrt(c * c + l * l),
                f = e.x - s / d,
                m = e.y + o / d,
                v = ((n.x - l / p - f) * l - (n.y + c / p - m) * c) / (o * l - s * c),
                g = (r = f + o * v - t.x) * r + (i = m + s * v - t.y) * i;if (g <= 2) return new pt(r, i);a = Math.sqrt(g / 2);
          } else {
            var y = !1;o > Number.EPSILON ? c > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), y ? (r = -s, i = o, a = Math.sqrt(u)) : (r = o, i = s, a = Math.sqrt(u / 2));
          }return new pt(r / a, i / a);
        }for (var z = [], G = 0, F = R.length, U = F - 1, H = G + 1; G < F; G++, U++, H++) {
          U === F && (U = 0), H === F && (H = 0), z[G] = B(R[G], R[U], R[H]);
        }for (var k, V = [], W = z.concat(), j = 0, q = S.length; j < q; j++) {
          var X = S[j];k = [];for (var Y = 0, Z = X.length, J = Z - 1, Q = Y + 1; Y < Z; Y++, J++, Q++) {
            J === Z && (J = 0), Q === Z && (Q = 0), k[Y] = B(X[Y], X[J], X[Q]);
          }V.push(k), W = W.concat(k);
        }for (var K = 0; K < p; K++) {
          for (var $ = K / p, tt = u * Math.cos($ * Math.PI / 2), et = h * Math.sin($ * Math.PI / 2) + d, nt = 0, rt = R.length; nt < rt; nt++) {
            var it = D(R[nt], z[nt], et);Dt(it.x, it.y, -tt);
          }for (var at = 0, ot = S.length; at < ot; at++) {
            var st = S[at];k = V[at];for (var ct = 0, lt = st.length; ct < lt; ct++) {
              var ut = D(st[ct], k[ct], et);Dt(ut.x, ut.y, -tt);
            }
          }
        }for (var ht = h + d, dt = 0; dt < O; dt++) {
          var ft = l ? D(M[dt], W[dt], ht) : M[dt];b ? (x.copy(g.normals[0]).multiplyScalar(ft.x), y.copy(g.binormals[0]).multiplyScalar(ft.y), _.copy(v[0]).add(x).add(y), Dt(_.x, _.y, _.z)) : Dt(ft.x, ft.y, 0);
        }for (var mt = 1; mt <= s; mt++) {
          for (var vt = 0; vt < O; vt++) {
            var gt = l ? D(M[vt], W[vt], ht) : M[vt];b ? (x.copy(g.normals[mt]).multiplyScalar(gt.x), y.copy(g.binormals[mt]).multiplyScalar(gt.y), _.copy(v[mt]).add(x).add(y), Dt(_.x, _.y, _.z)) : Dt(gt.x, gt.y, c / s * mt);
          }
        }for (var yt = p - 1; yt >= 0; yt--) {
          for (var xt = yt / p, _t = u * Math.cos(xt * Math.PI / 2), bt = h * Math.sin(xt * Math.PI / 2) + d, Mt = 0, St = R.length; Mt < St; Mt++) {
            var Tt = D(R[Mt], z[Mt], bt);Dt(Tt.x, Tt.y, c + _t);
          }for (var Et = 0, At = S.length; Et < At; Et++) {
            var Lt = S[Et];k = V[Et];for (var Rt = 0, Ct = Lt.length; Rt < Ct; Rt++) {
              var Pt = D(Lt[Rt], k[Rt], bt);b ? Dt(Pt.x, Pt.y + v[s - 1].y, v[s - 1].x + _t) : Dt(Pt.x, Pt.y, c + _t);
            }
          }
        }function It(t, e) {
          for (var n = t.length; --n >= 0;) {
            var r = n,
                i = n - 1;i < 0 && (i = t.length - 1);for (var a = 0, o = s + 2 * p; a < o; a++) {
              var c = O * a,
                  l = O * (a + 1);Nt(e + r + c, e + i + c, e + i + l, e + r + l);
            }
          }
        }function Dt(t, n, r) {
          e.push(t), e.push(n), e.push(r);
        }function Ot(t, e, n) {
          Bt(t), Bt(e), Bt(n);var r = a.length / 3,
              o = m.generateTopUV(i, a, r - 3, r - 2, r - 1);zt(o[0]), zt(o[1]), zt(o[2]);
        }function Nt(t, e, n, r) {
          Bt(t), Bt(e), Bt(r), Bt(e), Bt(n), Bt(r);var o = a.length / 3,
              s = m.generateSideWallUV(i, a, o - 6, o - 3, o - 2, o - 1);zt(s[0]), zt(s[1]), zt(s[3]), zt(s[1]), zt(s[2]), zt(s[3]);
        }function Bt(t) {
          a.push(e[3 * t + 0]), a.push(e[3 * t + 1]), a.push(e[3 * t + 2]);
        }function zt(t) {
          o.push(t.x), o.push(t.y);
        }!function () {
          var t = a.length / 3;if (l) {
            for (var e = 0, n = O * e, r = 0; r < N; r++) {
              var o = L[r];Ot(o[2] + n, o[1] + n, o[0] + n);
            }n = O * (e = s + 2 * p);for (var c = 0; c < N; c++) {
              var u = L[c];Ot(u[0] + n, u[1] + n, u[2] + n);
            }
          } else {
            for (var h = 0; h < N; h++) {
              var d = L[h];Ot(d[2], d[1], d[0]);
            }for (var f = 0; f < N; f++) {
              var m = L[f];Ot(m[0] + O * s, m[1] + O * s, m[2] + O * s);
            }
          }i.addGroup(t, a.length / 3 - t, 0);
        }(), function () {
          var t = a.length / 3,
              e = 0;It(R, e), e += R.length;for (var n = 0, r = S.length; n < r; n++) {
            var o = S[n];It(o, e), e += o.length;
          }i.addGroup(t, a.length / 3 - t, 1);
        }();
      }return r.setAttribute("position", new an(a, 3)), r.setAttribute("uv", new an(o, 2)), r.computeVertexNormals(), r;
    }return ut(e, t), e.prototype.toJSON = function () {
      var t = vn.prototype.toJSON.call(this);return function (t, e, n) {
        if (n.shapes = [], Array.isArray(t)) for (var r = 0, i = t.length; r < i; r++) {
          var a = t[r];n.shapes.push(a.uuid);
        } else n.shapes.push(t.uuid);void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());return n;
      }(this.parameters.shapes, this.parameters.options, t);
    }, e;
  }(vn),
      ls = { generateTopUV: function generateTopUV(t, e, n, r, i) {
      var a = e[3 * n],
          o = e[3 * n + 1],
          s = e[3 * r],
          c = e[3 * r + 1],
          l = e[3 * i],
          u = e[3 * i + 1];return [new pt(a, o), new pt(s, c), new pt(l, u)];
    }, generateSideWallUV: function generateSideWallUV(t, e, n, r, i, a) {
      var o = e[3 * n],
          s = e[3 * n + 1],
          c = e[3 * n + 2],
          l = e[3 * r],
          u = e[3 * r + 1],
          h = e[3 * r + 2],
          d = e[3 * i],
          p = e[3 * i + 1],
          f = e[3 * i + 2],
          m = e[3 * a],
          v = e[3 * a + 1],
          g = e[3 * a + 2];return Math.abs(s - u) < .01 ? [new pt(o, 1 - c), new pt(l, 1 - h), new pt(d, 1 - f), new pt(m, 1 - g)] : [new pt(s, 1 - c), new pt(u, 1 - h), new pt(p, 1 - f), new pt(v, 1 - g)];
    } };var us = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "ExtrudeGeometry", r.parameters = { shapes: e, options: n }, r.fromBufferGeometry(new cs(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e.prototype.toJSON = function () {
      var e = t.prototype.toJSON.call(this);return function (t, e, n) {
        if (n.shapes = [], Array.isArray(t)) for (var r = 0, i = t.length; r < i; r++) {
          var a = t[r];n.shapes.push(a.uuid);
        } else n.shapes.push(t.uuid);void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());return n;
      }(this.parameters.shapes, this.parameters.options, e);
    }, e;
  }(yo);var hs = function (t) {
    function e(e, n) {
      var r,
          i = (1 + Math.sqrt(5)) / 2,
          a = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];return (r = t.call(this, a, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, n) || this).type = "IcosahedronBufferGeometry", r.parameters = { radius: e, detail: n }, r;
    }return ut(e, t), e;
  }(Eo),
      ds = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "IcosahedronGeometry", r.parameters = { radius: e, detail: n }, r.fromBufferGeometry(new hs(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e;
  }(yo),
      ps = function (t) {
    function e(e, n, r, i) {
      var a;(a = t.call(this) || this).type = "LatheBufferGeometry", a.parameters = { points: e, segments: n, phiStart: r, phiLength: i }, n = Math.floor(n) || 12, r = r || 0, i = i || 2 * Math.PI, i = st.clamp(i, 0, 2 * Math.PI);for (var o = [], s = [], c = [], l = 1 / n, u = new wt(), h = new pt(), d = 0; d <= n; d++) {
        for (var p = r + d * l * i, f = Math.sin(p), m = Math.cos(p), v = 0; v <= e.length - 1; v++) {
          u.x = e[v].x * f, u.y = e[v].y, u.z = e[v].x * m, s.push(u.x, u.y, u.z), h.x = d / n, h.y = v / (e.length - 1), c.push(h.x, h.y);
        }
      }for (var g = 0; g < n; g++) {
        for (var y = 0; y < e.length - 1; y++) {
          var x = y + g * e.length,
              _ = x,
              b = x + e.length,
              w = x + e.length + 1,
              M = x + 1;o.push(_, b, M), o.push(b, w, M);
        }
      }if (a.setIndex(o), a.setAttribute("position", new an(s, 3)), a.setAttribute("uv", new an(c, 2)), a.computeVertexNormals(), i === 2 * Math.PI) for (var S = a.attributes.normal.array, T = new wt(), E = new wt(), A = new wt(), L = n * e.length * 3, R = 0, C = 0; R < e.length; R++, C += 3) {
        T.x = S[C + 0], T.y = S[C + 1], T.z = S[C + 2], E.x = S[L + C + 0], E.y = S[L + C + 1], E.z = S[L + C + 2], A.addVectors(T, E).normalize(), S[C + 0] = S[L + C + 0] = A.x, S[C + 1] = S[L + C + 1] = A.y, S[C + 2] = S[L + C + 2] = A.z;
      }return a;
    }return ut(e, t), e;
  }(vn),
      fs = function (t) {
    function e(e, n, r, i) {
      var a;return (a = t.call(this) || this).type = "LatheGeometry", a.parameters = { points: e, segments: n, phiStart: r, phiLength: i }, a.fromBufferGeometry(new ps(e, n, r, i)), a.mergeVertices(), a;
    }return ut(e, t), e;
  }(yo),
      ms = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, n) || this).type = "OctahedronBufferGeometry", r.parameters = { radius: e, detail: n }, r;
    }return ut(e, t), e;
  }(Eo),
      vs = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "OctahedronGeometry", r.parameters = { radius: e, detail: n }, r.fromBufferGeometry(new ms(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e;
  }(yo);function gs(t, e, n) {
    vn.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: n };var r = [],
        i = [],
        a = [],
        o = [],
        s = 1e-5,
        c = new wt(),
        l = new wt(),
        u = new wt(),
        h = new wt(),
        d = new wt();t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");for (var p = e + 1, f = 0; f <= n; f++) {
      for (var m = f / n, v = 0; v <= e; v++) {
        var g = v / e;t(g, m, l), i.push(l.x, l.y, l.z), g - s >= 0 ? (t(g - s, m, u), h.subVectors(l, u)) : (t(g + s, m, u), h.subVectors(u, l)), m - s >= 0 ? (t(g, m - s, u), d.subVectors(l, u)) : (t(g, m + s, u), d.subVectors(u, l)), c.crossVectors(h, d).normalize(), a.push(c.x, c.y, c.z), o.push(g, m);
      }
    }for (var y = 0; y < n; y++) {
      for (var x = 0; x < e; x++) {
        var _ = y * p + x,
            b = y * p + x + 1,
            w = (y + 1) * p + x + 1,
            M = (y + 1) * p + x;r.push(_, b, M), r.push(b, w, M);
      }
    }this.setIndex(r), this.setAttribute("position", new an(i, 3)), this.setAttribute("normal", new an(a, 3)), this.setAttribute("uv", new an(o, 2));
  }function ys(t, e, n) {
    yo.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n }, this.fromBufferGeometry(new gs(t, e, n)), this.mergeVertices();
  }gs.prototype = Object.create(vn.prototype), gs.prototype.constructor = gs, ys.prototype = Object.create(yo.prototype), ys.prototype.constructor = ys;var xs = function (t) {
    function e(e, n, r, i) {
      var a;return (a = t.call(this) || this).type = "PlaneGeometry", a.parameters = { width: e, height: n, widthSegments: r, heightSegments: i }, a.fromBufferGeometry(new tr(e, n, r, i)), a.mergeVertices(), a;
    }return ut(e, t), e;
  }(yo),
      _s = function (t) {
    function e(e, n, r, i) {
      var a;return (a = t.call(this) || this).type = "PolyhedronGeometry", a.parameters = { vertices: e, indices: n, radius: r, detail: i }, a.fromBufferGeometry(new Eo(e, n, r, i)), a.mergeVertices(), a;
    }return ut(e, t), e;
  }(yo),
      bs = function (t) {
    function e(e, n, r, i, a, o) {
      var s;(s = t.call(this) || this).type = "RingBufferGeometry", s.parameters = { innerRadius: e, outerRadius: n, thetaSegments: r, phiSegments: i, thetaStart: a, thetaLength: o }, e = e || .5, n = n || 1, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI, r = void 0 !== r ? Math.max(3, r) : 8;for (var c = [], l = [], u = [], h = [], d = e, p = (n - e) / (i = void 0 !== i ? Math.max(1, i) : 1), f = new wt(), m = new pt(), v = 0; v <= i; v++) {
        for (var g = 0; g <= r; g++) {
          var y = a + g / r * o;f.x = d * Math.cos(y), f.y = d * Math.sin(y), l.push(f.x, f.y, f.z), u.push(0, 0, 1), m.x = (f.x / n + 1) / 2, m.y = (f.y / n + 1) / 2, h.push(m.x, m.y);
        }d += p;
      }for (var x = 0; x < i; x++) {
        for (var _ = x * (r + 1), b = 0; b < r; b++) {
          var w = b + _,
              M = w,
              S = w + r + 1,
              T = w + r + 2,
              E = w + 1;c.push(M, S, E), c.push(S, T, E);
        }
      }return s.setIndex(c), s.setAttribute("position", new an(l, 3)), s.setAttribute("normal", new an(u, 3)), s.setAttribute("uv", new an(h, 2)), s;
    }return ut(e, t), e;
  }(vn),
      ws = function (t) {
    function e(e, n, r, i, a, o) {
      var s;return (s = t.call(this) || this).type = "RingGeometry", s.parameters = { innerRadius: e, outerRadius: n, thetaSegments: r, phiSegments: i, thetaStart: a, thetaLength: o }, s.fromBufferGeometry(new bs(e, n, r, i, a, o)), s.mergeVertices(), s;
    }return ut(e, t), e;
  }(yo),
      Ms = function (t) {
    function e(e, n) {
      var r;(r = t.call(this) || this).type = "ShapeBufferGeometry", r.parameters = { shapes: e, curveSegments: n }, n = n || 12;var i = [],
          a = [],
          o = [],
          s = [],
          c = 0,
          l = 0;if (!1 === Array.isArray(e)) h(e);else for (var u = 0; u < e.length; u++) {
        h(e[u]), r.addGroup(c, l, u), c += l, l = 0;
      }function h(t) {
        var e = a.length / 3,
            r = t.extractPoints(n),
            c = r.shape,
            u = r.holes;!1 === as.isClockWise(c) && (c = c.reverse());for (var h = 0, d = u.length; h < d; h++) {
          var p = u[h];!0 === as.isClockWise(p) && (u[h] = p.reverse());
        }for (var f = as.triangulateShape(c, u), m = 0, v = u.length; m < v; m++) {
          var g = u[m];c = c.concat(g);
        }for (var y = 0, x = c.length; y < x; y++) {
          var _ = c[y];a.push(_.x, _.y, 0), o.push(0, 0, 1), s.push(_.x, _.y);
        }for (var b = 0, w = f.length; b < w; b++) {
          var M = f[b],
              S = M[0] + e,
              T = M[1] + e,
              E = M[2] + e;i.push(S, T, E), l += 3;
        }
      }return r.setIndex(i), r.setAttribute("position", new an(a, 3)), r.setAttribute("normal", new an(o, 3)), r.setAttribute("uv", new an(s, 2)), r;
    }return ut(e, t), e.prototype.toJSON = function () {
      var t = vn.prototype.toJSON.call(this);return function (t, e) {
        if (e.shapes = [], Array.isArray(t)) for (var n = 0, r = t.length; n < r; n++) {
          var i = t[n];e.shapes.push(i.uuid);
        } else e.shapes.push(t.uuid);return e;
      }(this.parameters.shapes, t);
    }, e;
  }(vn);var Ss = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "ShapeGeometry", "object" == (typeof n === "undefined" ? "undefined" : _typeof(n)) && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), n = n.curveSegments), r.parameters = { shapes: e, curveSegments: n }, r.fromBufferGeometry(new Ms(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e.prototype.toJSON = function () {
      var t = yo.prototype.toJSON.call(this);return function (t, e) {
        if (e.shapes = [], Array.isArray(t)) for (var n = 0, r = t.length; n < r; n++) {
          var i = t[n];e.shapes.push(i.uuid);
        } else e.shapes.push(t.uuid);return e;
      }(this.parameters.shapes, t);
    }, e;
  }(yo);var Ts = function (t) {
    function e(e, n, r, i, a, o, s) {
      var c;(c = t.call(this) || this).type = "SphereBufferGeometry", c.parameters = { radius: e, widthSegments: n, heightSegments: r, phiStart: i, phiLength: a, thetaStart: o, thetaLength: s }, e = e || 1, n = Math.max(3, Math.floor(n) || 8), r = Math.max(2, Math.floor(r) || 6), i = void 0 !== i ? i : 0, a = void 0 !== a ? a : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI;for (var l = Math.min(o + s, Math.PI), u = 0, h = [], d = new wt(), p = new wt(), f = [], m = [], v = [], g = [], y = 0; y <= r; y++) {
        var x = [],
            _ = y / r,
            b = 0;0 == y && 0 == o ? b = .5 / n : y == r && l == Math.PI && (b = -.5 / n);for (var w = 0; w <= n; w++) {
          var M = w / n;d.x = -e * Math.cos(i + M * a) * Math.sin(o + _ * s), d.y = e * Math.cos(o + _ * s), d.z = e * Math.sin(i + M * a) * Math.sin(o + _ * s), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), g.push(M + b, 1 - _), x.push(u++);
        }h.push(x);
      }for (var S = 0; S < r; S++) {
        for (var T = 0; T < n; T++) {
          var E = h[S][T + 1],
              A = h[S][T],
              L = h[S + 1][T],
              R = h[S + 1][T + 1];(0 !== S || o > 0) && f.push(E, A, R), (S !== r - 1 || l < Math.PI) && f.push(A, L, R);
        }
      }return c.setIndex(f), c.setAttribute("position", new an(m, 3)), c.setAttribute("normal", new an(v, 3)), c.setAttribute("uv", new an(g, 2)), c;
    }return ut(e, t), e;
  }(vn),
      Es = function (t) {
    function e(e, n, r, i, a, o, s) {
      var c;return (c = t.call(this) || this).type = "SphereGeometry", c.parameters = { radius: e, widthSegments: n, heightSegments: r, phiStart: i, phiLength: a, thetaStart: o, thetaLength: s }, c.fromBufferGeometry(new Ts(e, n, r, i, a, o, s)), c.mergeVertices(), c;
    }return ut(e, t), e;
  }(yo),
      As = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, n) || this).type = "TetrahedronBufferGeometry", r.parameters = { radius: e, detail: n }, r;
    }return ut(e, t), e;
  }(Eo),
      Ls = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "TetrahedronGeometry", r.parameters = { radius: e, detail: n }, r.fromBufferGeometry(new As(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e;
  }(yo),
      Rs = function (t) {
    function e(e, n) {
      var r,
          i = (n = n || {}).font;if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new vn() || ht(r);var a = i.generateShapes(e, n.size);return n.depth = void 0 !== n.height ? n.height : 50, void 0 === n.bevelThickness && (n.bevelThickness = 10), void 0 === n.bevelSize && (n.bevelSize = 8), void 0 === n.bevelEnabled && (n.bevelEnabled = !1), (r = t.call(this, a, n) || this).type = "TextBufferGeometry", r;
    }return ut(e, t), e;
  }(cs),
      Cs = function (t) {
    function e(e, n) {
      var r;return (r = t.call(this) || this).type = "TextGeometry", r.parameters = { text: e, parameters: n }, r.fromBufferGeometry(new Rs(e, n)), r.mergeVertices(), r;
    }return ut(e, t), e;
  }(yo),
      Ps = function (t) {
    function e(e, n, r, i, a) {
      var o;(o = t.call(this) || this).type = "TorusBufferGeometry", o.parameters = { radius: e, tube: n, radialSegments: r, tubularSegments: i, arc: a }, e = e || 1, n = n || .4, r = Math.floor(r) || 8, i = Math.floor(i) || 6, a = a || 2 * Math.PI;for (var s = [], c = [], l = [], u = [], h = new wt(), d = new wt(), p = new wt(), f = 0; f <= r; f++) {
        for (var m = 0; m <= i; m++) {
          var v = m / i * a,
              g = f / r * Math.PI * 2;d.x = (e + n * Math.cos(g)) * Math.cos(v), d.y = (e + n * Math.cos(g)) * Math.sin(v), d.z = n * Math.sin(g), c.push(d.x, d.y, d.z), h.x = e * Math.cos(v), h.y = e * Math.sin(v), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), u.push(m / i), u.push(f / r);
        }
      }for (var y = 1; y <= r; y++) {
        for (var x = 1; x <= i; x++) {
          var _ = (i + 1) * y + x - 1,
              b = (i + 1) * (y - 1) + x - 1,
              w = (i + 1) * (y - 1) + x,
              M = (i + 1) * y + x;s.push(_, b, M), s.push(b, w, M);
        }
      }return o.setIndex(s), o.setAttribute("position", new an(c, 3)), o.setAttribute("normal", new an(l, 3)), o.setAttribute("uv", new an(u, 2)), o;
    }return ut(e, t), e;
  }(vn),
      Is = function (t) {
    function e(e, n, r, i, a) {
      var o;return (o = t.call(this) || this).type = "TorusGeometry", o.parameters = { radius: e, tube: n, radialSegments: r, tubularSegments: i, arc: a }, o.fromBufferGeometry(new Ps(e, n, r, i, a)), o.mergeVertices(), o;
    }return ut(e, t), e;
  }(yo),
      Ds = function (t) {
    function e(e, n, r, i, a, o) {
      var s;(s = t.call(this) || this).type = "TorusKnotBufferGeometry", s.parameters = { radius: e, tube: n, tubularSegments: r, radialSegments: i, p: a, q: o }, e = e || 1, n = n || .4, r = Math.floor(r) || 64, i = Math.floor(i) || 8, a = a || 2, o = o || 3;for (var c = [], l = [], u = [], h = [], d = new wt(), p = new wt(), f = new wt(), m = new wt(), v = new wt(), g = new wt(), y = new wt(), x = 0; x <= r; ++x) {
        var _ = x / r * a * Math.PI * 2;P(_, a, o, e, f), P(_ + .01, a, o, e, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize();for (var b = 0; b <= i; ++b) {
          var w = b / i * Math.PI * 2,
              M = -n * Math.cos(w),
              S = n * Math.sin(w);d.x = f.x + (M * y.x + S * v.x), d.y = f.y + (M * y.y + S * v.y), d.z = f.z + (M * y.z + S * v.z), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), u.push(p.x, p.y, p.z), h.push(x / r), h.push(b / i);
        }
      }for (var T = 1; T <= r; T++) {
        for (var E = 1; E <= i; E++) {
          var A = (i + 1) * (T - 1) + (E - 1),
              L = (i + 1) * T + (E - 1),
              R = (i + 1) * T + E,
              C = (i + 1) * (T - 1) + E;c.push(A, L, C), c.push(L, R, C);
        }
      }function P(t, e, n, r, i) {
        var a = Math.cos(t),
            o = Math.sin(t),
            s = n / e * t,
            c = Math.cos(s);i.x = r * (2 + c) * .5 * a, i.y = r * (2 + c) * o * .5, i.z = r * Math.sin(s) * .5;
      }return s.setIndex(c), s.setAttribute("position", new an(l, 3)), s.setAttribute("normal", new an(u, 3)), s.setAttribute("uv", new an(h, 2)), s;
    }return ut(e, t), e;
  }(vn),
      Os = function (t) {
    function e(e, n, r, i, a, o, s) {
      var c;return (c = t.call(this) || this).type = "TorusKnotGeometry", c.parameters = { radius: e, tube: n, tubularSegments: r, radialSegments: i, p: a, q: o }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), c.fromBufferGeometry(new Ds(e, n, r, i, a, o)), c.mergeVertices(), c;
    }return ut(e, t), e;
  }(yo),
      Ns = function (t) {
    function e(e, n, r, i, a) {
      var o;(o = t.call(this) || this).type = "TubeBufferGeometry", o.parameters = { path: e, tubularSegments: n, radius: r, radialSegments: i, closed: a }, n = n || 64, r = r || 1, i = i || 8, a = a || !1;var s = e.computeFrenetFrames(n, a);o.tangents = s.tangents, o.normals = s.normals, o.binormals = s.binormals;var c = new wt(),
          l = new wt(),
          u = new pt(),
          h = new wt(),
          d = [],
          p = [],
          f = [],
          m = [];function v(t) {
        h = e.getPointAt(t / n, h);for (var a = s.normals[t], o = s.binormals[t], u = 0; u <= i; u++) {
          var f = u / i * Math.PI * 2,
              m = Math.sin(f),
              v = -Math.cos(f);l.x = v * a.x + m * o.x, l.y = v * a.y + m * o.y, l.z = v * a.z + m * o.z, l.normalize(), p.push(l.x, l.y, l.z), c.x = h.x + r * l.x, c.y = h.y + r * l.y, c.z = h.z + r * l.z, d.push(c.x, c.y, c.z);
        }
      }return function () {
        for (var t = 0; t < n; t++) {
          v(t);
        }v(!1 === a ? n : 0), function () {
          for (var t = 0; t <= n; t++) {
            for (var e = 0; e <= i; e++) {
              u.x = t / n, u.y = e / i, f.push(u.x, u.y);
            }
          }
        }(), function () {
          for (var t = 1; t <= n; t++) {
            for (var e = 1; e <= i; e++) {
              var r = (i + 1) * (t - 1) + (e - 1),
                  a = (i + 1) * t + (e - 1),
                  o = (i + 1) * t + e,
                  s = (i + 1) * (t - 1) + e;m.push(r, a, s), m.push(a, o, s);
            }
          }
        }();
      }(), o.setIndex(m), o.setAttribute("position", new an(d, 3)), o.setAttribute("normal", new an(p, 3)), o.setAttribute("uv", new an(f, 2)), o;
    }return ut(e, t), e.prototype.toJSON = function () {
      var t = vn.prototype.toJSON.call(this);return t.path = this.parameters.path.toJSON(), t;
    }, e;
  }(vn),
      Bs = function (t) {
    function e(e, n, r, i, a, o) {
      var s;(s = t.call(this) || this).type = "TubeGeometry", s.parameters = { path: e, tubularSegments: n, radius: r, radialSegments: i, closed: a }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");var c = new Ns(e, n, r, i, a);return s.tangents = c.tangents, s.normals = c.normals, s.binormals = c.binormals, s.fromBufferGeometry(c), s.mergeVertices(), s;
    }return ut(e, t), e;
  }(yo),
      zs = function (t) {
    function e(e) {
      var n;(n = t.call(this) || this).type = "WireframeGeometry";var r = [],
          i = [0, 0],
          a = {},
          o = ["a", "b", "c"];if (e && e.isGeometry) {
        for (var s = e.faces, c = 0, l = s.length; c < l; c++) {
          for (var u = s[c], h = 0; h < 3; h++) {
            var d = u[o[h]],
                p = u[o[(h + 1) % 3]];i[0] = Math.min(d, p), i[1] = Math.max(d, p);var f = i[0] + "," + i[1];void 0 === a[f] && (a[f] = { index1: i[0], index2: i[1] });
          }
        }for (var m in a) {
          var v = a[m],
              g = e.vertices[v.index1];r.push(g.x, g.y, g.z), g = e.vertices[v.index2], r.push(g.x, g.y, g.z);
        }
      } else if (e && e.isBufferGeometry) {
        var y = new wt();if (null !== e.index) {
          var x = e.attributes.position,
              _ = e.index,
              b = e.groups;0 === b.length && (b = [{ start: 0, count: _.count, materialIndex: 0 }]);for (var w = 0, M = b.length; w < M; ++w) {
            for (var S = b[w], T = S.start, E = T, A = T + S.count; E < A; E += 3) {
              for (var L = 0; L < 3; L++) {
                var R = _.getX(E + L),
                    C = _.getX(E + (L + 1) % 3);i[0] = Math.min(R, C), i[1] = Math.max(R, C);var P = i[0] + "," + i[1];void 0 === a[P] && (a[P] = { index1: i[0], index2: i[1] });
              }
            }
          }for (var I in a) {
            var D = a[I];y.fromBufferAttribute(x, D.index1), r.push(y.x, y.y, y.z), y.fromBufferAttribute(x, D.index2), r.push(y.x, y.y, y.z);
          }
        } else for (var O = e.attributes.position, N = 0, B = O.count / 3; N < B; N++) {
          for (var z = 0; z < 3; z++) {
            var G = 3 * N + z;y.fromBufferAttribute(O, G), r.push(y.x, y.y, y.z);var F = 3 * N + (z + 1) % 3;y.fromBufferAttribute(O, F), r.push(y.x, y.y, y.z);
          }
        }
      }return n.setAttribute("position", new an(r, 3)), n;
    }return ut(e, t), e;
  }(vn),
      Gs = Object.freeze({ __proto__: null, BoxGeometry: xo, BoxBufferGeometry: zn, CircleGeometry: bo, CircleBufferGeometry: _o, ConeGeometry: So, ConeBufferGeometry: To, CylinderGeometry: Mo, CylinderBufferGeometry: wo, DodecahedronGeometry: Lo, DodecahedronBufferGeometry: Ao, EdgesGeometry: Do, ExtrudeGeometry: us, ExtrudeBufferGeometry: cs, IcosahedronGeometry: ds, IcosahedronBufferGeometry: hs, LatheGeometry: fs, LatheBufferGeometry: ps, OctahedronGeometry: vs, OctahedronBufferGeometry: ms, ParametricGeometry: ys, ParametricBufferGeometry: gs, PlaneGeometry: xs, PlaneBufferGeometry: tr, PolyhedronGeometry: _s, PolyhedronBufferGeometry: Eo, RingGeometry: ws, RingBufferGeometry: bs, ShapeGeometry: Ss, ShapeBufferGeometry: Ms, SphereGeometry: Es, SphereBufferGeometry: Ts, TetrahedronGeometry: Ls, TetrahedronBufferGeometry: As, TextGeometry: Cs, TextBufferGeometry: Rs, TorusGeometry: Is, TorusBufferGeometry: Ps, TorusKnotGeometry: Os, TorusKnotBufferGeometry: Ds, TubeGeometry: Bs, TubeBufferGeometry: Ns, WireframeGeometry: zs });function Fs(t) {
    qe.call(this), this.type = "ShadowMaterial", this.color = new Ve(0), this.transparent = !0, this.setValues(t);
  }function Us(t) {
    Hn.call(this, t), this.type = "RawShaderMaterial";
  }function Hs(t) {
    qe.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ve(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t);
  }function ks(t) {
    Hs.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new pt(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function get() {
        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity);
      }, set: function set(t) {
        this.reflectivity = st.clamp(2.5 * (t - 1) / (t + 1), 0, 1);
      } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t);
  }function Vs(t) {
    qe.call(this), this.type = "MeshPhongMaterial", this.color = new Ve(16777215), this.specular = new Ve(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
  }function Ws(t) {
    qe.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ve(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
  }function js(t) {
    qe.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
  }function qs(t) {
    qe.call(this), this.type = "MeshLambertMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
  }function Xs(t) {
    qe.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ve(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
  }function Ys(t) {
    ja.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
  }Fs.prototype = Object.create(qe.prototype), Fs.prototype.constructor = Fs, Fs.prototype.isShadowMaterial = !0, Fs.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this;
  }, Us.prototype = Object.create(Hn.prototype), Us.prototype.constructor = Us, Us.prototype.isRawShaderMaterial = !0, Hs.prototype = Object.create(qe.prototype), Hs.prototype.constructor = Hs, Hs.prototype.isMeshStandardMaterial = !0, Hs.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this;
  }, ks.prototype = Object.create(Hs.prototype), ks.prototype.constructor = ks, ks.prototype.isMeshPhysicalMaterial = !0, ks.prototype.copy = function (t) {
    return Hs.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Ve()).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this;
  }, Vs.prototype = Object.create(qe.prototype), Vs.prototype.constructor = Vs, Vs.prototype.isMeshPhongMaterial = !0, Vs.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Ws.prototype = Object.create(qe.prototype), Ws.prototype.constructor = Ws, Ws.prototype.isMeshToonMaterial = !0, Ws.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, js.prototype = Object.create(qe.prototype), js.prototype.constructor = js, js.prototype.isMeshNormalMaterial = !0, js.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, qs.prototype = Object.create(qe.prototype), qs.prototype.constructor = qs, qs.prototype.isMeshLambertMaterial = !0, qs.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Xs.prototype = Object.create(qe.prototype), Xs.prototype.constructor = Xs, Xs.prototype.isMeshMatcapMaterial = !0, Xs.prototype.copy = function (t) {
    return qe.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
  }, Ys.prototype = Object.create(ja.prototype), Ys.prototype.constructor = Ys, Ys.prototype.isLineDashedMaterial = !0, Ys.prototype.copy = function (t) {
    return ja.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
  };var Zs = Object.freeze({ __proto__: null, ShadowMaterial: Fs, SpriteMaterial: da, RawShaderMaterial: Us, ShaderMaterial: Hn, PointsMaterial: no, MeshPhysicalMaterial: ks, MeshStandardMaterial: Hs, MeshPhongMaterial: Vs, MeshToonMaterial: Ws, MeshNormalMaterial: js, MeshLambertMaterial: qs, MeshDepthMaterial: qi, MeshDistanceMaterial: Xi, MeshBasicMaterial: Xe, MeshMatcapMaterial: Xs, LineDashedMaterial: Ys, LineBasicMaterial: ja, Material: qe }),
      Js = { arraySlice: function arraySlice(t, e, n) {
      return Js.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n);
    }, convertArray: function convertArray(t, e, n) {
      return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
    }, isTypedArray: function isTypedArray(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }, getKeyframeOrder: function getKeyframeOrder(t) {
      for (var e = t.length, n = new Array(e), r = 0; r !== e; ++r) {
        n[r] = r;
      }return n.sort(function (e, n) {
        return t[e] - t[n];
      }), n;
    }, sortedArray: function sortedArray(t, e, n) {
      for (var r = t.length, i = new t.constructor(r), a = 0, o = 0; o !== r; ++a) {
        for (var s = n[a] * e, c = 0; c !== e; ++c) {
          i[o++] = t[s + c];
        }
      }return i;
    }, flattenJSON: function flattenJSON(t, e, n, r) {
      for (var i = 1, a = t[0]; void 0 !== a && void 0 === a[r];) {
        a = t[i++];
      }if (void 0 !== a) {
        var o = a[r];if (void 0 !== o) if (Array.isArray(o)) do {
          void 0 !== (o = a[r]) && (e.push(a.time), n.push.apply(n, o)), a = t[i++];
        } while (void 0 !== a);else if (void 0 !== o.toArray) do {
          void 0 !== (o = a[r]) && (e.push(a.time), o.toArray(n, n.length)), a = t[i++];
        } while (void 0 !== a);else do {
          void 0 !== (o = a[r]) && (e.push(a.time), n.push(o)), a = t[i++];
        } while (void 0 !== a);
      }
    }, subclip: function subclip(t, e, n, r, i) {
      i = i || 30;var a = t.clone();a.name = e;for (var o = [], s = 0; s < a.tracks.length; ++s) {
        for (var c = a.tracks[s], l = c.getValueSize(), u = [], h = [], d = 0; d < c.times.length; ++d) {
          var p = c.times[d] * i;if (!(p < n || p >= r)) {
            u.push(c.times[d]);for (var f = 0; f < l; ++f) {
              h.push(c.values[d * l + f]);
            }
          }
        }0 !== u.length && (c.times = Js.convertArray(u, c.times.constructor), c.values = Js.convertArray(h, c.values.constructor), o.push(c));
      }a.tracks = o;for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v) {
        m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
      }for (var g = 0; g < a.tracks.length; ++g) {
        a.tracks[g].shift(-1 * m);
      }return a.resetDuration(), a;
    }, makeClipAdditive: function makeClipAdditive(t, e, n, r) {
      void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === r || r <= 0) && (r = 30);for (var i = n.tracks.length, a = e / r, o = function o(e) {
        var r = n.tracks[e],
            i = r.ValueTypeName;if ("bool" === i || "string" === i) return "continue";var o = t.tracks.find(function (t) {
          return t.name === r.name && t.ValueTypeName === i;
        });if (void 0 === o) return "continue";var s = 0,
            c = r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = c / 3);var l = 0,
            u = o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3);var h = r.times.length - 1,
            d = void 0;if (a <= r.times[0]) {
          var p = s,
              f = c - s;d = Js.arraySlice(r.values, p, f);
        } else if (a >= r.times[h]) {
          var m = h * c + s,
              v = m + c - s;d = Js.arraySlice(r.values, m, v);
        } else {
          var g = r.createInterpolant(),
              y = s,
              x = c - s;g.evaluate(a), d = Js.arraySlice(g.resultBuffer, y, x);
        }"quaternion" === i && new bt().fromArray(d).normalize().conjugate().toArray(d);for (var _ = o.times.length, b = 0; b < _; ++b) {
          var w = b * u + l;if ("quaternion" === i) bt.multiplyQuaternionsFlat(o.values, w, d, 0, o.values, w);else for (var M = u - 2 * l, S = 0; S < M; ++S) {
            o.values[w + S] -= d[S];
          }
        }
      }, s = 0; s < i; ++s) {
        o(s);
      }return t.blendMode = j, t;
    } };function Qs(t, e, n, r) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n;
  }function Ks(t, e, n, r) {
    Qs.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
  }function $s(t, e, n, r) {
    Qs.call(this, t, e, n, r);
  }function tc(t, e, n, r) {
    Qs.call(this, t, e, n, r);
  }function ec(t, e, n, r) {
    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);this.name = t, this.times = Js.convertArray(e, this.TimeBufferType), this.values = Js.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }function nc(t, e, n) {
    ec.call(this, t, e, n);
  }function rc(t, e, n, r) {
    ec.call(this, t, e, n, r);
  }function ic(t, e, n, r) {
    ec.call(this, t, e, n, r);
  }function ac(t, e, n, r) {
    Qs.call(this, t, e, n, r);
  }function oc(t, e, n, r) {
    ec.call(this, t, e, n, r);
  }function sc(t, e, n, r) {
    ec.call(this, t, e, n, r);
  }function cc(t, e, n, r) {
    ec.call(this, t, e, n, r);
  }function lc(t, e, n, r) {
    this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== r ? r : W, this.uuid = st.generateUUID(), this.duration < 0 && this.resetDuration();
  }function uc(t) {
    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");var e = function (t) {
      switch (t.toLowerCase()) {case "scalar":case "double":case "float":case "number":case "integer":
          return ic;case "vector":case "vector2":case "vector3":case "vector4":
          return cc;case "color":
          return rc;case "quaternion":
          return oc;case "bool":case "boolean":
          return nc;case "string":
          return sc;}throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
    }(t.type);if (void 0 === t.times) {
      var n = [],
          r = [];Js.flattenJSON(t.keys, n, r, "value"), t.times = n, t.values = r;
    }return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
  }_extends(Qs.prototype, { evaluate: function evaluate(t) {
      var e = this.parameterPositions,
          n = this._cachedIndex,
          r = e[n],
          i = e[n - 1];t: {
        e: {
          var a;n: {
            r: if (!(t < r)) {
              for (var o = n + 2;;) {
                if (void 0 === r) {
                  if (t < i) break r;return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i);
                }if (n === o) break;if (i = r, t < (r = e[++n])) break e;
              }a = e.length;break n;
            }if (t >= i) break t;var s = e[1];t < s && (n = 2, i = s);for (var c = n - 2;;) {
              if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);if (n === c) break;if (r = i, t >= (i = e[--n - 1])) break e;
            }a = n, n = 0;
          }for (; n < a;) {
            var l = n + a >>> 1;t < e[l] ? a = l : n = l + 1;
          }if (r = e[n], void 0 === (i = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r);if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t);
        }this._cachedIndex = n, this.intervalChanged_(n, i, r);
      }return this.interpolate_(n, i, t, r);
    }, settings: null, DefaultSettings_: {}, getSettings_: function getSettings_() {
      return this.settings || this.DefaultSettings_;
    }, copySampleValue_: function copySampleValue_(t) {
      for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r, a = 0; a !== r; ++a) {
        e[a] = n[i + a];
      }return e;
    }, interpolate_: function interpolate_() {
      throw new Error("call to abstract method");
    }, intervalChanged_: function intervalChanged_() {} }), _extends(Qs.prototype, { beforeStart_: Qs.prototype.copySampleValue_, afterEnd_: Qs.prototype.copySampleValue_ }), Ks.prototype = _extends(Object.create(Qs.prototype), { constructor: Ks, DefaultSettings_: { endingStart: H, endingEnd: H }, intervalChanged_: function intervalChanged_(t, e, n) {
      var r = this.parameterPositions,
          i = t - 2,
          a = t + 1,
          o = r[i],
          s = r[a];if (void 0 === o) switch (this.getSettings_().endingStart) {case k:
          i = t, o = 2 * e - n;break;case V:
          o = e + r[i = r.length - 2] - r[i + 1];break;default:
          i = t, o = n;}if (void 0 === s) switch (this.getSettings_().endingEnd) {case k:
          a = t, s = 2 * n - e;break;case V:
          a = 1, s = n + r[1] - r[0];break;default:
          a = t - 1, s = e;}var c = .5 * (n - e),
          l = this.valueSize;this._weightPrev = c / (e - o), this._weightNext = c / (s - n), this._offsetPrev = i * l, this._offsetNext = a * l;
    }, interpolate_: function interpolate_(t, e, n, r) {
      for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - e) / (r - e), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, _ = 0; _ !== o; ++_) {
        i[_] = v * a[l + _] + g * a[c + _] + y * a[s + _] + x * a[u + _];
      }return i;
    } }), $s.prototype = _extends(Object.create(Qs.prototype), { constructor: $s, interpolate_: function interpolate_(t, e, n, r) {
      for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, l = (n - e) / (r - e), u = 1 - l, h = 0; h !== o; ++h) {
        i[h] = a[c + h] * u + a[s + h] * l;
      }return i;
    } }), tc.prototype = _extends(Object.create(Qs.prototype), { constructor: tc, interpolate_: function interpolate_(t) {
      return this.copySampleValue_(t - 1);
    } }), _extends(ec, { toJSON: function toJSON(t) {
      var e,
          n = t.constructor;if (void 0 !== n.toJSON) e = n.toJSON(t);else {
        e = { name: t.name, times: Js.convertArray(t.times, Array), values: Js.convertArray(t.values, Array) };var r = t.getInterpolation();r !== t.DefaultInterpolation && (e.interpolation = r);
      }return e.type = t.ValueTypeName, e;
    } }), _extends(ec.prototype, { constructor: ec, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: F, InterpolantFactoryMethodDiscrete: function InterpolantFactoryMethodDiscrete(t) {
      return new tc(this.times, this.values, this.getValueSize(), t);
    }, InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(t) {
      return new $s(this.times, this.values, this.getValueSize(), t);
    }, InterpolantFactoryMethodSmooth: function InterpolantFactoryMethodSmooth(t) {
      return new Ks(this.times, this.values, this.getValueSize(), t);
    }, setInterpolation: function setInterpolation(t) {
      var e;switch (t) {case G:
          e = this.InterpolantFactoryMethodDiscrete;break;case F:
          e = this.InterpolantFactoryMethodLinear;break;case U:
          e = this.InterpolantFactoryMethodSmooth;}if (void 0 === e) {
        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(n);this.setInterpolation(this.DefaultInterpolation);
        }return console.warn("THREE.KeyframeTrack:", n), this;
      }return this.createInterpolant = e, this;
    }, getInterpolation: function getInterpolation() {
      switch (this.createInterpolant) {case this.InterpolantFactoryMethodDiscrete:
          return G;case this.InterpolantFactoryMethodLinear:
          return F;case this.InterpolantFactoryMethodSmooth:
          return U;}
    }, getValueSize: function getValueSize() {
      return this.values.length / this.times.length;
    }, shift: function shift(t) {
      if (0 !== t) for (var e = this.times, n = 0, r = e.length; n !== r; ++n) {
        e[n] += t;
      }return this;
    }, scale: function scale(t) {
      if (1 !== t) for (var e = this.times, n = 0, r = e.length; n !== r; ++n) {
        e[n] *= t;
      }return this;
    }, trim: function trim(t, e) {
      for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < t;) {
        ++i;
      }for (; -1 !== a && n[a] > e;) {
        --a;
      }if (++a, 0 !== i || a !== r) {
        i >= a && (i = (a = Math.max(a, 1)) - 1);var o = this.getValueSize();this.times = Js.arraySlice(n, i, a), this.values = Js.arraySlice(this.values, i * o, a * o);
      }return this;
    }, validate: function validate() {
      var t = !0,
          e = this.getValueSize();e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);var n = this.times,
          r = this.values,
          i = n.length;0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);for (var a = null, o = 0; o !== i; o++) {
        var s = n[o];if ("number" == typeof s && isNaN(s)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), t = !1;break;
        }if (null !== a && a > s) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), t = !1;break;
        }a = s;
      }if (void 0 !== r && Js.isTypedArray(r)) for (var c = 0, l = r.length; c !== l; ++c) {
        var u = r[c];if (isNaN(u)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, c, u), t = !1;break;
        }
      }return t;
    }, optimize: function optimize() {
      for (var t = Js.arraySlice(this.times), e = Js.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === U, i = t.length - 1, a = 1, o = 1; o < i; ++o) {
        var s = !1,
            c = t[o];if (c !== t[o + 1] && (1 !== o || c !== c[0])) if (r) s = !0;else for (var l = o * n, u = l - n, h = l + n, d = 0; d !== n; ++d) {
          var p = e[l + d];if (p !== e[u + d] || p !== e[h + d]) {
            s = !0;break;
          }
        }if (s) {
          if (o !== a) {
            t[a] = t[o];for (var f = o * n, m = a * n, v = 0; v !== n; ++v) {
              e[m + v] = e[f + v];
            }
          }++a;
        }
      }if (i > 0) {
        t[a] = t[i];for (var g = i * n, y = a * n, x = 0; x !== n; ++x) {
          e[y + x] = e[g + x];
        }++a;
      }return a !== t.length ? (this.times = Js.arraySlice(t, 0, a), this.values = Js.arraySlice(e, 0, a * n)) : (this.times = t, this.values = e), this;
    }, clone: function clone() {
      var t = Js.arraySlice(this.times, 0),
          e = Js.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, t, e);return n.createInterpolant = this.createInterpolant, n;
    } }), nc.prototype = _extends(Object.create(ec.prototype), { constructor: nc, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: G, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), rc.prototype = _extends(Object.create(ec.prototype), { constructor: rc, ValueTypeName: "color" }), ic.prototype = _extends(Object.create(ec.prototype), { constructor: ic, ValueTypeName: "number" }), ac.prototype = _extends(Object.create(Qs.prototype), { constructor: ac, interpolate_: function interpolate_(t, e, n, r) {
      for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - e) / (r - e), c = t * o, l = c + o; c !== l; c += 4) {
        bt.slerpFlat(i, 0, a, c - o, a, c, s);
      }return i;
    } }), oc.prototype = _extends(Object.create(ec.prototype), { constructor: oc, ValueTypeName: "quaternion", DefaultInterpolation: F, InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(t) {
      return new ac(this.times, this.values, this.getValueSize(), t);
    }, InterpolantFactoryMethodSmooth: void 0 }), sc.prototype = _extends(Object.create(ec.prototype), { constructor: sc, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: G, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), cc.prototype = _extends(Object.create(ec.prototype), { constructor: cc, ValueTypeName: "vector" }), _extends(lc, { parse: function parse(t) {
      for (var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, a = n.length; i !== a; ++i) {
        e.push(uc(n[i]).scale(r));
      }return new lc(t.name, t.duration, e, t.blendMode);
    }, toJSON: function toJSON(t) {
      for (var e = [], n = t.tracks, r = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }, i = 0, a = n.length; i !== a; ++i) {
        e.push(ec.toJSON(n[i]));
      }return r;
    }, CreateFromMorphTargetSequence: function CreateFromMorphTargetSequence(t, e, n, r) {
      for (var i = e.length, a = [], o = 0; o < i; o++) {
        var s = [],
            c = [];s.push((o + i - 1) % i, o, (o + 1) % i), c.push(0, 1, 0);var l = Js.getKeyframeOrder(s);s = Js.sortedArray(s, 1, l), c = Js.sortedArray(c, 1, l), r || 0 !== s[0] || (s.push(i), c.push(c[0])), a.push(new ic(".morphTargetInfluences[" + e[o].name + "]", s, c).scale(1 / n));
      }return new lc(t, -1, a);
    }, findByName: function findByName(t, e) {
      var n = t;if (!Array.isArray(t)) {
        var r = t;n = r.geometry && r.geometry.animations || r.animations;
      }for (var i = 0; i < n.length; i++) {
        if (n[i].name === e) return n[i];
      }return null;
    }, CreateClipsFromMorphTargetSequences: function CreateClipsFromMorphTargetSequences(t, e, n) {
      for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
        var s = t[a],
            c = s.name.match(i);if (c && c.length > 1) {
          var l = c[1],
              u = r[l];u || (r[l] = u = []), u.push(s);
        }
      }var h = [];for (var d in r) {
        h.push(lc.CreateFromMorphTargetSequence(d, r[d], e, n));
      }return h;
    }, parseAnimation: function parseAnimation(t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;for (var n = function n(t, e, _n2, r, i) {
        if (0 !== _n2.length) {
          var a = [],
              o = [];Js.flattenJSON(_n2, a, o, r), 0 !== a.length && i.push(new t(e, a, o));
        }
      }, r = [], i = t.name || "default", a = t.fps || 30, o = t.blendMode, s = t.length || -1, c = t.hierarchy || [], l = 0; l < c.length; l++) {
        var u = c[l].keys;if (u && 0 !== u.length) if (u[0].morphTargets) {
          var h = {},
              d = void 0;for (d = 0; d < u.length; d++) {
            if (u[d].morphTargets) for (var p = 0; p < u[d].morphTargets.length; p++) {
              h[u[d].morphTargets[p]] = -1;
            }
          }for (var f in h) {
            for (var m = [], v = [], g = 0; g !== u[d].morphTargets.length; ++g) {
              var y = u[d];m.push(y.time), v.push(y.morphTarget === f ? 1 : 0);
            }r.push(new ic(".morphTargetInfluence[" + f + "]", m, v));
          }s = h.length * (a || 1);
        } else {
          var x = ".bones[" + e[l].name + "]";n(cc, x + ".position", u, "pos", r), n(oc, x + ".quaternion", u, "rot", r), n(cc, x + ".scale", u, "scl", r);
        }
      }return 0 === r.length ? null : new lc(i, s, r, o);
    } }), _extends(lc.prototype, { resetDuration: function resetDuration() {
      for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
        var r = this.tracks[e];t = Math.max(t, r.times[r.times.length - 1]);
      }return this.duration = t, this;
    }, trim: function trim() {
      for (var t = 0; t < this.tracks.length; t++) {
        this.tracks[t].trim(0, this.duration);
      }return this;
    }, validate: function validate() {
      for (var t = !0, e = 0; e < this.tracks.length; e++) {
        t = t && this.tracks[e].validate();
      }return t;
    }, optimize: function optimize() {
      for (var t = 0; t < this.tracks.length; t++) {
        this.tracks[t].optimize();
      }return this;
    }, clone: function clone() {
      for (var t = [], e = 0; e < this.tracks.length; e++) {
        t.push(this.tracks[e].clone());
      }return new lc(this.name, this.duration, t, this.blendMode);
    } });var hc = { enabled: !1, files: {}, add: function add(t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    }, get: function get(t) {
      if (!1 !== this.enabled) return this.files[t];
    }, remove: function remove(t) {
      delete this.files[t];
    }, clear: function clear() {
      this.files = {};
    } };function dc(t, e, n) {
    var r = this,
        i = !1,
        a = 0,
        o = 0,
        s = void 0,
        c = [];this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
      o++, !1 === i && void 0 !== r.onStart && r.onStart(t, a, o), i = !0;
    }, this.itemEnd = function (t) {
      a++, void 0 !== r.onProgress && r.onProgress(t, a, o), a === o && (i = !1, void 0 !== r.onLoad && r.onLoad());
    }, this.itemError = function (t) {
      void 0 !== r.onError && r.onError(t);
    }, this.resolveURL = function (t) {
      return s ? s(t) : t;
    }, this.setURLModifier = function (t) {
      return s = t, this;
    }, this.addHandler = function (t, e) {
      return c.push(t, e), this;
    }, this.removeHandler = function (t) {
      var e = c.indexOf(t);return -1 !== e && c.splice(e, 2), this;
    }, this.getHandler = function (t) {
      for (var e = 0, n = c.length; e < n; e += 2) {
        var r = c[e],
            i = c[e + 1];if (r.global && (r.lastIndex = 0), r.test(t)) return i;
      }return null;
    };
  }var pc = new dc();function fc(t) {
    this.manager = void 0 !== t ? t : pc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }_extends(fc.prototype, { load: function load() {}, loadAsync: function loadAsync(t, e) {
      var n = this;return new Promise(function (r, i) {
        n.load(t, r, e, i);
      });
    }, parse: function parse() {}, setCrossOrigin: function setCrossOrigin(t) {
      return this.crossOrigin = t, this;
    }, setWithCredentials: function setWithCredentials(t) {
      return this.withCredentials = t, this;
    }, setPath: function setPath(t) {
      return this.path = t, this;
    }, setResourcePath: function setResourcePath(t) {
      return this.resourcePath = t, this;
    }, setRequestHeader: function setRequestHeader(t) {
      return this.requestHeader = t, this;
    } });var mc = {};function vc(t) {
    fc.call(this, t);
  }function gc(t) {
    fc.call(this, t);
  }function yc(t) {
    fc.call(this, t);
  }function xc(t) {
    fc.call(this, t);
  }function _c(t) {
    fc.call(this, t);
  }function bc(t) {
    fc.call(this, t);
  }function wc(t) {
    fc.call(this, t);
  }function Mc() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }function Sc(t, e, n, r, i, a, o, s) {
    Mc.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0;
  }function Tc(t, e, n, r, i, a) {
    Sc.call(this, t, e, n, n, r, i, a), this.type = "ArcCurve";
  }function Ec() {
    var t = 0,
        e = 0,
        n = 0,
        r = 0;function i(i, a, o, s) {
      t = i, e = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s;
    }return { initCatmullRom: function initCatmullRom(t, e, n, r, a) {
        i(e, n, a * (n - t), a * (r - e));
      }, initNonuniformCatmullRom: function initNonuniformCatmullRom(t, e, n, r, a, o, s) {
        var c = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
            l = (n - e) / o - (r - e) / (o + s) + (r - n) / s;i(e, n, c *= o, l *= o);
      }, calc: function calc(i) {
        var a = i * i;return t + e * i + n * a + r * (a * i);
      } };
  }vc.prototype = _extends(Object.create(fc.prototype), { constructor: vc, load: function load(t, e, n, r) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);var i = this,
          a = hc.get(t);if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
        e && e(a), i.manager.itemEnd(t);
      }, 0), a;if (void 0 === mc[t]) {
        var o,
            s = t.match(/^data:(.*?)(;base64)?,(.*)$/);if (s) {
          var c = s[1],
              l = !!s[2],
              u = s[3];u = decodeURIComponent(u), l && (u = atob(u));try {
            var h,
                d = (this.responseType || "").toLowerCase();switch (d) {case "arraybuffer":case "blob":
                for (var p = new Uint8Array(u.length), f = 0; f < u.length; f++) {
                  p[f] = u.charCodeAt(f);
                }h = "blob" === d ? new Blob([p.buffer], { type: c }) : p.buffer;break;case "document":
                var m = new DOMParser();h = m.parseFromString(u, c);break;case "json":
                h = JSON.parse(u);break;default:
                h = u;}setTimeout(function () {
              e && e(h), i.manager.itemEnd(t);
            }, 0);
          } catch (e) {
            setTimeout(function () {
              r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
            }, 0);
          }
        } else {
          for (var v in mc[t] = [], mc[t].push({ onLoad: e, onProgress: n, onError: r }), (o = new XMLHttpRequest()).open("GET", t, !0), o.addEventListener("load", function (e) {
            var n = this.response,
                r = mc[t];if (delete mc[t], 200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), hc.add(t, n);for (var a = 0, o = r.length; a < o; a++) {
                var s = r[a];s.onLoad && s.onLoad(n);
              }i.manager.itemEnd(t);
            } else {
              for (var c = 0, l = r.length; c < l; c++) {
                var u = r[c];u.onError && u.onError(e);
              }i.manager.itemError(t), i.manager.itemEnd(t);
            }
          }, !1), o.addEventListener("progress", function (e) {
            for (var n = mc[t], r = 0, i = n.length; r < i; r++) {
              var a = n[r];a.onProgress && a.onProgress(e);
            }
          }, !1), o.addEventListener("error", function (e) {
            var n = mc[t];delete mc[t];for (var r = 0, a = n.length; r < a; r++) {
              var o = n[r];o.onError && o.onError(e);
            }i.manager.itemError(t), i.manager.itemEnd(t);
          }, !1), o.addEventListener("abort", function (e) {
            var n = mc[t];delete mc[t];for (var r = 0, a = n.length; r < a; r++) {
              var o = n[r];o.onError && o.onError(e);
            }i.manager.itemError(t), i.manager.itemEnd(t);
          }, !1), void 0 !== this.responseType && (o.responseType = this.responseType), void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials), o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) {
            o.setRequestHeader(v, this.requestHeader[v]);
          }o.send(null);
        }return i.manager.itemStart(t), o;
      }mc[t].push({ onLoad: e, onProgress: n, onError: r });
    }, setResponseType: function setResponseType(t) {
      return this.responseType = t, this;
    }, setMimeType: function setMimeType(t) {
      return this.mimeType = t, this;
    } }), gc.prototype = _extends(Object.create(fc.prototype), { constructor: gc, load: function load(t, e, n, r) {
      var i = this,
          a = new vc(i.manager);a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (n) {
        try {
          e(i.parse(JSON.parse(n)));
        } catch (e) {
          r ? r(e) : console.error(e), i.manager.itemError(t);
        }
      }, n, r);
    }, parse: function parse(t) {
      for (var e = [], n = 0; n < t.length; n++) {
        var r = lc.parse(t[n]);e.push(r);
      }return e;
    } }), yc.prototype = _extends(Object.create(fc.prototype), { constructor: yc, load: function load(t, e, n, r) {
      var i = this,
          a = [],
          o = new uo();o.image = a;var s = new vc(this.manager);s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials);var c = 0;function l(l) {
        s.load(t[l], function (t) {
          var n = i.parse(t, !0);a[l] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (c += 1) && (1 === n.mipmapCount && (o.minFilter = m), o.format = n.format, o.needsUpdate = !0, e && e(o));
        }, n, r);
      }if (Array.isArray(t)) for (var u = 0, h = t.length; u < h; ++u) {
        l(u);
      } else s.load(t, function (t) {
        var n = i.parse(t, !0);if (n.isCubemap) for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) {
          a[s] = { mipmaps: [] };for (var c = 0; c < n.mipmapCount; c++) {
            a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), a[s].format = n.format, a[s].width = n.width, a[s].height = n.height;
          }
        } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;1 === n.mipmapCount && (o.minFilter = m), o.format = n.format, o.needsUpdate = !0, e && e(o);
      }, n, r);return o;
    } }), xc.prototype = _extends(Object.create(fc.prototype), { constructor: xc, load: function load(t, e, n, r) {
      void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);var i = this,
          a = hc.get(t);if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
        e && e(a), i.manager.itemEnd(t);
      }, 0), a;var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");function s() {
        o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1), hc.add(t, this), e && e(this), i.manager.itemEnd(t);
      }function c(e) {
        o.removeEventListener("load", s, !1), o.removeEventListener("error", c, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
      }return o.addEventListener("load", s, !1), o.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o;
    } }), _c.prototype = _extends(Object.create(fc.prototype), { constructor: _c, load: function load(t, e, n, r) {
      var i = new qn(),
          a = new xc(this.manager);a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);var o = 0;function s(n) {
        a.load(t[n], function (t) {
          i.images[n] = t, 6 === ++o && (i.needsUpdate = !0, e && e(i));
        }, void 0, r);
      }for (var c = 0; c < t.length; ++c) {
        s(c);
      }return i;
    } }), bc.prototype = _extends(Object.create(fc.prototype), { constructor: bc, load: function load(t, e, n, r) {
      var i = this,
          a = new Yn(),
          o = new vc(this.manager);return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(t, function (t) {
        var n = i.parse(t);n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : u, a.wrapT = void 0 !== n.wrapT ? n.wrapT : u, a.magFilter = void 0 !== n.magFilter ? n.magFilter : m, a.minFilter = void 0 !== n.minFilter ? n.minFilter : m, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = g), 1 === n.mipmapCount && (a.minFilter = m), a.needsUpdate = !0, e && e(a, n));
      }, n, r), a;
    } }), wc.prototype = _extends(Object.create(fc.prototype), { constructor: wc, load: function load(t, e, n, r) {
      var i = new gt(),
          a = new xc(this.manager);return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function (n) {
        i.image = n;var r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);i.format = r ? S : T, i.needsUpdate = !0, void 0 !== e && e(i);
      }, n, r), i;
    } }), _extends(Mc.prototype, { getPoint: function getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }, getPointAt: function getPointAt(t, e) {
      var n = this.getUtoTmapping(t);return this.getPoint(n, e);
    }, getPoints: function getPoints(t) {
      void 0 === t && (t = 5);for (var e = [], n = 0; n <= t; n++) {
        e.push(this.getPoint(n / t));
      }return e;
    }, getSpacedPoints: function getSpacedPoints(t) {
      void 0 === t && (t = 5);for (var e = [], n = 0; n <= t; n++) {
        e.push(this.getPointAt(n / t));
      }return e;
    }, getLength: function getLength() {
      var t = this.getLengths();return t[t.length - 1];
    }, getLengths: function getLengths(t) {
      if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;this.needsUpdate = !1;var e,
          n = [],
          r = this.getPoint(0),
          i = 0;n.push(0);for (var a = 1; a <= t; a++) {
        i += (e = this.getPoint(a / t)).distanceTo(r), n.push(i), r = e;
      }return this.cacheArcLengths = n, n;
    }, updateArcLengths: function updateArcLengths() {
      this.needsUpdate = !0, this.getLengths();
    }, getUtoTmapping: function getUtoTmapping(t, e) {
      var n,
          r = this.getLengths(),
          i = 0,
          a = r.length;n = e || t * r[a - 1];for (var o, s = 0, c = a - 1; s <= c;) {
        if ((o = r[i = Math.floor(s + (c - s) / 2)] - n) < 0) s = i + 1;else {
          if (!(o > 0)) {
            c = i;break;
          }c = i - 1;
        }
      }if (r[i = c] === n) return i / (a - 1);var l = r[i];return (i + (n - l) / (r[i + 1] - l)) / (a - 1);
    }, getTangent: function getTangent(t, e) {
      var n = 1e-4,
          r = t - n,
          i = t + n;r < 0 && (r = 0), i > 1 && (i = 1);var a = this.getPoint(r),
          o = this.getPoint(i),
          s = e || (a.isVector2 ? new pt() : new wt());return s.copy(o).sub(a).normalize(), s;
    }, getTangentAt: function getTangentAt(t, e) {
      var n = this.getUtoTmapping(t);return this.getTangent(n, e);
    }, computeFrenetFrames: function computeFrenetFrames(t, e) {
      for (var n = new wt(), r = [], i = [], a = [], o = new wt(), s = new Jt(), c = 0; c <= t; c++) {
        var l = c / t;r[c] = this.getTangentAt(l, new wt()), r[c].normalize();
      }i[0] = new wt(), a[0] = new wt();var u = Number.MAX_VALUE,
          h = Math.abs(r[0].x),
          d = Math.abs(r[0].y),
          p = Math.abs(r[0].z);h <= u && (u = h, n.set(1, 0, 0)), d <= u && (u = d, n.set(0, 1, 0)), p <= u && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]);for (var f = 1; f <= t; f++) {
        if (i[f] = i[f - 1].clone(), a[f] = a[f - 1].clone(), o.crossVectors(r[f - 1], r[f]), o.length() > Number.EPSILON) {
          o.normalize();var m = Math.acos(st.clamp(r[f - 1].dot(r[f]), -1, 1));i[f].applyMatrix4(s.makeRotationAxis(o, m));
        }a[f].crossVectors(r[f], i[f]);
      }if (!0 === e) {
        var v = Math.acos(st.clamp(i[0].dot(i[t]), -1, 1));v /= t, r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (v = -v);for (var g = 1; g <= t; g++) {
          i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)), a[g].crossVectors(r[g], i[g]);
        }
      }return { tangents: r, normals: i, binormals: a };
    }, clone: function clone() {
      return new this.constructor().copy(this);
    }, copy: function copy(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }, toJSON: function toJSON() {
      var t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    }, fromJSON: function fromJSON(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    } }), Sc.prototype = Object.create(Mc.prototype), Sc.prototype.constructor = Sc, Sc.prototype.isEllipseCurve = !0, Sc.prototype.getPoint = function (t, e) {
    for (var n = e || new pt(), r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; i < 0;) {
      i += r;
    }for (; i > r;) {
      i -= r;
    }i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);var o = this.aStartAngle + t * i,
        s = this.aX + this.xRadius * Math.cos(o),
        c = this.aY + this.yRadius * Math.sin(o);if (0 !== this.aRotation) {
      var l = Math.cos(this.aRotation),
          u = Math.sin(this.aRotation),
          h = s - this.aX,
          d = c - this.aY;s = h * l - d * u + this.aX, c = h * u + d * l + this.aY;
    }return n.set(s, c);
  }, Sc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, Sc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }, Sc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }, Tc.prototype = Object.create(Sc.prototype), Tc.prototype.constructor = Tc, Tc.prototype.isArcCurve = !0;var Ac = new wt(),
      Lc = new Ec(),
      Rc = new Ec(),
      Cc = new Ec();function Pc(t, e, n, r) {
    Mc.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = void 0 !== r ? r : .5;
  }function Ic(t, e, n, r, i) {
    var a = .5 * (r - e),
        o = .5 * (i - n),
        s = t * t;return (2 * n - 2 * r + a + o) * (t * s) + (-3 * n + 3 * r - 2 * a - o) * s + a * t + n;
  }function Dc(t, e, n, r) {
    return function (t, e) {
      var n = 1 - t;return n * n * e;
    }(t, e) + function (t, e) {
      return 2 * (1 - t) * t * e;
    }(t, n) + function (t, e) {
      return t * t * e;
    }(t, r);
  }function Oc(t, e, n, r, i) {
    return function (t, e) {
      var n = 1 - t;return n * n * n * e;
    }(t, e) + function (t, e) {
      var n = 1 - t;return 3 * n * n * t * e;
    }(t, n) + function (t, e) {
      return 3 * (1 - t) * t * t * e;
    }(t, r) + function (t, e) {
      return t * t * t * e;
    }(t, i);
  }function Nc(t, e, n, r) {
    Mc.call(this), this.type = "CubicBezierCurve", this.v0 = t || new pt(), this.v1 = e || new pt(), this.v2 = n || new pt(), this.v3 = r || new pt();
  }function Bc(t, e, n, r) {
    Mc.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new wt(), this.v1 = e || new wt(), this.v2 = n || new wt(), this.v3 = r || new wt();
  }function zc(t, e) {
    Mc.call(this), this.type = "LineCurve", this.v1 = t || new pt(), this.v2 = e || new pt();
  }function Gc(t, e) {
    Mc.call(this), this.type = "LineCurve3", this.v1 = t || new wt(), this.v2 = e || new wt();
  }function Fc(t, e, n) {
    Mc.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new pt(), this.v1 = e || new pt(), this.v2 = n || new pt();
  }function Uc(t, e, n) {
    Mc.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new wt(), this.v1 = e || new wt(), this.v2 = n || new wt();
  }function Hc(t) {
    Mc.call(this), this.type = "SplineCurve", this.points = t || [];
  }Pc.prototype = Object.create(Mc.prototype), Pc.prototype.constructor = Pc, Pc.prototype.isCatmullRomCurve3 = !0, Pc.prototype.getPoint = function (t, e) {
    var n,
        r,
        i = e || new wt(),
        a = this.points,
        o = a.length,
        s = (o - (this.closed ? 0 : 1)) * t,
        c = Math.floor(s),
        l = s - c;this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / o) + 1) * o : 0 === l && c === o - 1 && (c = o - 2, l = 1), this.closed || c > 0 ? n = a[(c - 1) % o] : (Ac.subVectors(a[0], a[1]).add(a[0]), n = Ac);var u = a[c % o],
        h = a[(c + 1) % o];if (this.closed || c + 2 < o ? r = a[(c + 2) % o] : (Ac.subVectors(a[o - 1], a[o - 2]).add(a[o - 1]), r = Ac), "centripetal" === this.curveType || "chordal" === this.curveType) {
      var d = "chordal" === this.curveType ? .5 : .25,
          p = Math.pow(n.distanceToSquared(u), d),
          f = Math.pow(u.distanceToSquared(h), d),
          m = Math.pow(h.distanceToSquared(r), d);f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Lc.initNonuniformCatmullRom(n.x, u.x, h.x, r.x, p, f, m), Rc.initNonuniformCatmullRom(n.y, u.y, h.y, r.y, p, f, m), Cc.initNonuniformCatmullRom(n.z, u.z, h.z, r.z, p, f, m);
    } else "catmullrom" === this.curveType && (Lc.initCatmullRom(n.x, u.x, h.x, r.x, this.tension), Rc.initCatmullRom(n.y, u.y, h.y, r.y, this.tension), Cc.initCatmullRom(n.z, u.z, h.z, r.z, this.tension));return i.set(Lc.calc(l), Rc.calc(l), Cc.calc(l)), i;
  }, Pc.prototype.copy = function (t) {
    Mc.prototype.copy.call(this, t), this.points = [];for (var e = 0, n = t.points.length; e < n; e++) {
      var r = t.points[e];this.points.push(r.clone());
    }return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, Pc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);t.points = [];for (var e = 0, n = this.points.length; e < n; e++) {
      var r = this.points[e];t.points.push(r.toArray());
    }return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }, Pc.prototype.fromJSON = function (t) {
    Mc.prototype.fromJSON.call(this, t), this.points = [];for (var e = 0, n = t.points.length; e < n; e++) {
      var r = t.points[e];this.points.push(new wt().fromArray(r));
    }return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }, Nc.prototype = Object.create(Mc.prototype), Nc.prototype.constructor = Nc, Nc.prototype.isCubicBezierCurve = !0, Nc.prototype.getPoint = function (t, e) {
    var n = e || new pt(),
        r = this.v0,
        i = this.v1,
        a = this.v2,
        o = this.v3;return n.set(Oc(t, r.x, i.x, a.x, o.x), Oc(t, r.y, i.y, a.y, o.y)), n;
  }, Nc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, Nc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, Nc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, Bc.prototype = Object.create(Mc.prototype), Bc.prototype.constructor = Bc, Bc.prototype.isCubicBezierCurve3 = !0, Bc.prototype.getPoint = function (t, e) {
    var n = e || new wt(),
        r = this.v0,
        i = this.v1,
        a = this.v2,
        o = this.v3;return n.set(Oc(t, r.x, i.x, a.x, o.x), Oc(t, r.y, i.y, a.y, o.y), Oc(t, r.z, i.z, a.z, o.z)), n;
  }, Bc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }, Bc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }, Bc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }, zc.prototype = Object.create(Mc.prototype), zc.prototype.constructor = zc, zc.prototype.isLineCurve = !0, zc.prototype.getPoint = function (t, e) {
    var n = e || new pt();return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
  }, zc.prototype.getPointAt = function (t, e) {
    return this.getPoint(t, e);
  }, zc.prototype.getTangent = function (t, e) {
    var n = e || new pt();return n.copy(this.v2).sub(this.v1).normalize(), n;
  }, zc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, zc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, zc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Gc.prototype = Object.create(Mc.prototype), Gc.prototype.constructor = Gc, Gc.prototype.isLineCurve3 = !0, Gc.prototype.getPoint = function (t, e) {
    var n = e || new wt();return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
  }, Gc.prototype.getPointAt = function (t, e) {
    return this.getPoint(t, e);
  }, Gc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Gc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Gc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Fc.prototype = Object.create(Mc.prototype), Fc.prototype.constructor = Fc, Fc.prototype.isQuadraticBezierCurve = !0, Fc.prototype.getPoint = function (t, e) {
    var n = e || new pt(),
        r = this.v0,
        i = this.v1,
        a = this.v2;return n.set(Dc(t, r.x, i.x, a.x), Dc(t, r.y, i.y, a.y)), n;
  }, Fc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Fc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Fc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Uc.prototype = Object.create(Mc.prototype), Uc.prototype.constructor = Uc, Uc.prototype.isQuadraticBezierCurve3 = !0, Uc.prototype.getPoint = function (t, e) {
    var n = e || new wt(),
        r = this.v0,
        i = this.v1,
        a = this.v2;return n.set(Dc(t, r.x, i.x, a.x), Dc(t, r.y, i.y, a.y), Dc(t, r.z, i.z, a.z)), n;
  }, Uc.prototype.copy = function (t) {
    return Mc.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }, Uc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }, Uc.prototype.fromJSON = function (t) {
    return Mc.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }, Hc.prototype = Object.create(Mc.prototype), Hc.prototype.constructor = Hc, Hc.prototype.isSplineCurve = !0, Hc.prototype.getPoint = function (t, e) {
    var n = e || new pt(),
        r = this.points,
        i = (r.length - 1) * t,
        a = Math.floor(i),
        o = i - a,
        s = r[0 === a ? a : a - 1],
        c = r[a],
        l = r[a > r.length - 2 ? r.length - 1 : a + 1],
        u = r[a > r.length - 3 ? r.length - 1 : a + 2];return n.set(Ic(o, s.x, c.x, l.x, u.x), Ic(o, s.y, c.y, l.y, u.y)), n;
  }, Hc.prototype.copy = function (t) {
    Mc.prototype.copy.call(this, t), this.points = [];for (var e = 0, n = t.points.length; e < n; e++) {
      var r = t.points[e];this.points.push(r.clone());
    }return this;
  }, Hc.prototype.toJSON = function () {
    var t = Mc.prototype.toJSON.call(this);t.points = [];for (var e = 0, n = this.points.length; e < n; e++) {
      var r = this.points[e];t.points.push(r.toArray());
    }return t;
  }, Hc.prototype.fromJSON = function (t) {
    Mc.prototype.fromJSON.call(this, t), this.points = [];for (var e = 0, n = t.points.length; e < n; e++) {
      var r = t.points[e];this.points.push(new pt().fromArray(r));
    }return this;
  };var kc = Object.freeze({ __proto__: null, ArcCurve: Tc, CatmullRomCurve3: Pc, CubicBezierCurve: Nc, CubicBezierCurve3: Bc, EllipseCurve: Sc, LineCurve: zc, LineCurve3: Gc, QuadraticBezierCurve: Fc, QuadraticBezierCurve3: Uc, SplineCurve: Hc });function Vc() {
    Mc.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }function Wc(t) {
    Vc.call(this), this.type = "Path", this.currentPoint = new pt(), t && this.setFromPoints(t);
  }function jc(t) {
    Wc.call(this, t), this.uuid = st.generateUUID(), this.type = "Shape", this.holes = [];
  }function qc(t, e) {
    be.call(this), this.type = "Light", this.color = new Ve(t), this.intensity = void 0 !== e ? e : 1;
  }function Xc(t, e, n) {
    qc.call(this, t, n), this.type = "HemisphereLight", this.position.copy(be.DefaultUp), this.updateMatrix(), this.groundColor = new Ve(e);
  }function Yc(t) {
    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new pt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Jt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Qn(), this._frameExtents = new pt(1, 1), this._viewportCount = 1, this._viewports = [new yt(0, 0, 1, 1)];
  }function Zc() {
    Yc.call(this, new Vn(50, 1, .5, 500)), this.focus = 1;
  }function Jc(t, e, n, r, i, a) {
    qc.call(this, t, e), this.type = "SpotLight", this.position.copy(be.DefaultUp), this.updateMatrix(), this.target = new be(), Object.defineProperty(this, "power", { get: function get() {
        return this.intensity * Math.PI;
      }, set: function set(t) {
        this.intensity = t / Math.PI;
      } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Zc();
  }function Qc() {
    Yc.call(this, new Vn(90, 1, .5, 500)), this._frameExtents = new pt(4, 2), this._viewportCount = 6, this._viewports = [new yt(2, 1, 1, 1), new yt(0, 1, 1, 1), new yt(3, 1, 1, 1), new yt(1, 1, 1, 1), new yt(3, 0, 1, 1), new yt(1, 0, 1, 1)], this._cubeDirections = [new wt(1, 0, 0), new wt(-1, 0, 0), new wt(0, 0, 1), new wt(0, 0, -1), new wt(0, 1, 0), new wt(0, -1, 0)], this._cubeUps = [new wt(0, 1, 0), new wt(0, 1, 0), new wt(0, 1, 0), new wt(0, 1, 0), new wt(0, 0, 1), new wt(0, 0, -1)];
  }function Kc(t, e, n, r) {
    qc.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function get() {
        return 4 * this.intensity * Math.PI;
      }, set: function set(t) {
        this.intensity = t / (4 * Math.PI);
      } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Qc();
  }function $c(t, e, n, r, i, a) {
    kn.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix();
  }function tl() {
    Yc.call(this, new $c(-5, 5, 5, -5, .5, 500));
  }function el(t, e) {
    qc.call(this, t, e), this.type = "DirectionalLight", this.position.copy(be.DefaultUp), this.updateMatrix(), this.target = new be(), this.shadow = new tl();
  }function nl(t, e) {
    qc.call(this, t, e), this.type = "AmbientLight";
  }function rl(t, e, n, r) {
    qc.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10;
  }Vc.prototype = _extends(Object.create(Mc.prototype), { constructor: Vc, add: function add(t) {
      this.curves.push(t);
    }, closePath: function closePath() {
      var t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);t.equals(e) || this.curves.push(new zc(e, t));
    }, getPoint: function getPoint(t) {
      for (var e = t * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
        if (n[r] >= e) {
          var i = n[r] - e,
              a = this.curves[r],
              o = a.getLength(),
              s = 0 === o ? 0 : 1 - i / o;return a.getPointAt(s);
        }r++;
      }return null;
    }, getLength: function getLength() {
      var t = this.getCurveLengths();return t[t.length - 1];
    }, updateArcLengths: function updateArcLengths() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    }, getCurveLengths: function getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++) {
        e += this.curves[n].getLength(), t.push(e);
      }return this.cacheLengths = t, t;
    }, getSpacedPoints: function getSpacedPoints(t) {
      void 0 === t && (t = 40);for (var e = [], n = 0; n <= t; n++) {
        e.push(this.getPoint(n / t));
      }return this.autoClose && e.push(e[0]), e;
    }, getPoints: function getPoints(t) {
      t = t || 12;for (var e, n = [], r = 0, i = this.curves; r < i.length; r++) {
        for (var a = i[r], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), c = 0; c < s.length; c++) {
          var l = s[c];e && e.equals(l) || (n.push(l), e = l);
        }
      }return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
    }, copy: function copy(t) {
      Mc.prototype.copy.call(this, t), this.curves = [];for (var e = 0, n = t.curves.length; e < n; e++) {
        var r = t.curves[e];this.curves.push(r.clone());
      }return this.autoClose = t.autoClose, this;
    }, toJSON: function toJSON() {
      var t = Mc.prototype.toJSON.call(this);t.autoClose = this.autoClose, t.curves = [];for (var e = 0, n = this.curves.length; e < n; e++) {
        var r = this.curves[e];t.curves.push(r.toJSON());
      }return t;
    }, fromJSON: function fromJSON(t) {
      Mc.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];for (var e = 0, n = t.curves.length; e < n; e++) {
        var r = t.curves[e];this.curves.push(new kc[r.type]().fromJSON(r));
      }return this;
    } }), Wc.prototype = _extends(Object.create(Vc.prototype), { constructor: Wc, setFromPoints: function setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);for (var e = 1, n = t.length; e < n; e++) {
        this.lineTo(t[e].x, t[e].y);
      }return this;
    }, moveTo: function moveTo(t, e) {
      return this.currentPoint.set(t, e), this;
    }, lineTo: function lineTo(t, e) {
      var n = new zc(this.currentPoint.clone(), new pt(t, e));return this.curves.push(n), this.currentPoint.set(t, e), this;
    }, quadraticCurveTo: function quadraticCurveTo(t, e, n, r) {
      var i = new Fc(this.currentPoint.clone(), new pt(t, e), new pt(n, r));return this.curves.push(i), this.currentPoint.set(n, r), this;
    }, bezierCurveTo: function bezierCurveTo(t, e, n, r, i, a) {
      var o = new Nc(this.currentPoint.clone(), new pt(t, e), new pt(n, r), new pt(i, a));return this.curves.push(o), this.currentPoint.set(i, a), this;
    }, splineThru: function splineThru(t) {
      var e = new Hc([this.currentPoint.clone()].concat(t));return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this;
    }, arc: function arc(t, e, n, r, i, a) {
      var o = this.currentPoint.x,
          s = this.currentPoint.y;return this.absarc(t + o, e + s, n, r, i, a), this;
    }, absarc: function absarc(t, e, n, r, i, a) {
      return this.absellipse(t, e, n, n, r, i, a), this;
    }, ellipse: function ellipse(t, e, n, r, i, a, o, s) {
      var c = this.currentPoint.x,
          l = this.currentPoint.y;return this.absellipse(t + c, e + l, n, r, i, a, o, s), this;
    }, absellipse: function absellipse(t, e, n, r, i, a, o, s) {
      var c = new Sc(t, e, n, r, i, a, o, s);if (this.curves.length > 0) {
        var l = c.getPoint(0);l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
      }this.curves.push(c);var u = c.getPoint(1);return this.currentPoint.copy(u), this;
    }, copy: function copy(t) {
      return Vc.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
    }, toJSON: function toJSON() {
      var t = Vc.prototype.toJSON.call(this);return t.currentPoint = this.currentPoint.toArray(), t;
    }, fromJSON: function fromJSON(t) {
      return Vc.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
    } }), jc.prototype = _extends(Object.create(Wc.prototype), { constructor: jc, getPointsHoles: function getPointsHoles(t) {
      for (var e = [], n = 0, r = this.holes.length; n < r; n++) {
        e[n] = this.holes[n].getPoints(t);
      }return e;
    }, extractPoints: function extractPoints(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    }, copy: function copy(t) {
      Wc.prototype.copy.call(this, t), this.holes = [];for (var e = 0, n = t.holes.length; e < n; e++) {
        var r = t.holes[e];this.holes.push(r.clone());
      }return this;
    }, toJSON: function toJSON() {
      var t = Wc.prototype.toJSON.call(this);t.uuid = this.uuid, t.holes = [];for (var e = 0, n = this.holes.length; e < n; e++) {
        var r = this.holes[e];t.holes.push(r.toJSON());
      }return t;
    }, fromJSON: function fromJSON(t) {
      Wc.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];for (var e = 0, n = t.holes.length; e < n; e++) {
        var r = t.holes[e];this.holes.push(new Wc().fromJSON(r));
      }return this;
    } }), qc.prototype = _extends(Object.create(be.prototype), { constructor: qc, isLight: !0, copy: function copy(t) {
      return be.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
    }, toJSON: function toJSON(t) {
      var e = be.prototype.toJSON.call(this, t);return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
    } }), Xc.prototype = _extends(Object.create(qc.prototype), { constructor: Xc, isHemisphereLight: !0, copy: function copy(t) {
      return qc.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    } }), _extends(Yc.prototype, { _projScreenMatrix: new Jt(), _lightPositionWorld: new wt(), _lookTarget: new wt(), getViewportCount: function getViewportCount() {
      return this._viewportCount;
    }, getFrustum: function getFrustum() {
      return this._frustum;
    }, updateMatrices: function updateMatrices(t) {
      var e = this.camera,
          n = this.matrix,
          r = this._projScreenMatrix,
          i = this._lookTarget,
          a = this._lightPositionWorld;a.setFromMatrixPosition(t.matrixWorld), e.position.copy(a), i.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(i), e.updateMatrixWorld(), r.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
    }, getViewport: function getViewport(t) {
      return this._viewports[t];
    }, getFrameExtents: function getFrameExtents() {
      return this._frameExtents;
    }, copy: function copy(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    }, clone: function clone() {
      return new this.constructor().copy(this);
    }, toJSON: function toJSON() {
      var t = {};return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    } }), Zc.prototype = _extends(Object.create(Yc.prototype), { constructor: Zc, isSpotLightShadow: !0, updateMatrices: function updateMatrices(t) {
      var e = this.camera,
          n = 2 * st.RAD2DEG * t.angle * this.focus,
          r = this.mapSize.width / this.mapSize.height,
          i = t.distance || e.far;n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), Yc.prototype.updateMatrices.call(this, t);
    } }), Jc.prototype = _extends(Object.create(qc.prototype), { constructor: Jc, isSpotLight: !0, copy: function copy(t) {
      return qc.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    } }), Qc.prototype = _extends(Object.create(Yc.prototype), { constructor: Qc, isPointLightShadow: !0, updateMatrices: function updateMatrices(t, e) {
      void 0 === e && (e = 0);var n = this.camera,
          r = this.matrix,
          i = this._lightPositionWorld,
          a = this._lookTarget,
          o = this._projScreenMatrix;i.setFromMatrixPosition(t.matrixWorld), n.position.copy(i), a.copy(n.position), a.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(a), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o);
    } }), Kc.prototype = _extends(Object.create(qc.prototype), { constructor: Kc, isPointLight: !0, copy: function copy(t) {
      return qc.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    } }), $c.prototype = _extends(Object.create(kn.prototype), { constructor: $c, isOrthographicCamera: !0, copy: function copy(t, e) {
      return kn.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : _extends({}, t.view), this;
    }, setViewOffset: function setViewOffset(t, e, n, r, i, a) {
      null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix();
    }, clearViewOffset: function clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }, updateProjectionMatrix: function updateProjectionMatrix() {
      var t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          r = (this.top + this.bottom) / 2,
          i = n - t,
          a = n + t,
          o = r + e,
          s = r - e;if (null !== this.view && this.view.enabled) {
        var c = (this.right - this.left) / this.view.fullWidth / this.zoom,
            l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;a = (i += c * this.view.offsetX) + c * this.view.width, s = (o -= l * this.view.offsetY) - l * this.view.height;
      }this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    }, toJSON: function toJSON(t) {
      var e = be.prototype.toJSON.call(this, t);return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = _extends({}, this.view)), e;
    } }), tl.prototype = _extends(Object.create(Yc.prototype), { constructor: tl, isDirectionalLightShadow: !0, updateMatrices: function updateMatrices(t) {
      Yc.prototype.updateMatrices.call(this, t);
    } }), el.prototype = _extends(Object.create(qc.prototype), { constructor: el, isDirectionalLight: !0, copy: function copy(t) {
      return qc.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    } }), nl.prototype = _extends(Object.create(qc.prototype), { constructor: nl, isAmbientLight: !0 }), rl.prototype = _extends(Object.create(qc.prototype), { constructor: rl, isRectAreaLight: !0, copy: function copy(t) {
      return qc.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
    }, toJSON: function toJSON(t) {
      var e = qc.prototype.toJSON.call(this, t);return e.object.width = this.width, e.object.height = this.height, e;
    } });var il = function () {
    function t() {
      Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }), this.coefficients = [];for (var t = 0; t < 9; t++) {
        this.coefficients.push(new wt());
      }
    }var e = t.prototype;return e.set = function (t) {
      for (var e = 0; e < 9; e++) {
        this.coefficients[e].copy(t[e]);
      }return this;
    }, e.zero = function () {
      for (var t = 0; t < 9; t++) {
        this.coefficients[t].set(0, 0, 0);
      }return this;
    }, e.getAt = function (t, e) {
      var n = t.x,
          r = t.y,
          i = t.z,
          a = this.coefficients;return e.copy(a[0]).multiplyScalar(.282095), e.addScaledVector(a[1], .488603 * r), e.addScaledVector(a[2], .488603 * i), e.addScaledVector(a[3], .488603 * n), e.addScaledVector(a[4], n * r * 1.092548), e.addScaledVector(a[5], r * i * 1.092548), e.addScaledVector(a[6], .315392 * (3 * i * i - 1)), e.addScaledVector(a[7], n * i * 1.092548), e.addScaledVector(a[8], .546274 * (n * n - r * r)), e;
    }, e.getIrradianceAt = function (t, e) {
      var n = t.x,
          r = t.y,
          i = t.z,
          a = this.coefficients;return e.copy(a[0]).multiplyScalar(.886227), e.addScaledVector(a[1], 1.023328 * r), e.addScaledVector(a[2], 1.023328 * i), e.addScaledVector(a[3], 1.023328 * n), e.addScaledVector(a[4], .858086 * n * r), e.addScaledVector(a[5], .858086 * r * i), e.addScaledVector(a[6], .743125 * i * i - .247708), e.addScaledVector(a[7], .858086 * n * i), e.addScaledVector(a[8], .429043 * (n * n - r * r)), e;
    }, e.add = function (t) {
      for (var e = 0; e < 9; e++) {
        this.coefficients[e].add(t.coefficients[e]);
      }return this;
    }, e.addScaledSH = function (t, e) {
      for (var n = 0; n < 9; n++) {
        this.coefficients[n].addScaledVector(t.coefficients[n], e);
      }return this;
    }, e.scale = function (t) {
      for (var e = 0; e < 9; e++) {
        this.coefficients[e].multiplyScalar(t);
      }return this;
    }, e.lerp = function (t, e) {
      for (var n = 0; n < 9; n++) {
        this.coefficients[n].lerp(t.coefficients[n], e);
      }return this;
    }, e.equals = function (t) {
      for (var e = 0; e < 9; e++) {
        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
      }return !0;
    }, e.copy = function (t) {
      return this.set(t.coefficients);
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.fromArray = function (t, e) {
      void 0 === e && (e = 0);for (var n = this.coefficients, r = 0; r < 9; r++) {
        n[r].fromArray(t, e + 3 * r);
      }return this;
    }, e.toArray = function (t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0);for (var n = this.coefficients, r = 0; r < 9; r++) {
        n[r].toArray(t, e + 3 * r);
      }return t;
    }, t.getBasisAt = function (t, e) {
      var n = t.x,
          r = t.y,
          i = t.z;e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r);
    }, t;
  }();function al(t, e) {
    qc.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new il();
  }function ol(t) {
    fc.call(this, t), this.textures = {};
  }al.prototype = _extends(Object.create(qc.prototype), { constructor: al, isLightProbe: !0, copy: function copy(t) {
      return qc.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
    }, fromJSON: function fromJSON(t) {
      return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
    }, toJSON: function toJSON(t) {
      var e = qc.prototype.toJSON.call(this, t);return e.object.sh = this.sh.toArray(), e;
    } }), ol.prototype = _extends(Object.create(fc.prototype), { constructor: ol, load: function load(t, e, n, r) {
      var i = this,
          a = new vc(i.manager);a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (n) {
        try {
          e(i.parse(JSON.parse(n)));
        } catch (e) {
          r ? r(e) : console.error(e), i.manager.itemError(t);
        }
      }, n, r);
    }, parse: function parse(t) {
      var e = this.textures;function n(t) {
        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t];
      }var r = new Zs[t.type]();if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && void 0 !== r.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = new Ve().setHex(t.sheen)), void 0 !== t.emissive && void 0 !== r.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== r.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.vertexTangents && (r.vertexTangents = t.vertexTangents), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (var i in t.uniforms) {
        var a = t.uniforms[i];switch (r.uniforms[i] = {}, a.type) {case "t":
            r.uniforms[i].value = n(a.value);break;case "c":
            r.uniforms[i].value = new Ve().setHex(a.value);break;case "v2":
            r.uniforms[i].value = new pt().fromArray(a.value);break;case "v3":
            r.uniforms[i].value = new wt().fromArray(a.value);break;case "v4":
            r.uniforms[i].value = new yt().fromArray(a.value);break;case "m3":
            r.uniforms[i].value = new ft().fromArray(a.value);break;case "m4":
            r.uniforms[i].value = new Jt().fromArray(a.value);break;default:
            r.uniforms[i].value = a.value;}
      }if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var o in t.extensions) {
        r.extensions[o] = t.extensions[o];
      }if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.matcap && (r.matcap = n(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
        var s = t.normalScale;!1 === Array.isArray(s) && (s = [s, s]), r.normalScale = new pt().fromArray(s);
      }return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = new pt().fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.transmissionMap && (r.transmissionMap = n(t.transmissionMap)), r;
    }, setTextures: function setTextures(t) {
      return this.textures = t, this;
    } });var sl = { decodeText: function decodeText(t) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);for (var e = "", n = 0, r = t.length; n < r; n++) {
        e += String.fromCharCode(t[n]);
      }try {
        return decodeURIComponent(escape(e));
      } catch (t) {
        return e;
      }
    }, extractUrlBase: function extractUrlBase(t) {
      var e = t.lastIndexOf("/");return -1 === e ? "./" : t.substr(0, e + 1);
    } };function cl() {
    vn.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }function ll(t, e, n, r) {
    "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Je.call(this, t, e, n), this.meshPerAttribute = r || 1;
  }function ul(t) {
    fc.call(this, t);
  }cl.prototype = _extends(Object.create(vn.prototype), { constructor: cl, isInstancedBufferGeometry: !0, copy: function copy(t) {
      return vn.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this;
    }, clone: function clone() {
      return new this.constructor().copy(this);
    }, toJSON: function toJSON() {
      var t = vn.prototype.toJSON.call(this);return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
    } }), ll.prototype = _extends(Object.create(Je.prototype), { constructor: ll, isInstancedBufferAttribute: !0, copy: function copy(t) {
      return Je.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }, toJSON: function toJSON() {
      var t = Je.prototype.toJSON.call(this);return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
    } }), ul.prototype = _extends(Object.create(fc.prototype), { constructor: ul, load: function load(t, e, n, r) {
      var i = this,
          a = new vc(i.manager);a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (n) {
        try {
          e(i.parse(JSON.parse(n)));
        } catch (e) {
          r ? r(e) : console.error(e), i.manager.itemError(t);
        }
      }, n, r);
    }, parse: function parse(t) {
      var e = {},
          n = {};function r(t, r) {
        if (void 0 !== e[r]) return e[r];var i = t.interleavedBuffers[r],
            a = function (t, e) {
          if (void 0 !== n[e]) return n[e];var r = t.arrayBuffers[e],
              i = new Uint32Array(r).buffer;return n[e] = i, i;
        }(t, i.buffer),
            o = new ca(new dl[i.type](a), i.stride);return o.uuid = i.uuid, e[r] = o, o;
      }var i = t.isInstancedBufferGeometry ? new cl() : new vn(),
          a = t.data.index;if (void 0 !== a) {
        var o = new dl[a.type](a.array);i.setIndex(new Je(o, 1));
      }var s = t.data.attributes;for (var c in s) {
        var l = s[c],
            u = void 0;if (l.isInterleavedBufferAttribute) {
          u = new ha(r(t.data, l.data), l.itemSize, l.offset, l.normalized);
        } else {
          var h = new dl[l.type](l.array);u = new (l.isInstancedBufferAttribute ? ll : Je)(h, l.itemSize, l.normalized);
        }void 0 !== l.name && (u.name = l.name), i.setAttribute(c, u);
      }var d = t.data.morphAttributes;if (d) for (var p in d) {
        for (var f = d[p], m = [], v = 0, g = f.length; v < g; v++) {
          var y = f[v],
              x = void 0;if (y.isInterleavedBufferAttribute) x = new ha(r(t.data, y.data), y.itemSize, y.offset, y.normalized);else x = new Je(new dl[y.type](y.array), y.itemSize, y.normalized);void 0 !== y.name && (x.name = y.name), m.push(x);
        }i.morphAttributes[p] = m;
      }t.data.morphTargetsRelative && (i.morphTargetsRelative = !0);var _ = t.data.groups || t.data.drawcalls || t.data.offsets;if (void 0 !== _) for (var b = 0, w = _.length; b !== w; ++b) {
        var M = _[b];i.addGroup(M.start, M.count, M.materialIndex);
      }var S = t.data.boundingSphere;if (void 0 !== S) {
        var T = new wt();void 0 !== S.center && T.fromArray(S.center), i.boundingSphere = new Ht(T, S.radius);
      }return t.name && (i.name = t.name), t.userData && (i.userData = t.userData), i;
    } });var hl,
      dl = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array },
      pl = function (t) {
    function e(e) {
      return t.call(this, e) || this;
    }ut(e, t);var n = e.prototype;return n.load = function (t, e, n, r) {
      var i = this,
          a = "" === this.path ? sl.extractUrlBase(t) : this.path;this.resourcePath = this.resourcePath || a;var o = new vc(this.manager);o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function (n) {
        var a = null;try {
          a = JSON.parse(n);
        } catch (e) {
          return void 0 !== r && r(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message);
        }var o = a.metadata;void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? i.parse(a, e) : console.error("THREE.ObjectLoader: Can't load " + t);
      }, n, r);
    }, n.parse = function (t, e) {
      var n = this.parseShape(t.shapes),
          r = this.parseGeometries(t.geometries, n),
          i = this.parseImages(t.images, function () {
        void 0 !== e && e(s);
      }),
          a = this.parseTextures(t.textures, i),
          o = this.parseMaterials(t.materials, a),
          s = this.parseObject(t.object, r, o);return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s;
    }, n.parseShape = function (t) {
      var e = {};if (void 0 !== t) for (var n = 0, r = t.length; n < r; n++) {
        var i = new jc().fromJSON(t[n]);e[i.uuid] = i;
      }return e;
    }, n.parseGeometries = function (t, e) {
      var n,
          r = {};if (void 0 !== t) for (var i = new ul(), a = 0, o = t.length; a < o; a++) {
        var s = void 0,
            c = t[a];switch (c.type) {case "PlaneGeometry":case "PlaneBufferGeometry":
            s = new Gs[c.type](c.width, c.height, c.widthSegments, c.heightSegments);break;case "BoxGeometry":case "BoxBufferGeometry":case "CubeGeometry":
            s = new Gs[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);break;case "CircleGeometry":case "CircleBufferGeometry":
            s = new Gs[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);break;case "CylinderGeometry":case "CylinderBufferGeometry":
            s = new Gs[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);break;case "ConeGeometry":case "ConeBufferGeometry":
            s = new Gs[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);break;case "SphereGeometry":case "SphereBufferGeometry":
            s = new Gs[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);break;case "DodecahedronGeometry":case "DodecahedronBufferGeometry":case "IcosahedronGeometry":case "IcosahedronBufferGeometry":case "OctahedronGeometry":case "OctahedronBufferGeometry":case "TetrahedronGeometry":case "TetrahedronBufferGeometry":
            s = new Gs[c.type](c.radius, c.detail);break;case "RingGeometry":case "RingBufferGeometry":
            s = new Gs[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);break;case "TorusGeometry":case "TorusBufferGeometry":
            s = new Gs[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);break;case "TorusKnotGeometry":case "TorusKnotBufferGeometry":
            s = new Gs[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);break;case "TubeGeometry":case "TubeBufferGeometry":
            s = new Gs[c.type](new kc[c.path.type]().fromJSON(c.path), c.tubularSegments, c.radius, c.radialSegments, c.closed);break;case "LatheGeometry":case "LatheBufferGeometry":
            s = new Gs[c.type](c.points, c.segments, c.phiStart, c.phiLength);break;case "PolyhedronGeometry":case "PolyhedronBufferGeometry":
            s = new Gs[c.type](c.vertices, c.indices, c.radius, c.details);break;case "ShapeGeometry":case "ShapeBufferGeometry":
            n = [];for (var l = 0, u = c.shapes.length; l < u; l++) {
              var h = e[c.shapes[l]];n.push(h);
            }s = new Gs[c.type](n, c.curveSegments);break;case "ExtrudeGeometry":case "ExtrudeBufferGeometry":
            n = [];for (var d = 0, p = c.shapes.length; d < p; d++) {
              var f = e[c.shapes[d]];n.push(f);
            }var m = c.options.extrudePath;void 0 !== m && (c.options.extrudePath = new kc[m.type]().fromJSON(m)), s = new Gs[c.type](n, c.options);break;case "BufferGeometry":case "InstancedBufferGeometry":
            s = i.parse(c);break;case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');continue;}s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), r[c.uuid] = s;
      }return r;
    }, n.parseMaterials = function (t, e) {
      var n = {},
          r = {};if (void 0 !== t) {
        var i = new ol();i.setTextures(e);for (var a = 0, o = t.length; a < o; a++) {
          var s = t[a];if ("MultiMaterial" === s.type) {
            for (var c = [], l = 0; l < s.materials.length; l++) {
              var u = s.materials[l];void 0 === n[u.uuid] && (n[u.uuid] = i.parse(u)), c.push(n[u.uuid]);
            }r[s.uuid] = c;
          } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid];
        }
      }return r;
    }, n.parseAnimations = function (t) {
      for (var e = [], n = 0; n < t.length; n++) {
        var r = t[n],
            i = lc.parse(r);void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i);
      }return e;
    }, n.parseImages = function (t, e) {
      var n,
          r = this,
          i = {};function a(t) {
        return r.manager.itemStart(t), n.load(t, function () {
          r.manager.itemEnd(t);
        }, void 0, function () {
          r.manager.itemError(t), r.manager.itemEnd(t);
        });
      }if (void 0 !== t && t.length > 0) {
        var o = new dc(e);(n = new xc(o)).setCrossOrigin(this.crossOrigin);for (var s = 0, c = t.length; s < c; s++) {
          var l = t[s],
              u = l.url;if (Array.isArray(u)) {
            i[l.uuid] = [];for (var h = 0, d = u.length; h < d; h++) {
              var p = u[h],
                  f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : r.resourcePath + p;i[l.uuid].push(a(f));
            }
          } else {
            var m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : r.resourcePath + l.url;i[l.uuid] = a(m);
          }
        }
      }return i;
    }, n.parseTextures = function (t, e) {
      function n(t, e) {
        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]);
      }var r = {};if (void 0 !== t) for (var i = 0, a = t.length; i < a; i++) {
        var o = t[i];void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);var s = void 0;(s = Array.isArray(e[o.image]) ? new qn(e[o.image]) : new gt(e[o.image])).needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, fl)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], ml), s.wrapT = n(o.wrap[1], ml)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, vl)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, vl)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), r[o.uuid] = s;
      }return r;
    }, n.parseObject = function (t, e, n) {
      var r, i, a;function o(t) {
        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t];
      }function s(t) {
        if (void 0 !== t) {
          if (Array.isArray(t)) {
            for (var e = [], r = 0, i = t.length; r < i; r++) {
              var a = t[r];void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), e.push(n[a]);
            }return e;
          }return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t];
        }
      }switch (t.type) {case "Scene":
          r = new sa(), void 0 !== t.background && Number.isInteger(t.background) && (r.background = new Ve(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new oa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new aa(t.fog.color, t.fog.density)));break;case "PerspectiveCamera":
          r = new Vn(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (r.focus = t.focus), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset), void 0 !== t.view && (r.view = _extends({}, t.view));break;case "OrthographicCamera":
          r = new $c(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.view && (r.view = _extends({}, t.view));break;case "AmbientLight":
          r = new nl(t.color, t.intensity);break;case "DirectionalLight":
          r = new el(t.color, t.intensity);break;case "PointLight":
          r = new Kc(t.color, t.intensity, t.distance, t.decay);break;case "RectAreaLight":
          r = new rl(t.color, t.intensity, t.width, t.height);break;case "SpotLight":
          r = new Jc(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);break;case "HemisphereLight":
          r = new Xc(t.color, t.groundColor, t.intensity);break;case "LightProbe":
          r = new al().fromJSON(t);break;case "SkinnedMesh":
          console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case "Mesh":
          r = new On(i = o(t.geometry), a = s(t.material));break;case "InstancedMesh":
          i = o(t.geometry), a = s(t.material);var c = t.count,
              l = t.instanceMatrix;(r = new Wa(i, a, c)).instanceMatrix = new Je(new Float32Array(l.array), 16);break;case "LOD":
          r = new Oa();break;case "Line":
          r = new Qa(o(t.geometry), s(t.material), t.mode);break;case "LineLoop":
          r = new eo(o(t.geometry), s(t.material));break;case "LineSegments":
          r = new to(o(t.geometry), s(t.material));break;case "PointCloud":case "Points":
          r = new so(o(t.geometry), s(t.material));break;case "Sprite":
          r = new Ta(s(t.material));break;case "Group":
          r = new $i();break;default:
          r = new be();}if (r.uuid = t.uuid, void 0 !== t.name && (r.name = t.name), void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (r.matrixAutoUpdate = t.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position), void 0 !== t.rotation && r.rotation.fromArray(t.rotation), void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion), void 0 !== t.scale && r.scale.fromArray(t.scale)), void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (r.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.layers && (r.layers.mask = t.layers), void 0 !== t.children) for (var u = t.children, h = 0; h < u.length; h++) {
        r.add(this.parseObject(u[h], e, n));
      }if ("LOD" === t.type) {
        void 0 !== t.autoUpdate && (r.autoUpdate = t.autoUpdate);for (var d = t.levels, p = 0; p < d.length; p++) {
          var f = d[p],
              m = r.getObjectByProperty("uuid", f.object);void 0 !== m && r.addLevel(m, f.distance);
        }
      }return r;
    }, n.setTexturePath = function (t) {
      return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t);
    }, e;
  }(fc),
      fl = { UVMapping: n, CubeReflectionMapping: r, CubeRefractionMapping: i, EquirectangularReflectionMapping: a, EquirectangularRefractionMapping: o, CubeUVReflectionMapping: s, CubeUVRefractionMapping: c },
      ml = { RepeatWrapping: l, ClampToEdgeWrapping: u, MirroredRepeatWrapping: h },
      vl = { NearestFilter: d, NearestMipmapNearestFilter: p, NearestMipmapLinearFilter: f, LinearFilter: m, LinearMipmapNearestFilter: v, LinearMipmapLinearFilter: g };function gl(t) {
    "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), fc.call(this, t), this.options = { premultiplyAlpha: "none" };
  }function yl() {
    this.type = "ShapePath", this.color = new Ve(), this.subPaths = [], this.currentPath = null;
  }function xl(t) {
    this.type = "Font", this.data = t;
  }function _l(t, e, n, r, i) {
    var a = i.glyphs[t] || i.glyphs["?"];if (a) {
      var o,
          s,
          c,
          l,
          u,
          h,
          d,
          p,
          f = new yl();if (a.o) for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) {
        switch (m[v++]) {case "m":
            o = m[v++] * e + n, s = m[v++] * e + r, f.moveTo(o, s);break;case "l":
            o = m[v++] * e + n, s = m[v++] * e + r, f.lineTo(o, s);break;case "q":
            c = m[v++] * e + n, l = m[v++] * e + r, u = m[v++] * e + n, h = m[v++] * e + r, f.quadraticCurveTo(u, h, c, l);break;case "b":
            c = m[v++] * e + n, l = m[v++] * e + r, u = m[v++] * e + n, h = m[v++] * e + r, d = m[v++] * e + n, p = m[v++] * e + r, f.bezierCurveTo(u, h, d, p, c, l);}
      }return { offsetX: a.ha * e, path: f };
    }console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".");
  }function bl(t) {
    fc.call(this, t);
  }gl.prototype = _extends(Object.create(fc.prototype), { constructor: gl, isImageBitmapLoader: !0, setOptions: function setOptions(t) {
      return this.options = t, this;
    }, load: function load(t, e, n, r) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);var i = this,
          a = hc.get(t);if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
        e && e(a), i.manager.itemEnd(t);
      }, 0), a;var o = {};o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t, o).then(function (t) {
        return t.blob();
      }).then(function (t) {
        return createImageBitmap(t, i.options);
      }).then(function (n) {
        hc.add(t, n), e && e(n), i.manager.itemEnd(t);
      }).catch(function (e) {
        r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
      }), i.manager.itemStart(t);
    } }), _extends(yl.prototype, { moveTo: function moveTo(t, e) {
      return this.currentPath = new Wc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
    }, lineTo: function lineTo(t, e) {
      return this.currentPath.lineTo(t, e), this;
    }, quadraticCurveTo: function quadraticCurveTo(t, e, n, r) {
      return this.currentPath.quadraticCurveTo(t, e, n, r), this;
    }, bezierCurveTo: function bezierCurveTo(t, e, n, r, i, a) {
      return this.currentPath.bezierCurveTo(t, e, n, r, i, a), this;
    }, splineThru: function splineThru(t) {
      return this.currentPath.splineThru(t), this;
    }, toShapes: function toShapes(t, e) {
      function n(t) {
        for (var e = [], n = 0, r = t.length; n < r; n++) {
          var i = t[n],
              a = new jc();a.curves = i.curves, e.push(a);
        }return e;
      }function r(t, e) {
        for (var n = e.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
          var o = e[i],
              s = e[a],
              c = s.x - o.x,
              l = s.y - o.y;if (Math.abs(l) > Number.EPSILON) {
            if (l < 0 && (o = e[a], c = -c, s = e[i], l = -l), t.y < o.y || t.y > s.y) continue;if (t.y === o.y) {
              if (t.x === o.x) return !0;
            } else {
              var u = l * (t.x - o.x) - c * (t.y - o.y);if (0 === u) return !0;if (u < 0) continue;r = !r;
            }
          } else {
            if (t.y !== o.y) continue;if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0;
          }
        }return r;
      }var i,
          a,
          o,
          s = as.isClockWise,
          c = this.subPaths;if (0 === c.length) return [];if (!0 === e) return n(c);var l = [];if (1 === c.length) return a = c[0], (o = new jc()).curves = a.curves, l.push(o), l;var u = !s(c[0].getPoints());u = t ? !u : u;var h,
          d,
          p = [],
          f = [],
          m = [],
          v = 0;f[v] = void 0, m[v] = [];for (var g = 0, y = c.length; g < y; g++) {
        i = s(h = (a = c[g]).getPoints()), (i = t ? !i : i) ? (!u && f[v] && v++, f[v] = { s: new jc(), p: h }, f[v].s.curves = a.curves, u && v++, m[v] = []) : m[v].push({ h: a, p: h[0] });
      }if (!f[0]) return n(c);if (f.length > 1) {
        for (var x = !1, _ = [], b = 0, w = f.length; b < w; b++) {
          p[b] = [];
        }for (var M = 0, S = f.length; M < S; M++) {
          for (var T = m[M], E = 0; E < T.length; E++) {
            for (var A = T[E], L = !0, R = 0; R < f.length; R++) {
              r(A.p, f[R].p) && (M !== R && _.push({ froms: M, tos: R, hole: E }), L ? (L = !1, p[R].push(A)) : x = !0);
            }L && p[M].push(A);
          }
        }_.length > 0 && (x || (m = p));
      }for (var C = 0, P = f.length; C < P; C++) {
        o = f[C].s, l.push(o);for (var I = 0, D = (d = m[C]).length; I < D; I++) {
          o.holes.push(d[I].h);
        }
      }return l;
    } }), _extends(xl.prototype, { isFont: !0, generateShapes: function generateShapes(t, e) {
      void 0 === e && (e = 100);for (var n = [], r = function (t, e, n) {
        for (var r = Array.from ? Array.from(t) : String(t).split(""), i = e / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, o = [], s = 0, c = 0, l = 0; l < r.length; l++) {
          var u = r[l];if ("\n" === u) s = 0, c -= a;else {
            var h = _l(u, i, s, c, n);s += h.offsetX, o.push(h.path);
          }
        }return o;
      }(t, e, this.data), i = 0, a = r.length; i < a; i++) {
        Array.prototype.push.apply(n, r[i].toShapes());
      }return n;
    } }), bl.prototype = _extends(Object.create(fc.prototype), { constructor: bl, load: function load(t, e, n, r) {
      var i = this,
          a = new vc(this.manager);a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (t) {
        var n;try {
          n = JSON.parse(t);
        } catch (e) {
          console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2));
        }var r = i.parse(n);e && e(r);
      }, n, r);
    }, parse: function parse(t) {
      return new xl(t);
    } });var wl = { getContext: function getContext() {
      return void 0 === hl && (hl = new (window.AudioContext || window.webkitAudioContext)()), hl;
    }, setContext: function setContext(t) {
      hl = t;
    } };function Ml(t) {
    fc.call(this, t);
  }function Sl(t, e, n) {
    al.call(this, void 0, n);var r = new Ve().set(t),
        i = new Ve().set(e),
        a = new wt(r.r, r.g, r.b),
        o = new wt(i.r, i.g, i.b),
        s = Math.sqrt(Math.PI),
        c = s * Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
  }function Tl(t, e) {
    al.call(this, void 0, e);var n = new Ve().set(t);this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }Ml.prototype = _extends(Object.create(fc.prototype), { constructor: Ml, load: function load(t, e, n, r) {
      var i = this,
          a = new vc(i.manager);a.setResponseType("arraybuffer"), a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(t, function (n) {
        try {
          var a = n.slice(0);wl.getContext().decodeAudioData(a, function (t) {
            e(t);
          });
        } catch (e) {
          r ? r(e) : console.error(e), i.manager.itemError(t);
        }
      }, n, r);
    } }), Sl.prototype = _extends(Object.create(al.prototype), { constructor: Sl, isHemisphereLightProbe: !0, copy: function copy(t) {
      return al.prototype.copy.call(this, t), this;
    }, toJSON: function toJSON(t) {
      return al.prototype.toJSON.call(this, t);
    } }), Tl.prototype = _extends(Object.create(al.prototype), { constructor: Tl, isAmbientLightProbe: !0, copy: function copy(t) {
      return al.prototype.copy.call(this, t), this;
    }, toJSON: function toJSON(t) {
      return al.prototype.toJSON.call(this, t);
    } });var El = new Jt(),
      Al = new Jt();function Ll() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Vn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Vn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }_extends(Ll.prototype, { update: function update(t) {
      var e = this._cache;if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
        e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;var n,
            r,
            i = t.projectionMatrix.clone(),
            a = e.eyeSep / 2,
            o = a * e.near / e.focus,
            s = e.near * Math.tan(st.DEG2RAD * e.fov * .5) / e.zoom;Al.elements[12] = -a, El.elements[12] = a, n = -s * e.aspect + o, r = s * e.aspect + o, i.elements[0] = 2 * e.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(i), n = -s * e.aspect - o, r = s * e.aspect - o, i.elements[0] = 2 * e.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(i);
      }this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Al), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(El);
    } });var Rl = function () {
    function t(t) {
      this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
    }var e = t.prototype;return e.start = function () {
      this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
    }, e.stop = function () {
      this.getElapsedTime(), this.running = !1, this.autoStart = !1;
    }, e.getElapsedTime = function () {
      return this.getDelta(), this.elapsedTime;
    }, e.getDelta = function () {
      var t = 0;if (this.autoStart && !this.running) return this.start(), 0;if (this.running) {
        var e = ("undefined" == typeof performance ? Date : performance).now();t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }return t;
    }, t;
  }(),
      Cl = new wt(),
      Pl = new bt(),
      Il = new wt(),
      Dl = new wt(),
      Ol = function (t) {
    function e() {
      var e;return (e = t.call(this) || this).type = "AudioListener", e.context = wl.getContext(), e.gain = e.context.createGain(), e.gain.connect(e.context.destination), e.filter = null, e.timeDelta = 0, e._clock = new Rl(), e;
    }ut(e, t);var n = e.prototype;return n.getInput = function () {
      return this.gain;
    }, n.removeFilter = function () {
      return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }, n.getFilter = function () {
      return this.filter;
    }, n.setFilter = function (t) {
      return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }, n.getMasterVolume = function () {
      return this.gain.gain.value;
    }, n.setMasterVolume = function (t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
    }, n.updateMatrixWorld = function (e) {
      t.prototype.updateMatrixWorld.call(this, e);var n = this.context.listener,
          r = this.up;if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Cl, Pl, Il), Dl.set(0, 0, -1).applyQuaternion(Pl), n.positionX) {
        var i = this.context.currentTime + this.timeDelta;n.positionX.linearRampToValueAtTime(Cl.x, i), n.positionY.linearRampToValueAtTime(Cl.y, i), n.positionZ.linearRampToValueAtTime(Cl.z, i), n.forwardX.linearRampToValueAtTime(Dl.x, i), n.forwardY.linearRampToValueAtTime(Dl.y, i), n.forwardZ.linearRampToValueAtTime(Dl.z, i), n.upX.linearRampToValueAtTime(r.x, i), n.upY.linearRampToValueAtTime(r.y, i), n.upZ.linearRampToValueAtTime(r.z, i);
      } else n.setPosition(Cl.x, Cl.y, Cl.z), n.setOrientation(Dl.x, Dl.y, Dl.z, r.x, r.y, r.z);
    }, e;
  }(be),
      Nl = function (t) {
    function e(e) {
      var n;return (n = t.call(this) || this).type = "Audio", n.listener = e, n.context = e.context, n.gain = n.context.createGain(), n.gain.connect(e.getInput()), n.autoplay = !1, n.buffer = null, n.detune = 0, n.loop = !1, n.loopStart = 0, n.loopEnd = 0, n.offset = 0, n.duration = void 0, n.playbackRate = 1, n.isPlaying = !1, n.hasPlaybackControl = !0, n.source = null, n.sourceType = "empty", n._startedAt = 0, n._progress = 0, n._connected = !1, n.filters = [], n;
    }ut(e, t);var n = e.prototype;return n.getOutput = function () {
      return this.gain;
    }, n.setNodeSource = function (t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    }, n.setMediaElementSource = function (t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    }, n.setMediaStreamSource = function (t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
    }, n.setBuffer = function (t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }, n.play = function (t) {
      if (void 0 === t && (t = 0), !0 !== this.isPlaying) {
        if (!1 !== this.hasPlaybackControl) {
          this._startedAt = this.context.currentTime + t;var e = this.context.createBufferSource();return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }console.warn("THREE.Audio: this Audio has no playback control.");
      } else console.warn("THREE.Audio: Audio is already playing.");
    }, n.pause = function () {
      if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;console.warn("THREE.Audio: this Audio has no playback control.");
    }, n.stop = function () {
      if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;console.warn("THREE.Audio: this Audio has no playback control.");
    }, n.connect = function () {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);for (var t = 1, e = this.filters.length; t < e; t++) {
          this.filters[t - 1].connect(this.filters[t]);
        }this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());return this._connected = !0, this;
    }, n.disconnect = function () {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);for (var t = 1, e = this.filters.length; t < e; t++) {
          this.filters[t - 1].disconnect(this.filters[t]);
        }this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());return this._connected = !1, this;
    }, n.getFilters = function () {
      return this.filters;
    }, n.setFilters = function (t) {
      return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
    }, n.setDetune = function (t) {
      if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
    }, n.getDetune = function () {
      return this.detune;
    }, n.getFilter = function () {
      return this.getFilters()[0];
    }, n.setFilter = function (t) {
      return this.setFilters(t ? [t] : []);
    }, n.setPlaybackRate = function (t) {
      if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;console.warn("THREE.Audio: this Audio has no playback control.");
    }, n.getPlaybackRate = function () {
      return this.playbackRate;
    }, n.onEnded = function () {
      this.isPlaying = !1;
    }, n.getLoop = function () {
      return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    }, n.setLoop = function (t) {
      if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;console.warn("THREE.Audio: this Audio has no playback control.");
    }, n.setLoopStart = function (t) {
      return this.loopStart = t, this;
    }, n.setLoopEnd = function (t) {
      return this.loopEnd = t, this;
    }, n.getVolume = function () {
      return this.gain.gain.value;
    }, n.setVolume = function (t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
    }, e;
  }(be),
      Bl = new wt(),
      zl = new bt(),
      Gl = new wt(),
      Fl = new wt(),
      Ul = function (t) {
    function e(e) {
      var n;return (n = t.call(this, e) || this).panner = n.context.createPanner(), n.panner.panningModel = "HRTF", n.panner.connect(n.gain), n;
    }ut(e, t);var n = e.prototype;return n.getOutput = function () {
      return this.panner;
    }, n.getRefDistance = function () {
      return this.panner.refDistance;
    }, n.setRefDistance = function (t) {
      return this.panner.refDistance = t, this;
    }, n.getRolloffFactor = function () {
      return this.panner.rolloffFactor;
    }, n.setRolloffFactor = function (t) {
      return this.panner.rolloffFactor = t, this;
    }, n.getDistanceModel = function () {
      return this.panner.distanceModel;
    }, n.setDistanceModel = function (t) {
      return this.panner.distanceModel = t, this;
    }, n.getMaxDistance = function () {
      return this.panner.maxDistance;
    }, n.setMaxDistance = function (t) {
      return this.panner.maxDistance = t, this;
    }, n.setDirectionalCone = function (t, e, n) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this;
    }, n.updateMatrixWorld = function (e) {
      if (t.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
        this.matrixWorld.decompose(Bl, zl, Gl), Fl.set(0, 0, 1).applyQuaternion(zl);var n = this.panner;if (n.positionX) {
          var r = this.context.currentTime + this.listener.timeDelta;n.positionX.linearRampToValueAtTime(Bl.x, r), n.positionY.linearRampToValueAtTime(Bl.y, r), n.positionZ.linearRampToValueAtTime(Bl.z, r), n.orientationX.linearRampToValueAtTime(Fl.x, r), n.orientationY.linearRampToValueAtTime(Fl.y, r), n.orientationZ.linearRampToValueAtTime(Fl.z, r);
        } else n.setPosition(Bl.x, Bl.y, Bl.z), n.setOrientation(Fl.x, Fl.y, Fl.z);
      }
    }, e;
  }(Nl),
      Hl = function () {
    function t(t, e) {
      this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
    }var e = t.prototype;return e.getFrequencyData = function () {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }, e.getAverageFrequency = function () {
      for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) {
        t += e[n];
      }return t / e.length;
    }, t;
  }();function kl(t, e, n) {
    var r, i, a;switch (this.binding = t, this.valueSize = n, e) {case "quaternion":
        r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;break;case "string":case "bool":
        r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);break;default:
        r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);}this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }_extends(kl.prototype, { accumulate: function accumulate(t, e) {
      var n = this.buffer,
          r = this.valueSize,
          i = t * r + r,
          a = this.cumulativeWeight;if (0 === a) {
        for (var o = 0; o !== r; ++o) {
          n[i + o] = n[o];
        }a = e;
      } else {
        var s = e / (a += e);this._mixBufferRegion(n, i, 0, s, r);
      }this.cumulativeWeight = a;
    }, accumulateAdditive: function accumulateAdditive(t) {
      var e = this.buffer,
          n = this.valueSize,
          r = n * this._addIndex;0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t;
    }, apply: function apply(t) {
      var e = this.valueSize,
          n = this.buffer,
          r = t * e + e,
          i = this.cumulativeWeight,
          a = this.cumulativeWeightAdditive,
          o = this.binding;if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
        var s = e * this._origIndex;this._mixBufferRegion(n, r, s, 1 - i, e);
      }a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);for (var c = e, l = e + e; c !== l; ++c) {
        if (n[c] !== n[c + e]) {
          o.setValue(n, r);break;
        }
      }
    }, saveOriginalState: function saveOriginalState() {
      var t = this.binding,
          e = this.buffer,
          n = this.valueSize,
          r = n * this._origIndex;t.getValue(e, r);for (var i = n, a = r; i !== a; ++i) {
        e[i] = e[r + i % n];
      }this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }, restoreOriginalState: function restoreOriginalState() {
      var t = 3 * this.valueSize;this.binding.setValue(this.buffer, t);
    }, _setAdditiveIdentityNumeric: function _setAdditiveIdentityNumeric() {
      for (var t = this._addIndex * this.valueSize, e = t + this.valueSize, n = t; n < e; n++) {
        this.buffer[n] = 0;
      }
    }, _setAdditiveIdentityQuaternion: function _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }, _setAdditiveIdentityOther: function _setAdditiveIdentityOther() {
      for (var t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++) {
        this.buffer[e + n] = this.buffer[t + n];
      }
    }, _select: function _select(t, e, n, r, i) {
      if (r >= .5) for (var a = 0; a !== i; ++a) {
        t[e + a] = t[n + a];
      }
    }, _slerp: function _slerp(t, e, n, r) {
      bt.slerpFlat(t, e, t, e, t, n, r);
    }, _slerpAdditive: function _slerpAdditive(t, e, n, r, i) {
      var a = this._workIndex * i;bt.multiplyQuaternionsFlat(t, a, t, e, t, n), bt.slerpFlat(t, e, t, e, t, a, r);
    }, _lerp: function _lerp(t, e, n, r, i) {
      for (var a = 1 - r, o = 0; o !== i; ++o) {
        var s = e + o;t[s] = t[s] * a + t[n + o] * r;
      }
    }, _lerpAdditive: function _lerpAdditive(t, e, n, r, i) {
      for (var a = 0; a !== i; ++a) {
        var o = e + a;t[o] = t[o] + t[n + a] * r;
      }
    } });var Vl = "\\[\\]\\.:\\/",
      Wl = new RegExp("[\\[\\]\\.:\\/]", "g"),
      jl = "[^\\[\\]\\.:\\/]",
      ql = "[^" + Vl.replace("\\.", "") + "]",
      Xl = /((?:WC+[\/:])*)/.source.replace("WC", jl),
      Yl = /(WCOD+)?/.source.replace("WCOD", ql),
      Zl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", jl),
      Jl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", jl),
      Ql = new RegExp("^" + Xl + Yl + Zl + Jl + "$"),
      Kl = ["material", "materials", "bones"];function $l(t, e, n) {
    var r = n || tu.parseTrackName(e);this._targetGroup = t, this._bindings = t.subscribe_(e, r);
  }function tu(t, e, n) {
    this.path = e, this.parsedPath = n || tu.parseTrackName(e), this.node = tu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
  }function eu() {
    this.uuid = st.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;var t = {};this._indicesByUUID = t;for (var e = 0, n = arguments.length; e !== n; ++e) {
      t[arguments[e].uuid] = e;
    }this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};var r = this;this.stats = { objects: { get total() {
          return r._objects.length;
        }, get inUse() {
          return this.total - r.nCachedObjects_;
        } }, get bindingsPerObject() {
        return r._bindings.length;
      } };
  }_extends($l.prototype, { getValue: function getValue(t, e) {
      this.bind();var n = this._targetGroup.nCachedObjects_,
          r = this._bindings[n];void 0 !== r && r.getValue(t, e);
    }, setValue: function setValue(t, e) {
      for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) {
        n[r].setValue(t, e);
      }
    }, bind: function bind() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) {
        t[e].bind();
      }
    }, unbind: function unbind() {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) {
        t[e].unbind();
      }
    } }), _extends(tu, { Composite: $l, create: function create(t, e, n) {
      return t && t.isAnimationObjectGroup ? new tu.Composite(t, e, n) : new tu(t, e, n);
    }, sanitizeNodeName: function sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(Wl, "");
    }, parseTrackName: function parseTrackName(t) {
      var e = Ql.exec(t);if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);var n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
          r = n.nodeName && n.nodeName.lastIndexOf(".");if (void 0 !== r && -1 !== r) {
        var i = n.nodeName.substring(r + 1);-1 !== Kl.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i);
      }if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);return n;
    }, findNode: function findNode(t, e) {
      if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;if (t.skeleton) {
        var n = t.skeleton.getBoneByName(e);if (void 0 !== n) return n;
      }if (t.children) {
        var r = function t(n) {
          for (var r = 0; r < n.length; r++) {
            var i = n[r];if (i.name === e || i.uuid === e) return i;var a = t(i.children);if (a) return a;
          }return null;
        }(t.children);if (r) return r;
      }return null;
    } }), _extends(tu.prototype, { _getValue_unavailable: function _getValue_unavailable() {}, _setValue_unavailable: function _setValue_unavailable() {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) {
      t[e] = this.node[this.propertyName];
    }, function (t, e) {
      for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) {
        t[e++] = n[r];
      }
    }, function (t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }, function (t, e) {
      this.resolvedProperty.toArray(t, e);
    }], SetterByBindingTypeAndVersioning: [[function (t, e) {
      this.targetObject[this.propertyName] = t[e];
    }, function (t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
    }, function (t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
    }], [function (t, e) {
      for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) {
        n[r] = t[e++];
      }
    }, function (t, e) {
      for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) {
        n[r] = t[e++];
      }this.targetObject.needsUpdate = !0;
    }, function (t, e) {
      for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) {
        n[r] = t[e++];
      }this.targetObject.matrixWorldNeedsUpdate = !0;
    }], [function (t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }, function (t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
    }, function (t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
    }], [function (t, e) {
      this.resolvedProperty.fromArray(t, e);
    }, function (t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
    }, function (t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
    }]], getValue: function getValue(t, e) {
      this.bind(), this.getValue(t, e);
    }, setValue: function setValue(t, e) {
      this.bind(), this.setValue(t, e);
    }, bind: function bind() {
      var t = this.node,
          e = this.parsedPath,
          n = e.objectName,
          r = e.propertyName,
          i = e.propertyIndex;if (t || (t = tu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
        if (n) {
          var a = e.objectIndex;switch (n) {case "materials":
              if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);t = t.material.materials;break;case "bones":
              if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);t = t.skeleton.bones;for (var o = 0; o < t.length; o++) {
                if (t[o].name === a) {
                  a = o;break;
                }
              }break;default:
              if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);t = t[n];}if (void 0 !== a) {
            if (void 0 === t[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);t = t[a];
          }
        }var s = t[r];if (void 0 !== s) {
          var c = this.Versioning.None;this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);var l = this.BindingType.Direct;if (void 0 !== i) {
            if ("morphTargetInfluences" === r) {
              if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i]);
            }l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i;
          } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c];
        } else {
          var u = e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", t);
        }
      } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    }, unbind: function unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    } }), _extends(tu.prototype, { _getValue_unbound: tu.prototype.getValue, _setValue_unbound: tu.prototype.setValue }), _extends(eu.prototype, { isAnimationObjectGroup: !0, add: function add() {
      for (var t = this._objects, e = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, a = i.length, o = void 0, s = t.length, c = this.nCachedObjects_, l = 0, u = arguments.length; l !== u; ++l) {
        var h = arguments[l],
            d = h.uuid,
            p = e[d];if (void 0 === p) {
          p = s++, e[d] = p, t.push(h);for (var f = 0, m = a; f !== m; ++f) {
            i[f].push(new tu(h, n[f], r[f]));
          }
        } else if (p < c) {
          o = t[p];var v = --c,
              g = t[v];e[g.uuid] = p, t[p] = g, e[d] = v, t[v] = h;for (var y = 0, x = a; y !== x; ++y) {
            var _ = i[y],
                b = _[v],
                w = _[p];_[p] = b, void 0 === w && (w = new tu(h, n[y], r[y])), _[v] = w;
          }
        } else t[p] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }this.nCachedObjects_ = c;
    }, remove: function remove() {
      for (var t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = 0, o = arguments.length; a !== o; ++a) {
        var s = arguments[a],
            c = s.uuid,
            l = e[c];if (void 0 !== l && l >= i) {
          var u = i++,
              h = t[u];e[h.uuid] = l, t[l] = h, e[c] = u, t[u] = s;for (var d = 0, p = r; d !== p; ++d) {
            var f = n[d],
                m = f[u],
                v = f[l];f[l] = m, f[u] = v;
          }
        }
      }this.nCachedObjects_ = i;
    }, uncache: function uncache() {
      for (var t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = t.length, o = 0, s = arguments.length; o !== s; ++o) {
        var c = arguments[o],
            l = c.uuid,
            u = e[l];if (void 0 !== u) if (delete e[l], u < i) {
          var h = --i,
              d = t[h],
              p = --a,
              f = t[p];e[d.uuid] = u, t[u] = d, e[f.uuid] = h, t[h] = f, t.pop();for (var m = 0, v = r; m !== v; ++m) {
            var g = n[m],
                y = g[h],
                x = g[p];g[u] = y, g[h] = x, g.pop();
          }
        } else {
          var _ = --a,
              b = t[_];_ > 0 && (e[b.uuid] = u), t[u] = b, t.pop();for (var w = 0, M = r; w !== M; ++w) {
            var S = n[w];S[u] = S[_], S.pop();
          }
        }
      }this.nCachedObjects_ = i;
    }, subscribe_: function subscribe_(t, e) {
      var n = this._bindingsIndicesByPath,
          r = n[t],
          i = this._bindings;if (void 0 !== r) return i[r];var a = this._paths,
          o = this._parsedPaths,
          s = this._objects,
          c = s.length,
          l = this.nCachedObjects_,
          u = new Array(c);r = i.length, n[t] = r, a.push(t), o.push(e), i.push(u);for (var h = l, d = s.length; h !== d; ++h) {
        var p = s[h];u[h] = new tu(p, t, e);
      }return u;
    }, unsubscribe_: function unsubscribe_(t) {
      var e = this._bindingsIndicesByPath,
          n = e[t];if (void 0 !== n) {
        var r = this._paths,
            i = this._parsedPaths,
            a = this._bindings,
            o = a.length - 1,
            s = a[o];e[t[o]] = n, a[n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop();
      }
    } });var nu = function () {
    function t(t, e, n, r) {
      this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = r || e.blendMode;for (var i = e.tracks, a = i.length, o = new Array(a), s = { endingStart: H, endingEnd: H }, c = 0; c !== a; ++c) {
        var l = i[c].createInterpolant(null);o[c] = l, l.settings = s;
      }this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
    }var e = t.prototype;return e.play = function () {
      return this._mixer._activateAction(this), this;
    }, e.stop = function () {
      return this._mixer._deactivateAction(this), this.reset();
    }, e.reset = function () {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }, e.isRunning = function () {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    }, e.isScheduled = function () {
      return this._mixer._isActiveAction(this);
    }, e.startAt = function (t) {
      return this._startTime = t, this;
    }, e.setLoop = function (t, e) {
      return this.loop = t, this.repetitions = e, this;
    }, e.setEffectiveWeight = function (t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    }, e.getEffectiveWeight = function () {
      return this._effectiveWeight;
    }, e.fadeIn = function (t) {
      return this._scheduleFading(t, 0, 1);
    }, e.fadeOut = function (t) {
      return this._scheduleFading(t, 1, 0);
    }, e.crossFadeFrom = function (t, e, n) {
      if (t.fadeOut(e), this.fadeIn(e), n) {
        var r = this._clip.duration,
            i = t._clip.duration,
            a = i / r,
            o = r / i;t.warp(1, a, e), this.warp(o, 1, e);
      }return this;
    }, e.crossFadeTo = function (t, e, n) {
      return t.crossFadeFrom(this, e, n);
    }, e.stopFading = function () {
      var t = this._weightInterpolant;return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }, e.setEffectiveTimeScale = function (t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    }, e.getEffectiveTimeScale = function () {
      return this._effectiveTimeScale;
    }, e.setDuration = function (t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    }, e.syncWith = function (t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    }, e.halt = function (t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    }, e.warp = function (t, e, n) {
      var r = this._mixer,
          i = r.time,
          a = this.timeScale,
          o = this._timeScaleInterpolant;null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);var s = o.parameterPositions,
          c = o.sampleValues;return s[0] = i, s[1] = i + n, c[0] = t / a, c[1] = e / a, this;
    }, e.stopWarping = function () {
      var t = this._timeScaleInterpolant;return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }, e.getMixer = function () {
      return this._mixer;
    }, e.getClip = function () {
      return this._clip;
    }, e.getRoot = function () {
      return this._localRoot || this._mixer._root;
    }, e._update = function (t, e, n, r) {
      if (this.enabled) {
        var i = this._startTime;if (null !== i) {
          var a = (t - i) * n;if (a < 0 || 0 === n) return;this._startTime = null, e = n * a;
        }e *= this._updateTimeScale(t);var o = this._updateTime(e),
            s = this._updateWeight(t);if (s > 0) {
          var c = this._interpolants,
              l = this._propertyBindings;switch (this.blendMode) {case j:
              for (var u = 0, h = c.length; u !== h; ++u) {
                c[u].evaluate(o), l[u].accumulateAdditive(s);
              }break;case W:default:
              for (var d = 0, p = c.length; d !== p; ++d) {
                c[d].evaluate(o), l[d].accumulate(r, s);
              }}
        }
      } else this._updateWeight(t);
    }, e._updateWeight = function (t) {
      var e = 0;if (this.enabled) {
        e = this.weight;var n = this._weightInterpolant;if (null !== n) {
          var r = n.evaluate(t)[0];e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1));
        }
      }return this._effectiveWeight = e, e;
    }, e._updateTimeScale = function (t) {
      var e = 0;if (!this.paused) {
        e = this.timeScale;var n = this._timeScaleInterpolant;if (null !== n) e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e);
      }return this._effectiveTimeScale = e, e;
    }, e._updateTime = function (t) {
      var e = this._clip.duration,
          n = this.loop,
          r = this.time + t,
          i = this._loopCount,
          a = 2202 === n;if (0 === t) return -1 === i ? r : a && 1 == (1 & i) ? e - r : r;if (2200 === n) {
        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));t: {
          if (r >= e) r = e;else {
            if (!(r < 0)) {
              this.time = r;break t;
            }r = 0;
          }this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 });
        }
      } else {
        if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= e || r < 0) {
          var o = Math.floor(r / e);r -= e * o, i += Math.abs(o);var s = this.repetitions - i;if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });else {
            if (1 === s) {
              var c = t < 0;this._setEndings(c, !c, a);
            } else this._setEndings(!1, !1, a);this._loopCount = i, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o });
          }
        } else this.time = r;if (a && 1 == (1 & i)) return e - r;
      }return r;
    }, e._setEndings = function (t, e, n) {
      var r = this._interpolantSettings;n ? (r.endingStart = k, r.endingEnd = k) : (r.endingStart = t ? this.zeroSlopeAtStart ? k : H : V, r.endingEnd = e ? this.zeroSlopeAtEnd ? k : H : V);
    }, e._scheduleFading = function (t, e, n) {
      var r = this._mixer,
          i = r.time,
          a = this._weightInterpolant;null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);var o = a.parameterPositions,
          s = a.sampleValues;return o[0] = i, s[0] = e, o[1] = i + t, s[1] = n, this;
    }, t;
  }();function ru(t) {
    this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }ru.prototype = _extends(Object.create(rt.prototype), { constructor: ru, _bindAction: function _bindAction(t, e) {
      var n = t._localRoot || this._root,
          r = t._clip.tracks,
          i = r.length,
          a = t._propertyBindings,
          o = t._interpolants,
          s = n.uuid,
          c = this._bindingsByRootAndName,
          l = c[s];void 0 === l && (l = {}, c[s] = l);for (var u = 0; u !== i; ++u) {
        var h = r[u],
            d = h.name,
            p = l[d];if (void 0 !== p) a[u] = p;else {
          if (void 0 !== (p = a[u])) {
            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));continue;
          }var f = e && e._propertyBindings[u].binding.parsedPath;++(p = new kl(tu.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), a[u] = p;
        }o[u].resultBuffer = p.buffer;
      }
    }, _activateAction: function _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          var e = (t._localRoot || this._root).uuid,
              n = t._clip.uuid,
              r = this._actionsByClip[n];this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e);
        }for (var i = t._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
          var s = i[a];0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState());
        }this._lendAction(t);
      }
    }, _deactivateAction: function _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
          var i = e[n];0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i));
        }this._takeBackAction(t);
      }
    }, _initMemoryManager: function _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;var t = this;this.stats = { actions: { get total() {
            return t._actions.length;
          }, get inUse() {
            return t._nActiveActions;
          } }, bindings: { get total() {
            return t._bindings.length;
          }, get inUse() {
            return t._nActiveBindings;
          } }, controlInterpolants: { get total() {
            return t._controlInterpolants.length;
          }, get inUse() {
            return t._nActiveControlInterpolants;
          } } };
    }, _isActiveAction: function _isActiveAction(t) {
      var e = t._cacheIndex;return null !== e && e < this._nActiveActions;
    }, _addInactiveAction: function _addInactiveAction(t, e, n) {
      var r = this._actions,
          i = this._actionsByClip,
          a = i[e];if (void 0 === a) a = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, i[e] = a;else {
        var o = a.knownActions;t._byClipCacheIndex = o.length, o.push(t);
      }t._cacheIndex = r.length, r.push(t), a.actionByRoot[n] = t;
    }, _removeInactiveAction: function _removeInactiveAction(t) {
      var e = this._actions,
          n = e[e.length - 1],
          r = t._cacheIndex;n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;var i = t._clip.uuid,
          a = this._actionsByClip,
          o = a[i],
          s = o.knownActions,
          c = s[s.length - 1],
          l = t._byClipCacheIndex;c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(t);
    }, _removeInactiveBindingsForAction: function _removeInactiveBindingsForAction(t) {
      for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
        var i = e[n];0 == --i.referenceCount && this._removeInactiveBinding(i);
      }
    }, _lendAction: function _lendAction(t) {
      var e = this._actions,
          n = t._cacheIndex,
          r = this._nActiveActions++,
          i = e[r];t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i;
    }, _takeBackAction: function _takeBackAction(t) {
      var e = this._actions,
          n = t._cacheIndex,
          r = --this._nActiveActions,
          i = e[r];t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i;
    }, _addInactiveBinding: function _addInactiveBinding(t, e, n) {
      var r = this._bindingsByRootAndName,
          i = this._bindings,
          a = r[e];void 0 === a && (a = {}, r[e] = a), a[n] = t, t._cacheIndex = i.length, i.push(t);
    }, _removeInactiveBinding: function _removeInactiveBinding(t) {
      var e = this._bindings,
          n = t.binding,
          r = n.rootNode.uuid,
          i = n.path,
          a = this._bindingsByRootAndName,
          o = a[r],
          s = e[e.length - 1],
          c = t._cacheIndex;s._cacheIndex = c, e[c] = s, e.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r];
    }, _lendBinding: function _lendBinding(t) {
      var e = this._bindings,
          n = t._cacheIndex,
          r = this._nActiveBindings++,
          i = e[r];t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i;
    }, _takeBackBinding: function _takeBackBinding(t) {
      var e = this._bindings,
          n = t._cacheIndex,
          r = --this._nActiveBindings,
          i = e[r];t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i;
    }, _lendControlInterpolant: function _lendControlInterpolant() {
      var t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++,
          n = t[e];return void 0 === n && ((n = new $s(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n;
    }, _takeBackControlInterpolant: function _takeBackControlInterpolant(t) {
      var e = this._controlInterpolants,
          n = t.__cacheIndex,
          r = --this._nActiveControlInterpolants,
          i = e[r];t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i;
    }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function clipAction(t, e, n) {
      var r = e || this._root,
          i = r.uuid,
          a = "string" == typeof t ? lc.findByName(r, t) : t,
          o = null !== a ? a.uuid : t,
          s = this._actionsByClip[o],
          c = null;if (void 0 === n && (n = null !== a ? a.blendMode : W), void 0 !== s) {
        var l = s.actionByRoot[i];if (void 0 !== l && l.blendMode === n) return l;c = s.knownActions[0], null === a && (a = c._clip);
      }if (null === a) return null;var u = new nu(this, a, e, n);return this._bindAction(u, c), this._addInactiveAction(u, o, i), u;
    }, existingAction: function existingAction(t, e) {
      var n = e || this._root,
          r = n.uuid,
          i = "string" == typeof t ? lc.findByName(n, t) : t,
          a = i ? i.uuid : t,
          o = this._actionsByClip[a];return void 0 !== o && o.actionByRoot[r] || null;
    }, stopAllAction: function stopAllAction() {
      for (var t = this._actions, e = this._nActiveActions - 1; e >= 0; --e) {
        t[e].stop();
      }return this;
    }, update: function update(t) {
      t *= this.timeScale;for (var e = this._actions, n = this._nActiveActions, r = this.time += t, i = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
        e[o]._update(r, t, i, a);
      }for (var s = this._bindings, c = this._nActiveBindings, l = 0; l !== c; ++l) {
        s[l].apply(a);
      }return this;
    }, setTime: function setTime(t) {
      this.time = 0;for (var e = 0; e < this._actions.length; e++) {
        this._actions[e].time = 0;
      }return this.update(t);
    }, getRoot: function getRoot() {
      return this._root;
    }, uncacheClip: function uncacheClip(t) {
      var e = this._actions,
          n = t.uuid,
          r = this._actionsByClip,
          i = r[n];if (void 0 !== i) {
        for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
          var c = a[o];this._deactivateAction(c);var l = c._cacheIndex,
              u = e[e.length - 1];c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = l, e[l] = u, e.pop(), this._removeInactiveBindingsForAction(c);
        }delete r[n];
      }
    }, uncacheRoot: function uncacheRoot(t) {
      var e = t.uuid,
          n = this._actionsByClip;for (var r in n) {
        var i = n[r].actionByRoot[e];void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
      }var a = this._bindingsByRootAndName[e];if (void 0 !== a) for (var o in a) {
        var s = a[o];s.restoreOriginalState(), this._removeInactiveBinding(s);
      }
    }, uncacheAction: function uncacheAction(t, e) {
      var n = this.existingAction(t, e);null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
    } });var iu = function () {
    function t(t) {
      "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t;
    }return t.prototype.clone = function () {
      return new t(void 0 === this.value.clone ? this.value : this.value.clone());
    }, t;
  }();function au(t, e, n) {
    ca.call(this, t, e), this.meshPerAttribute = n || 1;
  }function ou(t, e, n, r, i) {
    this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0;
  }function su(t, e, n, r) {
    this.ray = new Zt(t, e), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new se(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function get() {
          return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
        } } });
  }function cu(t, e) {
    return t.distance - e.distance;
  }function lu(t, e, n, r) {
    if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) for (var i = t.children, a = 0, o = i.length; a < o; a++) {
      lu(i[a], e, n, !0);
    }
  }au.prototype = _extends(Object.create(ca.prototype), { constructor: au, isInstancedInterleavedBuffer: !0, copy: function copy(t) {
      return ca.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
    }, clone: function clone(t) {
      var e = ca.prototype.clone.call(this, t);return e.meshPerAttribute = this.meshPerAttribute, e;
    }, toJSON: function toJSON(t) {
      var e = ca.prototype.toJSON.call(this, t);return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
    } }), Object.defineProperty(ou.prototype, "needsUpdate", { set: function set(t) {
      !0 === t && this.version++;
    } }), _extends(ou.prototype, { isGLBufferAttribute: !0, setBuffer: function setBuffer(t) {
      return this.buffer = t, this;
    }, setType: function setType(t, e) {
      return this.type = t, this.elementSize = e, this;
    }, setItemSize: function setItemSize(t) {
      return this.itemSize = t, this;
    }, setCount: function setCount(t) {
      return this.count = t, this;
    } }), _extends(su.prototype, { set: function set(t, e) {
      this.ray.set(t, e);
    }, setFromCamera: function setFromCamera(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.");
    }, intersectObject: function intersectObject(t, e, n) {
      var r = n || [];return lu(t, this, r, e), r.sort(cu), r;
    }, intersectObjects: function intersectObjects(t, e, n) {
      var r = n || [];if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;for (var i = 0, a = t.length; i < a; i++) {
        lu(t[i], this, r, e);
      }return r.sort(cu), r;
    } });var uu = function () {
    function t(t, e, n) {
      return void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), this.radius = t, this.phi = e, this.theta = n, this;
    }var e = t.prototype;return e.set = function (t, e, n) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    }, e.makeSafe = function () {
      var t = 1e-6;return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this;
    }, e.setFromVector3 = function (t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }, e.setFromCartesianCoords = function (t, e, n) {
      return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(st.clamp(e / this.radius, -1, 1))), this;
    }, t;
  }(),
      hu = function () {
    function t(t, e, n) {
      return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this;
    }var e = t.prototype;return e.set = function (t, e, n) {
      return this.radius = t, this.theta = e, this.y = n, this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    }, e.setFromVector3 = function (t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }, e.setFromCartesianCoords = function (t, e, n) {
      return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this;
    }, t;
  }(),
      du = new pt(),
      pu = function () {
    function t(t, e) {
      Object.defineProperty(this, "isBox2", { value: !0 }), this.min = void 0 !== t ? t : new pt(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new pt(-1 / 0, -1 / 0);
    }var e = t.prototype;return e.set = function (t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }, e.setFromPoints = function (t) {
      this.makeEmpty();for (var e = 0, n = t.length; e < n; e++) {
        this.expandByPoint(t[e]);
      }return this;
    }, e.setFromCenterAndSize = function (t, e) {
      var n = du.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }, e.makeEmpty = function () {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }, e.isEmpty = function () {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }, e.getCenter = function (t) {
      return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new pt()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
    }, e.getSize = function (t) {
      return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new pt()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    }, e.expandByPoint = function (t) {
      return this.min.min(t), this.max.max(t), this;
    }, e.expandByVector = function (t) {
      return this.min.sub(t), this.max.add(t), this;
    }, e.expandByScalar = function (t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }, e.containsPoint = function (t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    }, e.containsBox = function (t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    }, e.getParameter = function (t, e) {
      return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new pt()), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
    }, e.intersectsBox = function (t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    }, e.clampPoint = function (t, e) {
      return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new pt()), e.copy(t).clamp(this.min, this.max);
    }, e.distanceToPoint = function (t) {
      return du.copy(t).clamp(this.min, this.max).sub(t).length();
    }, e.intersect = function (t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    }, e.union = function (t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }, e.translate = function (t) {
      return this.min.add(t), this.max.add(t), this;
    }, e.equals = function (t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }, t;
  }(),
      fu = new wt(),
      mu = new wt(),
      vu = function () {
    function t(t, e) {
      this.start = void 0 !== t ? t : new wt(), this.end = void 0 !== e ? e : new wt();
    }var e = t.prototype;return e.set = function (t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    }, e.clone = function () {
      return new this.constructor().copy(this);
    }, e.copy = function (t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    }, e.getCenter = function (t) {
      return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new wt()), t.addVectors(this.start, this.end).multiplyScalar(.5);
    }, e.delta = function (t) {
      return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new wt()), t.subVectors(this.end, this.start);
    }, e.distanceSq = function () {
      return this.start.distanceToSquared(this.end);
    }, e.distance = function () {
      return this.start.distanceTo(this.end);
    }, e.at = function (t, e) {
      return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new wt()), this.delta(e).multiplyScalar(t).add(this.start);
    }, e.closestPointToPointParameter = function (t, e) {
      fu.subVectors(t, this.start), mu.subVectors(this.end, this.start);var n = mu.dot(mu),
          r = mu.dot(fu) / n;return e && (r = st.clamp(r, 0, 1)), r;
    }, e.closestPointToPoint = function (t, e, n) {
      var r = this.closestPointToPointParameter(t, e);return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new wt()), this.delta(n).multiplyScalar(r).add(this.start);
    }, e.applyMatrix4 = function (t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    }, e.equals = function (t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }, t;
  }();function gu(t) {
    be.call(this), this.material = t, this.render = function () {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
  }gu.prototype = Object.create(be.prototype), gu.prototype.constructor = gu, gu.prototype.isImmediateRenderObject = !0;var yu = new wt(),
      xu = function (t) {
    function e(e, n) {
      var r;(r = t.call(this) || this).light = e, r.light.updateMatrixWorld(), r.matrix = e.matrixWorld, r.matrixAutoUpdate = !1, r.color = n;for (var i = new vn(), a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], o = 0, s = 1; o < 32; o++, s++) {
        var c = o / 32 * Math.PI * 2,
            l = s / 32 * Math.PI * 2;a.push(Math.cos(c), Math.sin(c), 1, Math.cos(l), Math.sin(l), 1);
      }i.setAttribute("position", new an(a, 3));var u = new ja({ fog: !1, toneMapped: !1 });return r.cone = new to(i, u), r.add(r.cone), r.update(), r;
    }ut(e, t);var n = e.prototype;return n.dispose = function () {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }, n.update = function () {
      this.light.updateMatrixWorld();var t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);this.cone.scale.set(e, e, t), yu.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(yu), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }, e;
  }(be),
      _u = new wt(),
      bu = new Jt(),
      wu = new Jt(),
      Mu = function (t) {
    function e(e) {
      for (var n, r = Su(e), i = new vn(), a = [], o = [], s = new Ve(0, 0, 1), c = new Ve(0, 1, 0), l = 0; l < r.length; l++) {
        var u = r[l];u.parent && u.parent.isBone && (a.push(0, 0, 0), a.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(c.r, c.g, c.b));
      }i.setAttribute("position", new an(a, 3)), i.setAttribute("color", new an(o, 3));var h = new ja({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });return (n = t.call(this, i, h) || this).type = "SkeletonHelper", n.isSkeletonHelper = !0, n.root = e, n.bones = r, n.matrix = e.matrixWorld, n.matrixAutoUpdate = !1, n;
    }return ut(e, t), e.prototype.updateMatrixWorld = function (e) {
      var n = this.bones,
          r = this.geometry,
          i = r.getAttribute("position");wu.getInverse(this.root.matrixWorld);for (var a = 0, o = 0; a < n.length; a++) {
        var s = n[a];s.parent && s.parent.isBone && (bu.multiplyMatrices(wu, s.matrixWorld), _u.setFromMatrixPosition(bu), i.setXYZ(o, _u.x, _u.y, _u.z), bu.multiplyMatrices(wu, s.parent.matrixWorld), _u.setFromMatrixPosition(bu), i.setXYZ(o + 1, _u.x, _u.y, _u.z), o += 2);
      }r.getAttribute("position").needsUpdate = !0, t.prototype.updateMatrixWorld.call(this, e);
    }, e;
  }(to);function Su(t) {
    var e = [];t && t.isBone && e.push(t);for (var n = 0; n < t.children.length; n++) {
      e.push.apply(e, Su(t.children[n]));
    }return e;
  }var Tu = function (t) {
    function e(e, n, r) {
      var i,
          a = new Ts(n, 4, 2),
          o = new Xe({ wireframe: !0, fog: !1, toneMapped: !1 });return (i = t.call(this, a, o) || this).light = e, i.light.updateMatrixWorld(), i.color = r, i.type = "PointLightHelper", i.matrix = i.light.matrixWorld, i.matrixAutoUpdate = !1, i.update(), i;
    }ut(e, t);var n = e.prototype;return n.dispose = function () {
      this.geometry.dispose(), this.material.dispose();
    }, n.update = function () {
      void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }, e;
  }(On),
      Eu = new wt(),
      Au = new Ve(),
      Lu = new Ve(),
      Ru = function (t) {
    function e(e, n, r) {
      var i;(i = t.call(this) || this).light = e, i.light.updateMatrixWorld(), i.matrix = e.matrixWorld, i.matrixAutoUpdate = !1, i.color = r;var a = new ms(n);a.rotateY(.5 * Math.PI), i.material = new Xe({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === i.color && (i.material.vertexColors = !0);var o = a.getAttribute("position"),
          s = new Float32Array(3 * o.count);return a.setAttribute("color", new Je(s, 3)), i.add(new On(a, i.material)), i.update(), i;
    }ut(e, t);var n = e.prototype;return n.dispose = function () {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, n.update = function () {
      var t = this.children[0];if (void 0 !== this.color) this.material.color.set(this.color);else {
        var e = t.geometry.getAttribute("color");Au.copy(this.light.color), Lu.copy(this.light.groundColor);for (var n = 0, r = e.count; n < r; n++) {
          var i = n < r / 2 ? Au : Lu;e.setXYZ(n, i.r, i.g, i.b);
        }e.needsUpdate = !0;
      }t.lookAt(Eu.setFromMatrixPosition(this.light.matrixWorld).negate());
    }, e;
  }(be),
      Cu = function (t) {
    function e(e, n, r, i) {
      var a;e = e || 10, n = n || 10, r = new Ve(void 0 !== r ? r : 4473924), i = new Ve(void 0 !== i ? i : 8947848);for (var o = n / 2, s = e / n, c = e / 2, l = [], u = [], h = 0, d = 0, p = -c; h <= n; h++, p += s) {
        l.push(-c, 0, p, c, 0, p), l.push(p, 0, -c, p, 0, c);var f = h === o ? r : i;f.toArray(u, d), d += 3, f.toArray(u, d), d += 3, f.toArray(u, d), d += 3, f.toArray(u, d), d += 3;
      }var m = new vn();m.setAttribute("position", new an(l, 3)), m.setAttribute("color", new an(u, 3));var v = new ja({ vertexColors: !0, toneMapped: !1 });return (a = t.call(this, m, v) || this).type = "GridHelper", a;
    }return ut(e, t), e;
  }(to),
      Pu = function (t) {
    function e(e, n, r, i, a, o) {
      var s;e = e || 10, n = n || 16, r = r || 8, i = i || 64, a = new Ve(void 0 !== a ? a : 4473924), o = new Ve(void 0 !== o ? o : 8947848);for (var c = [], l = [], u = 0; u <= n; u++) {
        var h = u / n * (2 * Math.PI),
            d = Math.sin(h) * e,
            p = Math.cos(h) * e;c.push(0, 0, 0), c.push(d, 0, p);var f = 1 & u ? a : o;l.push(f.r, f.g, f.b), l.push(f.r, f.g, f.b);
      }for (var m = 0; m <= r; m++) {
        for (var v = 1 & m ? a : o, g = e - e / r * m, y = 0; y < i; y++) {
          var x = y / i * (2 * Math.PI),
              _ = Math.sin(x) * g,
              b = Math.cos(x) * g;c.push(_, 0, b), l.push(v.r, v.g, v.b), x = (y + 1) / i * (2 * Math.PI), _ = Math.sin(x) * g, b = Math.cos(x) * g, c.push(_, 0, b), l.push(v.r, v.g, v.b);
        }
      }var w = new vn();w.setAttribute("position", new an(c, 3)), w.setAttribute("color", new an(l, 3));var M = new ja({ vertexColors: !0, toneMapped: !1 });return (s = t.call(this, w, M) || this).type = "PolarGridHelper", s;
    }return ut(e, t), e;
  }(to),
      Iu = new wt(),
      Du = new wt(),
      Ou = new wt(),
      Nu = function (t) {
    function e(e, n, r) {
      var i;(i = t.call(this) || this).light = e, i.light.updateMatrixWorld(), i.matrix = e.matrixWorld, i.matrixAutoUpdate = !1, i.color = r, void 0 === n && (n = 1);var a = new vn();a.setAttribute("position", new an([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3));var o = new ja({ fog: !1, toneMapped: !1 });return i.lightPlane = new Qa(a, o), i.add(i.lightPlane), (a = new vn()).setAttribute("position", new an([0, 0, 0, 0, 0, 1], 3)), i.targetLine = new Qa(a, o), i.add(i.targetLine), i.update(), i;
    }ut(e, t);var n = e.prototype;return n.dispose = function () {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }, n.update = function () {
      Iu.setFromMatrixPosition(this.light.matrixWorld), Du.setFromMatrixPosition(this.light.target.matrixWorld), Ou.subVectors(Du, Iu), this.lightPlane.lookAt(Du), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Du), this.targetLine.scale.z = Ou.length();
    }, e;
  }(be),
      Bu = new wt(),
      zu = new kn(),
      Gu = function (t) {
    function e(e) {
      var n,
          r = new vn(),
          i = new ja({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
          a = [],
          o = [],
          s = {},
          c = new Ve(16755200),
          l = new Ve(16711680),
          u = new Ve(43775),
          h = new Ve(16777215),
          d = new Ve(3355443);function p(t, e, n) {
        f(t, n), f(e, n);
      }function f(t, e) {
        a.push(0, 0, 0), o.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(a.length / 3 - 1);
      }return p("n1", "n2", c), p("n2", "n4", c), p("n4", "n3", c), p("n3", "n1", c), p("f1", "f2", c), p("f2", "f4", c), p("f4", "f3", c), p("f3", "f1", c), p("n1", "f1", c), p("n2", "f2", c), p("n3", "f3", c), p("n4", "f4", c), p("p", "n1", l), p("p", "n2", l), p("p", "n3", l), p("p", "n4", l), p("u1", "u2", u), p("u2", "u3", u), p("u3", "u1", u), p("c", "t", h), p("p", "c", d), p("cn1", "cn2", d), p("cn3", "cn4", d), p("cf1", "cf2", d), p("cf3", "cf4", d), r.setAttribute("position", new an(a, 3)), r.setAttribute("color", new an(o, 3)), (n = t.call(this, r, i) || this).type = "CameraHelper", n.camera = e, n.camera.updateProjectionMatrix && n.camera.updateProjectionMatrix(), n.matrix = e.matrixWorld, n.matrixAutoUpdate = !1, n.pointMap = s, n.update(), n;
    }return ut(e, t), e.prototype.update = function () {
      var t = this.geometry,
          e = this.pointMap;zu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Fu("c", e, t, zu, 0, 0, -1), Fu("t", e, t, zu, 0, 0, 1), Fu("n1", e, t, zu, -1, -1, -1), Fu("n2", e, t, zu, 1, -1, -1), Fu("n3", e, t, zu, -1, 1, -1), Fu("n4", e, t, zu, 1, 1, -1), Fu("f1", e, t, zu, -1, -1, 1), Fu("f2", e, t, zu, 1, -1, 1), Fu("f3", e, t, zu, -1, 1, 1), Fu("f4", e, t, zu, 1, 1, 1), Fu("u1", e, t, zu, .7, 1.1, -1), Fu("u2", e, t, zu, -.7, 1.1, -1), Fu("u3", e, t, zu, 0, 2, -1), Fu("cf1", e, t, zu, -1, 0, 1), Fu("cf2", e, t, zu, 1, 0, 1), Fu("cf3", e, t, zu, 0, -1, 1), Fu("cf4", e, t, zu, 0, 1, 1), Fu("cn1", e, t, zu, -1, 0, -1), Fu("cn2", e, t, zu, 1, 0, -1), Fu("cn3", e, t, zu, 0, -1, -1), Fu("cn4", e, t, zu, 0, 1, -1), t.getAttribute("position").needsUpdate = !0;
    }, e;
  }(to);function Fu(t, e, n, r, i, a, o) {
    Bu.set(i, a, o).unproject(r);var s = e[t];if (void 0 !== s) for (var c = n.getAttribute("position"), l = 0, u = s.length; l < u; l++) {
      c.setXYZ(s[l], Bu.x, Bu.y, Bu.z);
    }
  }var Uu,
      Hu,
      ku,
      Vu = new Tt(),
      Wu = function (t) {
    function e(e, n) {
      var r;void 0 === n && (n = 16776960);var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
          a = new Float32Array(24),
          o = new vn();return o.setIndex(new Je(i, 1)), o.setAttribute("position", new Je(a, 3)), (r = t.call(this, o, new ja({ color: n, toneMapped: !1 })) || this).object = e, r.type = "BoxHelper", r.matrixAutoUpdate = !1, r.update(), r;
    }ut(e, t);var n = e.prototype;return n.update = function (t) {
      if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Vu.setFromObject(this.object), !Vu.isEmpty()) {
        var e = Vu.min,
            n = Vu.max,
            r = this.geometry.attributes.position,
            i = r.array;i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = e.x, i[4] = n.y, i[5] = n.z, i[6] = e.x, i[7] = e.y, i[8] = n.z, i[9] = n.x, i[10] = e.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = e.z, i[15] = e.x, i[16] = n.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = n.x, i[22] = e.y, i[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
      }
    }, n.setFromObject = function (t) {
      return this.object = t, this.update(), this;
    }, n.copy = function (t) {
      return to.prototype.copy.call(this, t), this.object = t.object, this;
    }, e;
  }(to),
      ju = function (t) {
    function e(e, n) {
      var r;void 0 === n && (n = 16776960);var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
          a = new vn();return a.setIndex(new Je(i, 1)), a.setAttribute("position", new an([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), (r = t.call(this, a, new ja({ color: n, toneMapped: !1 })) || this).box = e, r.type = "Box3Helper", r.geometry.computeBoundingSphere(), r;
    }return ut(e, t), e.prototype.updateMatrixWorld = function (e) {
      var n = this.box;n.isEmpty() || (n.getCenter(this.position), n.getSize(this.scale), this.scale.multiplyScalar(.5), t.prototype.updateMatrixWorld.call(this, e));
    }, e;
  }(to),
      qu = function (t) {
    function e(e, n, r) {
      var i,
          a = void 0 !== r ? r : 16776960,
          o = new vn();o.setAttribute("position", new an([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), o.computeBoundingSphere(), (i = t.call(this, o, new ja({ color: a, toneMapped: !1 })) || this).type = "PlaneHelper", i.plane = e, i.size = void 0 === n ? 1 : n;var s = new vn();return s.setAttribute("position", new an([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), i.add(new On(s, new Xe({ color: a, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))), i;
    }return ut(e, t), e.prototype.updateMatrixWorld = function (e) {
      var n = -this.plane.constant;Math.abs(n) < 1e-8 && (n = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, n), this.children[0].material.side = n < 0 ? 1 : 0, this.lookAt(this.plane.normal), t.prototype.updateMatrixWorld.call(this, e);
    }, e;
  }(Qa),
      Xu = new wt(),
      Yu = function (t) {
    function e(e, n, r, i, a, o) {
      var s;return (s = t.call(this) || this).type = "ArrowHelper", void 0 === e && (e = new wt(0, 0, 1)), void 0 === n && (n = new wt(0, 0, 0)), void 0 === r && (r = 1), void 0 === i && (i = 16776960), void 0 === a && (a = .2 * r), void 0 === o && (o = .2 * a), void 0 === Uu && ((Uu = new vn()).setAttribute("position", new an([0, 0, 0, 0, 1, 0], 3)), (Hu = new wo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), s.position.copy(n), s.line = new Qa(Uu, new ja({ color: i, toneMapped: !1 })), s.line.matrixAutoUpdate = !1, s.add(s.line), s.cone = new On(Hu, new Xe({ color: i, toneMapped: !1 })), s.cone.matrixAutoUpdate = !1, s.add(s.cone), s.setDirection(e), s.setLength(r, a, o), s;
    }ut(e, t);var n = e.prototype;return n.setDirection = function (t) {
      if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);else {
        Xu.set(t.z, 0, -t.x).normalize();var e = Math.acos(t.y);this.quaternion.setFromAxisAngle(Xu, e);
      }
    }, n.setLength = function (t, e, n) {
      void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix();
    }, n.setColor = function (t) {
      this.line.material.color.set(t), this.cone.material.color.set(t);
    }, n.copy = function (e) {
      return t.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
    }, e;
  }(be),
      Zu = function (t) {
    function e(e) {
      var n;void 0 === e && (e = 1);var r = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
          i = new vn();i.setAttribute("position", new an(r, 3)), i.setAttribute("color", new an([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));var a = new ja({ vertexColors: !0, toneMapped: !1 });return (n = t.call(this, i, a) || this).type = "AxesHelper", n;
    }return ut(e, t), e;
  }(to),
      Ju = Math.pow(2, 8),
      Qu = [.125, .215, .35, .446, .526, .582],
      Ku = 5 + Qu.length,
      $u = 20,
      th = ((ku = {})[3e3] = 0, ku[3001] = 1, ku[3002] = 2, ku[3004] = 3, ku[3005] = 4, ku[3006] = 5, ku[3007] = 6, ku),
      eh = new $c(),
      nh = dh(),
      rh = nh._lodPlanes,
      ih = nh._sizeLods,
      ah = nh._sigmas,
      oh = null,
      sh = (1 + Math.sqrt(5)) / 2,
      ch = 1 / sh,
      lh = [new wt(1, 1, 1), new wt(-1, 1, 1), new wt(1, 1, -1), new wt(-1, 1, -1), new wt(0, sh, ch), new wt(0, sh, -ch), new wt(ch, 0, sh), new wt(-ch, 0, sh), new wt(sh, ch, 0), new wt(-sh, ch, 0)],
      uh = function () {
    function t(t) {
      var e, n, r;this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = (e = $u, n = new Float32Array(e), r = new wt(0, 1, 0), new Us({ name: "SphericalGaussianBlur", defines: { n: e }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r }, inputEncoding: { value: th[3e3] }, outputEncoding: { value: th[3e3] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 })), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
    }var e = t.prototype;return e.fromScene = function (t, e, n, r) {
      void 0 === e && (e = 0), void 0 === n && (n = .1), void 0 === r && (r = 100), oh = this._renderer.getRenderTarget();var i = this._allocateTargets();return this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i;
    }, e.fromEquirectangular = function (t) {
      return this._fromTexture(t);
    }, e.fromCubemap = function (t) {
      return this._fromTexture(t);
    }, e.compileCubemapShader = function () {
      null === this._cubemapShader && (this._cubemapShader = vh(), this._compileMaterial(this._cubemapShader));
    }, e.compileEquirectangularShader = function () {
      null === this._equirectShader && (this._equirectShader = mh(), this._compileMaterial(this._equirectShader));
    }, e.dispose = function () {
      this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();for (var t = 0; t < rh.length; t++) {
        rh[t].dispose();
      }
    }, e._cleanup = function (t) {
      this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(oh), t.scissorTest = !1, fh(t, 0, 0, t.width, t.height);
    }, e._fromTexture = function (t) {
      oh = this._renderer.getRenderTarget();var e = this._allocateTargets(t);return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
    }, e._allocateTargets = function (t) {
      var e = { magFilter: d, minFilter: d, generateMipmaps: !1, type: y, format: 1023, encoding: hh(t) ? t.encoding : Z, depthBuffer: !1 },
          n = ph(e);return n.depthBuffer = !t, this._pingPongRenderTarget = ph(e), n;
    }, e._compileMaterial = function (t) {
      var e = new On(rh[0], t);this._renderer.compile(e, eh);
    }, e._sceneToCubeUV = function (t, e, n, r) {
      var i = new Vn(90, 1, e, n),
          a = [1, -1, 1, 1, 1, 1],
          o = [1, 1, 1, -1, -1, -1],
          s = this._renderer,
          c = s.outputEncoding,
          l = s.toneMapping,
          u = s.getClearColor(),
          h = s.getClearAlpha();s.toneMapping = 0, s.outputEncoding = q;var d = t.background;if (d && d.isColor) {
        d.convertSRGBToLinear();var p = Math.max(d.r, d.g, d.b),
            f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127);d = d.multiplyScalar(Math.pow(2, -f));var m = (f + 128) / 255;s.setClearColor(d, m), t.background = null;
      }for (var v = 0; v < 6; v++) {
        var g = v % 3;0 == g ? (i.up.set(0, a[v], 0), i.lookAt(o[v], 0, 0)) : 1 == g ? (i.up.set(0, 0, a[v]), i.lookAt(0, o[v], 0)) : (i.up.set(0, a[v], 0), i.lookAt(0, 0, o[v])), fh(r, g * Ju, v > 2 ? Ju : 0, Ju, Ju), s.setRenderTarget(r), s.render(t, i);
      }s.toneMapping = l, s.outputEncoding = c, s.setClearColor(u, h);
    }, e._textureToCubeUV = function (t, e) {
      var n = this._renderer;t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = vh()) : null == this._equirectShader && (this._equirectShader = mh());var r = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
          i = new On(rh[0], r),
          a = r.uniforms;a.envMap.value = t, t.isCubeTexture || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), a.inputEncoding.value = th[t.encoding], a.outputEncoding.value = th[e.texture.encoding], fh(e, 0, 0, 3 * Ju, 2 * Ju), n.setRenderTarget(e), n.render(i, eh);
    }, e._applyPMREM = function (t) {
      var e = this._renderer,
          n = e.autoClear;e.autoClear = !1;for (var r = 1; r < Ku; r++) {
        var i = Math.sqrt(ah[r] * ah[r] - ah[r - 1] * ah[r - 1]),
            a = lh[(r - 1) % lh.length];this._blur(t, r - 1, r, i, a);
      }e.autoClear = n;
    }, e._blur = function (t, e, n, r, i) {
      var a = this._pingPongRenderTarget;this._halfBlur(t, a, e, n, r, "latitudinal", i), this._halfBlur(a, t, n, n, r, "longitudinal", i);
    }, e._halfBlur = function (t, e, n, r, i, a, o) {
      var s = this._renderer,
          c = this._blurMaterial;"latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");var l = new On(rh[r], c),
          u = c.uniforms,
          h = ih[n] - 1,
          d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
          p = i / d,
          f = isFinite(i) ? 1 + Math.floor(3 * p) : $u;f > $u && console.warn("sigmaRadians, " + i + ", is too large and will clip, as it requested " + f + " samples when the maximum is set to " + $u);for (var m = [], v = 0, g = 0; g < $u; ++g) {
        var y = g / p,
            x = Math.exp(-y * y / 2);m.push(x), 0 == g ? v += x : g < f && (v += 2 * x);
      }for (var _ = 0; _ < m.length; _++) {
        m[_] = m[_] / v;
      }u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, o && (u.poleAxis.value = o), u.dTheta.value = d, u.mipInt.value = 8 - n, u.inputEncoding.value = th[t.texture.encoding], u.outputEncoding.value = th[t.texture.encoding];var b = ih[r];fh(e, 3 * Math.max(0, Ju - 2 * b), (0 === r ? 0 : 2 * Ju) + 2 * b * (r > 4 ? r - 8 + 4 : 0), 3 * b, 2 * b), s.setRenderTarget(e), s.render(l, eh);
    }, t;
  }();function hh(t) {
    return void 0 !== t && t.type === y && (t.encoding === q || t.encoding === X || t.encoding === Y);
  }function dh() {
    for (var t = [], e = [], n = [], r = 8, i = 0; i < Ku; i++) {
      var a = Math.pow(2, r);e.push(a);var o = 1 / a;i > 4 ? o = Qu[i - 8 + 4 - 1] : 0 == i && (o = 0), n.push(o);for (var s = 1 / (a - 1), c = -s / 2, l = 1 + s / 2, u = [c, c, l, c, l, l, c, c, l, l, c, l], h = new Float32Array(108), d = new Float32Array(72), p = new Float32Array(36), f = 0; f < 6; f++) {
        var m = f % 3 * 2 / 3 - 1,
            v = f > 2 ? 0 : -1,
            g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, v + 1, 0, m, v, 0, m + 2 / 3, v + 1, 0, m, v + 1, 0];h.set(g, 18 * f), d.set(u, 12 * f);var y = [f, f, f, f, f, f];p.set(y, 6 * f);
      }var x = new vn();x.setAttribute("position", new Je(h, 3)), x.setAttribute("uv", new Je(d, 2)), x.setAttribute("faceIndex", new Je(p, 1)), t.push(x), r > 4 && r--;
    }return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
  }function ph(t) {
    var e = new xt(3 * Ju, 3 * Ju, t);return e.texture.mapping = s, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e;
  }function fh(t, e, n, r, i) {
    t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
  }function mh() {
    return new Us({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: new pt(1, 1) }, inputEncoding: { value: th[3e3] }, outputEncoding: { value: th[3e3] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 });
  }function vh() {
    return new Us({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: th[3e3] }, outputEncoding: { value: th[3e3] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 });
  }function gh(t) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Pc.call(this, t), this.type = "catmullrom", this.closed = !0;
  }function yh(t) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Pc.call(this, t), this.type = "catmullrom";
  }function xh(t) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Pc.call(this, t), this.type = "catmullrom";
  }Mc.create = function (t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Mc.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
  }, _extends(Vc.prototype, { createPointsGeometry: function createPointsGeometry(t) {
      console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");var e = this.getPoints(t);return this.createGeometry(e);
    }, createSpacedPointsGeometry: function createSpacedPointsGeometry(t) {
      console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");var e = this.getSpacedPoints(t);return this.createGeometry(e);
    }, createGeometry: function createGeometry(t) {
      console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");for (var e = new yo(), n = 0, r = t.length; n < r; n++) {
        var i = t[n];e.vertices.push(new wt(i.x, i.y, i.z || 0));
      }return e;
    } }), _extends(Wc.prototype, { fromPoints: function fromPoints(t) {
      return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
    } }), gh.prototype = Object.create(Pc.prototype), yh.prototype = Object.create(Pc.prototype), xh.prototype = Object.create(Pc.prototype), _extends(xh.prototype, { initFromArray: function initFromArray() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    }, getControlPointsArray: function getControlPointsArray() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    }, reparametrizeByArcLength: function reparametrizeByArcLength() {
      console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
    } }), Cu.prototype.setColors = function () {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  }, Mu.prototype.update = function () {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  }, _extends(fc.prototype, { extractUrlBase: function extractUrlBase(t) {
      return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), sl.extractUrlBase(t);
    } }), fc.Handlers = { add: function add() {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    }, get: function get() {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    } }, _extends(pu.prototype, { center: function center(t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
    }, empty: function empty() {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, isIntersectionBox: function isIntersectionBox(t) {
      return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, size: function size(t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
    } }), _extends(Tt.prototype, { center: function center(t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
    }, empty: function empty() {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    }, isIntersectionBox: function isIntersectionBox(t) {
      return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, isIntersectionSphere: function isIntersectionSphere(t) {
      return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
    }, size: function size(t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
    } }), _extends(Ht.prototype, { empty: function empty() {
      return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
    } }), Qn.prototype.setFromMatrix = function (t) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
  }, vu.prototype.center = function (t) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  }, _extends(st, { random16: function random16() {
      return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
    }, nearestPowerOfTwo: function nearestPowerOfTwo(t) {
      return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), st.floorPowerOfTwo(t);
    }, nextPowerOfTwo: function nextPowerOfTwo(t) {
      return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), st.ceilPowerOfTwo(t);
    } }), _extends(ft.prototype, { flattenToArrayOffset: function flattenToArrayOffset(t, e) {
      return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
    }, multiplyVector3: function multiplyVector3(t) {
      return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
    }, multiplyVector3Array: function multiplyVector3Array() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    }, applyToBufferAttribute: function applyToBufferAttribute(t) {
      return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
    }, applyToVector3Array: function applyToVector3Array() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    } }), _extends(Jt.prototype, { extractPosition: function extractPosition(t) {
      return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
    }, flattenToArrayOffset: function flattenToArrayOffset(t, e) {
      return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
    }, getPosition: function getPosition() {
      return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new wt().setFromMatrixColumn(this, 3);
    }, setRotationFromQuaternion: function setRotationFromQuaternion(t) {
      return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
    }, multiplyToArray: function multiplyToArray() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    }, multiplyVector3: function multiplyVector3(t) {
      return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, multiplyVector4: function multiplyVector4(t) {
      return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, multiplyVector3Array: function multiplyVector3Array() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    }, rotateAxis: function rotateAxis(t) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
    }, crossVector: function crossVector(t) {
      return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, translate: function translate() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    }, rotateX: function rotateX() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    }, rotateY: function rotateY() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    }, rotateZ: function rotateZ() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    }, rotateByAxis: function rotateByAxis() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    }, applyToBufferAttribute: function applyToBufferAttribute(t) {
      return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
    }, applyToVector3Array: function applyToVector3Array() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    }, makeFrustum: function makeFrustum(t, e, n, r, i, a) {
      return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, a);
    } }), Te.prototype.isIntersectionLine = function (t) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
  }, bt.prototype.multiplyVector3 = function (t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
  }, _extends(Zt.prototype, { isIntersectionBox: function isIntersectionBox(t) {
      return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
    }, isIntersectionPlane: function isIntersectionPlane(t) {
      return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
    }, isIntersectionSphere: function isIntersectionSphere(t) {
      return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
    } }), _extends(Be.prototype, { area: function area() {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
    }, barycoordFromPoint: function barycoordFromPoint(t, e) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
    }, midpoint: function midpoint(t) {
      return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
    }, normal: function normal(t) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
    }, plane: function plane(t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
    } }), _extends(Be, { barycoordFromPoint: function barycoordFromPoint(t, e, n, r, i) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Be.getBarycoord(t, e, n, r, i);
    }, normal: function normal(t, e, n, r) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Be.getNormal(t, e, n, r);
    } }), _extends(jc.prototype, { extractAllPoints: function extractAllPoints(t) {
      return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
    }, extrude: function extrude(t) {
      return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new us(this, t);
    }, makeGeometry: function makeGeometry(t) {
      return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ss(this, t);
    } }), _extends(pt.prototype, { fromAttribute: function fromAttribute(t, e, n) {
      return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
    }, distanceToManhattan: function distanceToManhattan(t) {
      return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
    }, lengthManhattan: function lengthManhattan() {
      return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    } }), _extends(wt.prototype, { setEulerFromRotationMatrix: function setEulerFromRotationMatrix() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    }, setEulerFromQuaternion: function setEulerFromQuaternion() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    }, getPositionFromMatrix: function getPositionFromMatrix(t) {
      return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
    }, getScaleFromMatrix: function getScaleFromMatrix(t) {
      return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
    }, getColumnFromMatrix: function getColumnFromMatrix(t, e) {
      return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
    }, applyProjection: function applyProjection(t) {
      return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
    }, fromAttribute: function fromAttribute(t, e, n) {
      return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
    }, distanceToManhattan: function distanceToManhattan(t) {
      return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
    }, lengthManhattan: function lengthManhattan() {
      return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    } }), _extends(yt.prototype, { fromAttribute: function fromAttribute(t, e, n) {
      return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
    }, lengthManhattan: function lengthManhattan() {
      return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
    } }), _extends(yo.prototype, { computeTangents: function computeTangents() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    }, computeLineDistances: function computeLineDistances() {
      console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    }, applyMatrix: function applyMatrix(t) {
      return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    } }), _extends(be.prototype, { getChildByName: function getChildByName(t) {
      return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
    }, renderDepth: function renderDepth() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    }, translate: function translate(t, e) {
      return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
    }, getWorldRotation: function getWorldRotation() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    }, applyMatrix: function applyMatrix(t) {
      return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    } }), Object.defineProperties(be.prototype, { eulerOrder: { get: function get() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      }, set: function set(t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
      } }, useQuaternion: { get: function get() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }, set: function set() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      } } }), _extends(On.prototype, { setDrawMode: function setDrawMode() {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    } }), Object.defineProperties(On.prototype, { drawMode: { get: function get() {
        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
      }, set: function set() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      } } }), Object.defineProperties(Oa.prototype, { objects: { get: function get() {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
      } } }), Object.defineProperty(Ga.prototype, "useVertexTexture", { get: function get() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }, set: function set() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    } }), Na.prototype.initBones = function () {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  }, Object.defineProperty(Mc.prototype, "__arcLengthDivisions", { get: function get() {
      return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
    }, set: function set(t) {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t;
    } }), Vn.prototype.setLens = function (t, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
  }, Object.defineProperties(qc.prototype, { onlyShadow: { set: function set() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      } }, shadowCameraFov: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
      } }, shadowCameraLeft: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
      } }, shadowCameraRight: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
      } }, shadowCameraTop: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
      } }, shadowCameraBottom: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
      } }, shadowCameraNear: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
      } }, shadowCameraFar: { set: function set(t) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
      } }, shadowCameraVisible: { set: function set() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      } }, shadowBias: { set: function set(t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
      } }, shadowDarkness: { set: function set() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      } }, shadowMapWidth: { set: function set(t) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
      } }, shadowMapHeight: { set: function set(t) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
      } } }), Object.defineProperties(Je.prototype, { length: { get: function get() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
      } }, dynamic: { get: function get() {
        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === et;
      }, set: function set() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(et);
      } } }), _extends(Je.prototype, { setDynamic: function setDynamic(t) {
      return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? et : tt), this;
    }, copyIndicesArray: function copyIndicesArray() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }, setArray: function setArray() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    } }), _extends(vn.prototype, { addIndex: function addIndex(t) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
    }, addAttribute: function addAttribute(t, e) {
      return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Je(arguments[1], arguments[2])));
    }, addDrawCall: function addDrawCall(t, e, n) {
      void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
    }, clearDrawCalls: function clearDrawCalls() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
    }, computeTangents: function computeTangents() {
      console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    }, computeOffsets: function computeOffsets() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }, removeAttribute: function removeAttribute(t) {
      return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
    }, applyMatrix: function applyMatrix(t) {
      return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
    } }), Object.defineProperties(vn.prototype, { drawcalls: { get: function get() {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
      } }, offsets: { get: function get() {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
      } } }), Object.defineProperties(cl.prototype, { maxInstancedCount: { get: function get() {
        return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
      }, set: function set(t) {
        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t;
      } } }), Object.defineProperties(su.prototype, { linePrecision: { get: function get() {
        return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
      }, set: function set(t) {
        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t;
      } } }), Object.defineProperties(ca.prototype, { dynamic: { get: function get() {
        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === et;
      }, set: function set(t) {
        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t);
      } } }), _extends(ca.prototype, { setDynamic: function setDynamic(t) {
      return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? et : tt), this;
    }, setArray: function setArray() {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    } }), _extends(cs.prototype, { getArrays: function getArrays() {
      console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
    }, addShapeList: function addShapeList() {
      console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
    }, addShape: function addShape() {
      console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
    } }), _extends(sa.prototype, { dispose: function dispose() {
      console.error("THREE.Scene: .dispose() has been removed.");
    } }), Object.defineProperties(iu.prototype, { dynamic: { set: function set() {
        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
      } }, onUpdate: { value: function value() {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
      } } }), Object.defineProperties(qe.prototype, { wrapAround: { get: function get() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }, set: function set() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      } }, overdraw: { get: function get() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }, set: function set() {
        console.warn("THREE.Material: .overdraw has been removed.");
      } }, wrapRGB: { get: function get() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new Ve();
      } }, shading: { get: function get() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      }, set: function set(t) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
      } }, stencilMask: { get: function get() {
        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
      }, set: function set(t) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
      } } }), Object.defineProperties(Vs.prototype, { metal: { get: function get() {
        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
      }, set: function set() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
      } } }), Object.defineProperties(ks.prototype, { transparency: { get: function get() {
        return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission;
      }, set: function set(t) {
        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t;
      } } }), Object.defineProperties(Hn.prototype, { derivatives: { get: function get() {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
      }, set: function set(t) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
      } } }), _extends(ra.prototype, { clearTarget: function clearTarget(t, e, n, r) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r);
    }, animate: function animate(t) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
    }, getCurrentRenderTarget: function getCurrentRenderTarget() {
      return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
    }, getMaxAnisotropy: function getMaxAnisotropy() {
      return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
    }, getPrecision: function getPrecision() {
      return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
    }, resetGLState: function resetGLState() {
      return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
    }, supportsFloatTextures: function supportsFloatTextures() {
      return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
    }, supportsHalfFloatTextures: function supportsHalfFloatTextures() {
      return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
    }, supportsStandardDerivatives: function supportsStandardDerivatives() {
      return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
    }, supportsCompressedTextureS3TC: function supportsCompressedTextureS3TC() {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
    }, supportsCompressedTexturePVRTC: function supportsCompressedTexturePVRTC() {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
    }, supportsBlendMinMax: function supportsBlendMinMax() {
      return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
    }, supportsVertexTextures: function supportsVertexTextures() {
      return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
    }, supportsInstancedArrays: function supportsInstancedArrays() {
      return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
    }, enableScissorTest: function enableScissorTest(t) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
    }, initMaterial: function initMaterial() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    }, addPrePlugin: function addPrePlugin() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    }, addPostPlugin: function addPostPlugin() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    }, updateShadowMap: function updateShadowMap() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    }, setFaceCulling: function setFaceCulling() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }, allocTextureUnit: function allocTextureUnit() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    }, setTexture: function setTexture() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    }, setTexture2D: function setTexture2D() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    }, setTextureCube: function setTextureCube() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    }, getActiveMipMapLevel: function getActiveMipMapLevel() {
      return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
    } }), Object.defineProperties(ra.prototype, { shadowMapEnabled: { get: function get() {
        return this.shadowMap.enabled;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
      } }, shadowMapType: { get: function get() {
        return this.shadowMap.type;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
      } }, shadowMapCullFace: { get: function get() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }, set: function set() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      } }, context: { get: function get() {
        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
      } }, vr: { get: function get() {
        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
      } }, gammaInput: { get: function get() {
        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
      }, set: function set() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      } }, gammaOutput: { get: function get() {
        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? X : q;
      } }, toneMappingWhitePoint: { get: function get() {
        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
      }, set: function set() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      } } }), Object.defineProperties(Yi.prototype, { cullFace: { get: function get() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }, set: function set() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      } }, renderReverseSided: { get: function get() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }, set: function set() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      } }, renderSingleSided: { get: function get() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }, set: function set() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      } } }), Object.defineProperties(xt.prototype, { wrapS: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
      } }, wrapT: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
      } }, magFilter: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
      } }, minFilter: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
      } }, anisotropy: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
      } }, offset: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
      } }, repeat: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
      } }, format: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
      } }, type: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
      } }, generateMipmaps: { get: function get() {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
      }, set: function set(t) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
      } } }), Object.defineProperties(Nl.prototype, { load: { value: function value(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");var e = this;return new Ml().load(t, function (t) {
          e.setBuffer(t);
        }), this;
      } }, startTime: { set: function set() {
        console.warn("THREE.Audio: .startTime is now .play( delay ).");
      } } }), Hl.prototype.getData = function () {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  }, jn.prototype.updateCubeMap = function (t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
  }, jn.prototype.clear = function (t, e, n, r) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r);
  };var _h = { merge: function merge(t, e, n) {
      var r;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, n);
    }, center: function center(t) {
      return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center();
    } };mt.crossOrigin = void 0, mt.loadTexture = function (t, e, n, r) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var i = new wc();i.setCrossOrigin(this.crossOrigin);var a = i.load(t, n, void 0, r);return e && (a.mapping = e), a;
  }, mt.loadTextureCube = function (t, e, n, r) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");var i = new _c();i.setCrossOrigin(this.crossOrigin);var a = i.load(t, n, void 0, r);return e && (a.mapping = e), a;
  }, mt.loadCompressedTexture = function () {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  }, mt.loadCompressedTextureCube = function () {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };var bh = { createMultiMaterialObject: function createMultiMaterialObject() {
      console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
    }, detach: function detach() {
      console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
    }, attach: function attach() {
      console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
    } };"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "122" } })), t.ACESFilmicToneMapping = 4, t.AddEquation = e, t.AddOperation = 2, t.AdditiveAnimationBlendMode = j, t.AdditiveBlending = 2, t.AlphaFormat = 1021, t.AlwaysDepth = 1, t.AlwaysStencilFunc = 519, t.AmbientLight = nl, t.AmbientLightProbe = Tl, t.AnimationClip = lc, t.AnimationLoader = gc, t.AnimationMixer = ru, t.AnimationObjectGroup = eu, t.AnimationUtils = Js, t.ArcCurve = Tc, t.ArrayCamera = Ki, t.ArrowHelper = Yu, t.Audio = Nl, t.AudioAnalyser = Hl, t.AudioContext = wl, t.AudioListener = Ol, t.AudioLoader = Ml, t.AxesHelper = Zu, t.AxisHelper = function (t) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Zu(t);
  }, t.BackSide = 1, t.BasicDepthPacking = 3200, t.BasicShadowMap = 0, t.BinaryTextureLoader = function (t) {
    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new bc(t);
  }, t.Bone = Fa, t.BooleanKeyframeTrack = nc, t.BoundingBoxHelper = function (t, e) {
    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Wu(t, e);
  }, t.Box2 = pu, t.Box3 = Tt, t.Box3Helper = ju, t.BoxBufferGeometry = zn, t.BoxGeometry = xo, t.BoxHelper = Wu, t.BufferAttribute = Je, t.BufferGeometry = vn, t.BufferGeometryLoader = ul, t.ByteType = 1010, t.Cache = hc, t.Camera = kn, t.CameraHelper = Gu, t.CanvasRenderer = function () {
    console.error("THREE.CanvasRenderer has been removed");
  }, t.CanvasTexture = ho, t.CatmullRomCurve3 = Pc, t.CineonToneMapping = 3, t.CircleBufferGeometry = _o, t.CircleGeometry = bo, t.ClampToEdgeWrapping = u, t.Clock = Rl, t.ClosedSplineCurve3 = gh, t.Color = Ve, t.ColorKeyframeTrack = rc, t.CompressedTexture = uo, t.CompressedTextureLoader = yc, t.ConeBufferGeometry = To, t.ConeGeometry = So, t.CubeCamera = jn, t.CubeGeometry = xo, t.CubeReflectionMapping = r, t.CubeRefractionMapping = i, t.CubeTexture = qn, t.CubeTextureLoader = _c, t.CubeUVReflectionMapping = s, t.CubeUVRefractionMapping = c, t.CubicBezierCurve = Nc, t.CubicBezierCurve3 = Bc, t.CubicInterpolant = Ks, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.CullFaceNone = 0, t.Curve = Mc, t.CurvePath = Vc, t.CustomBlending = 5, t.CustomToneMapping = 5, t.CylinderBufferGeometry = wo, t.CylinderGeometry = Mo, t.Cylindrical = hu, t.DataTexture = Yn, t.DataTexture2DArray = yr, t.DataTexture3D = xr, t.DataTextureLoader = bc, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = pc, t.DepthFormat = E, t.DepthStencilFormat = A, t.DepthTexture = po, t.DirectionalLight = el, t.DirectionalLightHelper = Nu, t.DiscreteInterpolant = tc, t.DodecahedronBufferGeometry = Ao, t.DodecahedronGeometry = Lo, t.DoubleSide = 2, t.DstAlphaFactor = 206, t.DstColorFactor = 208, t.DynamicBufferAttribute = function (t, e) {
    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Je(t, e).setUsage(et);
  }, t.DynamicCopyUsage = 35050, t.DynamicDrawUsage = et, t.DynamicReadUsage = 35049, t.EdgesGeometry = Do, t.EdgesHelper = function (t, e) {
    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new to(new Do(t.geometry), new ja({ color: void 0 !== e ? e : 16777215 }));
  }, t.EllipseCurve = Sc, t.EqualDepth = 4, t.EqualStencilFunc = 514, t.EquirectangularReflectionMapping = a, t.EquirectangularRefractionMapping = o, t.Euler = ie, t.EventDispatcher = rt, t.ExtrudeBufferGeometry = cs, t.ExtrudeGeometry = us, t.Face3 = We, t.Face4 = function (t, e, n, r, i, a, o) {
    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new We(t, e, n, i, a, o);
  }, t.FaceColors = 1, t.FileLoader = vc, t.FlatShading = 1, t.Float32Attribute = function (t, e) {
    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new an(t, e);
  }, t.Float32BufferAttribute = an, t.Float64Attribute = function (t, e) {
    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new on(t, e);
  }, t.Float64BufferAttribute = on, t.FloatType = b, t.Fog = oa, t.FogExp2 = aa, t.Font = xl, t.FontLoader = bl, t.FrontSide = 0, t.Frustum = Qn, t.GLBufferAttribute = ou, t.GLSL1 = "100", t.GLSL3 = nt, t.GammaEncoding = Y, t.Geometry = yo, t.GeometryUtils = _h, t.GreaterDepth = 6, t.GreaterEqualDepth = 5, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = Cu, t.Group = $i, t.HalfFloatType = w, t.HemisphereLight = Xc, t.HemisphereLightHelper = Ru, t.HemisphereLightProbe = Sl, t.IcosahedronBufferGeometry = hs, t.IcosahedronGeometry = ds, t.ImageBitmapLoader = gl, t.ImageLoader = xc, t.ImageUtils = mt, t.ImmediateRenderObject = gu, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = ll, t.InstancedBufferGeometry = cl, t.InstancedInterleavedBuffer = au, t.InstancedMesh = Wa, t.Int16Attribute = function (t, e) {
    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new tn(t, e);
  }, t.Int16BufferAttribute = tn, t.Int32Attribute = function (t, e) {
    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new nn(t, e);
  }, t.Int32BufferAttribute = nn, t.Int8Attribute = function (t, e) {
    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Qe(t, e);
  }, t.Int8BufferAttribute = Qe, t.IntType = 1013, t.InterleavedBuffer = ca, t.InterleavedBufferAttribute = ha, t.Interpolant = Qs, t.InterpolateDiscrete = G, t.InterpolateLinear = F, t.InterpolateSmooth = U, t.InvertStencilOp = 5386, t.JSONLoader = function () {
    console.error("THREE.JSONLoader has been removed.");
  }, t.KeepStencilOp = $, t.KeyframeTrack = ec, t.LOD = Oa, t.LatheBufferGeometry = ps, t.LatheGeometry = fs, t.Layers = se, t.LensFlare = function () {
    console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
  }, t.LessDepth = 2, t.LessEqualDepth = 3, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = qc, t.LightProbe = al, t.Line = Qa, t.Line3 = vu, t.LineBasicMaterial = ja, t.LineCurve = zc, t.LineCurve3 = Gc, t.LineDashedMaterial = Ys, t.LineLoop = eo, t.LinePieces = 1, t.LineSegments = to, t.LineStrip = 0, t.LinearEncoding = q, t.LinearFilter = m, t.LinearInterpolant = $s, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = g, t.LinearMipmapNearestFilter = v, t.LinearToneMapping = 1, t.Loader = fc, t.LoaderUtils = sl, t.LoadingManager = dc, t.LogLuvEncoding = 3003, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = 1025, t.LuminanceFormat = 1024, t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, t.Material = qe, t.MaterialLoader = ol, t.Math = st, t.MathUtils = st, t.Matrix3 = ft, t.Matrix4 = Jt, t.MaxEquation = 104, t.Mesh = On, t.MeshBasicMaterial = Xe, t.MeshDepthMaterial = qi, t.MeshDistanceMaterial = Xi, t.MeshFaceMaterial = function (t) {
    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t;
  }, t.MeshLambertMaterial = qs, t.MeshMatcapMaterial = Xs, t.MeshNormalMaterial = js, t.MeshPhongMaterial = Vs, t.MeshPhysicalMaterial = ks, t.MeshStandardMaterial = Hs, t.MeshToonMaterial = Ws, t.MinEquation = 103, t.MirroredRepeatWrapping = h, t.MixOperation = 1, t.MultiMaterial = function (t) {
    return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function () {
      return t.slice();
    }, t;
  }, t.MultiplyBlending = 4, t.MultiplyOperation = 0, t.NearestFilter = d, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = f, t.NearestMipmapNearestFilter = p, t.NeverDepth = 0, t.NeverStencilFunc = 512, t.NoBlending = 0, t.NoColors = 0, t.NoToneMapping = 0, t.NormalAnimationBlendMode = W, t.NormalBlending = 1, t.NotEqualDepth = 7, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = ic, t.Object3D = be, t.ObjectLoader = pl, t.ObjectSpaceNormalMap = 1, t.OctahedronBufferGeometry = ms, t.OctahedronGeometry = vs, t.OneFactor = 201, t.OneMinusDstAlphaFactor = 207, t.OneMinusDstColorFactor = 209, t.OneMinusSrcAlphaFactor = 205, t.OneMinusSrcColorFactor = 203, t.OrthographicCamera = $c, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.PMREMGenerator = uh, t.ParametricBufferGeometry = gs, t.ParametricGeometry = ys, t.Particle = function (t) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ta(t);
  }, t.ParticleBasicMaterial = function (t) {
    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new no(t);
  }, t.ParticleSystem = function (t, e) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new so(t, e);
  }, t.ParticleSystemMaterial = function (t) {
    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new no(t);
  }, t.Path = Wc, t.PerspectiveCamera = Vn, t.Plane = Te, t.PlaneBufferGeometry = tr, t.PlaneGeometry = xs, t.PlaneHelper = qu, t.PointCloud = function (t, e) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new so(t, e);
  }, t.PointCloudMaterial = function (t) {
    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new no(t);
  }, t.PointLight = Kc, t.PointLightHelper = Tu, t.Points = so, t.PointsMaterial = no, t.PolarGridHelper = Pu, t.PolyhedronBufferGeometry = Eo, t.PolyhedronGeometry = _s, t.PositionalAudio = Ul, t.PropertyBinding = tu, t.PropertyMixer = kl, t.QuadraticBezierCurve = Fc, t.QuadraticBezierCurve3 = Uc, t.Quaternion = bt, t.QuaternionKeyframeTrack = oc, t.QuaternionLinearInterpolant = ac, t.REVISION = "122", t.RGBADepthPacking = 3201, t.RGBAFormat = T, t.RGBAIntegerFormat = 1033, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.RGBA_ASTC_4x4_Format = 37808, t.RGBA_ASTC_5x4_Format = 37809, t.RGBA_ASTC_5x5_Format = 37810, t.RGBA_ASTC_6x5_Format = 37811, t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_BPTC_Format = 36492, t.RGBA_ETC2_EAC_Format = z, t.RGBA_PVRTC_2BPPV1_Format = N, t.RGBA_PVRTC_4BPPV1_Format = O, t.RGBA_S3TC_DXT1_Format = R, t.RGBA_S3TC_DXT3_Format = C, t.RGBA_S3TC_DXT5_Format = P, t.RGBDEncoding = K, t.RGBEEncoding = Z, t.RGBEFormat = 1023, t.RGBFormat = S, t.RGBIntegerFormat = 1032, t.RGBM16Encoding = Q, t.RGBM7Encoding = J, t.RGB_ETC1_Format = 36196, t.RGB_ETC2_Format = B, t.RGB_PVRTC_2BPPV1_Format = D, t.RGB_PVRTC_4BPPV1_Format = I, t.RGB_S3TC_DXT1_Format = L, t.RGFormat = 1030, t.RGIntegerFormat = 1031, t.RawShaderMaterial = Us, t.Ray = Zt, t.Raycaster = su, t.RectAreaLight = rl, t.RedFormat = 1028, t.RedIntegerFormat = 1029, t.ReinhardToneMapping = 2, t.RepeatWrapping = l, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = 102, t.RingBufferGeometry = bs, t.RingGeometry = ws, t.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, t.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, t.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, t.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, t.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, t.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, t.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, t.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, t.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, t.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, t.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, t.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, t.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, t.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, t.Scene = sa, t.SceneUtils = bh, t.ShaderChunk = er, t.ShaderLib = rr, t.ShaderMaterial = Hn, t.ShadowMaterial = Fs, t.Shape = jc, t.ShapeBufferGeometry = Ms, t.ShapeGeometry = Ss, t.ShapePath = yl, t.ShapeUtils = as, t.ShortType = 1011, t.Skeleton = Ga, t.SkeletonHelper = Mu, t.SkinnedMesh = Na, t.SmoothShading = 2, t.Sphere = Ht, t.SphereBufferGeometry = Ts, t.SphereGeometry = Es, t.Spherical = uu, t.SphericalHarmonics3 = il, t.Spline = xh, t.SplineCurve = Hc, t.SplineCurve3 = yh, t.SpotLight = Jc, t.SpotLightHelper = xu, t.Sprite = Ta, t.SpriteMaterial = da, t.SrcAlphaFactor = 204, t.SrcAlphaSaturateFactor = 210, t.SrcColorFactor = 202, t.StaticCopyUsage = 35046, t.StaticDrawUsage = tt, t.StaticReadUsage = 35045, t.StereoCamera = Ll, t.StreamCopyUsage = 35042, t.StreamDrawUsage = 35040, t.StreamReadUsage = 35041, t.StringKeyframeTrack = sc, t.SubtractEquation = 101, t.SubtractiveBlending = 3, t.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, t.TangentSpaceNormalMap = 0, t.TetrahedronBufferGeometry = As, t.TetrahedronGeometry = Ls, t.TextBufferGeometry = Rs, t.TextGeometry = Cs, t.Texture = gt, t.TextureLoader = wc, t.TorusBufferGeometry = Ps, t.TorusGeometry = Is, t.TorusKnotBufferGeometry = Ds, t.TorusKnotGeometry = Os, t.Triangle = Be, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = Ns, t.TubeGeometry = Bs, t.UVMapping = n, t.Uint16Attribute = function (t, e) {
    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new en(t, e);
  }, t.Uint16BufferAttribute = en, t.Uint32Attribute = function (t, e) {
    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new rn(t, e);
  }, t.Uint32BufferAttribute = rn, t.Uint8Attribute = function (t, e) {
    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ke(t, e);
  }, t.Uint8BufferAttribute = Ke, t.Uint8ClampedAttribute = function (t, e) {
    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new $e(t, e);
  }, t.Uint8ClampedBufferAttribute = $e, t.Uniform = iu, t.UniformsLib = nr, t.UniformsUtils = Un, t.UnsignedByteType = y, t.UnsignedInt248Type = M, t.UnsignedIntType = _, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedShortType = x, t.VSMShadowMap = 3, t.Vector2 = pt, t.Vector3 = wt, t.Vector4 = yt, t.VectorKeyframeTrack = cc, t.Vertex = function (t, e, n) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new wt(t, e, n);
  }, t.VertexColors = 2, t.VideoTexture = lo, t.WebGL1Renderer = ia, t.WebGLCubeRenderTarget = Xn, t.WebGLMultisampleRenderTarget = _t, t.WebGLRenderTarget = xt, t.WebGLRenderTargetCube = function (t, e, n) {
    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Xn(t, n);
  }, t.WebGLRenderer = ra, t.WebGLUtils = Qi, t.WireframeGeometry = zs, t.WireframeHelper = function (t, e) {
    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new to(new zs(t.geometry), new ja({ color: void 0 !== e ? e : 16777215 }));
  }, t.WrapAroundEnding = V, t.XHRLoader = function (t) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new vc(t);
  }, t.ZeroCurvatureEnding = H, t.ZeroFactor = 200, t.ZeroSlopeEnding = k, t.ZeroStencilOp = 0, t.sRGBEncoding = X, Object.defineProperty(t, "__esModule", { value: !0 });
});

/***/ }),

/***/ 1704:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

THREE.GLTFLoader = function () {

    function GLTFLoader(manager) {

        THREE.Loader.call(this, manager);

        this.dracoLoader = null;
        this.ddsLoader = null;
        this.ktx2Loader = null;
        this.meshoptDecoder = null;

        this.pluginCallbacks = [];

        this.register(function (parser) {

            return new GLTFMaterialsClearcoatExtension(parser);
        });

        this.register(function (parser) {

            return new GLTFTextureBasisUExtension(parser);
        });

        this.register(function (parser) {

            return new GLTFTextureWebPExtension(parser);
        });

        this.register(function (parser) {

            return new GLTFMaterialsTransmissionExtension(parser);
        });

        this.register(function (parser) {

            return new GLTFLightsExtension(parser);
        });

        this.register(function (parser) {

            return new GLTFMeshoptCompression(parser);
        });
    }

    GLTFLoader.prototype = _extends(Object.create(THREE.Loader.prototype), {

        constructor: GLTFLoader,

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var resourcePath;

            if (this.resourcePath !== '') {

                resourcePath = this.resourcePath;
            } else if (this.path !== '') {

                resourcePath = this.path;
            } else {

                resourcePath = THREE.LoaderUtils.extractUrlBase(url);
            }

            // Tells the LoadingManager to track an extra item, which resolves after
            // the model is fully loaded. This means the count of items loaded will
            // be incorrect, but ensures manager.onLoad() does not fire early.
            this.manager.itemStart(url);

            var _onError = function _onError(e) {

                if (onError) {

                    onError(e);
                } else {

                    console.error(e);
                }

                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            };

            var loader = new THREE.FileLoader(this.manager);

            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);

            loader.load(url, function (data) {

                try {

                    scope.parse(data, resourcePath, function (gltf) {

                        onLoad(gltf);

                        scope.manager.itemEnd(url);
                    }, _onError);
                } catch (e) {

                    _onError(e);
                }
            }, onProgress, _onError);
        },

        setDRACOLoader: function setDRACOLoader(dracoLoader) {

            this.dracoLoader = dracoLoader;
            return this;
        },

        setDDSLoader: function setDDSLoader(ddsLoader) {

            this.ddsLoader = ddsLoader;
            return this;
        },

        setKTX2Loader: function setKTX2Loader(ktx2Loader) {

            this.ktx2Loader = ktx2Loader;
            return this;
        },

        setMeshoptDecoder: function setMeshoptDecoder(meshoptDecoder) {

            this.meshoptDecoder = meshoptDecoder;
            return this;
        },

        register: function register(callback) {

            if (this.pluginCallbacks.indexOf(callback) === -1) {

                this.pluginCallbacks.push(callback);
            }

            return this;
        },

        unregister: function unregister(callback) {

            if (this.pluginCallbacks.indexOf(callback) !== -1) {

                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
            }

            return this;
        },

        parse: function parse(data, path, onLoad, onError) {

            var content;
            var extensions = {};
            var plugins = {};

            if (typeof data === 'string') {

                content = data;
            } else {

                var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

                if (magic === BINARY_EXTENSION_HEADER_MAGIC) {

                    try {

                        extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
                    } catch (error) {

                        if (onError) onError(error);
                        return;
                    }

                    content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
                } else {

                    content = THREE.LoaderUtils.decodeText(new Uint8Array(data));
                }
            }

            var json = JSON.parse(content);

            if (json.asset === undefined || json.asset.version[0] < 2) {

                if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
                return;
            }

            var parser = new GLTFParser(json, {

                path: path || this.resourcePath || '',
                crossOrigin: this.crossOrigin,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder

            });

            parser.fileLoader.setRequestHeader(this.requestHeader);

            for (var i = 0; i < this.pluginCallbacks.length; i++) {

                var plugin = this.pluginCallbacks[i](parser);
                plugins[plugin.name] = plugin;

                // Workaround to avoid determining as unknown extension
                // in addUnknownExtensionsToUserData().
                // Remove this workaround if we move all the existing
                // extension handlers to plugin system
                extensions[plugin.name] = true;
            }

            if (json.extensionsUsed) {

                for (var i = 0; i < json.extensionsUsed.length; ++i) {

                    var extensionName = json.extensionsUsed[i];
                    var extensionsRequired = json.extensionsRequired || [];

                    switch (extensionName) {

                        case EXTENSIONS.KHR_MATERIALS_UNLIT:
                            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                            break;

                        case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                            break;

                        case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                            break;

                        case EXTENSIONS.MSFT_TEXTURE_DDS:
                            extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
                            break;

                        case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                            extensions[extensionName] = new GLTFTextureTransformExtension();
                            break;

                        case EXTENSIONS.KHR_MESH_QUANTIZATION:
                            extensions[extensionName] = new GLTFMeshQuantizationExtension();
                            break;

                        default:

                            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {

                                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                            }

                    }
                }
            }

            parser.setExtensions(extensions);
            parser.setPlugins(plugins);
            parser.parse(onLoad, onError);
        }

    });

    /* GLTFREGISTRY */

    function GLTFRegistry() {

        var objects = {};

        return {

            get: function get(key) {

                return objects[key];
            },

            add: function add(key, object) {

                objects[key] = object;
            },

            remove: function remove(key) {

                delete objects[key];
            },

            removeAll: function removeAll() {

                objects = {};
            }

        };
    }

    /*********************************/
    /********** EXTENSIONS ***********/
    /*********************************/

    var EXTENSIONS = {
        KHR_BINARY_GLTF: 'KHR_binary_glTF',
        KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
        KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
        KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
        KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
        KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
        KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
        KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
        KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
        EXT_TEXTURE_WEBP: 'EXT_texture_webp',
        EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
        MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
    };

    /**
     * DDS Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
     *
     */
    function GLTFTextureDDSExtension(ddsLoader) {

        if (!ddsLoader) {

            throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');
        }

        this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
        this.ddsLoader = ddsLoader;
    }

    /**
     * Punctual Lights Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
     */
    function GLTFLightsExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

        // Object3D instance caches
        this.cache = { refs: {}, uses: {} };
    }

    GLTFLightsExtension.prototype._markDefs = function () {

        var parser = this.parser;
        var nodeDefs = this.parser.json.nodes || [];

        for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

            var nodeDef = nodeDefs[nodeIndex];

            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {

                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
            }
        }
    };

    GLTFLightsExtension.prototype._loadLight = function (lightIndex) {

        var parser = this.parser;
        var cacheKey = 'light:' + lightIndex;
        var dependency = parser.cache.get(cacheKey);

        if (dependency) return dependency;

        var json = parser.json;
        var extensions = json.extensions && json.extensions[this.name] || {};
        var lightDefs = extensions.lights || [];
        var lightDef = lightDefs[lightIndex];
        var lightNode;

        var color = new THREE.Color(0xffffff);

        if (lightDef.color !== undefined) color.fromArray(lightDef.color);

        var range = lightDef.range !== undefined ? lightDef.range : 0;

        switch (lightDef.type) {

            case 'directional':
                lightNode = new THREE.DirectionalLight(color);
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;

            case 'point':
                lightNode = new THREE.PointLight(color);
                lightNode.distance = range;
                break;

            case 'spot':
                lightNode = new THREE.SpotLight(color);
                lightNode.distance = range;
                // Handle spotlight properties.
                lightDef.spot = lightDef.spot || {};
                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                lightNode.angle = lightDef.spot.outerConeAngle;
                lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;

            default:
                throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');

        }

        // Some lights (e.g. spot) default to a position other than the origin. Reset the position
        // here, because node-level parsing will only override position if explicitly specified.
        lightNode.position.set(0, 0, 0);

        lightNode.decay = 2;

        if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;

        lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);

        dependency = Promise.resolve(lightNode);

        parser.cache.add(cacheKey, dependency);

        return dependency;
    };

    GLTFLightsExtension.prototype.createNodeAttachment = function (nodeIndex) {

        var self = this;
        var parser = this.parser;
        var json = parser.json;
        var nodeDef = json.nodes[nodeIndex];
        var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
        var lightIndex = lightDef.light;

        if (lightIndex === undefined) return null;

        return this._loadLight(lightIndex).then(function (light) {

            return parser._getNodeRef(self.cache, lightIndex, light);
        });
    };

    /**
     * Unlit Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
     */
    function GLTFMaterialsUnlitExtension() {

        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }

    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {

        return THREE.MeshBasicMaterial;
    };

    GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {

        var pending = [];

        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;

        var metallicRoughness = materialDef.pbrMetallicRoughness;

        if (metallicRoughness) {

            if (Array.isArray(metallicRoughness.baseColorFactor)) {

                var array = metallicRoughness.baseColorFactor;

                materialParams.color.fromArray(array);
                materialParams.opacity = array[3];
            }

            if (metallicRoughness.baseColorTexture !== undefined) {

                pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
            }
        }

        return Promise.all(pending);
    };

    /**
     * Clearcoat Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
     */
    function GLTFMaterialsClearcoatExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }

    GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function (materialIndex) {

        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];

        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

        return THREE.MeshPhysicalMaterial;
    };

    GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function (materialIndex, materialParams) {

        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];

        if (!materialDef.extensions || !materialDef.extensions[this.name]) {

            return Promise.resolve();
        }

        var pending = [];

        var extension = materialDef.extensions[this.name];

        if (extension.clearcoatFactor !== undefined) {

            materialParams.clearcoat = extension.clearcoatFactor;
        }

        if (extension.clearcoatTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
        }

        if (extension.clearcoatRoughnessFactor !== undefined) {

            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
        }

        if (extension.clearcoatRoughnessTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
        }

        if (extension.clearcoatNormalTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

            if (extension.clearcoatNormalTexture.scale !== undefined) {

                var scale = extension.clearcoatNormalTexture.scale;

                materialParams.clearcoatNormalScale = new THREE.Vector2(scale, scale);
            }
        }

        return Promise.all(pending);
    };

    /**
     * Transmission Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
     * Draft: https://github.com/KhronosGroup/glTF/pull/1698
     */
    function GLTFMaterialsTransmissionExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }

    GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function (materialIndex) {

        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];

        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

        return THREE.MeshPhysicalMaterial;
    };

    GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function (materialIndex, materialParams) {

        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];

        if (!materialDef.extensions || !materialDef.extensions[this.name]) {

            return Promise.resolve();
        }

        var pending = [];

        var extension = materialDef.extensions[this.name];

        if (extension.transmissionFactor !== undefined) {

            materialParams.transmission = extension.transmissionFactor;
        }

        if (extension.transmissionTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));
        }

        return Promise.all(pending);
    };

    /**
     * BasisU Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
     */
    function GLTFTextureBasisUExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }

    GLTFTextureBasisUExtension.prototype.loadTexture = function (textureIndex) {

        var parser = this.parser;
        var json = parser.json;

        var textureDef = json.textures[textureIndex];

        if (!textureDef.extensions || !textureDef.extensions[this.name]) {

            return null;
        }

        var extension = textureDef.extensions[this.name];
        var source = json.images[extension.source];
        var loader = parser.options.ktx2Loader;

        if (!loader) {

            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {

                throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
            } else {

                // Assumes that the extension is optional and that a fallback texture is present
                return null;
            }
        }

        return parser.loadTextureImage(textureIndex, source, loader);
    };

    /**
     * WebP Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
     */
    function GLTFTextureWebPExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
        this.isSupported = null;
    }

    GLTFTextureWebPExtension.prototype.loadTexture = function (textureIndex) {

        var name = this.name;
        var parser = this.parser;
        var json = parser.json;

        var textureDef = json.textures[textureIndex];

        if (!textureDef.extensions || !textureDef.extensions[name]) {

            return null;
        }

        var extension = textureDef.extensions[name];
        var source = json.images[extension.source];
        var loader = source.uri ? parser.options.manager.getHandler(source.uri) : parser.textureLoader;

        return this.detectSupport().then(function (isSupported) {

            if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);

            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {

                throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
            }

            // Fall back to PNG or JPEG.
            return parser.loadTexture(textureIndex);
        });
    };

    GLTFTextureWebPExtension.prototype.detectSupport = function () {

        if (!this.isSupported) {

            this.isSupported = new Promise(function (resolve) {

                var image = new Image();

                // Lossy test image. Support for lossy images doesn't guarantee support for all
                // WebP images, unfortunately.
                image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

                image.onload = image.onerror = function () {

                    resolve(image.height === 1);
                };
            });
        }

        return this.isSupported;
    };

    /**
     * meshopt BufferView Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
     */
    function GLTFMeshoptCompression(parser) {

        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
        this.parser = parser;
    }

    GLTFMeshoptCompression.prototype.loadBufferView = function (index) {

        var json = this.parser.json;
        var bufferView = json.bufferViews[index];

        if (bufferView.extensions && bufferView.extensions[this.name]) {

            var extensionDef = bufferView.extensions[this.name];

            var buffer = this.parser.getDependency('buffer', extensionDef.buffer);
            var decoder = this.parser.options.meshoptDecoder;

            if (!decoder || !decoder.supported) {

                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {

                    throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
                } else {

                    // Assumes that the extension is optional and that fallback buffer data is present
                    return null;
                }
            }

            return Promise.all([buffer, decoder.ready]).then(function (res) {

                var byteOffset = extensionDef.byteOffset || 0;
                var byteLength = extensionDef.byteLength || 0;

                var count = extensionDef.count;
                var stride = extensionDef.byteStride;

                var result = new ArrayBuffer(count * stride);
                var source = new Uint8Array(res[0], byteOffset, byteLength);

                decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
                return result;
            });
        } else {

            return null;
        }
    };

    /* BINARY EXTENSION */
    var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

    function GLTFBinaryExtension(data) {

        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;

        var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);

        this.header = {
            magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
        };

        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {

            throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
        } else if (this.header.version < 2.0) {

            throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
        }

        var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
        var chunkIndex = 0;

        while (chunkIndex < chunkView.byteLength) {

            var chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;

            var chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;

            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {

                var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                this.content = THREE.LoaderUtils.decodeText(contentArray);
            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {

                var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                this.body = data.slice(byteOffset, byteOffset + chunkLength);
            }

            // Clients must ignore chunks with unknown types.

            chunkIndex += chunkLength;
        }

        if (this.content === null) {

            throw new Error('THREE.GLTFLoader: JSON content not found.');
        }
    }

    /**
     * DRACO Mesh Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
     */
    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {

        if (!dracoLoader) {

            throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
        }

        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
        this.json = json;
        this.dracoLoader = dracoLoader;
        this.dracoLoader.preload();
    }

    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {

        var json = this.json;
        var dracoLoader = this.dracoLoader;
        var bufferViewIndex = primitive.extensions[this.name].bufferView;
        var gltfAttributeMap = primitive.extensions[this.name].attributes;
        var threeAttributeMap = {};
        var attributeNormalizedMap = {};
        var attributeTypeMap = {};

        for (var attributeName in gltfAttributeMap) {

            var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
        }

        for (attributeName in primitive.attributes) {

            var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

            if (gltfAttributeMap[attributeName] !== undefined) {

                var accessorDef = json.accessors[primitive.attributes[attributeName]];
                var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

                attributeTypeMap[threeAttributeName] = componentType;
                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
            }
        }

        return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {

            return new Promise(function (resolve) {

                dracoLoader.decodeDracoFile(bufferView, function (geometry) {

                    for (var attributeName in geometry.attributes) {

                        var attribute = geometry.attributes[attributeName];
                        var normalized = attributeNormalizedMap[attributeName];

                        if (normalized !== undefined) attribute.normalized = normalized;
                    }

                    resolve(geometry);
                }, threeAttributeMap, attributeTypeMap);
            });
        });
    };

    /**
     * Texture Transform Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
     */
    function GLTFTextureTransformExtension() {

        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }

    GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {

        texture = texture.clone();

        if (transform.offset !== undefined) {

            texture.offset.fromArray(transform.offset);
        }

        if (transform.rotation !== undefined) {

            texture.rotation = transform.rotation;
        }

        if (transform.scale !== undefined) {

            texture.repeat.fromArray(transform.scale);
        }

        if (transform.texCoord !== undefined) {

            console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
        }

        texture.needsUpdate = true;

        return texture;
    };

    /**
     * Specular-Glossiness Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
     */

    /**
     * A sub class of THREE.StandardMaterial with some of the functionality
     * changed via the `onBeforeCompile` callback
     * @pailhead
     */

    function GLTFMeshStandardSGMaterial(params) {

        THREE.MeshStandardMaterial.call(this);

        this.isGLTFSpecularGlossinessMaterial = true;

        //various chunks that need replacing
        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');

        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');

        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');

        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');

        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\n');

        var uniforms = {
            specular: { value: new THREE.Color().setHex(0xffffff) },
            glossiness: { value: 1 },
            specularMap: { value: null },
            glossinessMap: { value: null }
        };

        this._extraUniforms = uniforms;

        this.onBeforeCompile = function (shader) {

            for (var uniformName in uniforms) {

                shader.uniforms[uniformName] = uniforms[uniformName];
            }

            shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
        };

        Object.defineProperties(this, {

            specular: {
                get: function get() {

                    return uniforms.specular.value;
                },
                set: function set(v) {

                    uniforms.specular.value = v;
                }
            },

            specularMap: {
                get: function get() {

                    return uniforms.specularMap.value;
                },
                set: function set(v) {

                    uniforms.specularMap.value = v;

                    if (v) {

                        this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps
                    } else {

                        delete this.defines.USE_SPECULARMAP;
                    }
                }
            },

            glossiness: {
                get: function get() {

                    return uniforms.glossiness.value;
                },
                set: function set(v) {

                    uniforms.glossiness.value = v;
                }
            },

            glossinessMap: {
                get: function get() {

                    return uniforms.glossinessMap.value;
                },
                set: function set(v) {

                    uniforms.glossinessMap.value = v;

                    if (v) {

                        this.defines.USE_GLOSSINESSMAP = '';
                        this.defines.USE_UV = '';
                    } else {

                        delete this.defines.USE_GLOSSINESSMAP;
                        delete this.defines.USE_UV;
                    }
                }
            }

        });

        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;

        this.setValues(params);
    }

    GLTFMeshStandardSGMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
    GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

    GLTFMeshStandardSGMaterial.prototype.copy = function (source) {

        THREE.MeshStandardMaterial.prototype.copy.call(this, source);
        this.specularMap = source.specularMap;
        this.specular.copy(source.specular);
        this.glossinessMap = source.glossinessMap;
        this.glossiness = source.glossiness;
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        return this;
    };

    function GLTFMaterialsPbrSpecularGlossinessExtension() {

        return {

            name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

            specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],

            getMaterialType: function getMaterialType() {

                return GLTFMeshStandardSGMaterial;
            },

            extendParams: function extendParams(materialParams, materialDef, parser) {

                var pbrSpecularGlossiness = materialDef.extensions[this.name];

                materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
                materialParams.opacity = 1.0;

                var pending = [];

                if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {

                    var array = pbrSpecularGlossiness.diffuseFactor;

                    materialParams.color.fromArray(array);
                    materialParams.opacity = array[3];
                }

                if (pbrSpecularGlossiness.diffuseTexture !== undefined) {

                    pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
                }

                materialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);
                materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
                materialParams.specular = new THREE.Color(1.0, 1.0, 1.0);

                if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {

                    materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
                }

                if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {

                    var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
                    pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
                    pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
                }

                return Promise.all(pending);
            },

            createMaterial: function createMaterial(materialParams) {

                var material = new GLTFMeshStandardSGMaterial(materialParams);
                material.fog = true;

                material.color = materialParams.color;

                material.map = materialParams.map === undefined ? null : materialParams.map;

                material.lightMap = null;
                material.lightMapIntensity = 1.0;

                material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
                material.aoMapIntensity = 1.0;

                material.emissive = materialParams.emissive;
                material.emissiveIntensity = 1.0;
                material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

                material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
                material.bumpScale = 1;

                material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
                material.normalMapType = THREE.TangentSpaceNormalMap;

                if (materialParams.normalScale) material.normalScale = materialParams.normalScale;

                material.displacementMap = null;
                material.displacementScale = 1;
                material.displacementBias = 0;

                material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
                material.specular = materialParams.specular;

                material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
                material.glossiness = materialParams.glossiness;

                material.alphaMap = null;

                material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
                material.envMapIntensity = 1.0;

                material.refractionRatio = 0.98;

                return material;
            }

        };
    }

    /**
     * Mesh Quantization Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
     */
    function GLTFMeshQuantizationExtension() {

        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }

    /*********************************/
    /********** INTERPOLATION ********/
    /*********************************/

    // Spline Interpolation
    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }

    GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);
    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {

        // Copies a sample value to the result buffer. See description of glTF
        // CUBICSPLINE values layout in interpolate_() function below.

        var result = this.resultBuffer,
            values = this.sampleValues,
            valueSize = this.valueSize,
            offset = index * valueSize * 3 + valueSize;

        for (var i = 0; i !== valueSize; i++) {

            result[i] = values[offset + i];
        }

        return result;
    };

    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {

        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;

        var stride2 = stride * 2;
        var stride3 = stride * 3;

        var td = t1 - t0;

        var p = (t - t0) / td;
        var pp = p * p;
        var ppp = pp * p;

        var offset1 = i1 * stride3;
        var offset0 = offset1 - stride3;

        var s2 = -2 * ppp + 3 * pp;
        var s3 = ppp - pp;
        var s0 = 1 - s2;
        var s1 = s3 - pp + p;

        // Layout of keyframe output values for CUBICSPLINE animations:
        //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
        for (var i = 0; i !== stride; i++) {

            var p0 = values[offset0 + i + stride]; // splineVertex_k
            var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
            var p1 = values[offset1 + i + stride]; // splineVertex_k+1
            var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
        }

        return result;
    };

    /*********************************/
    /********** INTERNALS ************/
    /*********************************/

    /* CONSTANTS */

    var WEBGL_CONSTANTS = {
        FLOAT: 5126,
        //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    };

    var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };

    var WEBGL_FILTERS = {
        9728: THREE.NearestFilter,
        9729: THREE.LinearFilter,
        9984: THREE.NearestMipmapNearestFilter,
        9985: THREE.LinearMipmapNearestFilter,
        9986: THREE.NearestMipmapLinearFilter,
        9987: THREE.LinearMipmapLinearFilter
    };

    var WEBGL_WRAPPINGS = {
        33071: THREE.ClampToEdgeWrapping,
        33648: THREE.MirroredRepeatWrapping,
        10497: THREE.RepeatWrapping
    };

    var WEBGL_TYPE_SIZES = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };

    var ATTRIBUTES = {
        POSITION: 'position',
        NORMAL: 'normal',
        TANGENT: 'tangent',
        TEXCOORD_0: 'uv',
        TEXCOORD_1: 'uv2',
        COLOR_0: 'color',
        WEIGHTS_0: 'skinWeight',
        JOINTS_0: 'skinIndex'
    };

    var PATH_PROPERTIES = {
        scale: 'scale',
        translation: 'position',
        rotation: 'quaternion',
        weights: 'morphTargetInfluences'
    };

    var INTERPOLATION = {
        CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
        // keyframe track will be initialized with a default interpolation type, then modified.
        LINEAR: THREE.InterpolateLinear,
        STEP: THREE.InterpolateDiscrete
    };

    var ALPHA_MODES = {
        OPAQUE: 'OPAQUE',
        MASK: 'MASK',
        BLEND: 'BLEND'
    };

    /* UTILITY FUNCTIONS */

    function resolveURL(url, path) {

        // Invalid URL
        if (typeof url !== 'string' || url === '') return '';

        // Host Relative URL
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {

            path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
        }

        // Absolute URL http://,https://,//
        if (/^(https?:)?\/\//i.test(url)) return url;

        // Data URI
        if (/^data:.*,.*$/i.test(url)) return url;

        // Blob URL
        if (/^blob:.*$/i.test(url)) return url;

        // Relative URL
        return path + url;
    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
     */
    function createDefaultMaterial(cache) {

        if (cache['DefaultMaterial'] === undefined) {

            cache['DefaultMaterial'] = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0x000000,
                metalness: 1,
                roughness: 1,
                transparent: false,
                depthTest: true,
                side: THREE.FrontSide
            });
        }

        return cache['DefaultMaterial'];
    }

    function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {

        // Add unknown glTF extensions to an object's userData.

        for (var name in objectDef.extensions) {

            if (knownExtensions[name] === undefined) {

                object.userData.gltfExtensions = object.userData.gltfExtensions || {};
                object.userData.gltfExtensions[name] = objectDef.extensions[name];
            }
        }
    }

    /**
     * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object
     * @param {GLTF.definition} gltfDef
     */
    function assignExtrasToUserData(object, gltfDef) {

        if (gltfDef.extras !== undefined) {

            if (_typeof(gltfDef.extras) === 'object') {

                _extends(object.userData, gltfDef.extras);
            } else {

                console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
            }
        }
    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
     *
     * @param {THREE.BufferGeometry} geometry
     * @param {Array<GLTF.Target>} targets
     * @param {GLTFParser} parser
     * @return {Promise<THREE.BufferGeometry>}
     */
    function addMorphTargets(geometry, targets, parser) {

        var hasMorphPosition = false;
        var hasMorphNormal = false;

        for (var i = 0, il = targets.length; i < il; i++) {

            var target = targets[i];

            if (target.POSITION !== undefined) hasMorphPosition = true;
            if (target.NORMAL !== undefined) hasMorphNormal = true;

            if (hasMorphPosition && hasMorphNormal) break;
        }

        if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);

        var pendingPositionAccessors = [];
        var pendingNormalAccessors = [];

        for (var i = 0, il = targets.length; i < il; i++) {

            var target = targets[i];

            if (hasMorphPosition) {

                var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;

                pendingPositionAccessors.push(pendingAccessor);
            }

            if (hasMorphNormal) {

                var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;

                pendingNormalAccessors.push(pendingAccessor);
            }
        }

        return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {

            var morphPositions = accessors[0];
            var morphNormals = accessors[1];

            if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
            if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
            geometry.morphTargetsRelative = true;

            return geometry;
        });
    }

    /**
     * @param {THREE.Mesh} mesh
     * @param {GLTF.Mesh} meshDef
     */
    function updateMorphTargets(mesh, meshDef) {

        mesh.updateMorphTargets();

        if (meshDef.weights !== undefined) {

            for (var i = 0, il = meshDef.weights.length; i < il; i++) {

                mesh.morphTargetInfluences[i] = meshDef.weights[i];
            }
        }

        // .extras has user-defined data, so check that .extras.targetNames is an array.
        if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {

            var targetNames = meshDef.extras.targetNames;

            if (mesh.morphTargetInfluences.length === targetNames.length) {

                mesh.morphTargetDictionary = {};

                for (var i = 0, il = targetNames.length; i < il; i++) {

                    mesh.morphTargetDictionary[targetNames[i]] = i;
                }
            } else {

                console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
            }
        }
    }

    function createPrimitiveKey(primitiveDef) {

        var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
        var geometryKey;

        if (dracoExtension) {

            geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
        } else {

            geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
        }

        return geometryKey;
    }

    function createAttributesKey(attributes) {

        var attributesKey = '';

        var keys = Object.keys(attributes).sort();

        for (var i = 0, il = keys.length; i < il; i++) {

            attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
        }

        return attributesKey;
    }

    /* GLTF PARSER */

    function GLTFParser(json, options) {

        this.json = json || {};
        this.extensions = {};
        this.plugins = {};
        this.options = options || {};

        // loader object cache
        this.cache = new GLTFRegistry();

        // associations between Three.js objects and glTF elements
        this.associations = new Map();

        // BufferGeometry caching
        this.primitiveCache = {};

        // Object3D instance caches
        this.meshCache = { refs: {}, uses: {} };
        this.cameraCache = { refs: {}, uses: {} };
        this.lightCache = { refs: {}, uses: {} };

        // Track node names, to ensure no duplicates
        this.nodeNamesUsed = {};

        // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
        // expensive work of uploading a texture to the GPU off the main thread.
        if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {

            this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager);
        } else {

            this.textureLoader = new THREE.TextureLoader(this.options.manager);
        }

        this.textureLoader.setCrossOrigin(this.options.crossOrigin);

        this.fileLoader = new THREE.FileLoader(this.options.manager);
        this.fileLoader.setResponseType('arraybuffer');

        if (this.options.crossOrigin === 'use-credentials') {

            this.fileLoader.setWithCredentials(true);
        }
    }

    GLTFParser.prototype.setExtensions = function (extensions) {

        this.extensions = extensions;
    };

    GLTFParser.prototype.setPlugins = function (plugins) {

        this.plugins = plugins;
    };

    GLTFParser.prototype.parse = function (onLoad, onError) {

        var parser = this;
        var json = this.json;
        var extensions = this.extensions;

        // Clear the loader cache
        this.cache.removeAll();

        // Mark the special nodes/meshes in json for efficient parse
        this._invokeAll(function (ext) {

            return ext._markDefs && ext._markDefs();
        });

        Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {

            var result = {
                scene: dependencies[0][json.scene || 0],
                scenes: dependencies[0],
                animations: dependencies[1],
                cameras: dependencies[2],
                asset: json.asset,
                parser: parser,
                userData: {}
            };

            addUnknownExtensionsToUserData(extensions, result, json);

            assignExtrasToUserData(result, json);

            onLoad(result);
        }).catch(onError);
    };

    /**
     * Marks the special nodes/meshes in json for efficient parse.
     */
    GLTFParser.prototype._markDefs = function () {

        var nodeDefs = this.json.nodes || [];
        var skinDefs = this.json.skins || [];
        var meshDefs = this.json.meshes || [];

        // Nothing in the node definition indicates whether it is a Bone or an
        // Object3D. Use the skins' joint references to mark bones.
        for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {

            var joints = skinDefs[skinIndex].joints;

            for (var i = 0, il = joints.length; i < il; i++) {

                nodeDefs[joints[i]].isBone = true;
            }
        }

        // Iterate over all nodes, marking references to shared resources,
        // as well as skeleton joints.
        for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

            var nodeDef = nodeDefs[nodeIndex];

            if (nodeDef.mesh !== undefined) {

                this._addNodeRef(this.meshCache, nodeDef.mesh);

                // Nothing in the mesh definition indicates whether it is
                // a SkinnedMesh or Mesh. Use the node's mesh reference
                // to mark SkinnedMesh if node has skin.
                if (nodeDef.skin !== undefined) {

                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;
                }
            }

            if (nodeDef.camera !== undefined) {

                this._addNodeRef(this.cameraCache, nodeDef.camera);
            }
        }
    };

    /**
     * Counts references to shared node / Object3D resources. These resources
     * can be reused, or "instantiated", at multiple nodes in the scene
     * hierarchy. Mesh, Camera, and Light instances are instantiated and must
     * be marked. Non-scenegraph resources (like Materials, Geometries, and
     * Textures) can be reused directly and are not marked here.
     *
     * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
     */
    GLTFParser.prototype._addNodeRef = function (cache, index) {

        if (index === undefined) return;

        if (cache.refs[index] === undefined) {

            cache.refs[index] = cache.uses[index] = 0;
        }

        cache.refs[index]++;
    };

    /** Returns a reference to a shared resource, cloning it if necessary. */
    GLTFParser.prototype._getNodeRef = function (cache, index, object) {

        if (cache.refs[index] <= 1) return object;

        var ref = object.clone();

        ref.name += '_instance_' + cache.uses[index]++;

        return ref;
    };

    GLTFParser.prototype._invokeOne = function (func) {

        var extensions = Object.values(this.plugins);
        extensions.push(this);

        for (var i = 0; i < extensions.length; i++) {

            var result = func(extensions[i]);

            if (result) return result;
        }
    };

    GLTFParser.prototype._invokeAll = function (func) {

        var extensions = Object.values(this.plugins);
        extensions.unshift(this);

        var pending = [];

        for (var i = 0; i < extensions.length; i++) {

            var result = func(extensions[i]);

            if (result) pending.push(result);
        }

        return pending;
    };

    /**
     * Requests the specified dependency asynchronously, with caching.
     * @param {string} type
     * @param {number} index
     * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}
     */
    GLTFParser.prototype.getDependency = function (type, index) {

        var cacheKey = type + ':' + index;
        var dependency = this.cache.get(cacheKey);

        if (!dependency) {

            switch (type) {

                case 'scene':
                    dependency = this.loadScene(index);
                    break;

                case 'node':
                    dependency = this.loadNode(index);
                    break;

                case 'mesh':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadMesh && ext.loadMesh(index);
                    });
                    break;

                case 'accessor':
                    dependency = this.loadAccessor(index);
                    break;

                case 'bufferView':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadBufferView && ext.loadBufferView(index);
                    });
                    break;

                case 'buffer':
                    dependency = this.loadBuffer(index);
                    break;

                case 'material':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadMaterial && ext.loadMaterial(index);
                    });
                    break;

                case 'texture':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadTexture && ext.loadTexture(index);
                    });
                    break;

                case 'skin':
                    dependency = this.loadSkin(index);
                    break;

                case 'animation':
                    dependency = this.loadAnimation(index);
                    break;

                case 'camera':
                    dependency = this.loadCamera(index);
                    break;

                default:
                    throw new Error('Unknown type: ' + type);

            }

            this.cache.add(cacheKey, dependency);
        }

        return dependency;
    };

    /**
     * Requests all dependencies of the specified type asynchronously, with caching.
     * @param {string} type
     * @return {Promise<Array<Object>>}
     */
    GLTFParser.prototype.getDependencies = function (type) {

        var dependencies = this.cache.get(type);

        if (!dependencies) {

            var parser = this;
            var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];

            dependencies = Promise.all(defs.map(function (def, index) {

                return parser.getDependency(type, index);
            }));

            this.cache.add(type, dependencies);
        }

        return dependencies;
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferIndex
     * @return {Promise<ArrayBuffer>}
     */
    GLTFParser.prototype.loadBuffer = function (bufferIndex) {

        var bufferDef = this.json.buffers[bufferIndex];
        var loader = this.fileLoader;

        if (bufferDef.type && bufferDef.type !== 'arraybuffer') {

            throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
        }

        // If present, GLB container is required to be the first buffer.
        if (bufferDef.uri === undefined && bufferIndex === 0) {

            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        }

        var options = this.options;

        return new Promise(function (resolve, reject) {

            loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {

                reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
            });
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferViewIndex
     * @return {Promise<ArrayBuffer>}
     */
    GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {

        var bufferViewDef = this.json.bufferViews[bufferViewIndex];

        return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {

            var byteLength = bufferViewDef.byteLength || 0;
            var byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
     * @param {number} accessorIndex
     * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}
     */
    GLTFParser.prototype.loadAccessor = function (accessorIndex) {

        var parser = this;
        var json = this.json;

        var accessorDef = this.json.accessors[accessorIndex];

        if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {

            // Ignore empty accessors, which may be used to declare runtime
            // information about attributes coming from another source (e.g. Draco
            // compression extension).
            return Promise.resolve(null);
        }

        var pendingBufferViews = [];

        if (accessorDef.bufferView !== undefined) {

            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
        } else {

            pendingBufferViews.push(null);
        }

        if (accessorDef.sparse !== undefined) {

            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
        }

        return Promise.all(pendingBufferViews).then(function (bufferViews) {

            var bufferView = bufferViews[0];

            var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

            // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
            var elementBytes = TypedArray.BYTES_PER_ELEMENT;
            var itemBytes = elementBytes * itemSize;
            var byteOffset = accessorDef.byteOffset || 0;
            var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
            var normalized = accessorDef.normalized === true;
            var array, bufferAttribute;

            // The buffer is not interleaved if the stride is the item size in bytes.
            if (byteStride && byteStride !== itemBytes) {

                // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
                // This makes sure that IBA.count reflects accessor.count properly
                var ibSlice = Math.floor(byteOffset / byteStride);
                var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
                var ib = parser.cache.get(ibCacheKey);

                if (!ib) {

                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);

                    // Integer parameters to IB/IBA are in array elements, not bytes.
                    ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);

                    parser.cache.add(ibCacheKey, ib);
                }

                bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
            } else {

                if (bufferView === null) {

                    array = new TypedArray(accessorDef.count * itemSize);
                } else {

                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
                }

                bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);
            }

            // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
            if (accessorDef.sparse !== undefined) {

                var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];

                var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

                var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

                if (bufferView !== null) {

                    // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                    bufferAttribute = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
                }

                for (var i = 0, il = sparseIndices.length; i < il; i++) {

                    var index = sparseIndices[i];

                    bufferAttribute.setX(index, sparseValues[i * itemSize]);
                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                    if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
                }
            }

            return bufferAttribute;
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
     * @param {number} textureIndex
     * @return {Promise<THREE.Texture>}
     */
    GLTFParser.prototype.loadTexture = function (textureIndex) {

        var parser = this;
        var json = this.json;
        var options = this.options;

        var textureDef = json.textures[textureIndex];

        var textureExtensions = textureDef.extensions || {};

        var source;

        if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {

            source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
        } else {

            source = json.images[textureDef.source];
        }

        var loader;

        if (source.uri) {

            loader = options.manager.getHandler(source.uri);
        }

        if (!loader) {

            loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader;
        }

        return this.loadTextureImage(textureIndex, source, loader);
    };

    GLTFParser.prototype.loadTextureImage = function (textureIndex, source, loader) {

        var parser = this;
        var json = this.json;
        var options = this.options;

        var textureDef = json.textures[textureIndex];

        var URL = self.URL || self.webkitURL;

        var sourceURI = source.uri;
        var isObjectURL = false;
        var hasAlpha = true;

        if (source.mimeType === 'image/jpeg') hasAlpha = false;

        if (source.bufferView !== undefined) {

            // Load binary image data from bufferView, if provided.

            sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {

                if (source.mimeType === 'image/png') {

                    // Inspect the PNG 'IHDR' chunk to determine whether the image could have an
                    // alpha channel. This check is conservative — the image could have an alpha
                    // channel with all values == 1, and the indexed type (colorType == 3) only
                    // sometimes contains alpha.
                    //
                    // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
                    var colorType = new DataView(bufferView, 25, 1).getUint8(0, false);
                    hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;
                }

                isObjectURL = true;
                var blob = new Blob([bufferView], { type: source.mimeType });
                sourceURI = URL.createObjectURL(blob);
                return sourceURI;
            });
        }

        return Promise.resolve(sourceURI).then(function (sourceURI) {

            return new Promise(function (resolve, reject) {

                var onLoad = resolve;

                if (loader.isImageBitmapLoader === true) {

                    onLoad = function onLoad(imageBitmap) {

                        resolve(new THREE.CanvasTexture(imageBitmap));
                    };
                }

                loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);
            });
        }).then(function (texture) {

            // Clean up resources and configure Texture.

            if (isObjectURL === true) {

                URL.revokeObjectURL(sourceURI);
            }

            texture.flipY = false;

            if (textureDef.name) texture.name = textureDef.name;

            // When there is definitely no alpha channel in the texture, set RGBFormat to save space.
            if (!hasAlpha) texture.format = THREE.RGBFormat;

            var samplers = json.samplers || {};
            var sampler = samplers[textureDef.sampler] || {};

            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;
            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;
            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;
            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;

            parser.associations.set(texture, {
                type: 'textures',
                index: textureIndex
            });

            return texture;
        });
    };

    /**
     * Asynchronously assigns a texture to the given material parameters.
     * @param {Object} materialParams
     * @param {string} mapName
     * @param {Object} mapDef
     * @return {Promise}
     */
    GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {

        var parser = this;

        return this.getDependency('texture', mapDef.index).then(function (texture) {

            // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
            // However, we will copy UV set 0 to UV set 1 on demand for aoMap
            if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {

                console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
            }

            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {

                var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

                if (transform) {

                    var gltfReference = parser.associations.get(texture);
                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                    parser.associations.set(texture, gltfReference);
                }
            }

            materialParams[mapName] = texture;
        });
    };

    /**
     * Assigns final material to a Mesh, Line, or Points instance. The instance
     * already has a material (generated from the glTF material options alone)
     * but reuse of the same glTF material may require multiple threejs materials
     * to accomodate different primitive types, defines, etc. New materials will
     * be created if necessary, and reused from a cache.
     * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.
     */
    GLTFParser.prototype.assignFinalMaterial = function (mesh) {

        var geometry = mesh.geometry;
        var material = mesh.material;

        var useVertexTangents = geometry.attributes.tangent !== undefined;
        var useVertexColors = geometry.attributes.color !== undefined;
        var useFlatShading = geometry.attributes.normal === undefined;
        var useSkinning = mesh.isSkinnedMesh === true;
        var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
        var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

        if (mesh.isPoints) {

            var cacheKey = 'PointsMaterial:' + material.uuid;

            var pointsMaterial = this.cache.get(cacheKey);

            if (!pointsMaterial) {

                pointsMaterial = new THREE.PointsMaterial();
                THREE.Material.prototype.copy.call(pointsMaterial, material);
                pointsMaterial.color.copy(material.color);
                pointsMaterial.map = material.map;
                pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

                this.cache.add(cacheKey, pointsMaterial);
            }

            material = pointsMaterial;
        } else if (mesh.isLine) {

            var cacheKey = 'LineBasicMaterial:' + material.uuid;

            var lineMaterial = this.cache.get(cacheKey);

            if (!lineMaterial) {

                lineMaterial = new THREE.LineBasicMaterial();
                THREE.Material.prototype.copy.call(lineMaterial, material);
                lineMaterial.color.copy(material.color);

                this.cache.add(cacheKey, lineMaterial);
            }

            material = lineMaterial;
        }

        // Clone the material if it will be modified
        if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {

            var cacheKey = 'ClonedMaterial:' + material.uuid + ':';

            if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
            if (useSkinning) cacheKey += 'skinning:';
            if (useVertexTangents) cacheKey += 'vertex-tangents:';
            if (useVertexColors) cacheKey += 'vertex-colors:';
            if (useFlatShading) cacheKey += 'flat-shading:';
            if (useMorphTargets) cacheKey += 'morph-targets:';
            if (useMorphNormals) cacheKey += 'morph-normals:';

            var cachedMaterial = this.cache.get(cacheKey);

            if (!cachedMaterial) {

                cachedMaterial = material.clone();

                if (useSkinning) cachedMaterial.skinning = true;
                if (useVertexTangents) cachedMaterial.vertexTangents = true;
                if (useVertexColors) cachedMaterial.vertexColors = true;
                if (useFlatShading) cachedMaterial.flatShading = true;
                if (useMorphTargets) cachedMaterial.morphTargets = true;
                if (useMorphNormals) cachedMaterial.morphNormals = true;

                this.cache.add(cacheKey, cachedMaterial);

                this.associations.set(cachedMaterial, this.associations.get(material));
            }

            material = cachedMaterial;
        }

        // workarounds for mesh and geometry

        if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {

            geometry.setAttribute('uv2', geometry.attributes.uv);
        }

        // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
        if (material.normalScale && !useVertexTangents) {

            material.normalScale.y = -material.normalScale.y;
        }

        if (material.clearcoatNormalScale && !useVertexTangents) {

            material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;
        }

        mesh.material = material;
    };

    GLTFParser.prototype.getMaterialType = function () /* materialIndex */{

        return THREE.MeshStandardMaterial;
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
     * @param {number} materialIndex
     * @return {Promise<THREE.Material>}
     */
    GLTFParser.prototype.loadMaterial = function (materialIndex) {

        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var materialDef = json.materials[materialIndex];

        var materialType;
        var materialParams = {};
        var materialExtensions = materialDef.extensions || {};

        var pending = [];

        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {

            var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            materialType = sgExtension.getMaterialType();
            pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
        } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {

            var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType();
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
        } else {

            // Specification:
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

            var metallicRoughness = materialDef.pbrMetallicRoughness || {};

            materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
            materialParams.opacity = 1.0;

            if (Array.isArray(metallicRoughness.baseColorFactor)) {

                var array = metallicRoughness.baseColorFactor;

                materialParams.color.fromArray(array);
                materialParams.opacity = array[3];
            }

            if (metallicRoughness.baseColorTexture !== undefined) {

                pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
            }

            materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
            materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

            if (metallicRoughness.metallicRoughnessTexture !== undefined) {

                pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
                pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
            }

            materialType = this._invokeOne(function (ext) {

                return ext.getMaterialType && ext.getMaterialType(materialIndex);
            });

            pending.push(Promise.all(this._invokeAll(function (ext) {

                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
            })));
        }

        if (materialDef.doubleSided === true) {

            materialParams.side = THREE.DoubleSide;
        }

        var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

        if (alphaMode === ALPHA_MODES.BLEND) {

            materialParams.transparent = true;

            // See: https://github.com/mrdoob/three.js/issues/17706
            materialParams.depthWrite = false;
        } else {

            materialParams.transparent = false;

            if (alphaMode === ALPHA_MODES.MASK) {

                materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
            }
        }

        if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {

            pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));

            materialParams.normalScale = new THREE.Vector2(1, 1);

            if (materialDef.normalTexture.scale !== undefined) {

                materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
            }
        }

        if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {

            pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

            if (materialDef.occlusionTexture.strength !== undefined) {

                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
            }
        }

        if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {

            materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);
        }

        if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {

            pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
        }

        return Promise.all(pending).then(function () {

            var material;

            if (materialType === GLTFMeshStandardSGMaterial) {

                material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
            } else {

                material = new materialType(materialParams);
            }

            if (materialDef.name) material.name = materialDef.name;

            // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
            if (material.map) material.map.encoding = THREE.sRGBEncoding;
            if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;

            assignExtrasToUserData(material, materialDef);

            parser.associations.set(material, { type: 'materials', index: materialIndex });

            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);

            return material;
        });
    };

    /** When Object3D instances are targeted by animation, they need unique names. */
    GLTFParser.prototype.createUniqueName = function (originalName) {

        var name = THREE.PropertyBinding.sanitizeNodeName(originalName || '');

        for (var i = 1; this.nodeNamesUsed[name]; ++i) {

            name = originalName + '_' + i;
        }

        this.nodeNamesUsed[name] = true;

        return name;
    };

    /**
     * @param {THREE.BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     */
    function computeBounds(geometry, primitiveDef, parser) {

        var attributes = primitiveDef.attributes;

        var box = new THREE.Box3();

        if (attributes.POSITION !== undefined) {

            var accessor = parser.json.accessors[attributes.POSITION];

            var min = accessor.min;
            var max = accessor.max;

            // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

            if (min !== undefined && max !== undefined) {

                box.set(new THREE.Vector3(min[0], min[1], min[2]), new THREE.Vector3(max[0], max[1], max[2]));
            } else {

                console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');

                return;
            }
        } else {

            return;
        }

        var targets = primitiveDef.targets;

        if (targets !== undefined) {

            var maxDisplacement = new THREE.Vector3();
            var vector = new THREE.Vector3();

            for (var i = 0, il = targets.length; i < il; i++) {

                var target = targets[i];

                if (target.POSITION !== undefined) {

                    var accessor = parser.json.accessors[target.POSITION];
                    var min = accessor.min;
                    var max = accessor.max;

                    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

                    if (min !== undefined && max !== undefined) {

                        // we need to get max of absolute components because target weight is [-1,1]
                        vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                        vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                        vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));

                        // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
                        // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
                        // are used to implement key-frame animations and as such only two are active at a time - this results in very large
                        // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
                        maxDisplacement.max(vector);
                    } else {

                        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
                    }
                }
            }

            // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
            box.expandByVector(maxDisplacement);
        }

        geometry.boundingBox = box;

        var sphere = new THREE.Sphere();

        box.getCenter(sphere.center);
        sphere.radius = box.min.distanceTo(box.max) / 2;

        geometry.boundingSphere = sphere;
    }

    /**
     * @param {THREE.BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     * @return {Promise<THREE.BufferGeometry>}
     */
    function addPrimitiveAttributes(geometry, primitiveDef, parser) {

        var attributes = primitiveDef.attributes;

        var pending = [];

        function assignAttributeAccessor(accessorIndex, attributeName) {

            return parser.getDependency('accessor', accessorIndex).then(function (accessor) {

                geometry.setAttribute(attributeName, accessor);
            });
        }

        for (var gltfAttributeName in attributes) {

            var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();

            // Skip attributes already provided by e.g. Draco extension.
            if (threeAttributeName in geometry.attributes) continue;

            pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
        }

        if (primitiveDef.indices !== undefined && !geometry.index) {

            var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {

                geometry.setIndex(accessor);
            });

            pending.push(accessor);
        }

        assignExtrasToUserData(geometry, primitiveDef);

        computeBounds(geometry, primitiveDef, parser);

        return Promise.all(pending).then(function () {

            return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
        });
    }

    /**
     * @param {THREE.BufferGeometry} geometry
     * @param {Number} drawMode
     * @return {THREE.BufferGeometry}
     */
    function toTrianglesDrawMode(geometry, drawMode) {

        var index = geometry.getIndex();

        // generate index if not present

        if (index === null) {

            var indices = [];

            var position = geometry.getAttribute('position');

            if (position !== undefined) {

                for (var i = 0; i < position.count; i++) {

                    indices.push(i);
                }

                geometry.setIndex(indices);
                index = geometry.getIndex();
            } else {

                console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
                return geometry;
            }
        }

        //

        var numberOfTriangles = index.count - 2;
        var newIndices = [];

        if (drawMode === THREE.TriangleFanDrawMode) {

            // gl.TRIANGLE_FAN

            for (var i = 1; i <= numberOfTriangles; i++) {

                newIndices.push(index.getX(0));
                newIndices.push(index.getX(i));
                newIndices.push(index.getX(i + 1));
            }
        } else {

            // gl.TRIANGLE_STRIP

            for (var i = 0; i < numberOfTriangles; i++) {

                if (i % 2 === 0) {

                    newIndices.push(index.getX(i));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i + 2));
                } else {

                    newIndices.push(index.getX(i + 2));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i));
                }
            }
        }

        if (newIndices.length / 3 !== numberOfTriangles) {

            console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
        }

        // build final geometry

        var newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);

        return newGeometry;
    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
     *
     * Creates BufferGeometries from primitives.
     *
     * @param {Array<GLTF.Primitive>} primitives
     * @return {Promise<Array<THREE.BufferGeometry>>}
     */
    GLTFParser.prototype.loadGeometries = function (primitives) {

        var parser = this;
        var extensions = this.extensions;
        var cache = this.primitiveCache;

        function createDracoPrimitive(primitive) {

            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {

                return addPrimitiveAttributes(geometry, primitive, parser);
            });
        }

        var pending = [];

        for (var i = 0, il = primitives.length; i < il; i++) {

            var primitive = primitives[i];
            var cacheKey = createPrimitiveKey(primitive);

            // See if we've already created this geometry
            var cached = cache[cacheKey];

            if (cached) {

                // Use the cached geometry if it exists
                pending.push(cached.promise);
            } else {

                var geometryPromise;

                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {

                    // Use DRACO geometry if available
                    geometryPromise = createDracoPrimitive(primitive);
                } else {

                    // Otherwise create a new geometry
                    geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);
                }

                // Cache this geometry
                cache[cacheKey] = { primitive: primitive, promise: geometryPromise };

                pending.push(geometryPromise);
            }
        }

        return Promise.all(pending);
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
     * @param {number} meshIndex
     * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}
     */
    GLTFParser.prototype.loadMesh = function (meshIndex) {

        var parser = this;
        var json = this.json;

        var meshDef = json.meshes[meshIndex];
        var primitives = meshDef.primitives;

        var pending = [];

        for (var i = 0, il = primitives.length; i < il; i++) {

            var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);

            pending.push(material);
        }

        pending.push(parser.loadGeometries(primitives));

        return Promise.all(pending).then(function (results) {

            var materials = results.slice(0, results.length - 1);
            var geometries = results[results.length - 1];

            var meshes = [];

            for (var i = 0, il = geometries.length; i < il; i++) {

                var geometry = geometries[i];
                var primitive = primitives[i];

                // 1. create Mesh

                var mesh;

                var material = materials[i];

                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {

                    // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
                    mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);

                    if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {

                        // we normalize floating point skin weight array to fix malformed assets (see #15319)
                        // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
                        mesh.normalizeSkinWeights();
                    }

                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {

                        mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleStripDrawMode);
                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {

                        mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleFanDrawMode);
                    }
                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {

                    mesh = new THREE.LineSegments(geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {

                    mesh = new THREE.Line(geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {

                    mesh = new THREE.LineLoop(geometry, material);
                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {

                    mesh = new THREE.Points(geometry, material);
                } else {

                    throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
                }

                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {

                    updateMorphTargets(mesh, meshDef);
                }

                mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);

                assignExtrasToUserData(mesh, meshDef);

                parser.assignFinalMaterial(mesh);

                meshes.push(mesh);
            }

            if (meshes.length === 1) {

                return meshes[0];
            }

            var group = new THREE.Group();

            for (var i = 0, il = meshes.length; i < il; i++) {

                group.add(meshes[i]);
            }

            return group;
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
     * @param {number} cameraIndex
     * @return {Promise<THREE.Camera>}
     */
    GLTFParser.prototype.loadCamera = function (cameraIndex) {

        var camera;
        var cameraDef = this.json.cameras[cameraIndex];
        var params = cameraDef[cameraDef.type];

        if (!params) {

            console.warn('THREE.GLTFLoader: Missing camera parameters.');
            return;
        }

        if (cameraDef.type === 'perspective') {

            camera = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
        } else if (cameraDef.type === 'orthographic') {

            camera = new THREE.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
        }

        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);

        assignExtrasToUserData(camera, cameraDef);

        return Promise.resolve(camera);
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
     * @param {number} skinIndex
     * @return {Promise<Object>}
     */
    GLTFParser.prototype.loadSkin = function (skinIndex) {

        var skinDef = this.json.skins[skinIndex];

        var skinEntry = { joints: skinDef.joints };

        if (skinDef.inverseBindMatrices === undefined) {

            return Promise.resolve(skinEntry);
        }

        return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {

            skinEntry.inverseBindMatrices = accessor;

            return skinEntry;
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
     * @param {number} animationIndex
     * @return {Promise<THREE.AnimationClip>}
     */
    GLTFParser.prototype.loadAnimation = function (animationIndex) {

        var json = this.json;

        var animationDef = json.animations[animationIndex];

        var pendingNodes = [];
        var pendingInputAccessors = [];
        var pendingOutputAccessors = [];
        var pendingSamplers = [];
        var pendingTargets = [];

        for (var i = 0, il = animationDef.channels.length; i < il; i++) {

            var channel = animationDef.channels[i];
            var sampler = animationDef.samplers[channel.sampler];
            var target = channel.target;
            var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
            var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
            var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;

            pendingNodes.push(this.getDependency('node', name));
            pendingInputAccessors.push(this.getDependency('accessor', input));
            pendingOutputAccessors.push(this.getDependency('accessor', output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);
        }

        return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {

            var nodes = dependencies[0];
            var inputAccessors = dependencies[1];
            var outputAccessors = dependencies[2];
            var samplers = dependencies[3];
            var targets = dependencies[4];

            var tracks = [];

            for (var i = 0, il = nodes.length; i < il; i++) {

                var node = nodes[i];
                var inputAccessor = inputAccessors[i];
                var outputAccessor = outputAccessors[i];
                var sampler = samplers[i];
                var target = targets[i];

                if (node === undefined) continue;

                node.updateMatrix();
                node.matrixAutoUpdate = true;

                var TypedKeyframeTrack;

                switch (PATH_PROPERTIES[target.path]) {

                    case PATH_PROPERTIES.weights:

                        TypedKeyframeTrack = THREE.NumberKeyframeTrack;
                        break;

                    case PATH_PROPERTIES.rotation:

                        TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
                        break;

                    case PATH_PROPERTIES.position:
                    case PATH_PROPERTIES.scale:
                    default:

                        TypedKeyframeTrack = THREE.VectorKeyframeTrack;
                        break;

                }

                var targetName = node.name ? node.name : node.uuid;

                var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;

                var targetNames = [];

                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {

                    // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.
                    node.traverse(function (object) {

                        if (object.isMesh === true && object.morphTargetInfluences) {

                            targetNames.push(object.name ? object.name : object.uuid);
                        }
                    });
                } else {

                    targetNames.push(targetName);
                }

                var outputArray = outputAccessor.array;

                if (outputAccessor.normalized) {

                    var scale;

                    if (outputArray.constructor === Int8Array) {

                        scale = 1 / 127;
                    } else if (outputArray.constructor === Uint8Array) {

                        scale = 1 / 255;
                    } else if (outputArray.constructor == Int16Array) {

                        scale = 1 / 32767;
                    } else if (outputArray.constructor === Uint16Array) {

                        scale = 1 / 65535;
                    } else {

                        throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');
                    }

                    var scaled = new Float32Array(outputArray.length);

                    for (var j = 0, jl = outputArray.length; j < jl; j++) {

                        scaled[j] = outputArray[j] * scale;
                    }

                    outputArray = scaled;
                }

                for (var j = 0, jl = targetNames.length; j < jl; j++) {

                    var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);

                    // Override interpolation with custom factory method.
                    if (sampler.interpolation === 'CUBICSPLINE') {

                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {

                            // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                            // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                            // must be divided by three to get the interpolant's sampleSize argument.

                            return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
                        };

                        // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
                    }

                    tracks.push(track);
                }
            }

            var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

            return new THREE.AnimationClip(name, undefined, tracks);
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
     * @param {number} nodeIndex
     * @return {Promise<THREE.Object3D>}
     */
    GLTFParser.prototype.loadNode = function (nodeIndex) {

        var json = this.json;
        var extensions = this.extensions;
        var parser = this;

        var nodeDef = json.nodes[nodeIndex];

        // reserve node's name before its dependencies, so the root has the intended name.
        var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';

        return function () {

            var pending = [];

            if (nodeDef.mesh !== undefined) {

                pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {

                    var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

                    // if weights are provided on the node, override weights on the mesh.
                    if (nodeDef.weights !== undefined) {

                        node.traverse(function (o) {

                            if (!o.isMesh) return;

                            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {

                                o.morphTargetInfluences[i] = nodeDef.weights[i];
                            }
                        });
                    }

                    return node;
                }));
            }

            if (nodeDef.camera !== undefined) {

                pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {

                    return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
                }));
            }

            parser._invokeAll(function (ext) {

                return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
            }).forEach(function (promise) {

                pending.push(promise);
            });

            return Promise.all(pending);
        }().then(function (objects) {

            var node;

            // .isBone isn't in glTF spec. See ._markDefs
            if (nodeDef.isBone === true) {

                node = new THREE.Bone();
            } else if (objects.length > 1) {

                node = new THREE.Group();
            } else if (objects.length === 1) {

                node = objects[0];
            } else {

                node = new THREE.Object3D();
            }

            if (node !== objects[0]) {

                for (var i = 0, il = objects.length; i < il; i++) {

                    node.add(objects[i]);
                }
            }

            if (nodeDef.name) {

                node.userData.name = nodeDef.name;
                node.name = nodeName;
            }

            assignExtrasToUserData(node, nodeDef);

            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

            if (nodeDef.matrix !== undefined) {

                var matrix = new THREE.Matrix4();
                matrix.fromArray(nodeDef.matrix);
                node.applyMatrix4(matrix);
            } else {

                if (nodeDef.translation !== undefined) {

                    node.position.fromArray(nodeDef.translation);
                }

                if (nodeDef.rotation !== undefined) {

                    node.quaternion.fromArray(nodeDef.rotation);
                }

                if (nodeDef.scale !== undefined) {

                    node.scale.fromArray(nodeDef.scale);
                }
            }

            parser.associations.set(node, { type: 'nodes', index: nodeIndex });

            return node;
        });
    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
     * @param {number} sceneIndex
     * @return {Promise<THREE.Group>}
     */
    GLTFParser.prototype.loadScene = function () {

        // scene node hierachy builder

        function buildNodeHierachy(nodeId, parentObject, json, parser) {

            var nodeDef = json.nodes[nodeId];

            return parser.getDependency('node', nodeId).then(function (node) {

                if (nodeDef.skin === undefined) return node;

                // build skeleton here as well

                var skinEntry;

                return parser.getDependency('skin', nodeDef.skin).then(function (skin) {

                    skinEntry = skin;

                    var pendingJoints = [];

                    for (var i = 0, il = skinEntry.joints.length; i < il; i++) {

                        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
                    }

                    return Promise.all(pendingJoints);
                }).then(function (jointNodes) {

                    node.traverse(function (mesh) {

                        if (!mesh.isMesh) return;

                        var bones = [];
                        var boneInverses = [];

                        for (var j = 0, jl = jointNodes.length; j < jl; j++) {

                            var jointNode = jointNodes[j];

                            if (jointNode) {

                                bones.push(jointNode);

                                var mat = new THREE.Matrix4();

                                if (skinEntry.inverseBindMatrices !== undefined) {

                                    mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                                }

                                boneInverses.push(mat);
                            } else {

                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                            }
                        }

                        mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);
                    });

                    return node;
                });
            }).then(function (node) {

                // build node hierachy

                parentObject.add(node);

                var pending = [];

                if (nodeDef.children) {

                    var children = nodeDef.children;

                    for (var i = 0, il = children.length; i < il; i++) {

                        var child = children[i];
                        pending.push(buildNodeHierachy(child, node, json, parser));
                    }
                }

                return Promise.all(pending);
            });
        }

        return function loadScene(sceneIndex) {

            var json = this.json;
            var extensions = this.extensions;
            var sceneDef = this.json.scenes[sceneIndex];
            var parser = this;

            // Loader returns Group, not Scene.
            // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
            var scene = new THREE.Group();
            if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);

            assignExtrasToUserData(scene, sceneDef);

            if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);

            var nodeIds = sceneDef.nodes || [];

            var pending = [];

            for (var i = 0, il = nodeIds.length; i < il; i++) {

                pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
            }

            return Promise.all(pending).then(function () {

                return scene;
            });
        };
    }();

    return GLTFLoader;
}();

/***/ }),

/***/ 1705:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _WebGL = __webpack_require__(1706);

var _Application = __webpack_require__(1707);

(function () {
    if (!_WebGL.WEBGL.isWebGLAvailable()) {
        console.log(_WebGL.WEBGL.getWebGLErrorMessage());

        return;
    }

    var windowWidth = void 0;
    var windowHeight = void 0;
    var windowHeighttoDistance = void 0;

    if (window.matchMedia("(min-width: 1025px)").matches) {
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight;
        windowHeighttoDistance = window.innerHeight;
    } else {
        windowWidth = document.documentElement.clientWidth;
        windowHeight = document.documentElement.clientHeight + 200;
        windowHeighttoDistance = document.documentElement.clientHeight;
    }

    var application = new _Application.Application("hamburgerCanvas", "particlesCanvas", windowWidth, windowHeight);

    var ANIMATION_EASE_RATIO = 0.1;

    var windowHalfWidth;
    var windowHalfHeight;

    windowHalfWidth = windowWidth / 2;
    windowHalfHeight = windowHeight / 2;

    var ipadElem = document.querySelector(".bk__features__inner__block");
    var ipadElemInner = document.querySelector(".bk__features__inner__block__ipad");
    var ipadElemPhoto = document.querySelector(".bk__features__inner__block__ipad__photo");
    var challengeSolution = document.querySelector(".bk__challenge_solution");
    var feedback = document.querySelector(".bk__feedback");
    var mainFeatures = document.querySelector(".bk__main_features__bottom");
    var features = document.querySelector(".bk__features");
    var featuresBottom = document.querySelector(".bk__features__bottom");

    var mainContainer = document.querySelector(".landing__scrollable-container-1");
    var scrollContainer = mainContainer.querySelector(".landing__scrollable-container-2");
    var hamInner = document.querySelector("#hamburgerCanvas");

    var challengeText = document.querySelector(".bk__challenge_solution__inner__right__ch");
    var solutionText = document.querySelector(".bk__challenge_solution__inner__right__so");

    if (window.matchMedia("(min-width: 1025px)").matches) {
        hamInner.style.top = "0px";
    } else {
        hamInner.style.top = "-100px";
    }

    var opacityDuration = 50; // взять из animation.js

    var HeightBig = void 0;

    if (window.matchMedia("(min-width: 1025px)").matches) {
        HeightBig = scrollContainer.offsetWidth * 0.6;
    } else {
        HeightBig = 0;
    }

    // анимация двух текстов

    var challenge1 = void 0;
    var challenge2 = void 0;
    var challenge3 = void 0;

    // if (window.matchMedia("(min-width: 1025px)").matches) {
    challenge3 = getElementOffsetTop(challengeText) + HeightBig - 3 * getElementOffsetTop(mainContainer);
    challenge2 = getElementOffsetTop(challengeText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + challengeText.offsetHeight) / 2;
    challenge1 = getElementOffsetTop(challengeText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + challengeText.offsetHeight;
    // }


    var solution1 = void 0;
    var solution2 = void 0;
    var solution3 = void 0;

    solution3 = getElementOffsetTop(solutionText) + HeightBig - 3 * getElementOffsetTop(mainContainer);
    solution2 = getElementOffsetTop(solutionText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + solutionText.offsetHeight) / 2;
    solution1 = getElementOffsetTop(solutionText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + solutionText.offsetHeight;

    // анимация двух текстов

    var mouseWheelDeltaDistance = 0;
    var mouseWheelDistance;

    if (window.matchMedia("(min-width: 1025px)").matches) {

        mouseWheelDistance = getElementOffsetTop(ipadElem) - 3 * getElementOffsetTop(mainContainer);
    } else {

        mouseWheelDistance = getElementOffsetTop(ipadElemInner) + HeightBig - 4 * getElementOffsetTop(mainContainer) - windowHeighttoDistance;

        if (mouseWheelDistance <= 0) {
            mouseWheelDistance = 200;
        }
    }

    // let mouseWheelDistance2 = getElementOffsetTop(challengeSolution) - 3*getElementOffsetTop(mainContainer) + scrollContainer.offsetWidth * 2 - window.innerHeight + 50;

    // let paddingFeatures = parseFloat(window.getComputedStyle(features, null).getPropertyValue('padding-bottom'));
    var mouseWheelDistance2 = getElementOffsetTop(features) + HeightBig - 2 * getElementOffsetTop(mainContainer) + features.offsetHeight - featuresBottom.offsetHeight - windowHeighttoDistance;

    // let mouseWheelDistance2End = getElementOffsetTop(feedback) + HeightBig - 3*getElementOffsetTop(mainContainer);
    var mouseWheelDistance2End = getElementOffsetTop(mainFeatures) + HeightBig - 3 * getElementOffsetTop(mainContainer);

    var deltaWheel2 = mouseWheelDistance2End - mouseWheelDistance2;

    var mouseWheelDistance3 = getElementOffsetTop(features) + HeightBig - 3 * getElementOffsetTop(mainContainer) + features.offsetHeight - featuresBottom.offsetHeight;

    var mouseWheelDistance3End = getElementOffsetTop(feedback) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance;

    var deltaWheel3 = mouseWheelDistance3End - mouseWheelDistance3;

    var mouseWheelDeltaDistance2 = 0;

    var mouseWheelRatio = 0;
    var mouseWheelDelayedRatio = 0;

    var mouseWheelRatio2 = 0;
    var mouseWheelDelayedRatio2 = 0;

    var partOfBigAnimation = HeightBig * opacityDuration / 100;

    if (window.matchMedia("(min-width: 1025px)").matches) {

        partOfBigAnimation = HeightBig * opacityDuration / 100;
    } else {

        partOfBigAnimation = ipadElemInner.offsetHeight;
    }

    // const opacityDelay = 180;
    var opacityDelay = partOfBigAnimation;

    var cursorRatioX = 0;
    var cursorDelayedRatioX = 0;
    var cursorRatioY = 0;
    var cursorDelayedRatioY = 0;

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Canvas3D listeners
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    var hamCanv = document.getElementById('hamburgerCanvas');

    function canvas3DLoadingCompleteListener() {
        window.addEventListener("resize", windowResizeListener, false);
        // window.addEventListener("wheel", mouseWheelListener, false);
        // window.addEventListener("scroll", mouseWheelListener, false);
        hamCanv.addEventListener("mousemove", mouseMoveListener, false);

        animate();
    }

    function canvas3DLoadingProgressListener(bytesLoaded, bytesTotal) {
        console.log(Math.round(bytesLoaded / bytesTotal * 100) + "% loaded");
    }

    function canvas3DLoadingErrorListener(error) {
        console.log(error);
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Listeners
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function mouseMoveListener(event) {

        var mouseX = event.offsetX;
        var mouseY = event.offsetY;

        if (mouseX >= windowHalfWidth) {
            cursorRatioY = (mouseX - windowHalfWidth) / windowHalfWidth;
        } else {
            cursorRatioY = -(windowHalfWidth - mouseX) / windowHalfWidth;
        }

        if (mouseY >= windowHalfHeight) {
            cursorRatioX = (mouseY - windowHalfHeight) / windowHalfHeight;
        } else {
            cursorRatioX = -(windowHalfHeight - mouseY) / windowHalfHeight;
        }
    }

    function getElementOffsetTop(element) {
        var offsetTop = 0;

        while (element && typeof element.offsetTop === "number") {
            offsetTop += element.offsetTop;
            element = element.parentNode;
        }

        return offsetTop;
    }

    function mouseWheelListener(event) {
        // event.preventDefault();

        var opacityPar = 100;

        var opacityNew = 100;

        var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;

        if (scrollTop > mouseWheelDistance && scrollTop <= mouseWheelDistance + opacityDelay) {

            var innerPar = (scrollTop - mouseWheelDistance) / opacityDelay * 100;

            opacityPar = opacityPar - innerPar;

            hamInner.style.opacity = "" + Math.round(opacityPar) / 100;

            if (window.matchMedia("(max-width: 1024px)").matches) {
                ipadElemPhoto.style.opacity = "" + Math.round(100 - opacityPar) / 100;
            }
        }

        if (scrollTop <= mouseWheelDistance) {
            opacityPar = 100;
            hamInner.style.opacity = "" + Math.round(opacityPar) / 100;

            if (window.matchMedia("(max-width: 1024px)").matches) {
                ipadElemPhoto.style.opacity = "" + Math.round(100 - opacityPar) / 100;
            }
        }

        if (scrollTop > mouseWheelDistance + opacityDelay) {
            opacityPar = 0;
            hamInner.style.opacity = "" + Math.round(opacityPar) / 100;

            if (window.matchMedia("(max-width: 1024px)").matches) {
                ipadElemPhoto.style.opacity = "" + Math.round(100 - opacityPar) / 100;
            }
        }

        if (scrollTop >= mouseWheelDistance2) {
            hamInner.style.opacity = "" + Math.round(opacityNew) / 100;
        }

        // 1-я анимация


        if (scrollTop > 0 && scrollTop <= mouseWheelDistance) {

            // mouseWheelDeltaDistance += event.deltaY;

            mouseWheelDeltaDistance = scrollTop;

            if (mouseWheelDeltaDistance > mouseWheelDistance) {
                mouseWheelDeltaDistance = mouseWheelDistance;
            } else if (mouseWheelDeltaDistance < 0) {
                mouseWheelDeltaDistance = 0;
            }

            mouseWheelRatio = mouseWheelDeltaDistance / mouseWheelDistance / 2;

            application._camera.position.z = mouseWheelDeltaDistance / mouseWheelDistance * 10 + 8;
        }

        if (scrollTop <= 0) {
            mouseWheelRatio = 0;
            mouseWheelDeltaDistance = 0;
            application._camera.position.z = 8;
        }

        if (scrollTop > mouseWheelDistance) {
            mouseWheelRatio = mouseWheelDistance;
            mouseWheelDeltaDistance = mouseWheelDistance;
            application._camera.position.z = 18;
        }

        // 1-я анимация


        // 2-я анимация


        if (scrollTop > mouseWheelDistance2 && scrollTop <= mouseWheelDistance2End) {

            // mouseWheelDeltaDistance += event.deltaY;

            mouseWheelDeltaDistance2 = scrollTop - mouseWheelDistance2;

            if (mouseWheelDeltaDistance2 > deltaWheel2) {
                mouseWheelDeltaDistance2 = deltaWheel2;
            } else if (mouseWheelDeltaDistance2 < 0) {
                mouseWheelDeltaDistance2 = 0;
            }

            mouseWheelRatio2 = 0.5 + mouseWheelDeltaDistance2 / deltaWheel2 / 2;
        }

        if (scrollTop <= mouseWheelDistance2) {
            mouseWheelRatio2 = 0.5;
            mouseWheelDeltaDistance2 = 0;
        }

        if (scrollTop > mouseWheelDistance2End) {
            mouseWheelRatio2 = 1;
            mouseWheelDeltaDistance2 = deltaWheel2;
        }

        var opacityIpad = 100;

        if (scrollTop > mouseWheelDistance2 && scrollTop <= mouseWheelDistance3) {
            var innerParIpad = (scrollTop - mouseWheelDistance2) / (mouseWheelDistance3 - mouseWheelDistance2) * 100;

            opacityIpad = opacityIpad - innerParIpad;

            ipadElemInner.style.opacity = "" + Math.round(opacityIpad) / 100;
        }

        if (scrollTop > mouseWheelDistance3) {
            opacityIpad = 0;
            ipadElemInner.style.opacity = "" + Math.round(opacityIpad) / 100;
        }

        if (scrollTop < mouseWheelDistance2) {
            opacityIpad = 100;
            ipadElemInner.style.opacity = "" + Math.round(opacityIpad) / 100;
        }

        //  анимация текста 1

        var HeightPadd = windowHeighttoDistance / 10 / 2;

        if (window.matchMedia("(min-width: 1025px)").matches) {

            if (challenge3 - challenge1 >= challengeText.offsetHeight - HeightPadd * 4) {

                var OpacityChall1 = 0;
                var OpacityChall2 = 100;

                if (scrollTop > challenge1 && scrollTop <= challenge2 - HeightPadd) {
                    var koefChall1 = (scrollTop - challenge1) / (challenge2 - HeightPadd - challenge1) * 100;

                    OpacityChall1 = OpacityChall1 + koefChall1;

                    challengeText.style.opacity = "" + Math.round(OpacityChall1) / 100;
                }

                if (scrollTop < challenge1) {
                    OpacityChall1 = 0;
                    challengeText.style.opacity = "" + Math.round(OpacityChall1) / 100;
                }

                if (scrollTop >= challenge2 - HeightPadd && scrollTop <= challenge2 + HeightPadd) {
                    challengeText.style.opacity = 1;
                }

                if (scrollTop > challenge2 + HeightPadd && scrollTop <= challenge3) {
                    var koefChall2 = (scrollTop - challenge2 - HeightPadd) / (challenge3 - challenge2 - HeightPadd) * 100;

                    OpacityChall2 = OpacityChall2 - koefChall2;

                    challengeText.style.opacity = "" + Math.round(OpacityChall2) / 100;
                }

                if (scrollTop > challenge3) {
                    OpacityChall2 = 0;
                    challengeText.style.opacity = "" + Math.round(OpacityChall2) / 100;
                }
            } else {
                challengeText.style.opacity = 1;
            }
        } else {
            challengeText.style.opacity = 1;
        }

        // анимация текста 1


        //  анимация текста 2

        if (window.matchMedia("(min-width: 1025px)").matches) {

            if (challenge3 - challenge1 >= challengeText.offsetHeight - HeightPadd * 4) {

                var OpacitySol1 = 0;
                var OpacitySol2 = 100;

                if (scrollTop > solution1 && scrollTop <= solution2 - HeightPadd) {
                    var koefSol1 = (scrollTop - solution1) / (solution2 - HeightPadd - solution1) * 100;

                    OpacitySol1 = OpacitySol1 + koefSol1;

                    solutionText.style.opacity = "" + Math.round(OpacitySol1) / 100;
                }

                if (scrollTop < solution1) {
                    OpacitySol1 = 0;
                    solutionText.style.opacity = "" + Math.round(OpacitySol1) / 100;
                }

                if (scrollTop >= solution2 - HeightPadd && scrollTop <= solution2 + HeightPadd) {
                    solutionText.style.opacity = 1;
                }

                if (scrollTop > solution2 + HeightPadd && scrollTop <= solution3) {
                    var koefSol2 = (scrollTop - solution2 - HeightPadd) / (solution3 - solution2 - HeightPadd) * 100;

                    OpacitySol2 = OpacitySol2 - koefSol2;

                    solutionText.style.opacity = "" + Math.round(OpacitySol2) / 100;
                }

                if (scrollTop > solution3) {
                    OpacitySol2 = 0;
                    solutionText.style.opacity = "" + Math.round(OpacitySol2) / 100;
                }

                solutionText.style.marginTop = 0;
            } else {
                solutionText.style.opacity = 1;

                solutionText.style.marginTop = "100px";
            }
        } else {
            solutionText.style.opacity = 1;

            solutionText.style.marginTop = 0;
        }

        // анимация текста 2


        // if (scrollTop > mouseWheelDistance3 && scrollTop <= mouseWheelDistance3End) {
        //
        //     // mouseWheelDeltaDistance += event.deltaY;
        //
        //     mouseWheelDeltaDistance2 = scrollTop - mouseWheelDistance3;
        //
        //     if (mouseWheelDeltaDistance2 > deltaWheel3) {
        //         mouseWheelDeltaDistance2 = deltaWheel3;
        //     } else if (mouseWheelDeltaDistance2 < 0) {
        //         mouseWheelDeltaDistance2 = 0;
        //     }
        //
        //     mouseWheelRatio2 = 0.5 + mouseWheelDeltaDistance2 / deltaWheel3 / 2;
        //
        // }
        //
        // if (scrollTop <= mouseWheelDistance3) {
        //     mouseWheelRatio2 = 0.5;
        //     mouseWheelDeltaDistance2 = 0;
        // }
        //
        // if (scrollTop > mouseWheelDistance3End) {
        //     mouseWheelRatio2 = 1;
        //     mouseWheelDeltaDistance2 = deltaWheel3;
        // }

        // 2-я анимация
    }

    function windowResizeListener() {

        if (window.matchMedia("(min-width: 1025px)").matches) {
            windowWidth = window.innerWidth;
            windowHeight = window.innerHeight;
            windowHeighttoDistance = window.innerHeight;
        } else {
            windowWidth = document.documentElement.clientWidth;
            windowHeight = document.documentElement.clientHeight + 200;
            windowHeighttoDistance = document.documentElement.clientHeight;
        }

        if (window.matchMedia("(min-width: 1025px)").matches) {
            hamInner.style.top = "0px";
        } else {
            hamInner.style.top = "-100px";
        }

        windowHalfWidth = windowWidth / 2;
        windowHalfHeight = windowHeight / 2;

        application.setSize(windowWidth, windowHeight);

        // alert(document.documentElement.clientWidth);
        // alert(document.documentElement.clientHeight);


        if (window.matchMedia("(min-width: 1025px)").matches) {
            HeightBig = scrollContainer.offsetWidth * 0.6;
        } else {
            HeightBig = 0;
        }

        if (window.matchMedia("(min-width: 1025px)").matches) {

            mouseWheelDistance = getElementOffsetTop(ipadElem) - getElementOffsetTop(mainContainer);

            partOfBigAnimation = HeightBig * opacityDuration / 100;
            opacityDelay = partOfBigAnimation;
            // mouseWheelDistance2 = getElementOffsetTop(challengeSolution) - getElementOffsetTop(mainContainer) + scrollContainer.offsetWidth * 2 - window.innerHeight + 50;

            // paddingFeatures = parseFloat(window.getComputedStyle(features, null).getPropertyValue('padding-bottom'));
            mouseWheelDistance2 = getElementOffsetTop(features) + HeightBig + features.offsetHeight - featuresBottom.offsetHeight - windowHeighttoDistance;

            // mouseWheelDistance2End = getElementOffsetTop(feedback) + HeightBig - getElementOffsetTop(mainContainer);
            mouseWheelDistance2End = getElementOffsetTop(mainFeatures) + HeightBig - getElementOffsetTop(mainContainer);
            deltaWheel2 = mouseWheelDistance2End - mouseWheelDistance2;

            mouseWheelDistance3 = getElementOffsetTop(features) + HeightBig - getElementOffsetTop(mainContainer) + features.offsetHeight - featuresBottom.offsetHeight;

            mouseWheelDistance3End = getElementOffsetTop(feedback) + HeightBig - windowHeighttoDistance;

            deltaWheel3 = mouseWheelDistance3End - mouseWheelDistance3;
        } else {

            mouseWheelDistance = getElementOffsetTop(ipadElemInner) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance;

            if (mouseWheelDistance <= 0) {
                mouseWheelDistance = 200;
            }

            mouseWheelDistance2 = getElementOffsetTop(features) + HeightBig - 2 * getElementOffsetTop(mainContainer) + features.offsetHeight - featuresBottom.offsetHeight - windowHeighttoDistance;

            mouseWheelDistance2End = getElementOffsetTop(mainFeatures) + HeightBig - 3 * getElementOffsetTop(mainContainer);

            deltaWheel2 = mouseWheelDistance2End - mouseWheelDistance2;

            mouseWheelDistance3 = getElementOffsetTop(features) + HeightBig - 3 * getElementOffsetTop(mainContainer) + features.offsetHeight - featuresBottom.offsetHeight;

            mouseWheelDistance3End = getElementOffsetTop(feedback) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance;

            deltaWheel3 = mouseWheelDistance3End - mouseWheelDistance3;

            partOfBigAnimation = ipadElemInner.offsetHeight;

            opacityDelay = partOfBigAnimation;
        }

        if (window.matchMedia("(min-width: 1025px)").matches) {
            challenge3 = getElementOffsetTop(challengeText) + HeightBig - getElementOffsetTop(mainContainer);
            challenge2 = getElementOffsetTop(challengeText) + HeightBig - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + challengeText.offsetHeight) / 2;
            challenge1 = getElementOffsetTop(challengeText) + HeightBig - windowHeighttoDistance + challengeText.offsetHeight;
        } else {
            challenge3 = getElementOffsetTop(challengeText) + HeightBig - 3 * getElementOffsetTop(mainContainer);
            challenge2 = getElementOffsetTop(challengeText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + challengeText.offsetHeight) / 2;
            challenge1 = getElementOffsetTop(challengeText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + challengeText.offsetHeight;
        }

        if (window.matchMedia("(min-width: 1025px)").matches) {
            solution3 = getElementOffsetTop(solutionText) + HeightBig - getElementOffsetTop(mainContainer);
            solution2 = getElementOffsetTop(solutionText) + HeightBig - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + solutionText.offsetHeight) / 2;
            solution1 = getElementOffsetTop(solutionText) + HeightBig - windowHeighttoDistance + solutionText.offsetHeight;
        } else {
            solution3 = getElementOffsetTop(solutionText) + HeightBig - 3 * getElementOffsetTop(mainContainer);
            solution2 = getElementOffsetTop(solutionText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + solutionText.offsetHeight) / 2;
            solution1 = getElementOffsetTop(solutionText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + solutionText.offsetHeight;
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Animation
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function animate() {

        var scrollTopFrame = document.body.scrollTop || document.documentElement.scrollTop;

        requestAnimationFrame(animate);

        mouseWheelListener();

        if (window.matchMedia("(min-width: 1025px)").matches) {
            mouseWheelDistance = getElementOffsetTop(ipadElem) - getElementOffsetTop(mainContainer);
            mouseWheelDistance2 = getElementOffsetTop(features) + HeightBig + features.offsetHeight - featuresBottom.offsetHeight - windowHeighttoDistance;
            mouseWheelDistance2End = getElementOffsetTop(mainFeatures) + HeightBig - getElementOffsetTop(mainContainer);
        } else {
            mouseWheelDistance = getElementOffsetTop(ipadElemInner) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance;
            if (mouseWheelDistance <= 0) {
                mouseWheelDistance = 200;
            }

            mouseWheelDistance2 = getElementOffsetTop(features) + HeightBig - 2 * getElementOffsetTop(mainContainer) + features.offsetHeight - featuresBottom.offsetHeight - windowHeighttoDistance;
            mouseWheelDistance2End = getElementOffsetTop(mainFeatures) + HeightBig - 3 * getElementOffsetTop(mainContainer);
        }

        if (window.matchMedia("(min-width: 1025px)").matches) {
            challenge3 = getElementOffsetTop(challengeText) + HeightBig - getElementOffsetTop(mainContainer);
            challenge2 = getElementOffsetTop(challengeText) + HeightBig - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + challengeText.offsetHeight) / 2;
            challenge1 = getElementOffsetTop(challengeText) + HeightBig - windowHeighttoDistance + challengeText.offsetHeight;
        } else {
            challenge3 = getElementOffsetTop(challengeText) + HeightBig - 3 * getElementOffsetTop(mainContainer);
            challenge2 = getElementOffsetTop(challengeText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + challengeText.offsetHeight) / 2;
            challenge1 = getElementOffsetTop(challengeText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + challengeText.offsetHeight;
        }

        if (window.matchMedia("(min-width: 1025px)").matches) {
            solution3 = getElementOffsetTop(solutionText) + HeightBig - getElementOffsetTop(mainContainer);
            solution2 = getElementOffsetTop(solutionText) + HeightBig - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + solutionText.offsetHeight) / 2;
            solution1 = getElementOffsetTop(solutionText) + HeightBig - windowHeighttoDistance + solutionText.offsetHeight;
        } else {
            solution3 = getElementOffsetTop(solutionText) + HeightBig - 3 * getElementOffsetTop(mainContainer);
            solution2 = getElementOffsetTop(solutionText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + (windowHeighttoDistance - getElementOffsetTop(mainContainer) + solutionText.offsetHeight) / 2;
            solution1 = getElementOffsetTop(solutionText) + HeightBig - 2 * getElementOffsetTop(mainContainer) - windowHeighttoDistance + solutionText.offsetHeight;
        }

        if (scrollTopFrame <= mouseWheelDistance + opacityDelay) {

            // TODO stop calculations
            cursorDelayedRatioX = cursorDelayedRatioX + (cursorRatioX - cursorDelayedRatioX) * ANIMATION_EASE_RATIO;
            cursorDelayedRatioY = cursorDelayedRatioY + (cursorRatioY - cursorDelayedRatioY) * ANIMATION_EASE_RATIO;
            mouseWheelDelayedRatio = mouseWheelDelayedRatio + (mouseWheelRatio - mouseWheelDelayedRatio) * 1;

            application.setRotationRatio(cursorDelayedRatioX, cursorDelayedRatioY);

            application.setAnimationTimeRatio(mouseWheelDelayedRatio);

            application.tick();

            application._camera.position.x = 0;

            application._camera.position.y = 0;

            hamInner.style.zIndex = 6;
        } else if (scrollTopFrame >= mouseWheelDistance2 && scrollTopFrame <= mouseWheelDistance2End) {

            if (window.matchMedia("(min-width: 1025px)").matches) {
                application._camera.position.z = 10;

                application._camera.position.x = 3;

                hamInner.style.opacity = 1;

                application._camera.position.y = -0.3;
            } else if (window.matchMedia("(max-width: 1024px)").matches) {
                application._camera.position.z = 10;

                application._camera.position.x = 0;

                hamInner.style.opacity = 0.2;

                application._camera.position.y = -0.4;
            }

            hamInner.style.zIndex = 5;

            cursorDelayedRatioX = cursorDelayedRatioX + (cursorRatioX - cursorDelayedRatioX) * ANIMATION_EASE_RATIO;
            cursorDelayedRatioY = cursorDelayedRatioY + (cursorRatioY - cursorDelayedRatioY) * ANIMATION_EASE_RATIO;

            mouseWheelDelayedRatio2 = mouseWheelDelayedRatio2 + (mouseWheelRatio2 - mouseWheelDelayedRatio2) * 1;

            application.setRotationRatio(cursorDelayedRatioX, cursorDelayedRatioY);

            application.setAnimationTimeRatio(mouseWheelDelayedRatio2);

            application.tick();
        } else {
            hamInner.style.opacity = 0;
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Initialization
    //
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    application.run(canvas3DLoadingCompleteListener);

    /*canvas3D.init(
        canvas3DLoadingCompleteListener,
        canvas3DLoadingProgressListener,
        canvas3DLoadingErrorListener
    );*/
})();

/***/ }),

/***/ 1706:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var WEBGL = exports.WEBGL = {

    isWebGLAvailable: function isWebGLAvailable() {

        try {

            var canvas = document.createElement('canvas');
            return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {

            return false;
        }
    },

    isWebGL2Available: function isWebGL2Available() {

        try {

            var canvas = document.createElement('canvas');
            return !!(window.WebGL2RenderingContext && canvas.getContext('webgl2'));
        } catch (e) {

            return false;
        }
    },

    getWebGLErrorMessage: function getWebGLErrorMessage() {

        return this.getErrorMessage(1);
    },

    getWebGL2ErrorMessage: function getWebGL2ErrorMessage() {

        return this.getErrorMessage(2);
    },

    getErrorMessage: function getErrorMessage(version) {

        var names = {
            1: 'WebGL',
            2: 'WebGL 2'
        };

        var contexts = {
            1: window.WebGLRenderingContext,
            2: window.WebGL2RenderingContext
        };

        var message = 'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';

        var element = document.createElement('div');
        element.id = 'webglmessage';
        element.style.fontFamily = 'monospace';
        element.style.fontSize = '13px';
        element.style.fontWeight = 'normal';
        element.style.textAlign = 'center';
        element.style.background = '#fff';
        element.style.color = '#000';
        element.style.padding = '1.5em';
        element.style.width = '400px';
        element.style.margin = '5em auto 0';

        if (contexts[version]) {

            message = message.replace('$0', 'graphics card');
        } else {

            message = message.replace('$0', 'browser');
        }

        message = message.replace('$1', names[version]);

        element.innerHTML = message;

        return element;
    }

};

/***/ }),

/***/ 1707:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Application = Application;

var _Hamburger = __webpack_require__(1708);

var count = 0;

// import {Particles} from './Particles';
function Application(hamburgerCanvasDomElementId, particlesCanvasDomElementId, width, height) {
    this._scaleHeight = 1024;

    this._width = width;
    this._height = height;

    this._animationDuration = 0;
    this._animationMixer = null;

    this._hamburgerScene = null;

    // коэффициент времени анимации, от 0 до 1, где 0 - начало анимации, 1 - конец анимации
    this._animationTimeRatio = 0;

    // угол вращения гамбургера по вертикали, 30 градусов вверх, 30 градусов вниз
    this._rotationAngleX = this._getAngleInRadians(3);

    // угол вращения гамбургера по горизотали, 30 градусов влево, 30 градусов вправо
    this._rotationAngleY = this._getAngleInRadians(10);

    // коэффициент вращения по вертикали, от -1 до 1, где -1 - крайнее верхнее положение, 1 - крайнее нижнее положение
    this._rotationRatioX = 0;

    // коэффициент вращения по горизонтали, от -1 до 1, где -1 - крайнее левое положение, 1 - крайнее правое положение
    this._rotationRatioY = 0;

    // this._particlesCanvasDomElement = document.getElementById(particlesCanvasDomElementId);
    this._hamburgerCanvasDomElement = document.getElementById(hamburgerCanvasDomElementId);

    this._hamburgerScene = null;
    this._particlesScene = null;

    this._camera = null;

    this._particlesRenderer = null;
    this._hamburgerRenderer = null;

    this._rotationX = null;
    this._rotationY = null;

    this._hamburger = null;
    this._particles = null;

    this._hamburgerIsLoaded = false;
    this._patriclesIsLoaded = false;

    this._constantRotationY = 0;
    this._deltaConstantRotationY = 0.008;

    this._particlesEffectComposer = null;
    this._hamburgerEffectComposer = null;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Public methods
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Application.prototype.run = function (canvas3DLoadingCompleteListener) {
    var _this = this;
    var gltfLoader = new THREE.GLTFLoader();
    // var loader = new THREE.TextureLoader();

    var file;

    if (window.matchMedia("(min-width: 1025px)").matches) {
        file = __webpack_require__(1709);
    } else {
        file = __webpack_require__(1710);
    }

    // file = require("./glb/G_highpoly-Denis-Mobile.glb");

    gltfLoader.load(file, function (glb) {
        _this._hamburger = new _Hamburger.Hamburger(glb);
        _this._hamburgerIsLoaded = true;

        done();
    }, function (xhr) {
        // loadintProgeressListener(xhr.loaded, xhr.total);
    }, function (error) {
        //loadingErrorListener(error);

        console.log(error);
    });

    // loader.load(
    //     // resource URL
    //     require("./images/Particle.png"),
    //
    //     // onLoad callback
    //     function(texture)
    //     {
    //         _this._particles = new Particles(texture, _this._height / _this._scaleHeight);
    //         _this._patriclesIsLoaded = true;
    //
    //         done();
    //     },
    //
    //     // onProgress callback currently not supported
    //     undefined,
    //
    //     // onError callback
    //     function(error)
    //     {
    //         console.error(error);
    //     }
    // );

    function done() {
        // if (_this._hamburgerIsLoaded && _this._patriclesIsLoaded)

        if (_this._hamburgerIsLoaded) {
            _this.init();

            canvas3DLoadingCompleteListener();
        }
    }

    // function loadintProgeressListener(a, b) {
    //     console.log("loaded",a/b*100);
    //     console.log("total",b);
    // }
};

Application.prototype.init = function () {
    this._hamburgerScene = new THREE.Scene();
    // this._particlesScene = new THREE.Scene();

    this._camera = new THREE.PerspectiveCamera(35, this._width / this._height, 0.1, 60);
    this._camera.position.z = 8;

    // this._particlesRenderer = new THREE.WebGLRenderer({ canvas: this._particlesCanvasDomElement, antialias: true, alpha: true });
    // this._particlesRenderer.setSize(window.innerWidth, window.innerHeight);
    // this._particlesRenderer.outputEncoding = THREE.sRGBEncoding;

    this._hamburgerRenderer = new THREE.WebGLRenderer({
        canvas: this._hamburgerCanvasDomElement,
        antialias: true,
        alpha: true
    });

    var windowWidth = void 0;
    var windowHeight = void 0;

    if (window.matchMedia("(min-width: 1025px)").matches) {
        windowWidth = window.innerWidth;
        windowHeight = window.innerHeight;
    } else {
        windowWidth = document.documentElement.clientWidth;
        windowHeight = document.documentElement.clientHeight + 200;
    }

    this._hamburgerRenderer.setSize(windowWidth, windowHeight);
    this._hamburgerRenderer.outputEncoding = THREE.sRGBEncoding;
    this._hamburgerRenderer.shadowMap.enabled = true;
    this._hamburgerRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // var pointLight = new THREE.PointLight(0xffffff, 1.5, 0);
    // pointLight.castShadow = true;
    // pointLight.position.set(8, 8, 8);
    // pointLight.shadow.mapSize.width = 1024;
    // pointLight.shadow.mapSize.height = 1024;
    // pointLight.shadow.camera.near = 0.1;
    // pointLight.shadow.camera.far = 100;
    // pointLight.shadow.bias = -0.01;
    //
    // this._hamburgerScene.add(pointLight);


    // var pointLight2 = new THREE.PointLight(0xffffff, 1, 100);
    // pointLight2.castShadow = true;
    // pointLight2.position.set(1.056, -6.318, -0.052);
    // pointLight2.shadow.mapSize.width = 1024;
    // pointLight2.shadow.mapSize.height = 1024;
    // pointLight2.shadow.camera.near = 0.1;
    // pointLight2.shadow.camera.far = 100;
    // pointLight2.shadow.bias = -0.01;
    //
    // this._hamburgerScene.add(pointLight2);
    //
    //
    // var pointLight3 = new THREE.PointLight(0xffffff, 1.2, 100);
    // pointLight3.castShadow = true;
    // pointLight3.position.set(9.576, 7.305, -0.005);
    // pointLight3.shadow.mapSize.width = 1024;
    // pointLight3.shadow.mapSize.height = 1024;
    // pointLight3.shadow.camera.near = 0.1;
    // pointLight3.shadow.camera.far = 100;
    // pointLight3.shadow.bias = -0.01;
    //
    // this._hamburgerScene.add(pointLight3);
    //
    //
    // var pointLight4 = new THREE.PointLight(0xffffff, 1.2, 100);
    // pointLight4.castShadow = true;
    // pointLight4.position.set(-9.188, 7.702, -1.653);
    // pointLight4.shadow.mapSize.width = 1024;
    // pointLight4.shadow.mapSize.height = 1024;
    // pointLight4.shadow.camera.near = 0.1;
    // pointLight4.shadow.camera.far = 100;
    // pointLight4.shadow.bias = -0.01;
    //
    // this._hamburgerScene.add(pointLight4);


    var spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(15.056, -16.318, -10.052);

    spotLight.power = 3;
    spotLight.decay = 1.5;
    spotLight.distance = Infinity;

    spotLight.castShadow = true;

    spotLight.shadow.mapSize.width = 1024;
    spotLight.shadow.mapSize.height = 1024;

    spotLight.shadow.camera.near = 0.1;
    spotLight.shadow.camera.far = 100;
    spotLight.shadow.camera.fov = 30;
    spotLight.shadow.bias = -0.01;

    this._hamburgerScene.add(spotLight);

    // const helper = new THREE.SpotLightHelper(spotLight);
    // this._hamburgerScene.add(helper);


    var spotLight2 = new THREE.SpotLight(0xffffff);
    spotLight2.position.set(10.576, 17.305, -10.005);

    spotLight2.power = 3;
    spotLight2.decay = 1.5;
    spotLight2.distance = Infinity;

    spotLight2.castShadow = true;

    spotLight2.shadow.mapSize.width = 1024;
    spotLight2.shadow.mapSize.height = 1024;

    spotLight2.shadow.camera.near = 0.1;
    spotLight2.shadow.camera.far = 100;
    spotLight2.shadow.camera.fov = 30;
    spotLight2.shadow.bias = -0.01;

    this._hamburgerScene.add(spotLight2);

    // const helper2 = new THREE.SpotLightHelper(spotLight2);
    // this._hamburgerScene.add(helper2);


    var spotLight3 = new THREE.SpotLight(0xffffff);
    spotLight3.position.set(-19.188, 17.702, -11.653);

    spotLight3.power = 3;
    spotLight3.decay = 1.5;
    spotLight3.distance = Infinity;

    spotLight3.castShadow = true;

    spotLight3.shadow.mapSize.width = 1024;
    spotLight3.shadow.mapSize.height = 1024;

    spotLight3.shadow.camera.near = 0.1;
    spotLight3.shadow.camera.far = 100;
    spotLight3.shadow.camera.fov = 30;
    spotLight3.shadow.bias = -0.01;

    this._hamburgerScene.add(spotLight3);

    // const helper3 = new THREE.SpotLightHelper(spotLight3);
    // this._hamburgerScene.add(helper3);


    var ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    this._hamburgerScene.add(ambientLight);
    this._hamburgerScene.add(this._hamburger.object3D);

    // this._particlesScene.add(this._particles.object3D);

    // var particlesRenderPass = new THREE.RenderPass(this._particlesScene, this._camera);
    // var hamburgerRenderPass = new THREE.RenderPass(this._hamburgerScene, this._camera);

    // var filmPass = new THREE.FilmPass(0.35, 0.025, 648, false);

    // var renderTarget = new THREE.WebGLMultisampleRenderTarget(this._width, this._height, {});

    // this._particlesEffectComposer = new THREE.EffectComposer(this._particlesRenderer, renderTarget);
    // this._particlesEffectComposer.renderTarget1.texture.encoding = THREE.sRGBEncoding;
    // this._particlesEffectComposer.renderTarget2.texture.encoding = THREE.sRGBEncoding;
    // this._particlesEffectComposer.addPass(particlesRenderPass);
    // this._particlesEffectComposer.addPass(filmPass);

    // this._hamburgerEffectComposer = new THREE.EffectComposer(this._hamburgerRenderer, renderTarget);
    // this._hamburgerEffectComposer.renderTarget1.texture.encoding = THREE.sRGBEncoding;
    // this._hamburgerEffectComposer.renderTarget2.texture.encoding = THREE.sRGBEncoding;
    // this._hamburgerEffectComposer.addPass(hamburgerRenderPass);
    // this._hamburgerEffectComposer.addPass(filmPass);
};

Application.prototype.setSize = function (width, height) {
    this._width = width;
    this._height = height;

    // this._particles.setScale(this._height / this._scaleHeight);

    this._camera.aspect = this._width / this._height;
    this._camera.updateProjectionMatrix();

    // this._particlesRenderer.setSize(this._width, this._height);
    this._hamburgerRenderer.setSize(this._width, this._height);
};

Application.prototype.setRotationRatio = function (rotationRatioX, rotationRatioY) {
    if (rotationRatioX < -1) {
        this._rotationRatioX = -1;
    } else if (rotationRatioX > 1) {
        this._rotationRatioX = 1;
    } else {
        this._rotationRatioX = rotationRatioX;
    }

    if (rotationRatioY < -1) {
        this._rotationRatioY = -1;
    } else if (rotationRatioY > 1) {
        this._rotationRatioY = 1;
    } else {
        this._rotationRatioY = rotationRatioY;
    }
};

Application.prototype.setAnimationTimeRatio = function (value) {
    if (value < 0) {
        this._animationTimeRatio = 0;
    } else if (value >= 1) {
        this._animationTimeRatio = 1;
    } else {
        this._animationTimeRatio = value;
    }
};

Application.prototype.tick = function () {
    this._constantRotationY += this._deltaConstantRotationY;

    var rotationY = this._rotationRatioY * this._rotationAngleY;
    var rotationX = this._rotationRatioX * this._rotationAngleX;

    this._hamburger.tick(rotationX, rotationY, this._constantRotationY * 0.05, this._animationTimeRatio);
    // this._particles.tick(rotationX, rotationY, this._constantRotationY * 0.05);

    // this._particlesEffectComposer.render(0.01);
    // this._hamburgerEffectComposer.render(0.01);

    this._hamburgerRenderer.render(this._hamburgerScene, this._camera);
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Private methods
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Application.prototype._getAngleInRadians = function (angleInDegrese) {
    return angleInDegrese / 180 * Math.PI;
};

/***/ }),

/***/ 1708:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Hamburger = Hamburger;
function Hamburger(glb) {
    this._animationDuration = 0;

    glb.scene.traverse(function (node) {
        if (node.isMesh) {
            // TODO make not all objects receive/cast a shadow
            node.castShadow = true;
            node.receiveShadow = true;
        }
    });

    this._animationMixer = new THREE.AnimationMixer(glb.scene);

    var animations = glb.animations;

    for (var i = 0; i < animations.length; i++) {
        var animation = animations[i];

        if (animation.duration > this._animationDuration) {
            this._animationDuration = animation.duration;
        }
    }

    // TODO find out what the hell is going on
    this._animationDuration *= 0.999;

    for (var i = 0; i < animations.length; i++) {
        this._animationMixer.clipAction(animations[i]).play();
    }

    var rotationGroupY = new THREE.Group();
    rotationGroupY.add(glb.scene);

    var rotationGroupX = new THREE.Group();
    rotationGroupX.add(rotationGroupY);

    this.object3D = rotationGroupX;

    this._rotationX = rotationGroupX.rotation;
    this._rotationY = rotationGroupY.rotation;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Public methods
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

Hamburger.prototype.tick = function (rotationX, rotationY, constantRotationY, animationTimeRatio) {
    this._rotationX.x = rotationX;
    this._rotationY.y = rotationY + constantRotationY;

    this._animationMixer.setTime(animationTimeRatio * this._animationDuration);
};

/***/ }),

/***/ 1709:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/files/G_highpoly-Denis-Bread.glb";

/***/ }),

/***/ 171:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loopCreate = __webpack_require__(172);

var _loopCreate2 = _interopRequireDefault(_loopCreate);

var _loopFix = __webpack_require__(173);

var _loopFix2 = _interopRequireDefault(_loopFix);

var _loopDestroy = __webpack_require__(174);

var _loopDestroy2 = _interopRequireDefault(_loopDestroy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  loopCreate: _loopCreate2.default,
  loopFix: _loopFix2.default,
  loopDestroy: _loopDestroy2.default
};

/***/ }),

/***/ 1710:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/files/G_highpoly-Denis-Mobile.glb";

/***/ }),

/***/ 1711:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function initAnimation() {
    // Return on IE
    if (!!window.MSInputMethodContext && !!document.documentMode) {
        return;
    }

    var containerElement1 = document.querySelector(".landing__scrollable-container-1");

    if (containerElement1) {
        var getElementOffsetTop = function getElementOffsetTop(element) {
            var offsetTop = 0;

            while (element && typeof element.offsetTop === "number") {
                offsetTop += element.offsetTop;
                element = element.parentNode;
            }

            return offsetTop;
        };

        var handleResize = function handleResize() {
            if (window.matchMedia("(min-width: 1025px)").matches) {
                // TODO use something making sense
                extraHeight = containerElement2.offsetWidth * 0.6;

                deltaHeight = extraHeight;

                containerElement1.style.minHeight = containerElement2.offsetHeight + extraHeight + "px";
                containerElement2.classList.add("landing__scroll-container-2--fixed");

                window.addEventListener("scroll", function () {
                    window.requestAnimationFrame(handleScroll);
                }, false);
                window.requestAnimationFrame(handleScroll);
            } else {
                containerElement2.classList.remove("landing__scroll-container-2--fixed");
                containerElement1.removeAttribute("style");
                containerElement2.removeAttribute("style");

                window.removeEventListener("scroll", function () {
                    handleScroll();
                }, false);
            }
        };

        var handleScroll = function handleScroll() {

            if (window.matchMedia("(min-width: 1025px)").matches) {

                var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
                var stopScrollOffsetY = getElementOffsetTop(scrollSectionElement) - getElementOffsetTop(containerElement1);

                if (scrollTop <= stopScrollOffsetY) {
                    top = -scrollTop + getElementOffsetTop(containerElement1);

                    // значения при 0

                    iBlock = 100;

                    oPhoto = 0;

                    tab1Left = 0;
                    tab1Top = 0;
                    tab1Scale = 0;

                    tab2Top = 0;
                    tab2Scale = 0;

                    tab3Right = 0;
                    tab3Top = 0;
                    tab3Scale = 0;

                    tab4Right = 0;
                    tab4Top = 0;
                    tab4Scale = 0;

                    tab5Left = 0;
                    tab5Top = 0;
                    tab5Scale = 0;

                    tab6Left = 0;
                    tab6Bottom = 0;
                    tab6Scale = 0;

                    tab7Left = 0;
                    tab7Bottom = 0;
                    tab7Scale = 0;

                    tab8Bottom = 0;
                    tab8Scale = 0;

                    tab9Right = 0;
                    tab9Bottom = 0;
                    tab9Scale = 0;

                    winnerRight = 0;
                    winnerBottom = 0;
                    winnerScale = 0;
                } else {
                    top = -stopScrollOffsetY + getElementOffsetTop(containerElement1);
                }

                var dy = containerElement1.offsetHeight - scrollTop + getElementOffsetTop(containerElement1) - (containerElement2.offsetHeight + top);

                if (dy < 0) {
                    top += dy;

                    // значения при 100

                    iBlock = 0;

                    oPhoto = 100;

                    // tab1Left = -35;
                    // tab1Top = -50;
                    tab1Left = -14;
                    tab1Top = -16;
                    tab1Scale = 1;

                    // tab2Top = -40;
                    tab2Top = -18;
                    tab2Scale = 1;

                    // tab3Right = -35;
                    // tab3Top = -45;
                    tab3Right = 15;
                    tab3Top = -16;
                    tab3Scale = 1;

                    // tab4Right = -20;
                    // tab4Top = 10;
                    tab4Right = 12;
                    tab4Top = 5;
                    tab4Scale = 1;

                    // tab5Left = -20;
                    // tab5Top = 10;
                    tab5Left = -12;
                    tab5Top = 5;
                    tab5Scale = 1;

                    // tab6Left = -45;
                    // tab6Bottom = 5;
                    // tab6Left = -34;
                    // tab6Bottom = 6;

                    tab6Left = -25;
                    tab6Bottom = -3;

                    tab6Scale = 1;

                    // tab7Left = -35;
                    // tab7Bottom = -45;
                    tab7Left = -10;
                    tab7Bottom = 17;
                    tab7Scale = 1;

                    // tab8Bottom = -55;
                    tab8Bottom = 20;
                    tab8Scale = 1;

                    // tab9Right = -30;
                    // tab9Bottom = -50;
                    tab9Right = 14;
                    tab9Bottom = 18;
                    tab9Scale = 1;

                    // winnerRight = -35;
                    winnerRight = 22;
                    winnerBottom = 2;
                    winnerScale = 1;
                } else {

                    lambda = (1 - dy / deltaHeight) * 100;

                    lambda = lambda <= 0 ? 0 : lambda;

                    // if (lambda >= 0 && lambda <= 10){
                    //     iBlock = 100 - (lambda * 10);
                    //
                    // } else{
                    //     iBlock = 0;
                    // }


                    if (lambda >= 0 && lambda <= 50) {
                        oPhoto = lambda * 100 / 30;
                    } else {
                        oPhoto = 100;
                    }

                    // if (lambda >= 15 && lambda <= 30){
                    //     oPhoto = (lambda - 15) * 6.666;
                    //
                    // } else if(lambda < 15){
                    //     oPhoto = 0;
                    // } else {
                    //     oPhoto = 100;
                    // }

                    if (lambda >= 50 && lambda <= 65) {
                        tab1Left = -13 * (lambda - 50) / 15;
                        tab1Top = -15 * (lambda - 50) / 15;
                        tab1Scale = (lambda - 50) / 15;
                    } else if (lambda < 50) {
                        tab1Left = 0;
                        tab1Top = 0;
                        tab1Scale = 0;
                    } else if (lambda > 65) {
                        tab1Scale = 1;
                    } else if (lambda > 95) {
                        tab1Left = -14;
                        tab1Top = -16;
                        tab1Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 95) {
                        tab1Left = -13 + -1 * (lambda - 65) / 30;
                        tab1Top = -15 + -1 * (lambda - 65) / 30;
                    }

                    if (lambda >= 51 && lambda <= 65) {
                        tab3Right = 14 * (lambda - 51) / 14;
                        tab3Top = -15 * (lambda - 51) / 14;
                        tab3Scale = (lambda - 51) / 14;
                    } else if (lambda < 51) {
                        tab3Right = 0;
                        tab3Top = 0;
                        tab3Scale = 0;
                    } else if (lambda > 65) {
                        tab3Scale = 1;
                    } else if (lambda > 95) {
                        tab3Right = 15;
                        tab3Top = -16;
                        tab3Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 95) {
                        tab3Right = 14 + 1 * (lambda - 65) / 30;
                        tab3Top = -15 + -1 * (lambda - 65) / 30;
                    }

                    // if (lambda >= 51 && lambda <= 65){
                    //     tab3Right = -20 * (lambda - 51) / 14;
                    //     tab3Top = -35 * (lambda - 51) / 14;
                    //     tab3Scale = (lambda - 51) / 14;
                    // } else if(lambda < 51){
                    //     tab3Right = 0;
                    //     tab3Top = 0;
                    //     tab3Scale = 0;
                    // } else {
                    //     tab3Right = -20;
                    //     tab3Top = -35;
                    //     tab3Scale = 1;
                    // }


                    // if (lambda >= 27 && lambda <= 41){
                    //     tab3Right = -20 * (lambda - 27) / 14;
                    //     tab3Top = -35 * (lambda - 27) / 14;
                    //     tab3Scale = (lambda - 27) / 14;
                    // } else if(lambda < 27){
                    //     tab3Right = 0;
                    //     tab3Top = 0;
                    //     tab3Scale = 0;
                    // } else {
                    //     tab3Right = -20;
                    //     tab3Top = -35;
                    //     tab3Scale = 1;
                    // }

                    if (lambda >= 53 && lambda <= 65) {
                        tab9Right = 13 * (lambda - 53) / 12;
                        tab9Bottom = 17 * (lambda - 53) / 12;
                        tab9Scale = (lambda - 53) / 12;
                    } else if (lambda < 53) {
                        tab9Right = 0;
                        tab9Bottom = 0;
                        tab9Scale = 0;
                    } else if (lambda > 65) {
                        tab9Scale = 1;
                    } else if (lambda > 96) {
                        tab9Right = 14;
                        tab9Bottom = 18;
                        tab9Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 96) {
                        tab9Right = 13 + 1 * (lambda - 65) / 31;
                        tab9Bottom = 17 + 1 * (lambda - 65) / 31;
                    }

                    // if (lambda >= 34 && lambda <= 48){
                    //     tab9Right = -20 * (lambda - 34) / 14;
                    //     tab9Bottom = -42 * (lambda - 34) / 14;
                    //     tab9Scale = (lambda - 34) / 14;
                    // } else if(lambda < 34){
                    //     tab9Right = 0;
                    //     tab9Bottom = 0;
                    //     tab9Scale = 0;
                    // } else {
                    //     tab9Right = -20;
                    //     tab9Bottom = -42;
                    //     tab9Scale = 1;
                    // }


                    if (lambda >= 54 && lambda <= 65) {
                        tab7Left = -9 * (lambda - 54) / 11;
                        tab7Bottom = 16 * (lambda - 54) / 11;
                        tab7Scale = (lambda - 54) / 11;
                    } else if (lambda < 54) {
                        tab7Left = 0;
                        tab7Bottom = 0;
                        tab7Scale = 0;
                    } else if (lambda > 65) {
                        tab7Scale = 1;
                    } else if (lambda > 97) {
                        tab7Left = -10;
                        tab7Bottom = 17;
                        tab7Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 97) {
                        tab7Left = -9 + -1 * (lambda - 65) / 32;
                        tab7Bottom = 16 + 1 * (lambda - 65) / 32;
                    }

                    // if (lambda >= 41 && lambda <= 55){
                    //     tab7Left = -20 * (lambda - 41) / 14;
                    //     tab7Bottom = -35 * (lambda - 41) / 14;
                    //     tab7Scale = (lambda - 41) / 14;
                    // } else if(lambda < 41){
                    //     tab7Left = 0;
                    //     tab7Bottom = 0;
                    //     tab7Scale = 0;
                    // } else {
                    //     tab7Left = -20;
                    //     tab7Bottom = -35;
                    //     tab7Scale = 1;
                    // }


                    if (lambda >= 56 && lambda <= 65) {
                        tab5Left = -11 * (lambda - 56) / 9;
                        tab5Top = 4 * (lambda - 56) / 9;
                        tab5Scale = (lambda - 56) / 9;
                    } else if (lambda < 56) {
                        tab5Left = 0;
                        tab5Top = 0;
                        tab5Scale = 0;
                    } else if (lambda > 65) {
                        tab5Scale = 1;
                    } else if (lambda > 97) {
                        tab5Left = -12;
                        tab5Top = 5;
                        tab5Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 97) {
                        tab5Left = -11 + -1 * (lambda - 65) / 32;
                        tab5Top = 4 + 1 * (lambda - 65) / 32;
                    }

                    // if (lambda >= 48 && lambda <= 62){
                    //     tab5Left = -15 * (lambda - 48) / 14;
                    //     tab5Top = 12 * (lambda - 48) / 14;
                    //     tab5Scale = (lambda - 48) / 14;
                    //
                    // } else if(lambda < 48){
                    //     tab5Left = 0;
                    //     tab5Top = 0;
                    //     tab5Scale = 0;
                    //
                    // } else {
                    //     tab5Left = -15;
                    //     tab5Top = 12;
                    //     tab5Scale = 1;
                    // }


                    if (lambda >= 57 && lambda <= 65) {

                        tab8Bottom = 19 * (lambda - 57) / 8;
                        tab8Scale = (lambda - 57) / 8;
                    } else if (lambda < 57) {
                        tab8Bottom = 0;
                        tab8Scale = 0;
                    } else if (lambda > 65) {
                        tab8Scale = 1;
                    } else if (lambda > 97) {
                        tab8Bottom = 20;
                        tab8Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 97) {
                        tab8Bottom = 19 + 1 * (lambda - 65) / 32;
                    }

                    // if (lambda >= 55 && lambda <= 69){
                    //
                    //     tab8Bottom = -34 * (lambda - 55) / 14;
                    //     tab8Scale = (lambda - 55) / 14;
                    //
                    // } else if(lambda < 55){
                    //
                    //     tab8Bottom = 0;
                    //     tab8Scale = 0;
                    // } else {
                    //
                    //     tab8Bottom = -34;
                    //     tab8Scale = 1;
                    // }

                    if (lambda >= 58 && lambda <= 65) {
                        tab4Right = 11 * (lambda - 58) / 7;
                        tab4Top = 4 * (lambda - 58) / 7;
                        tab4Scale = (lambda - 58) / 7;
                    } else if (lambda < 58) {
                        tab4Right = 0;
                        tab4Top = 0;
                        tab4Scale = 0;
                    } else if (lambda > 65) {
                        tab4Scale = 1;
                    } else if (lambda > 98) {
                        tab4Right = 12;
                        tab4Top = 5;
                        tab4Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 98) {
                        tab4Right = 11 + 1 * (lambda - 65) / 33;
                        tab4Top = 4 + 1 * (lambda - 65) / 33;
                    }

                    // if (lambda >= 62 && lambda <= 76){
                    //     tab4Right = -15 * (lambda - 62) / 14;
                    //     tab4Top = 12 * (lambda - 62) / 14;
                    //     tab4Scale = (lambda - 62) / 14;
                    //
                    //
                    // } else if(lambda < 62){
                    //     tab4Right = 0;
                    //     tab4Top = 0;
                    //     tab4Scale = 0;
                    //
                    // } else {
                    //     tab4Right = -15;
                    //     tab4Top = 12;
                    //     tab4Scale = 1;
                    // }


                    if (lambda >= 60 && lambda <= 65) {

                        tab6Left = -24 * (lambda - 60) / 5;
                        tab6Bottom = -2 * (lambda - 60) / 5;
                        tab6Scale = (lambda - 60) / 5;
                    } else if (lambda < 60) {
                        tab6Left = 0;
                        tab6Bottom = 0;
                        tab6Scale = 0;
                    } else if (lambda > 65) {
                        tab6Scale = 1;
                    } else if (lambda > 99) {
                        tab6Left = -25;
                        tab6Bottom = -3;
                        tab6Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 99) {
                        tab6Left = -24 + -1 * (lambda - 65) / 34;
                        tab6Bottom = -2 + -1 * (lambda - 65) / 34;
                    }

                    // if (lambda >= 69 && lambda <= 83){
                    //
                    //     tab6Left = -35 * (lambda - 69) / 14;
                    //     tab6Bottom = 3 * (lambda - 69) / 14;
                    //     tab6Scale = (lambda - 69) / 14;
                    //
                    // } else if(lambda < 69){
                    //
                    //     tab6Left = 0;
                    //     tab6Bottom = 0;
                    //     tab6Scale = 0;
                    // } else {
                    //
                    //     tab6Left = -35;
                    //     tab6Bottom = 3;
                    //     tab6Scale = 1;
                    // }


                    if (lambda >= 61 && lambda <= 65) {
                        tab2Top = -17 * (lambda - 61) / 4;
                        tab2Scale = (lambda - 61) / 4;
                    } else if (lambda < 61) {
                        tab2Top = 0;
                        tab2Scale = 0;
                    } else if (lambda > 65) {
                        tab2Scale = 1;
                    } else if (lambda >= 100) {
                        tab2Top = -18;
                        tab2Scale = 1;
                    }

                    if (lambda >= 65 && lambda <= 100) {
                        tab2Top = -17 + -1 * (lambda - 65) / 35;
                    }

                    if (lambda >= 62 && lambda <= 65) {
                        winnerRight = 21 * (lambda - 62) / 3;
                        winnerBottom = 1 * (lambda - 62) / 3;
                        winnerScale = (lambda - 62) / 3;
                    } else if (lambda < 62) {
                        winnerRight = 0;
                        winnerBottom = 0;
                        winnerScale = 0;
                    } else if (lambda > 65) {
                        winnerScale = 1;
                    } else if (lambda >= 100) {
                        winnerRight = 22;
                        winnerBottom = 2;
                    }

                    if (lambda >= 65 && lambda <= 100) {
                        winnerRight = 21 + 1 * (lambda - 65) / 35;
                        winnerBottom = 1 + 1 * (lambda - 65) / 35;
                    }

                    // if (lambda >= 76 && lambda <= 90){
                    //     tab2Top = -28 * (lambda - 76) / 14;
                    //     tab2Scale = (lambda - 76) / 14;
                    // } else if(lambda < 76){
                    //     tab2Top = 0;
                    //     tab2Scale = 0;
                    // } else {
                    //     tab2Top = -28;
                    //     tab2Scale = 1;
                    // }
                    //
                    // if (lambda >= 83 && lambda <= 97){
                    //     winnerRight = -26 * (lambda - 83) / 14;
                    //     winnerBottom = -2 * (lambda - 83) / 14;
                    //     winnerScale = (lambda - 83) / 14;
                    // } else if(lambda < 83){
                    //     winnerRight = 0;
                    //     winnerBottom = 0;
                    //     winnerScale = 0;
                    // } else {
                    //     winnerRight = -26;
                    //     winnerBottom = -2;
                    //     winnerScale = 1;
                    // }
                }

                var features = document.querySelector(".bk__features");
                var featuresBottom = document.querySelector(".bk__features__bottom");

                var lineToSecondAnimation = getElementOffsetTop(features) + extraHeight + features.offsetHeight - featuresBottom.offsetHeight - window.innerHeight;

                var hamTop = void 0;

                if (scrollTop >= lineToSecondAnimation) {
                    hamTop = top;
                } else {
                    hamTop = top - getElementOffsetTop(containerElement1) / 5;
                }

                containerElement2.style.transform = "translate3d(0," + top + "px,0)";
                // containerElement2.style.transform = `translateY(${top}px)`;

                hamInner.style.transform = "translate3d(0," + -hamTop + "px,0)";
                // hamInner.style.transform = `translateY(${-hamTop}px)`;


                // ipadBlock.style.top = `${Math.round(iBlock)}%`;

                opacityPhoto.style.opacity = "" + Math.round(oPhoto) / 100;

                // tab1.style.left = `${tab1Left}%`;
                // tab1.style.top = `${tab1Top}%`;

                // tab1.style.transform=`scale(${tab1Scale})`;
                tab1.style.transform = "translate3d(" + tab1Left.toFixed(2) + "vh , " + tab1Top.toFixed(2) + "vh,0) scale3d(" + (tab1Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab1Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab2.style.top = `${tab2Top}%`;

                // tab2.style.transform=`scale(${tab2Scale})`;
                tab2.style.transform = "translate3d( 0, " + tab2Top.toFixed(2) + "vh, 0) scale3d(" + (tab2Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab2Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab3.style.right = `${tab3Right}%`;
                // tab3.style.top = `${tab3Top}%`;

                // tab3.style.transform=`scale(${tab3Scale})`;
                tab3.style.transform = "translate3d(" + tab3Right.toFixed(2) + "vh , " + tab3Top.toFixed(2) + "vh,0) scale3d(" + (tab3Scale * window.innerHeight / HeightMax).toFixed(2) + ", " + (tab3Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab4.style.right = `${tab4Right}%`;
                // tab4.style.top = `${tab4Top}%`;

                // tab4.style.transform=`scale(${tab4Scale})`;
                tab4.style.transform = "translate3d(" + tab4Right.toFixed(2) + "vh , " + tab4Top.toFixed(2) + "vh,0) scale3d(" + (tab4Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab4Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab5.style.left = `${tab5Left}%`;
                // tab5.style.top = `${tab5Top}%`;

                // tab5.style.transform=`scale(${tab5Scale})`;
                tab5.style.transform = "translate3d(" + tab5Left.toFixed(2) + "vh , " + tab5Top.toFixed(2) + "vh,0) scale3d(" + (tab5Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab5Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab6.style.left = `${tab6Left}%`;
                // tab6.style.bottom = `${tab6Bottom}%`;

                // tab6.style.transform=`scale(${tab6Scale})`;
                tab6.style.transform = "translate3d(" + tab6Left.toFixed(2) + "vh , " + tab6Bottom.toFixed(2) + "vh,0) scale3d(" + (tab6Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab6Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab7.style.left = `${tab7Left}%`;
                // tab7.style.bottom = `${tab7Bottom}%`;

                // tab7.style.transform=`scale(${tab7Scale}`;
                tab7.style.transform = "translate3d(" + tab7Left.toFixed(2) + "vh , " + tab7Bottom.toFixed(2) + "vh,0) scale3d(" + (tab7Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab7Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab8.style.bottom = `${tab8Bottom}%`;

                // tab8.style.transform=`scale(${tab8Scale})`;
                tab8.style.transform = "translate3d( 0, " + tab8Bottom.toFixed(2) + "vh, 0) scale3d(" + (tab8Scale * window.innerHeight / HeightMax).toFixed(2) + ", " + (tab8Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // tab9.style.right = `${tab9Right}%`;
                // tab9.style.bottom = `${tab9Bottom}%`;

                // tab9.style.transform=`scale(${tab9Scale})`;
                tab9.style.transform = "translate3d(" + tab9Right.toFixed(2) + "vh , " + tab9Bottom.toFixed(2) + "vh,0) scale3d(" + (tab9Scale * window.innerHeight / HeightMax).toFixed(2) + "," + (tab9Scale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";

                // winner.style.right = `${winnerRight}%`;
                // winner.style.bottom = `${winnerBottom}%`;

                // winner.style.transform=`scale(${winnerScale})`;
                winner.style.transform = "translate3d(" + winnerRight.toFixed(2) + "vh , " + winnerBottom.toFixed(2) + "vh,0) scale3d(" + (winnerScale * window.innerHeight / HeightMax).toFixed(2) + "," + (winnerScale * window.innerHeight / HeightMax).toFixed(2) + ", 1)";
            }
        };

        var containerElement2 = containerElement1.querySelector(".landing__scrollable-container-2");

        var hamInner = containerElement1.querySelector("#hamburgerCanvas");

        var scrollSectionElement = containerElement1.querySelector(".bk__features__inner__block");

        var opacityPhoto = containerElement1.querySelector(".bk__features__inner__block__ipad__photo");

        var tab1 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--1");

        var tab2 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--2");

        var tab3 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--3");

        var tab4 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--4");

        var tab5 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--5");

        var tab6 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--6");

        var tab7 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--7");

        var tab8 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--8");

        var tab9 = containerElement1.querySelector(".bk__features__inner__block__ipad__external--9");

        var winner = containerElement1.querySelector(".bk__features__inner__block__ipad__winner");

        var HeightMax = 1440; // max height for scale


        var deltaHeight = void 0;

        var lambda = void 0;

        var iBlock = void 0;

        var oPhoto = void 0;

        var tab1Left = void 0;
        var tab1Top = void 0;
        var tab1Scale = void 0;

        var tab2Top = void 0;
        var tab2Scale = void 0;

        var tab3Right = void 0;
        var tab3Top = void 0;
        var tab3Scale = void 0;

        var tab4Right = void 0;
        var tab4Top = void 0;
        var tab4Scale = void 0;

        var tab5Left = void 0;
        var tab5Top = void 0;
        var tab5Scale = void 0;

        var tab6Left = void 0;
        var tab6Bottom = void 0;
        var tab6Scale = void 0;

        var tab7Left = void 0;
        var tab7Bottom = void 0;
        var tab7Scale = void 0;

        var tab8Bottom = void 0;
        var tab8Scale = void 0;

        var tab9Right = void 0;
        var tab9Bottom = void 0;
        var tab9Scale = void 0;

        var winnerRight = void 0;
        var winnerBottom = void 0;
        var winnerScale = void 0;

        var top = void 0;
        var extraHeight = void 0;

        window.addEventListener("resize", handleResize, false);
        handleResize();
    }
}

window.addEventListener("load", initAnimation, false);

/***/ }),

/***/ 1712:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _swiper = __webpack_require__(128);

var _swiper2 = _interopRequireDefault(_swiper);

var _View = __webpack_require__(129);

var _View2 = _interopRequireDefault(_View);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_swiper2.default.use([_swiper.Navigation, _swiper.Pagination, _swiper.Autoplay]);

var view = _View2.default.getInstance();
var section = document.querySelector('.bk__main_features');
var slider = section.querySelector('.landing__carousel2-container--mobile--images');

var swiperCarousel = void 0;
var clientWidth = document.body.clientWidth;


var changeContentSlide = function changeContentSlide(newIndex) {
    if (typeof newIndex === 'undefined') {
        return;
    }

    var activeClassName = 'landing__carousel2-container--mobile--content__item--active';
    var slides = section.querySelectorAll('.landing__carousel2-container--mobile--content__item');
    var activeSlide = section.querySelector('.' + activeClassName);

    if (activeSlide) {
        activeSlide.classList.remove(activeClassName);
    }

    slides[newIndex].classList.add(activeClassName);
};

var sliderInit = function sliderInit() {
    if (view.isPhone()) {
        swiperCarousel = new _swiper2.default(slider, {
            loop: true,
            loopAdditionalSlides: 2,

            navigation: {
                nextEl: '.landing__carousel2-container--mobile__swiper-button-next',
                prevEl: '.landing__carousel2-container--mobile__swiper-button-prev'
            },

            // autoplay: {
            //     delay: 5000,
            //     disableOnInteraction: false,
            // },

            autoplay: false,

            pagination: {
                bulletActiveClass: 'slider__bullets2__item--active',
                bulletClass: 'slider__bullets2__item',
                clickable: true,
                el: '.slider__bullets2',
                type: 'bullets'
            },

            on: {
                slideChangeTransitionStart: function slideChangeTransitionStart() {
                    if (swiperCarousel) {
                        changeContentSlide(swiperCarousel.realIndex);
                    }
                },

                reachEnd: function reachEnd() {
                    swiperCarousel.autoplay.stop();
                }

            }
        });
    }
};

var initAutoPlay2 = function initAutoPlay2() {
    if (view.isPhone()) {
        if (swiperCarousel.autoplay.running) {
            return;
        }

        var current = swiperCarousel.wrapperEl;

        while (!current.classList.contains('bk__main_features__bottom')) {
            current = current.parentNode;
        }

        var bounding = current.getBoundingClientRect();

        if (bounding.top < 0) {
            swiperCarousel.autoplay.start();
            swiperCarousel.params.autoplay.delay = 5000;
            swiperCarousel.params.autoplay.disableOnInteraction = false;
        }
    }
};

window.addEventListener('scroll', initAutoPlay2);

var resizeHandlerSlider = function resizeHandlerSlider() {
    if (clientWidth !== document.body.clientWidth) {
        clientWidth = document.body.clientWidth;

        view._resize();

        if (swiperCarousel) {
            swiperCarousel.destroy();
            changeContentSlide(0);
        }

        sliderInit();
        initAutoPlay2();
    }
};

window.addEventListener('resize', resizeHandlerSlider);
sliderInit();
initAutoPlay2();

/***/ }),

/***/ 172:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loopCreate;

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function loopCreate() {
  var swiper = this;
  var document = (0, _ssrWindow.getDocument)();
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
  var slides = $wrapperEl.children("." + params.slideClass);

  if (params.loopFillGroupWithBlank) {
    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (var i = 0; i < blankSlidesNum; i += 1) {
        var blankNode = (0, _dom2.default)(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
        $wrapperEl.append(blankNode);
      }

      slides = $wrapperEl.children("." + params.slideClass);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  var prependSlides = [];
  var appendSlides = [];
  slides.each(function (el, index) {
    var slide = (0, _dom2.default)(el);

    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }

    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }

    slide.attr('data-swiper-slide-index', index);
  });

  for (var _i = 0; _i < appendSlides.length; _i += 1) {
    $wrapperEl.append((0, _dom2.default)(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
    $wrapperEl.prepend((0, _dom2.default)(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

/***/ }),

/***/ 173:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loopFix;
function loopFix() {
  var swiper = this;
  swiper.emit('beforeLoopFix');
  var activeIndex = swiper.activeIndex,
      slides = swiper.slides,
      loopedSlides = swiper.loopedSlides,
      allowSlidePrev = swiper.allowSlidePrev,
      allowSlideNext = swiper.allowSlideNext,
      snapGrid = swiper.snapGrid,
      rtl = swiper.rtlTranslate;
  var newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  var snapTranslate = -snapGrid[activeIndex];
  var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    var slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;

    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (_slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}

/***/ }),

/***/ 174:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loopDestroy;
function loopDestroy() {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      slides = swiper.slides;
  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
  slides.removeAttr('data-swiper-slide-index');
}

/***/ }),

/***/ 175:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setGrabCursor = __webpack_require__(176);

var _setGrabCursor2 = _interopRequireDefault(_setGrabCursor);

var _unsetGrabCursor = __webpack_require__(177);

var _unsetGrabCursor2 = _interopRequireDefault(_unsetGrabCursor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  setGrabCursor: _setGrabCursor2.default,
  unsetGrabCursor: _unsetGrabCursor2.default
};

/***/ }),

/***/ 176:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setGrabCursor;
function setGrabCursor(moving) {
  var swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  var el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

/***/ }),

/***/ 177:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = unsetGrabCursor;
function unsetGrabCursor() {
  var swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper.el.style.cursor = '';
}

/***/ }),

/***/ 178:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _appendSlide = __webpack_require__(179);

var _appendSlide2 = _interopRequireDefault(_appendSlide);

var _prependSlide = __webpack_require__(180);

var _prependSlide2 = _interopRequireDefault(_prependSlide);

var _addSlide = __webpack_require__(181);

var _addSlide2 = _interopRequireDefault(_addSlide);

var _removeSlide = __webpack_require__(182);

var _removeSlide2 = _interopRequireDefault(_removeSlide);

var _removeAllSlides = __webpack_require__(183);

var _removeAllSlides2 = _interopRequireDefault(_removeAllSlides);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  appendSlide: _appendSlide2.default,
  prependSlide: _prependSlide2.default,
  addSlide: _addSlide2.default,
  removeSlide: _removeSlide2.default,
  removeAllSlides: _removeAllSlides2.default
};

/***/ }),

/***/ 179:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = appendSlide;
function appendSlide(slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params;

  if (params.loop) {
    swiper.loopDestroy();
  }

  if ((typeof slides === 'undefined' ? 'undefined' : _typeof(slides)) === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
}

/***/ }),

/***/ 18:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ 180:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = prependSlide;
function prependSlide(slides) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;

  if (params.loop) {
    swiper.loopDestroy();
  }

  var newActiveIndex = activeIndex + 1;

  if ((typeof slides === 'undefined' ? 'undefined' : _typeof(slides)) === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }

    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  swiper.slideTo(newActiveIndex, 0, false);
}

/***/ }),

/***/ 181:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = addSlide;
function addSlide(index, slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }

  var baseLength = swiper.slides.length;

  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }

  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }

  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  var slidesBuffer = [];

  for (var i = baseLength - 1; i >= index; i -= 1) {
    var currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if ((typeof slides === 'undefined' ? 'undefined' : _typeof(slides)) === 'object' && 'length' in slides) {
    for (var _i = 0; _i < slides.length; _i += 1) {
      if (slides[_i]) $wrapperEl.append(slides[_i]);
    }

    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
    $wrapperEl.append(slidesBuffer[_i2]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

/***/ }),

/***/ 182:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = removeSlide;
function removeSlide(slidesIndexes) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }

  var newActiveIndex = activeIndexBuffer;
  var indexToRemove;

  if ((typeof slidesIndexes === 'undefined' ? 'undefined' : _typeof(slidesIndexes)) === 'object' && 'length' in slidesIndexes) {
    for (var i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }

    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

/***/ }),

/***/ 183:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeAllSlides;
function removeAllSlides() {
  var swiper = this;
  var slidesIndexes = [];

  for (var i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }

  swiper.removeSlide(slidesIndexes);
}

/***/ }),

/***/ 184:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _onTouchStart = __webpack_require__(185);

var _onTouchStart2 = _interopRequireDefault(_onTouchStart);

var _onTouchMove = __webpack_require__(186);

var _onTouchMove2 = _interopRequireDefault(_onTouchMove);

var _onTouchEnd = __webpack_require__(187);

var _onTouchEnd2 = _interopRequireDefault(_onTouchEnd);

var _onResize = __webpack_require__(188);

var _onResize2 = _interopRequireDefault(_onResize);

var _onClick = __webpack_require__(189);

var _onClick2 = _interopRequireDefault(_onClick);

var _onScroll = __webpack_require__(190);

var _onScroll2 = _interopRequireDefault(_onScroll);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dummyEventAttached = false;

function dummyEventListener() {}

function attachEvents() {
  var swiper = this;
  var document = (0, _ssrWindow.getDocument)();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  swiper.onTouchStart = _onTouchStart2.default.bind(swiper);
  swiper.onTouchMove = _onTouchMove2.default.bind(swiper);
  swiper.onTouchEnd = _onTouchEnd2.default.bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = _onScroll2.default.bind(swiper);
  }

  swiper.onClick = _onClick2.default.bind(swiper);
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture: capture
      } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }

      if (!dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      document.addEventListener('mousemove', swiper.onTouchMove, capture);
      document.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', _onResize2.default, true);
  } else {
    swiper.on('observerUpdate', _onResize2.default, true);
  }
}

function detachEvents() {
  var swiper = this;
  var document = (0, _ssrWindow.getDocument)();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      document.removeEventListener('mousemove', swiper.onTouchMove, capture);
      document.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  } // Resize handler


  swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', _onResize2.default);
}

exports.default = {
  attachEvents: attachEvents,
  detachEvents: detachEvents
};

/***/ }),

/***/ 185:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onTouchStart;

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd

function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }

  function __closestFrom(el) {
    if (!el || el === (0, _ssrWindow.getDocument)() || el === (0, _ssrWindow.getWindow)()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    var found = el.closest(selector);
    return found || __closestFrom(el.getRootNode().host);
  }

  return __closestFrom(base);
}

function onTouchStart(event) {
  var swiper = this;
  var document = (0, _ssrWindow.getDocument)();
  var window = (0, _ssrWindow.getWindow)();
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      enabled = swiper.enabled;
  if (!enabled) return;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  var $targetEl = (0, _dom2.default)(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root component

  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = (0, _dom2.default)(event.path[0]);
  }

  var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass;
  var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  var startX = touches.currentX;
  var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  (0, _utils.extend)(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = (0, _utils.now)();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    var preventDefault = true;
    if ($targetEl.is(data.focusableElements)) preventDefault = false;

    if (document.activeElement && (0, _dom2.default)(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  swiper.emit('touchStart', e);
}

/***/ }),

/***/ 186:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onTouchMove;

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function onTouchMove(event) {
  var document = (0, _ssrWindow.getDocument)();
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;

    if (data.isTouched) {
      (0, _utils.extend)(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = (0, _utils.now)();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && (0, _dom2.default)(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  var diffX = touches.currentX - touches.startX;
  var diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    var touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  var diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  var disableParentSwiper = true;
  var resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }

    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: (0, _utils.now)()
    });
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}

/***/ }),

/***/ 187:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onTouchEnd;

var _utils = __webpack_require__(1);

function onTouchEnd(event) {
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      $wrapperEl = swiper.$wrapperEl,
      slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      enabled = swiper.enabled;
  if (!enabled) return;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  var touchEndTime = (0, _utils.now)();
  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = (0, _utils.now)();
  (0, _utils.nextTick)(function () {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  var currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }

      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        var lastMoveEvent = data.velocities.pop();
        var velocityEvent = data.velocities.pop();
        var distance = lastMoveEvent.position - velocityEvent.position;
        var time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;

        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        } // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.


        if (time > 150 || (0, _utils.now)() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }

      swiper.velocity *= params.freeModeMomentumVelocityRatio;
      data.velocities.length = 0;
      var momentumDuration = 1000 * params.freeModeMomentumRatio;
      var momentumDistance = swiper.velocity * momentumDuration;
      var newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      var doBounce = false;
      var afterBouncePosition;
      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      var needsLoopFix;

      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }

          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }

          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        var nextSlide;

        for (var j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }

        newPosition = -newPosition;
      }

      if (needsLoopFix) {
        swiper.once('transitionEnd', function () {
          swiper.loopFix();
        });
      } // Fix duration


      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }

        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(function () {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(function () {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);

        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      swiper.emit('_freeModeNoMomentumRelease');
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    return;
  } // Find current slide


  var stopIndex = 0;
  var groupSize = swiper.slidesSizesGrid[0];

  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + _increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  } // Find current slide size


  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

/***/ }),

/***/ 188:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onResize;
function onResize() {
  var swiper = this;
  var params = swiper.params,
      el = swiper.el;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  var allowSlideNext = swiper.allowSlideNext,
      allowSlidePrev = swiper.allowSlidePrev,
      snapGrid = swiper.snapGrid; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

/***/ }),

/***/ 189:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onClick;
function onClick(e) {
  var swiper = this;
  if (!swiper.enabled) return;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

/***/ }),

/***/ 190:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = onScroll;
function onScroll() {
  var swiper = this;
  var wrapperEl = swiper.wrapperEl,
      rtlTranslate = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

/***/ }),

/***/ 191:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _setBreakpoint = __webpack_require__(192);

var _setBreakpoint2 = _interopRequireDefault(_setBreakpoint);

var _getBreakpoint = __webpack_require__(193);

var _getBreakpoint2 = _interopRequireDefault(_getBreakpoint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  setBreakpoint: _setBreakpoint2.default,
  getBreakpoint: _getBreakpoint2.default
};

/***/ }),

/***/ 192:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setBreakpoint;

var _utils = __webpack_require__(1);

function setBreakpoint() {
  var swiper = this;
  var activeIndex = swiper.activeIndex,
      initialized = swiper.initialized,
      _swiper$loopedSlides = swiper.loopedSlides,
      loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
      params = swiper.params,
      $el = swiper.$el;
  var breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

  if (breakpointOnlyParams) {
    ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
      var paramValue = breakpointOnlyParams[param];
      if (typeof paramValue === 'undefined') return;

      if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
        breakpointOnlyParams[param] = 'auto';
      } else if (param === 'slidesPerView') {
        breakpointOnlyParams[param] = parseFloat(paramValue);
      } else {
        breakpointOnlyParams[param] = parseInt(paramValue, 10);
      }
    });
  }

  var breakpointParams = breakpointOnlyParams || swiper.originalParams;
  var wasMultiRow = params.slidesPerColumn > 1;
  var isMultiRow = breakpointParams.slidesPerColumn > 1;
  var wasEnabled = params.enabled;

  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(params.containerModifierClass + "multirow");

    if (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column' || !breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column') {
      $el.addClass(params.containerModifierClass + "multirow-column");
    }

    swiper.emitContainerClasses();
  }

  var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

  if (directionChanged && initialized) {
    swiper.changeDirection();
  }

  (0, _utils.extend)(swiper.params, breakpointParams);
  var isEnabled = swiper.params.enabled;
  (0, _utils.extend)(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });

  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }

  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);

  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }

  swiper.emit('breakpoint', breakpointParams);
}

/***/ }),

/***/ 193:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBreakpoint;

var _ssrWindow = __webpack_require__(5);

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }

  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  var breakpoint = false;
  var window = (0, _ssrWindow.getWindow)();
  var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  var points = Object.keys(breakpoints).map(function (point) {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      var minRatio = parseFloat(point.substr(1));
      var value = currentHeight * minRatio;
      return {
        value: value,
        point: point
      };
    }

    return {
      value: point,
      point: point
    };
  });
  points.sort(function (a, b) {
    return parseInt(a.value, 10) - parseInt(b.value, 10);
  });

  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i],
        point = _points$i.point,
        value = _points$i.value;

    if (base === 'window') {
      if (window.matchMedia("(min-width: " + value + "px)").matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}

/***/ }),

/***/ 194:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _addClasses = __webpack_require__(195);

var _addClasses2 = _interopRequireDefault(_addClasses);

var _removeClasses = __webpack_require__(196);

var _removeClasses2 = _interopRequireDefault(_removeClasses);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  addClasses: _addClasses2.default,
  removeClasses: _removeClasses2.default
};

/***/ }),

/***/ 195:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = addClasses;
function prepareClasses(entries, prefix) {
  var resultClasses = [];
  entries.forEach(function (item) {
    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
      Object.keys(item).forEach(function (classNames) {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  var swiper = this;
  var classNames = swiper.classNames,
      params = swiper.params,
      rtl = swiper.rtl,
      $el = swiper.$el,
      device = swiper.device,
      support = swiper.support; // prettier-ignore

  var suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': support.pointerEvents && !support.touch
  }, {
    'free-mode': params.freeMode
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'multirow': params.slidesPerColumn > 1
  }, {
    'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }], params.containerModifierClass);
  classNames.push.apply(classNames, suffixes);
  $el.addClass([].concat(classNames).join(' '));
  swiper.emitContainerClasses();
}

/***/ }),

/***/ 196:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeClasses;
function removeClasses() {
  var swiper = this;
  var $el = swiper.$el,
      classNames = swiper.classNames;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}

/***/ }),

/***/ 197:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loadImage = __webpack_require__(198);

var _loadImage2 = _interopRequireDefault(_loadImage);

var _preloadImages = __webpack_require__(199);

var _preloadImages2 = _interopRequireDefault(_preloadImages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  loadImage: _loadImage2.default,
  preloadImages: _preloadImages2.default
};

/***/ }),

/***/ 198:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadImage;

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  var window = (0, _ssrWindow.getWindow)();
  var image;

  function onReady() {
    if (callback) callback();
  }

  var isPicture = (0, _dom2.default)(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

/***/ }),

/***/ 199:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = preloadImages;
function preloadImages() {
  var swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
    var imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}

/***/ }),

/***/ 2:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var utils = __webpack_require__(0);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function (code) {
  descriptors[code] = { value: code };
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', { value: true });

// eslint-disable-next-line func-names
AxiosError.from = function (error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && _extends(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;

/***/ }),

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @public
 * @type {Object}
 */

module.exports = {
	width: function width() {
		return document.documentElement.clientWidth < window.innerWidth ? window.innerWidth : document.documentElement.clientWidth;
	},
	height: function height() {
		return document.documentElement.clientHeight < window.innerHeight ? window.innerHeight : document.documentElement.clientHeight;
	},
	orientation: function orientation() {
		var width = this.width();
		var height = this.height();

		if (width < height) {
			return "portrait";
		} else if (width > height) {
			return "landscape";
		} else {
			return "";
		}
	},
	isPortrait: function isPortrait() {
		return this.orientation() === "portrait" ? true : false;
	},
	isLandscape: function isLandscape() {
		return this.orientation() === "landscape" ? true : false;
	},
	isMobile: function isMobile() {
		return this.width() < 1025 ? true : false;
	},
	isPhone: function isPhone() {
		return this.width() < 768 ? true : false;
	},
	isTablet: function isTablet() {
		return this.isMobile() && !this.isPhone();
	},
	isDesktop: function isDesktop() {
		return !this.isMobile();
	}
};

/***/ }),

/***/ 200:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function checkOverflow() {
  var swiper = this;
  var params = swiper.params;
  var wasLocked = swiper.isLocked;
  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked; // events

  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation) swiper.navigation.update();
  }
}

exports.default = {
  checkOverflow: checkOverflow
};

/***/ }),

/***/ 201:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: false,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  // NS
  containerModifierClass: 'swiper-container-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

/***/ }),

/***/ 202:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Virtual = {
  update: function update(force) {
    var swiper = this;
    var _swiper$params = swiper.params,
        slidesPerView = _swiper$params.slidesPerView,
        slidesPerGroup = _swiper$params.slidesPerGroup,
        centeredSlides = _swiper$params.centeredSlides;
    var _swiper$params$virtua = swiper.params.virtual,
        addSlidesBefore = _swiper$params$virtua.addSlidesBefore,
        addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
    var _swiper$virtual = swiper.virtual,
        previousFrom = _swiper$virtual.from,
        previousTo = _swiper$virtual.to,
        slides = _swiper$virtual.slides,
        previousSlidesGrid = _swiper$virtual.slidesGrid,
        renderSlide = _swiper$virtual.renderSlide,
        previousOffset = _swiper$virtual.offset;
    swiper.updateActiveIndex();
    var activeIndex = swiper.activeIndex || 0;
    var offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    var slidesAfter;
    var slidesBefore;

    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = slidesPerGroup + addSlidesBefore;
    }

    var from = Math.max((activeIndex || 0) - slidesBefore, 0);
    var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    (0, _utils.extend)(swiper.virtual, {
      from: from,
      to: to,
      offset: offset,
      slidesGrid: swiper.slidesGrid
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, offset + "px");
      }

      swiper.updateProgress();
      return;
    }

    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset: offset,
        from: from,
        to: to,
        slides: function getSlides() {
          var slidesToRender = [];

          for (var i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }

          return slidesToRender;
        }()
      });

      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      }

      return;
    }

    var prependIndexes = [];
    var appendIndexes = [];

    if (force) {
      swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
    } else {
      for (var i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + i + "\"]").remove();
        }
      }
    }

    for (var _i = 0; _i < slides.length; _i += 1) {
      if (_i >= from && _i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(_i);
        } else {
          if (_i > previousTo) appendIndexes.push(_i);
          if (_i < previousFrom) prependIndexes.push(_i);
        }
      }
    }

    appendIndexes.forEach(function (index) {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort(function (a, b) {
      return b - a;
    }).forEach(function (index) {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, offset + "px");
    onRendered();
  },
  renderSlide: function renderSlide(slide, index) {
    var swiper = this;
    var params = swiper.params.virtual;

    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }

    var $slideEl = params.renderSlide ? (0, _dom2.default)(params.renderSlide.call(swiper, slide, index)) : (0, _dom2.default)("<div class=\"" + swiper.params.slideClass + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>");
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide: function appendSlide(slides) {
    var swiper = this;

    if ((typeof slides === 'undefined' ? 'undefined' : _typeof(slides)) === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }

    swiper.virtual.update(true);
  },
  prependSlide: function prependSlide(slides) {
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var newActiveIndex = activeIndex + 1;
    var numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }

      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }

    if (swiper.params.virtual.cache) {
      var cache = swiper.virtual.cache;
      var newCache = {};
      Object.keys(cache).forEach(function (cachedIndex) {
        var $cachedEl = cache[cachedIndex];
        var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
        }

        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }

    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide: function removeSlide(slidesIndexes) {
    var swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    var activeIndex = swiper.activeIndex;

    if (Array.isArray(slidesIndexes)) {
      for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }

        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);

      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }

      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }

    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides: function removeAllSlides() {
    var swiper = this;
    swiper.virtual.slides = [];

    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }

    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  }
};
exports.default = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      virtual: _extends({}, Virtual, {
        slides: swiper.params.virtual.slides,
        cache: {}
      })
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
      var overwriteParams = {
        watchSlidesProgress: true
      };
      (0, _utils.extend)(swiper.params, overwriteParams);
      (0, _utils.extend)(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate: function setTranslate(swiper) {
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    }
  }
};

/***/ }),

/***/ 203:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

/* eslint-disable consistent-return */

var Keyboard = {
  handle: function handle(event) {
    var swiper = this;
    if (!swiper.enabled) return;
    var window = (0, _ssrWindow.getWindow)();
    var document = (0, _ssrWindow.getDocument)();
    var rtl = swiper.rtlTranslate;
    var e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    var kc = e.keyCode || e.charCode;
    var pageUpDown = swiper.params.keyboard.pageUpDown;
    var isPageUp = pageUpDown && kc === 33;
    var isPageDown = pageUpDown && kc === 34;
    var isArrowLeft = kc === 37;
    var isArrowRight = kc === 39;
    var isArrowUp = kc === 38;
    var isArrowDown = kc === 40; // Directions locks

    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }

    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }

    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }

    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }

    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      var inView = false; // Check that swiper should be inside of visible area of window

      if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
        return undefined;
      }

      var $el = swiper.$el;
      var swiperWidth = $el[0].clientWidth;
      var swiperHeight = $el[0].clientHeight;
      var windowWidth = window.innerWidth;
      var windowHeight = window.innerHeight;
      var swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];

      for (var i = 0; i < swiperCoord.length; i += 1) {
        var point = swiperCoord[i];

        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

          inView = true;
        }
      }

      if (!inView) return undefined;
    }

    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }

      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }

    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable: function enable() {
    var swiper = this;
    var document = (0, _ssrWindow.getDocument)();
    if (swiper.keyboard.enabled) return;
    (0, _dom2.default)(document).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable: function disable() {
    var swiper = this;
    var document = (0, _ssrWindow.getDocument)();
    if (!swiper.keyboard.enabled) return;
    (0, _dom2.default)(document).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  }
};
exports.default = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      keyboard: _extends({
        enabled: false
      }, Keyboard)
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    }
  }
};

/***/ }),

/***/ 204:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isEventSupported() {
  var document = (0, _ssrWindow.getDocument)();
  var eventName = 'onwheel';
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
} /* eslint-disable consistent-return */


var Mousewheel = {
  lastScrollTime: (0, _utils.now)(),
  lastEventBeforeSnap: undefined,
  recentWheelEvents: [],
  event: function event() {
    var window = (0, _ssrWindow.getWindow)();
    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  },
  normalize: function normalize(e) {
    // Reasonable defaults
    var PIXEL_STEP = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;
    var sX = 0;
    var sY = 0; // spinX, spinY

    var pX = 0;
    var pY = 0; // pixelX, pixelY
    // Legacy

    if ('detail' in e) {
      sY = e.detail;
    }

    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }

    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }

    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    } // side scrolling on FF with DOMMouseScroll


    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }

    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    } // Fall-back if spin cannot be determined


    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }

    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  },
  handleMouseEnter: function handleMouseEnter() {
    var swiper = this;
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  },
  handleMouseLeave: function handleMouseLeave() {
    var swiper = this;
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  },
  handle: function handle(event) {
    var e = event;
    var disableParentSwiper = true;
    var swiper = this;
    if (!swiper.enabled) return;
    var params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    var target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0, _dom2.default)(swiper.params.mousewheel.eventsTarget);
    }

    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix

    var delta = 0;
    var rtlFactor = swiper.rtlTranslate ? -1 : 1;
    var data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;
    if (params.invert) delta = -delta; // Get the scroll positions

    var positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.

    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();

    if (!swiper.params.freeMode) {
      // Register the new event in a variable which stores the relevant data
      var newEvent = {
        time: (0, _utils.now)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      }; // Keep the most recent events

      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;

      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.

      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          swiper.mousewheel.animateSlider(newEvent);
        }
      } else {
        swiper.mousewheel.animateSlider(newEvent);
      } // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.


      if (swiper.mousewheel.releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:
      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      var _newEvent = {
        time: (0, _utils.now)(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;

      if (!ignoreWheelEvents) {
        swiper.mousewheel.lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }

        var position = swiper.getTranslate() + delta * params.sensitivity;
        var wasBeginning = swiper.isBeginning;
        var wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeModeSticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = undefined;
          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;

          if (_recentWheelEvents.length >= 15) {
            _recentWheelEvents.shift(); // only store the last N events
          }

          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;

          var firstEvent = _recentWheelEvents[0];

          _recentWheelEvents.push(_newEvent);

          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            _recentWheelEvents.splice(0);
          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            var snapToThreshold = delta > 0 ? 0.8 : 0.2;
            swiper.mousewheel.lastEventBeforeSnap = _newEvent;

            _recentWheelEvents.splice(0);

            swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!swiper.mousewheel.timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            swiper.mousewheel.timeout = (0, _utils.nextTick)(function () {
              var snapToThreshold = 0.5;
              swiper.mousewheel.lastEventBeforeSnap = _newEvent;

              _recentWheelEvents.splice(0);

              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        } // Emit event


        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay

        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions

        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  },
  animateSlider: function animateSlider(newEvent) {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();

    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }

    if (this.params.mousewheel.thresholdTime && (0, _utils.now)() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    } // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).


    if (newEvent.delta >= 6 && (0, _utils.now)() - swiper.mousewheel.lastScrollTime < 60) {
      // Return false as a default
      return true;
    } // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.


    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        swiper.emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      swiper.emit('scroll', newEvent.raw);
    } // If you got here is because an animation has been triggered so store the current time


    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default

    return false;
  },
  releaseScroll: function releaseScroll(newEvent) {
    var swiper = this;
    var params = swiper.params.mousewheel;

    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }

    return false;
  },
  enable: function enable() {
    var swiper = this;
    var event = Mousewheel.event();

    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
      return true;
    }

    if (!event) return false;
    if (swiper.mousewheel.enabled) return false;
    var target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0, _dom2.default)(swiper.params.mousewheel.eventsTarget);
    }

    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable: function disable() {
    var swiper = this;
    var event = Mousewheel.event();

    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
      return true;
    }

    if (!event) return false;
    if (!swiper.mousewheel.enabled) return false;
    var target = swiper.$el;

    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      target = (0, _dom2.default)(swiper.params.mousewheel.eventsTarget);
    }

    target.off(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  }
};
exports.default = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      mousewheel: {
        enabled: false,
        lastScrollTime: (0, _utils.now)(),
        lastEventBeforeSnap: undefined,
        recentWheelEvents: [],
        enable: Mousewheel.enable,
        disable: Mousewheel.disable,
        handle: Mousewheel.handle,
        handleMouseEnter: Mousewheel.handleMouseEnter,
        handleMouseLeave: Mousewheel.handleMouseLeave,
        animateSlider: Mousewheel.animateSlider,
        releaseScroll: Mousewheel.releaseScroll
      }
    });
  },
  on: {
    init: function init(swiper) {
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        swiper.mousewheel.disable();
      }

      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy: function destroy(swiper) {
      if (swiper.params.cssMode) {
        swiper.mousewheel.enable();
      }

      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    }
  }
};

/***/ }),

/***/ 205:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Navigation = {
  toggleEl: function toggleEl($el, disabled) {
    $el[disabled ? 'addClass' : 'removeClass'](this.params.navigation.disabledClass);
    if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
  },
  update: function update() {
    // Update Navigation Buttons
    var swiper = this;
    var params = swiper.params.navigation;
    var toggleEl = swiper.navigation.toggleEl;
    if (swiper.params.loop) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        toggleEl($prevEl, true);
      } else {
        toggleEl($prevEl, false);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $prevEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        toggleEl($nextEl, true);
      } else {
        toggleEl($nextEl, false);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $nextEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }
  },
  onPrevClick: function onPrevClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick: function onNextClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.navigation;
    swiper.params.navigation = (0, _utils.createElementIfNotDefined)(swiper.$el, swiper.params.navigation, swiper.params.createElements, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    var $nextEl;
    var $prevEl;

    if (params.nextEl) {
      $nextEl = (0, _dom2.default)(params.nextEl);

      if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }

    if (params.prevEl) {
      $prevEl = (0, _dom2.default)(params.prevEl);

      if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    (0, _utils.extend)(swiper.navigation, {
      $nextEl: $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl: $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });

    if (!swiper.enabled) {
      if ($nextEl) $nextEl.addClass(params.lockClass);
      if ($prevEl) $prevEl.addClass(params.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var _swiper$navigation2 = swiper.navigation,
        $nextEl = _swiper$navigation2.$nextEl,
        $prevEl = _swiper$navigation2.$prevEl;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }
};
exports.default = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      navigation: _extends({}, Navigation)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge: function toEdge(swiper) {
      swiper.navigation.update();
    },
    fromEdge: function fromEdge(swiper) {
      swiper.navigation.update();
    },
    destroy: function destroy(swiper) {
      swiper.navigation.destroy();
    },
    'enable disable': function enableDisable(swiper) {
      var _swiper$navigation3 = swiper.navigation,
          $nextEl = _swiper$navigation3.$nextEl,
          $prevEl = _swiper$navigation3.$prevEl;

      if ($nextEl) {
        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }

      if ($prevEl) {
        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }
    },
    click: function click(swiper, e) {
      var _swiper$navigation4 = swiper.navigation,
          $nextEl = _swiper$navigation4.$nextEl,
          $prevEl = _swiper$navigation4.$prevEl;
      var targetEl = e.target;

      if (swiper.params.navigation.hideOnClick && !(0, _dom2.default)(targetEl).is($prevEl) && !(0, _dom2.default)(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        var isHidden;

        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }

        if (isHidden === true) {
          swiper.emit('navigationShow');
        } else {
          swiper.emit('navigationHide');
        }

        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }

        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    }
  }
};

/***/ }),

/***/ 206:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Pagination = {
  update: function update() {
    // Render || Update Pagination bullets/items
    var swiper = this;
    var rtl = swiper.rtl;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el; // Current/Total

    var current;
    var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      var bullets = swiper.pagination.bullets;
      var firstIndex;
      var lastIndex;
      var midIndex;

      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }

        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

      if ($el.length > 1) {
        bullets.each(function (bullet) {
          var $bullet = (0, _dom2.default)(bullet);
          var bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(params.bulletActiveClass + "-main");
            }

            if (bulletIndex === firstIndex) {
              $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            }

            if (bulletIndex === lastIndex) {
              $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          }
        });
      } else {
        var $bullet = bullets.eq(current);
        var bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          var $firstDisplayedBullet = bullets.eq(firstIndex);
          var $lastDisplayedBullet = bullets.eq(lastIndex);

          for (var i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(params.bulletActiveClass + "-main");
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
            } else {
              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          } else {
            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
          }
        }
      }

      if (params.dynamicBullets) {
        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
        var offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
      }
    }

    if (params.type === 'fraction') {
      $el.find((0, _utils.classesToSelector)(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find((0, _utils.classesToSelector)(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      var progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      var scale = (current + 1) / total;
      var scaleX = 1;
      var scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find((0, _utils.classesToSelector)(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', $el[0]);
    } else {
      swiper.emit('paginationUpdate', $el[0]);
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  render: function render() {
    // Render Container
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el;
    var paginationHTML = '';

    if (params.type === 'bullets') {
      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (var i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find((0, _utils.classesToSelector)(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + ("<span class=\"" + params.totalClass + "\"></span>");
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init: function init() {
    var swiper = this;
    swiper.params.pagination = (0, _utils.createElementIfNotDefined)(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
      el: 'swiper-pagination'
    });
    var params = swiper.params.pagination;
    if (!params.el) return;
    var $el = (0, _dom2.default)(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass("" + params.modifierClass + params.type + "-dynamic");
      swiper.pagination.dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', (0, _utils.classesToSelector)(params.bulletClass), function onClick(e) {
        e.preventDefault();
        var index = (0, _dom2.default)(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    (0, _utils.extend)(swiper.pagination, {
      $el: $el,
      el: $el[0]
    });

    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', (0, _utils.classesToSelector)(params.bulletClass));
    }
  }
};
exports.default = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: function formatFractionCurrent(number) {
        return number;
      },
      formatFractionTotal: function formatFractionTotal(number) {
        return number;
      },
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-',
      // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable',
      // NEW
      lockClass: 'swiper-pagination-lock'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      pagination: _extends({
        dynamicBulletIndex: 0
      }, Pagination)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange: function activeIndexChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange: function snapIndexChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange: function slidesLengthChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange: function snapGridLengthChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy: function destroy(swiper) {
      swiper.pagination.destroy();
    },
    'enable disable': function enableDisable(swiper) {
      var $el = swiper.pagination.$el;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
      }
    },
    click: function click(swiper, e) {
      var targetEl = e.target;

      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !(0, _dom2.default)(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

        if (isHidden === true) {
          swiper.emit('paginationShow');
        } else {
          swiper.emit('paginationHide');
        }

        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    }
  }
};

/***/ }),

/***/ 207:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Scrollbar = {
  setTranslate: function setTranslate() {
    var swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    var scrollbar = swiper.scrollbar,
        rtl = swiper.rtlTranslate,
        progress = swiper.progress;
    var dragSize = scrollbar.dragSize,
        trackSize = scrollbar.trackSize,
        $dragEl = scrollbar.$dragEl,
        $el = scrollbar.$el;
    var params = swiper.params.scrollbar;
    var newSize = dragSize;
    var newPos = (trackSize - dragSize) * progress;

    if (rtl) {
      newPos = -newPos;

      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }

    if (swiper.isHorizontal()) {
      $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
      $dragEl[0].style.width = newSize + "px";
    } else {
      $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
      $dragEl[0].style.height = newSize + "px";
    }

    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(function () {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize: function updateSize() {
    var swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    var scrollbar = swiper.scrollbar;
    var $dragEl = scrollbar.$dragEl,
        $el = scrollbar.$el;
    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    var divider = swiper.size / swiper.virtualSize;
    var moveDivider = divider * (trackSize / swiper.size);
    var dragSize;

    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = dragSize + "px";
    } else {
      $dragEl[0].style.height = dragSize + "px";
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }

    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }

    (0, _utils.extend)(scrollbar, {
      trackSize: trackSize,
      divider: divider,
      moveDivider: moveDivider,
      dragSize: dragSize
    });

    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    }
  },
  getPointerPosition: function getPointerPosition(e) {
    var swiper = this;

    if (swiper.isHorizontal()) {
      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
    }

    return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
  },
  setDragPosition: function setDragPosition(e) {
    var swiper = this;
    var scrollbar = swiper.scrollbar,
        rtl = swiper.rtlTranslate;
    var $el = scrollbar.$el,
        dragSize = scrollbar.dragSize,
        trackSize = scrollbar.trackSize,
        dragStartPos = scrollbar.dragStartPos;
    var positionRatio;
    positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);

    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart: function onDragStart(e) {
    var swiper = this;
    var params = swiper.params.scrollbar;
    var scrollbar = swiper.scrollbar,
        $wrapperEl = swiper.$wrapperEl;
    var $el = scrollbar.$el,
        $dragEl = scrollbar.$dragEl;
    swiper.scrollbar.isTouched = true;
    swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);
    clearTimeout(swiper.scrollbar.dragTimeout);
    $el.transition(0);

    if (params.hide) {
      $el.css('opacity', 1);
    }

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }

    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove: function onDragMove(e) {
    var swiper = this;
    var scrollbar = swiper.scrollbar,
        $wrapperEl = swiper.$wrapperEl;
    var $el = scrollbar.$el,
        $dragEl = scrollbar.$dragEl;
    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd: function onDragEnd(e) {
    var swiper = this;
    var params = swiper.params.scrollbar;
    var scrollbar = swiper.scrollbar,
        $wrapperEl = swiper.$wrapperEl;
    var $el = scrollbar.$el;
    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;

    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }

    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = (0, _utils.nextTick)(function () {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }

    swiper.emit('scrollbarDragEnd', e);

    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable: function enableDraggable() {
    var swiper = this;
    if (!swiper.params.scrollbar.el) return;
    var document = (0, _ssrWindow.getDocument)();
    var scrollbar = swiper.scrollbar,
        touchEventsTouch = swiper.touchEventsTouch,
        touchEventsDesktop = swiper.touchEventsDesktop,
        params = swiper.params,
        support = swiper.support;
    var $el = scrollbar.$el;
    var target = $el[0];
    var activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    var passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;

    if (!support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      document.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      document.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable: function disableDraggable() {
    var swiper = this;
    if (!swiper.params.scrollbar.el) return;
    var document = (0, _ssrWindow.getDocument)();
    var scrollbar = swiper.scrollbar,
        touchEventsTouch = swiper.touchEventsTouch,
        touchEventsDesktop = swiper.touchEventsDesktop,
        params = swiper.params,
        support = swiper.support;
    var $el = scrollbar.$el;
    var target = $el[0];
    var activeListener = support.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    var passiveListener = support.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;

    if (!support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      document.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      document.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init: function init() {
    var swiper = this;
    var scrollbar = swiper.scrollbar,
        $swiperEl = swiper.$el;
    swiper.params.scrollbar = (0, _utils.createElementIfNotDefined)($swiperEl, swiper.params.scrollbar, swiper.params.createElements, {
      el: 'swiper-scrollbar'
    });
    var params = swiper.params.scrollbar;
    if (!params.el) return;
    var $el = (0, _dom2.default)(params.el);

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);

    if ($dragEl.length === 0) {
      $dragEl = (0, _dom2.default)("<div class=\"" + swiper.params.scrollbar.dragClass + "\"></div>");
      $el.append($dragEl);
    }

    (0, _utils.extend)(scrollbar, {
      $el: $el,
      el: $el[0],
      $dragEl: $dragEl,
      dragEl: $dragEl[0]
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }

    if ($el) {
      $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.scrollbar.disableDraggable();
  }
};
exports.default = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      scrollbar: _extends({
        isTouched: false,
        timeout: null,
        dragTimeout: null
      }, Scrollbar)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update: function update(swiper) {
      swiper.scrollbar.updateSize();
    },
    resize: function resize(swiper) {
      swiper.scrollbar.updateSize();
    },
    observerUpdate: function observerUpdate(swiper) {
      swiper.scrollbar.updateSize();
    },
    setTranslate: function setTranslate(swiper) {
      swiper.scrollbar.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      swiper.scrollbar.setTransition(duration);
    },
    'enable disable': function enableDisable(swiper) {
      var $el = swiper.scrollbar.$el;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
      }
    },
    destroy: function destroy(swiper) {
      swiper.scrollbar.destroy();
    }
  }
};

/***/ }),

/***/ 208:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Parallax = {
  setTransform: function setTransform(el, progress) {
    var swiper = this;
    var rtl = swiper.rtl;
    var $el = (0, _dom2.default)(el);
    var rtlFactor = rtl ? -1 : 1;
    var p = $el.attr('data-swiper-parallax') || '0';
    var x = $el.attr('data-swiper-parallax-x');
    var y = $el.attr('data-swiper-parallax-y');
    var scale = $el.attr('data-swiper-parallax-scale');
    var opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if (x.indexOf('%') >= 0) {
      x = parseInt(x, 10) * progress * rtlFactor + "%";
    } else {
      x = x * progress * rtlFactor + "px";
    }

    if (y.indexOf('%') >= 0) {
      y = parseInt(y, 10) * progress + "%";
    } else {
      y = y * progress + "px";
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      $el[0].style.opacity = currentOpacity;
    }

    if (typeof scale === 'undefined' || scale === null) {
      $el.transform("translate3d(" + x + ", " + y + ", 0px)");
    } else {
      var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
    }
  },
  setTranslate: function setTranslate() {
    var swiper = this;
    var $el = swiper.$el,
        slides = swiper.slides,
        progress = swiper.progress,
        snapGrid = swiper.snapGrid;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
      swiper.parallax.setTransform(el, progress);
    });
    slides.each(function (slideEl, slideIndex) {
      var slideProgress = slideEl.progress;

      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }

      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      (0, _dom2.default)(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {
        swiper.parallax.setTransform(el, slideProgress);
      });
    });
  },
  setTransition: function setTransition(duration) {
    if (duration === void 0) {
      duration = this.params.speed;
    }

    var swiper = this;
    var $el = swiper.$el;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (parallaxEl) {
      var $parallaxEl = (0, _dom2.default)(parallaxEl);
      var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      $parallaxEl.transition(parallaxDuration);
    });
  }
};
exports.default = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      parallax: _extends({}, Parallax)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init: function init(swiper) {
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate: function setTranslate(swiper) {
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    }
  }
};

/***/ }),

/***/ 209:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    var x1 = e.targetTouches[0].pageX;
    var y1 = e.targetTouches[0].pageY;
    var x2 = e.targetTouches[1].pageX;
    var y2 = e.targetTouches[1].pageY;
    var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    return distance;
  },
  // Events
  onGestureStart: function onGestureStart(e) {
    var swiper = this;
    var support = swiper.support;
    var params = swiper.params.zoom;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;

    if (!support.gestures) {
      if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
        return;
      }

      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }

    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = (0, _dom2.default)(e.target).closest("." + swiper.params.slideClass);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }

    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }

    swiper.zoom.isScaling = true;
  },
  onGestureChange: function onGestureChange(e) {
    var swiper = this;
    var support = swiper.support;
    var params = swiper.params.zoom;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;

    if (!support.gestures) {
      if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
        return;
      }

      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
      if (e.type === 'gesturechange') zoom.onGestureStart(e);
      return;
    }

    if (support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
    }

    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
    }

    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
    }

    gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
  },
  onGestureEnd: function onGestureEnd(e) {
    var swiper = this;
    var device = swiper.device;
    var support = swiper.support;
    var params = swiper.params.zoom;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;

    if (!support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }

      if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {
        return;
      }

      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart: function onTouchStart(e) {
    var swiper = this;
    var device = swiper.device;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture,
        image = zoom.image;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove: function onTouchMove(e) {
    var swiper = this;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture,
        image = zoom.image,
        velocity = zoom.velocity;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = (0, _utils.getTranslate)(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = (0, _utils.getTranslate)(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
    } // Define if we need image drag


    var scaledWidth = image.width * zoom.scale;
    var scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        return;
      }

      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        return;
      }
    }

    if (e.cancelable) {
      e.preventDefault();
    }

    e.stopPropagation();
    image.isMoved = true;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
    }

    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
    }

    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
    } // Velocity


    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
  },
  onTouchEnd: function onTouchEnd() {
    var swiper = this;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture,
        image = zoom.image,
        velocity = zoom.velocity;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }

    image.isTouched = false;
    image.isMoved = false;
    var momentumDurationX = 300;
    var momentumDurationY = 300;
    var momentumDistanceX = velocity.x * momentumDurationX;
    var newPositionX = image.currentX + momentumDistanceX;
    var momentumDistanceY = velocity.y * momentumDurationY;
    var newPositionY = image.currentY + momentumDistanceY; // Fix duration

    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY; // Define if we need image drag

    var scaledWidth = image.width * zoom.scale;
    var scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
  },
  onTransitionEnd: function onTransitionEnd() {
    var swiper = this;
    var zoom = swiper.zoom;
    var gesture = zoom.gesture;

    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }

      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      zoom.currentScale = 1;
      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle: function toggle(e) {
    var swiper = this;
    var zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in: function _in(e) {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();
    var zoom = swiper.zoom;
    var params = swiper.params.zoom;
    var gesture = zoom.gesture,
        image = zoom.image;

    if (!gesture.$slideEl) {
      if (e && e.target) {
        gesture.$slideEl = (0, _dom2.default)(e.target).closest("." + swiper.params.slideClass);
      }

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }
      }

      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
    gesture.$slideEl.addClass("" + params.zoomedSlideClass);
    var touchX;
    var touchY;
    var offsetX;
    var offsetY;
    var diffX;
    var diffY;
    var translateX;
    var translateY;
    var imageWidth;
    var imageHeight;
    var scaledWidth;
    var scaledHeight;
    var translateMinX;
    var translateMinY;
    var translateMaxX;
    var translateMaxY;
    var slideWidth;
    var slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left + window.scrollX;
      offsetY = gesture.$slideEl.offset().top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }

      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }

      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }

    gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
    gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
  },
  out: function out() {
    var swiper = this;
    var zoom = swiper.zoom;
    var params = swiper.params.zoom;
    var gesture = zoom.gesture;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }

      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
    }

    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
    gesture.$slideEl = undefined;
  },
  toggleGestures: function toggleGestures(method) {
    var swiper = this;
    var zoom = swiper.zoom;
    var selector = zoom.slideSelector,
        passive = zoom.passiveListener;
    swiper.$wrapperEl[method]('gesturestart', selector, zoom.onGestureStart, passive);
    swiper.$wrapperEl[method]('gesturechange', selector, zoom.onGestureChange, passive);
    swiper.$wrapperEl[method]('gestureend', selector, zoom.onGestureEnd, passive);
  },
  enableGestures: function enableGestures() {
    if (this.zoom.gesturesEnabled) return;
    this.zoom.gesturesEnabled = true;
    this.zoom.toggleGestures('on');
  },
  disableGestures: function disableGestures() {
    if (!this.zoom.gesturesEnabled) return;
    this.zoom.gesturesEnabled = false;
    this.zoom.toggleGestures('off');
  },
  // Attach/Detach Events
  enable: function enable() {
    var swiper = this;
    var support = swiper.support;
    var zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    var activeListenerWithCapture = support.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    var slideSelector = "." + swiper.params.slideClass;
    swiper.zoom.passiveListener = passiveListener;
    swiper.zoom.slideSelector = slideSelector; // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.on(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
  },
  disable: function disable() {
    var swiper = this;
    var zoom = swiper.zoom;
    if (!zoom.enabled) return;
    var support = swiper.support;
    swiper.zoom.enabled = false;
    var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    var activeListenerWithCapture = support.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    var slideSelector = "." + swiper.params.slideClass; // Scale image

    if (support.gestures) {
      swiper.$wrapperEl.off(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    } // Move image


    swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
  }
};
exports.default = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      zoom: _extends({
        enabled: false,
        scale: 1,
        currentScale: 1,
        isScaling: false,
        gesture: {
          $slideEl: undefined,
          slideWidth: undefined,
          slideHeight: undefined,
          $imageEl: undefined,
          $imageWrapEl: undefined,
          maxRatio: 3
        },
        image: {
          isTouched: undefined,
          isMoved: undefined,
          currentX: undefined,
          currentY: undefined,
          minX: undefined,
          minY: undefined,
          maxX: undefined,
          maxY: undefined,
          width: undefined,
          height: undefined,
          startX: undefined,
          startY: undefined,
          touchesStart: {},
          touchesCurrent: {}
        },
        velocity: {
          x: undefined,
          y: undefined,
          prevPositionX: undefined,
          prevPositionY: undefined,
          prevTime: undefined
        }
      }, Zoom)
    });
    var scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get: function get() {
        return scale;
      },
      set: function set(value) {
        if (scale !== value) {
          var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }

        scale = value;
      }
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy: function destroy(swiper) {
      swiper.zoom.disable();
    },
    touchStart: function touchStart(swiper, e) {
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd: function touchEnd(swiper, e) {
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap: function doubleTap(swiper, e) {
      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd: function transitionEnd(swiper) {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        swiper.zoom.onTransitionEnd();
      }
    }
  }
};

/***/ }),

/***/ 21:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(50);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),

/***/ 210:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Lazy = {
  loadInSlide: function loadInSlide(index, loadInDuplicate) {
    if (loadInDuplicate === void 0) {
      loadInDuplicate = true;
    }

    var swiper = this;
    var params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + index + "\"]") : swiper.slides.eq(index);
    var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");

    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images.push($slideEl[0]);
    }

    if ($images.length === 0) return;
    $images.each(function (imageEl) {
      var $imageEl = (0, _dom2.default)(imageEl);
      $imageEl.addClass(params.loadingClass);
      var background = $imageEl.attr('data-background');
      var src = $imageEl.attr('data-src');
      var srcset = $imageEl.attr('data-srcset');
      var sizes = $imageEl.attr('data-sizes');
      var $pictureEl = $imageEl.parent('picture');
      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;

        if (background) {
          $imageEl.css('background-image', "url(\"" + background + "\")");
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }

          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }

          if ($pictureEl.length) {
            $pictureEl.children('source').each(function (sourceEl) {
              var $source = (0, _dom2.default)(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }

          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find("." + params.preloaderClass).remove();

        if (swiper.params.loop && loadInDuplicate) {
          var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + swiper.params.slideDuplicateClass + ")");
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]");
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }

        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });
      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load: function load() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl,
        swiperParams = swiper.params,
        slides = swiper.slides,
        activeIndex = swiper.activeIndex;
    var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    var params = swiperParams.lazy;
    var slidesPerView = swiperParams.slidesPerView;

    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children("." + swiperParams.slideClass + "[data-swiper-slide-index=\"" + index + "\"]").length) {
          return true;
        }
      } else if (slides[index]) return true;

      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return (0, _dom2.default)(slideEl).attr('data-swiper-slide-index');
      }

      return (0, _dom2.default)(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;

    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (slideEl) {
        var index = isVirtual ? (0, _dom2.default)(slideEl).attr('data-swiper-slide-index') : (0, _dom2.default)(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }

    if (params.loadPrevNext) {
      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
        var amount = params.loadPrevNextAmount;
        var spv = slidesPerView;
        var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

        for (var _i = activeIndex + slidesPerView; _i < maxIndex; _i += 1) {
          if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
        } // Prev Slides


        for (var _i2 = minIndex; _i2 < activeIndex; _i2 += 1) {
          if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
        }
      } else {
        var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
        var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
  checkInViewOnLoad: function checkInViewOnLoad() {
    var window = (0, _ssrWindow.getWindow)();
    var swiper = this;
    if (!swiper || swiper.destroyed) return;
    var $scrollElement = swiper.params.lazy.scrollingElement ? (0, _dom2.default)(swiper.params.lazy.scrollingElement) : (0, _dom2.default)(window);
    var isWindow = $scrollElement[0] === window;
    var scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
    var scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
    var swiperOffset = swiper.$el.offset();
    var rtl = swiper.rtlTranslate;
    var inView = false;
    if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
    var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

    for (var i = 0; i < swiperCoord.length; i += 1) {
      var point = swiperCoord[i];

      if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
        if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line

        inView = true;
      }
    }

    var passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;

    if (inView) {
      swiper.lazy.load();
      $scrollElement.off('scroll', swiper.lazy.checkInViewOnLoad, passiveListener);
    } else if (!swiper.lazy.scrollHandlerAttached) {
      swiper.lazy.scrollHandlerAttached = true;
      $scrollElement.on('scroll', swiper.lazy.checkInViewOnLoad, passiveListener);
    }
  }
};
exports.default = {
  name: 'lazy',
  params: {
    lazy: {
      checkInView: false,
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,
      scrollingElement: '',
      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      lazy: _extends({
        initialImageLoaded: false
      }, Lazy)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init: function init(swiper) {
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        if (swiper.params.lazy.checkInView) {
          swiper.lazy.checkInViewOnLoad();
        } else {
          swiper.lazy.load();
        }
      }
    },
    scroll: function scroll(swiper) {
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    'scrollbarDragMove resize _freeModeNoMomentumRelease': function lazyLoad(swiper) {
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart: function transitionStart(swiper) {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd: function transitionEnd(swiper) {
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
    slideChange: function slideChange(swiper) {
      var _swiper$params = swiper.params,
          lazy = _swiper$params.lazy,
          cssMode = _swiper$params.cssMode,
          watchSlidesVisibility = _swiper$params.watchSlidesVisibility,
          watchSlidesProgress = _swiper$params.watchSlidesProgress,
          touchReleaseOnEdges = _swiper$params.touchReleaseOnEdges,
          resistanceRatio = _swiper$params.resistanceRatio;

      if (lazy.enabled && (cssMode || (watchSlidesVisibility || watchSlidesProgress) && (touchReleaseOnEdges || resistanceRatio === 0))) {
        swiper.lazy.load();
      }
    }
  }
};

/***/ }),

/***/ 211:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

var Controller = {
  LinearSpline: function LinearSpline(x, y) {
    var binarySearch = function search() {
      var maxIndex;
      var minIndex;
      var guess;
      return function (array, val) {
        minIndex = -1;
        maxIndex = array.length;

        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;

          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }

        return maxIndex;
      };
    }();

    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.

    var i1;
    var i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };

    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction: function getInterpolateFunction(c) {
    var swiper = this;

    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate: function setTranslate(_setTranslate, byController) {
    var swiper = this;
    var controlled = swiper.controller.control;
    var multiplier;
    var controlledTranslate;
    var Swiper = swiper.constructor;

    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out

        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }

      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }

    if (Array.isArray(controlled)) {
      for (var i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition: function setTransition(duration, byController) {
    var swiper = this;
    var Swiper = swiper.constructor;
    var controlled = swiper.controller.control;
    var i;

    function setControlledTransition(c) {
      c.setTransition(duration, swiper);

      if (duration !== 0) {
        c.transitionStart();

        if (c.params.autoHeight) {
          (0, _utils.nextTick)(function () {
            c.updateAutoHeight();
          });
        }

        c.$wrapperEl.transitionEnd(function () {
          if (!controlled) return;

          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }

          c.transitionEnd();
        });
      }
    }

    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
};
exports.default = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'

    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      controller: _extends({
        control: swiper.params.controller.control
      }, Controller)
    });
  },
  on: {
    update: function update(swiper) {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize: function resize(swiper) {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate: function observerUpdate(swiper) {
      if (!swiper.controller.control) return;

      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate: function setTranslate(swiper, translate, byController) {
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition: function setTransition(swiper, duration, byController) {
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    }
  }
};

/***/ }),

/***/ 212:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var A11y = {
  getRandomNumber: function getRandomNumber(size) {
    if (size === void 0) {
      size = 16;
    }

    var randomChar = function randomChar() {
      return Math.round(16 * Math.random()).toString(16);
    };

    return 'x'.repeat(size).replace(/x/g, randomChar);
  },
  makeElFocusable: function makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  makeElNotFocusable: function makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
    return $el;
  },
  addElRole: function addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElRoleDescription: function addElRoleDescription($el, description) {
    $el.attr('aria-roledescription', description);
    return $el;
  },
  addElControls: function addElControls($el, controls) {
    $el.attr('aria-controls', controls);
    return $el;
  },
  addElLabel: function addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  addElId: function addElId($el, id) {
    $el.attr('id', id);
    return $el;
  },
  addElLive: function addElLive($el, live) {
    $el.attr('aria-live', live);
    return $el;
  },
  disableEl: function disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl: function enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterOrSpaceKey: function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    var swiper = this;
    var params = swiper.params.a11y;
    var $targetEl = (0, _dom2.default)(e.target);

    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }

      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }

    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }

      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }

    if (swiper.pagination && $targetEl.is((0, _utils.classesToSelector)(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  },
  notify: function notify(message) {
    var swiper = this;
    var notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation: function updateNavigation() {
    var swiper = this;
    if (swiper.params.loop || !swiper.navigation) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
        swiper.a11y.makeElNotFocusable($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
        swiper.a11y.makeElFocusable($prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
        swiper.a11y.makeElNotFocusable($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
        swiper.a11y.makeElFocusable($nextEl);
      }
    }
  },
  updatePagination: function updatePagination() {
    var swiper = this;
    var params = swiper.params.a11y;

    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each(function (bulletEl) {
        var $bulletEl = (0, _dom2.default)(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);

        if (!swiper.params.pagination.renderBullet) {
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      });
    }
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.a11y;
    swiper.$el.append(swiper.a11y.liveRegion); // Container

    var $containerEl = swiper.$el;

    if (params.containerRoleDescriptionMessage) {
      swiper.a11y.addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }

    if (params.containerMessage) {
      swiper.a11y.addElLabel($containerEl, params.containerMessage);
    } // Wrapper


    var $wrapperEl = swiper.$wrapperEl;
    var wrapperId = $wrapperEl.attr('id') || "swiper-wrapper-" + swiper.a11y.getRandomNumber(16);
    var live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    swiper.a11y.addElId($wrapperEl, wrapperId);
    swiper.a11y.addElLive($wrapperEl, live); // Slide

    if (params.itemRoleDescriptionMessage) {
      swiper.a11y.addElRoleDescription((0, _dom2.default)(swiper.slides), params.itemRoleDescriptionMessage);
    }

    swiper.a11y.addElRole((0, _dom2.default)(swiper.slides), params.slideRole);
    var slidesLength = swiper.params.loop ? swiper.slides.filter(function (el) {
      return !el.classList.contains(swiper.params.slideDuplicateClass);
    }).length : swiper.slides.length;
    swiper.slides.each(function (slideEl, index) {
      var $slideEl = (0, _dom2.default)(slideEl);
      var slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;
      var ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
      swiper.a11y.addElLabel($slideEl, ariaLabelMessage);
    }); // Navigation

    var $nextEl;
    var $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl && $nextEl.length) {
      swiper.a11y.makeElFocusable($nextEl);

      if ($nextEl[0].tagName !== 'BUTTON') {
        swiper.a11y.addElRole($nextEl, 'button');
        $nextEl.on('keydown', swiper.a11y.onEnterOrSpaceKey);
      }

      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      swiper.a11y.addElControls($nextEl, wrapperId);
    }

    if ($prevEl && $prevEl.length) {
      swiper.a11y.makeElFocusable($prevEl);

      if ($prevEl[0].tagName !== 'BUTTON') {
        swiper.a11y.addElRole($prevEl, 'button');
        $prevEl.on('keydown', swiper.a11y.onEnterOrSpaceKey);
      }

      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      swiper.a11y.addElControls($prevEl, wrapperId);
    } // Pagination


    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', (0, _utils.classesToSelector)(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
    var $nextEl;
    var $prevEl;

    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }

    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }

    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterOrSpaceKey);
    }

    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterOrSpaceKey);
    } // Pagination


    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', (0, _utils.classesToSelector)(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
    }
  }
};
exports.default = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      a11y: _extends({}, A11y, {
        liveRegion: (0, _dom2.default)("<span class=\"" + swiper.params.a11y.notificationClass + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")
      })
    });
  },
  on: {
    afterInit: function afterInit(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge: function toEdge(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge: function fromEdge(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate: function paginationUpdate(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy: function destroy(swiper) {
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    }
  }
};

/***/ }),

/***/ 213:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _utils = __webpack_require__(1);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var History = {
  init: function init() {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();
    if (!swiper.params.history) return;

    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }

    var history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues(swiper.params.url);
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);

    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();

    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState: function setHistoryPopState() {
    var swiper = this;
    swiper.history.paths = History.getPathValues(swiper.params.url);
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues: function getPathValues(urlOverride) {
    var window = (0, _ssrWindow.getWindow)();
    var location;

    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }

    var pathArray = location.pathname.slice(1).split('/').filter(function (part) {
      return part !== '';
    });
    var total = pathArray.length;
    var key = pathArray[total - 2];
    var value = pathArray[total - 1];
    return {
      key: key,
      value: value
    };
  },
  setHistory: function setHistory(key, index) {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    var location;

    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }

    var slide = swiper.slides.eq(index);
    var value = History.slugify(slide.attr('data-history'));

    if (swiper.params.history.root.length > 0) {
      var root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = root + "/" + key + "/" + value;
    } else if (!location.pathname.includes(key)) {
      value = key + "/" + value;
    }

    var currentState = window.history.state;

    if (currentState && currentState.value === value) {
      return;
    }

    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value: value
      }, null, value);
    } else {
      window.history.pushState({
        value: value
      }, null, value);
    }
  },
  slugify: function slugify(text) {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  },
  scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
    var swiper = this;

    if (value) {
      for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
        var slide = swiper.slides.eq(i);
        var slideHistory = History.slugify(slide.attr('data-history'));

        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          var index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  }
};
exports.default = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      history: _extends({}, History)
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    'transitionEnd _freeModeNoMomentumRelease': function transitionEnd_freeModeNoMomentumRelease(swiper) {
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.history.initialized && swiper.params.cssMode) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    }
  }
};

/***/ }),

/***/ 214:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var HashNavigation = {
  onHashChange: function onHashChange() {
    var swiper = this;
    var document = (0, _ssrWindow.getDocument)();
    swiper.emit('hashChange');
    var newHash = document.location.hash.replace('#', '');
    var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

    if (newHash !== activeSlideHash) {
      var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-hash=\"" + newHash + "\"]").index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash: function setHash() {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();
    var document = (0, _ssrWindow.getDocument)();
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;

    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr('data-hash') || '');
      swiper.emit('hashSet');
    } else {
      var slide = swiper.slides.eq(swiper.activeIndex);
      var hash = slide.attr('data-hash') || slide.attr('data-history');
      document.location.hash = hash || '';
      swiper.emit('hashSet');
    }
  },
  init: function init() {
    var swiper = this;
    var document = (0, _ssrWindow.getDocument)();
    var window = (0, _ssrWindow.getWindow)();
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    swiper.hashNavigation.initialized = true;
    var hash = document.location.hash.replace('#', '');

    if (hash) {
      var speed = 0;

      for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
        var slide = swiper.slides.eq(i);
        var slideHash = slide.attr('data-hash') || slide.attr('data-history');

        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          var index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }

    if (swiper.params.hashNavigation.watchState) {
      (0, _dom2.default)(window).on('hashchange', swiper.hashNavigation.onHashChange);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var window = (0, _ssrWindow.getWindow)();

    if (swiper.params.hashNavigation.watchState) {
      (0, _dom2.default)(window).off('hashchange', swiper.hashNavigation.onHashChange);
    }
  }
};
exports.default = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      hashNavigation: _extends({
        initialized: false
      }, HashNavigation)
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy: function destroy(swiper) {
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    'transitionEnd _freeModeNoMomentumRelease': function transitionEnd_freeModeNoMomentumRelease(swiper) {
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
    slideChange: function slideChange(swiper) {
      if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
        swiper.hashNavigation.setHash();
      }
    }
  }
};

/***/ }),

/***/ 215:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ssrWindow = __webpack_require__(5);

var _utils = __webpack_require__(1);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

/* eslint no-underscore-dangle: "off" */

var Autoplay = {
  run: function run() {
    var swiper = this;
    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    var delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = (0, _utils.nextTick)(function () {
      var autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();else if (autoplayResult === false) {
        swiper.autoplay.run();
      }
    }, delay);
  },
  start: function start() {
    var swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop: function stop() {
    var swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }

    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause: function pause(speed) {
    var swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        swiper.$wrapperEl[0].addEventListener(event, swiper.autoplay.onTransitionEnd);
      });
    }
  },
  onVisibilityChange: function onVisibilityChange() {
    var swiper = this;
    var document = (0, _ssrWindow.getDocument)();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      swiper.autoplay.pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      swiper.autoplay.run();
      swiper.autoplay.paused = false;
    }
  },
  onTransitionEnd: function onTransitionEnd(e) {
    var swiper = this;
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);
    });
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.run();
    }
  },
  onMouseEnter: function onMouseEnter() {
    var swiper = this;

    if (swiper.params.autoplay.disableOnInteraction) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.pause();
    }

    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);
    });
  },
  onMouseLeave: function onMouseLeave() {
    var swiper = this;

    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }

    swiper.autoplay.paused = false;
    swiper.autoplay.run();
  },
  attachMouseEvents: function attachMouseEvents() {
    var swiper = this;

    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on('mouseenter', swiper.autoplay.onMouseEnter);
      swiper.$el.on('mouseleave', swiper.autoplay.onMouseLeave);
    }
  },
  detachMouseEvents: function detachMouseEvents() {
    var swiper = this;
    swiper.$el.off('mouseenter', swiper.autoplay.onMouseEnter);
    swiper.$el.off('mouseleave', swiper.autoplay.onMouseLeave);
  }
};
exports.default = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      autoplay: _extends({}, Autoplay, {
        running: false,
        paused: false
      })
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        var document = (0, _ssrWindow.getDocument)();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        swiper.autoplay.attachMouseEvents();
      }
    },
    beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove: function sliderFirstMove(swiper) {
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd: function touchEnd(swiper) {
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy: function destroy(swiper) {
      swiper.autoplay.detachMouseEvents();

      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }

      var document = (0, _ssrWindow.getDocument)();
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    }
  }
};

/***/ }),

/***/ 216:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Fade = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = swiper.slides.eq(i);
      var offset = $slideEl[0].swiperSlideOffset;
      var tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      var ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl.css({
        opacity: slideOpacity
      }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var slides = swiper.slides,
        $wrapperEl = swiper.$wrapperEl;
    slides.transition(duration);

    if (swiper.params.virtualTranslate && duration !== 0) {
      var eventTriggered = false;
      slides.transitionEnd(function () {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (var i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }
};
exports.default = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      fadeEffect: _extends({}, Fade)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(swiper.params.containerModifierClass + "fade");
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true
      };
      (0, _utils.extend)(swiper.params, overwriteParams);
      (0, _utils.extend)(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    }
  }
};

/***/ }),

/***/ 217:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Cube = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var $el = swiper.$el,
        $wrapperEl = swiper.$wrapperEl,
        slides = swiper.slides,
        swiperWidth = swiper.width,
        swiperHeight = swiper.height,
        rtl = swiper.rtlTranslate,
        swiperSize = swiper.size,
        browser = swiper.browser;
    var params = swiper.params.cubeEffect;
    var isHorizontal = swiper.isHorizontal();
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var wrapperRotate = 0;
    var $cubeShadowEl;

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = (0, _dom2.default)('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }

        $cubeShadowEl.css({
          height: swiperWidth + "px"
        });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');

        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = (0, _dom2.default)('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = slides.eq(i);
      var slideIndex = i;

      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }

      var slideAngle = slideIndex * 90;
      var round = Math.floor(slideAngle / 360);

      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }

      var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      var tx = 0;
      var ty = 0;
      var tz = 0;

      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }

      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";

      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }

      $slideEl.transform(transform);

      if (params.slideShadows) {
        // Set shadows
        var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if (shadowBefore.length === 0) {
          shadowBefore = (0, _dom2.default)("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
          $slideEl.append(shadowBefore);
        }

        if (shadowAfter.length === 0) {
          shadowAfter = (0, _dom2.default)("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
          $slideEl.append(shadowAfter);
        }

        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }

    $wrapperEl.css({
      '-webkit-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
      '-moz-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
      '-ms-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
      'transform-origin': "50% 50% -" + swiperSize / 2 + "px"
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
      } else {
        var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        var scale1 = params.shadowScale;
        var scale2 = params.shadowScale / multiplier;
        var offset = params.shadowOffset;
        $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
      }
    }

    var zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
    $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var $el = swiper.$el,
        slides = swiper.slides;
    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  }
};
exports.default = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      cubeEffect: _extends({}, Cube)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(swiper.params.containerModifierClass + "cube");
      swiper.classNames.push(swiper.params.containerModifierClass + "3d");
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true
      };
      (0, _utils.extend)(swiper.params, overwriteParams);
      (0, _utils.extend)(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    }
  }
};

/***/ }),

/***/ 218:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Flip = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var slides = swiper.slides,
        rtl = swiper.rtlTranslate;

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = slides.eq(i);
      var progress = $slideEl[0].progress;

      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }

      var offset = $slideEl[0].swiperSlideOffset;
      var rotate = -180 * progress;
      var rotateY = rotate;
      var rotateX = 0;
      var tx = -offset;
      var ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if (shadowBefore.length === 0) {
          shadowBefore = (0, _dom2.default)("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>");
          $slideEl.append(shadowBefore);
        }

        if (shadowAfter.length === 0) {
          shadowAfter = (0, _dom2.default)("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>");
          $slideEl.append(shadowAfter);
        }

        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }

      $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var slides = swiper.slides,
        activeIndex = swiper.activeIndex,
        $wrapperEl = swiper.$wrapperEl;
    slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

    if (swiper.params.virtualTranslate && duration !== 0) {
      var eventTriggered = false; // eslint-disable-next-line

      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return; // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;

        eventTriggered = true;
        swiper.animating = false;
        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (var i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }
};
exports.default = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      flipEffect: _extends({}, Flip)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(swiper.params.containerModifierClass + "flip");
      swiper.classNames.push(swiper.params.containerModifierClass + "3d");
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true
      };
      (0, _utils.extend)(swiper.params, overwriteParams);
      (0, _utils.extend)(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    }
  }
};

/***/ }),

/***/ 219:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Coverflow = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var swiperWidth = swiper.width,
        swiperHeight = swiper.height,
        slides = swiper.slides,
        slidesSizesGrid = swiper.slidesSizesGrid;
    var params = swiper.params.coverflowEffect;
    var isHorizontal = swiper.isHorizontal();
    var transform = swiper.translate;
    var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    var rotate = isHorizontal ? params.rotate : -params.rotate;
    var translate = params.depth; // Each slide offset from center

    for (var i = 0, length = slides.length; i < length; i += 1) {
      var $slideEl = slides.eq(i);
      var slideSize = slidesSizesGrid[i];
      var slideOffset = $slideEl[0].swiperSlideOffset;
      var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
      var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

      var translateZ = -translate * Math.abs(offsetMultiplier);
      var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }

      var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values

      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg) scale(" + scale + ")";
      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

      if (params.slideShadows) {
        // Set shadows
        var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = (0, _dom2.default)("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
          $slideEl.append($shadowBeforeEl);
        }

        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = (0, _dom2.default)("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
          $slideEl.append($shadowAfterEl);
        }

        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
  }
};
exports.default = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      coverflowEffect: _extends({}, Coverflow)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'coverflow') return;
      swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
      swiper.classNames.push(swiper.params.containerModifierClass + "3d");
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    }
  }
};

/***/ }),

/***/ 22:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ 220:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var _dom = __webpack_require__(4);

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };return _extends.apply(this, arguments);
}

var Thumbs = {
  init: function init() {
    var swiper = this;
    var thumbsParams = swiper.params.thumbs;
    if (swiper.thumbs.initialized) return false;
    swiper.thumbs.initialized = true;
    var SwiperClass = swiper.constructor;

    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      (0, _utils.extend)(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      (0, _utils.extend)(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if ((0, _utils.isObject)(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass((0, _utils.extend)({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false
      }));
      swiper.thumbs.swiperCreated = true;
    }

    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
    return true;
  },
  onThumbClick: function onThumbClick() {
    var swiper = this;
    var thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    var clickedIndex = thumbsSwiper.clickedIndex;
    var clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && (0, _dom2.default)(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    var slideToIndex;

    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt((0, _dom2.default)(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }

    if (swiper.params.loop) {
      var currentIndex = swiper.activeIndex;

      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }

      var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
      var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;else slideToIndex = prevIndex;
    }

    swiper.slideTo(slideToIndex);
  },
  update: function update(initial) {
    var swiper = this;
    var thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;

    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      var currentThumbsIndex = thumbsSwiper.activeIndex;
      var newThumbsIndex;
      var direction;

      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix(); // eslint-disable-next-line

          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        } // Find actual thumbs index to slide to


        var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
        var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();

        if (typeof prevThumbsIndex === 'undefined') {
          newThumbsIndex = nextThumbsIndex;
        } else if (typeof nextThumbsIndex === 'undefined') {
          newThumbsIndex = prevThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = nextThumbsIndex;
        } else {
          newThumbsIndex = prevThumbsIndex;
        }

        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }

      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {// newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }

        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    } // Activate thumbs


    var thumbsToActivate = 1;
    var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);

    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (var i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]").addClass(thumbActiveClass);
      }
    } else {
      for (var _i = 0; _i < thumbsToActivate; _i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);
      }
    }
  }
};
exports.default = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs'
    }
  },
  create: function create() {
    var swiper = this;
    (0, _utils.bindModuleMethods)(swiper, {
      thumbs: _extends({
        swiper: null,
        initialized: false
      }, Thumbs)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      var thumbs = swiper.params.thumbs;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange: function slideChange(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update: function update(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize: function resize(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate: function observerUpdate(swiper) {
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition: function setTransition(swiper, duration) {
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy: function beforeDestroy(swiper) {
      var thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;

      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    }
  }
};

/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

/***/ }),

/***/ 25:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var utils = __webpack_require__(0);

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function (el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57).Buffer))

/***/ }),

/***/ 26:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var settle = __webpack_require__(61);
var cookies = __webpack_require__(62);
var buildURL = __webpack_require__(23);
var buildFullPath = __webpack_require__(27);
var parseHeaders = __webpack_require__(65);
var isURLSameOrigin = __webpack_require__(66);
var transitionalDefaults = __webpack_require__(24);
var AxiosError = __webpack_require__(2);
var CanceledError = __webpack_require__(8);
var parseProtocol = __webpack_require__(67);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function onCanceled(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && ['http', 'https', 'file'].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData);
  });
};

/***/ }),

/***/ 27:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(63);
var combineURLs = __webpack_require__(64);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

/***/ }),

/***/ 28:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ 29:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });

  return config;
};

/***/ }),

/***/ 3:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assign = __webpack_require__(42);

/**
 * @public
 * @type {Object}
 */
module.exports = {
  virtualPage: function virtualPage(configs) {
    configs = assign.assign({
      command: 'send',
      type: 'pageview',
      page: ''
    }, configs);

    ga(configs.command, configs.type, configs.page);
  },
  sendEvent: function sendEvent(configs) {
    configs = assign.assign({
      command: 'send',
      type: 'event',
      eventCategory: '',
      eventAction: '',
      eventLabel: ''
    }, configs);

    ga(configs.command, configs.type, configs.eventCategory, configs.eventAction, configs.eventLabel);
  }
};

/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "version": "0.27.2"
};

/***/ }),

/***/ 31:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(11),
    now = __webpack_require__(75),
    toNumber = __webpack_require__(76);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),

/***/ 32:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(21);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),

/***/ 33:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */
// var SVGPolyfill = require("../polyfills/svg");

var viewport = __webpack_require__(20);
var Handlers = __webpack_require__(7);
var requestEstimatePopup = __webpack_require__(16);
var scrollBlocker = __webpack_require__(10);
var debounce = __webpack_require__(31);
var throttle = __webpack_require__(74);

/**
 * @private
 */
var DOM = {};
var handlers = new Handlers();
var marker = {
	enableMobileHandlers: false,
	navIcoAnimateTimer: false
};

// SVGPolyfill.init();

/**
 * @public
 * @type {Object}
 */
module.exports = {
	init: function init() {
		requestEstimatePopup.init();
		setDOM();
		initHandlers();
		fixSafariScroll();
		// toggleTransparentLayout();

		/* http://gitlab.mercury.office/mercdev.com/Web/merge_requests/902  - все ломает*/
	},
	isOpen: isOpen,
	on: handlers.add.bind(handlers),
	off: handlers.remove.bind(handlers)
};

/**
 * @private
 */
function isOpen() {
	return DOM.nav.classList.contains("active");
}

/**
 * @private
 */
function setDOM() {
	DOM.nav = document.querySelector(".js-nav");
	DOM.header = document.querySelector('.l-header');
	DOM.content = document.querySelector('.c-slides');
	DOM.main = document.querySelector('.c-slides-main');

	// for mobile
	DOM.mobileRequestEstimateLink = DOM.nav.querySelector('.js-nav_request_estimate_link');
	DOM.navIco = DOM.nav.querySelector(".js-nav_ico");
	DOM.navWrap = DOM.nav.querySelector(".c-nav_wrap");
	DOM.navOverlay = DOM.nav.querySelector(".c-nav_overlay");
	DOM.scrollable = document.querySelectorAll('.scrollable');
}

/**
 * @private
 */
function initHandlers() {
	viewport.isMobile() && enableMobileHandlers();

	initToggleTransparentLayout();

	window.addEventListener("resize", debounce(function () {
		viewport.isMobile() ? enableMobileHandlers() : disableMobileHandlers();

		// close mobile menu on viewport change (for iPad)
		if (isOpen() && !viewport.isMobile()) {
			toggleNavIcon();
		}
	}, 300));
}

function fixSafariScroll() {
	// About the problem: https://github.com/scottjehl/device-bugs/issues/23
	function getSafariVersion() {
		var navUserAgent = navigator.userAgent;
		var tempVersionOffset = void 0;
		var tempVersion = void 0;
		var browserVersion = void 0;

		if ((tempVersionOffset = navUserAgent.indexOf("Safari")) !== -1) {
			browserVersion = navUserAgent.substring(tempVersionOffset + 7);

			if ((tempVersionOffset = navUserAgent.indexOf("Version")) !== -1) {
				browserVersion = navUserAgent.substring(tempVersionOffset + 8);
			}
		} else {
			return false;
		}

		if ((tempVersion = browserVersion.indexOf(";")) != -1) {
			browserVersion = browserVersion.substring(0, tempVersion);
		}

		if ((tempVersion = browserVersion.indexOf(" ")) !== -1) {
			browserVersion = browserVersion.substring(0, tempVersion);
		}

		return parseFloat(browserVersion);
	}

	var safariVersion = getSafariVersion();

	if (safariVersion && safariVersion < 13) {

		if (DOM.main) {
			if (DOM.header) {
				DOM.header.classList.add("l-header--sticky");
			}
			if (DOM.content) {
				DOM.content.classList.add("c-slides--relative");
			}
		}
	}
}

/**
 * @private
 */
function enableMobileHandlers() {
	if (!marker.enableMobileHandlers) {
		marker.enableMobileHandlers = true;

		navCollapse();

		window.addEventListener("scroll", throttle(function () {
			navCollapse();
		}, 300));

		DOM.mobileRequestEstimateLink.addEventListener("click", requestEstimateShow);

		// nav ico
		DOM.navIco.addEventListener("click", toggleNavIcon);
	}
}

/**
 * @private
 */
function disableMobileHandlers() {
	if (marker.enableMobileHandlers) {
		marker.enableMobileHandlers = false;

		navCollapse();

		window.removeEventListener("scroll", navCollapse);

		DOM.mobileRequestEstimateLink.removeEventListener("click", requestEstimateShow);

		// nav ico
		DOM.navIco.removeEventListener("click", toggleNavIcon);
	}
}

/**
 * @private
 */
function navCollapse() {
	var isCollapse = isHeaderScrolled();
	var domNavClassList = DOM.nav.classList;

	if (isCollapse) domNavClassList.add("collapse");else domNavClassList.remove("collapse");

	handlers.call("collapse", [isCollapse], DOM.nav);
}

/**
 * @private
 * @returns {boolean}
 */
function isHeaderScrolled() {
	if (isOpen()) {
		return false;
	}

	return window.pageYOffset && window.pageYOffset > DOM.nav.parentNode.offsetHeight ? true : false;
}

/**
 * @private
 */
function requestEstimateShow() {
	requestEstimatePopup.show();
}

/**
 * @private
 */

function toggleNavIcon() {
	var isActive = DOM.nav.classList.toggle("active");

	iosBodyScrolling(isActive);

	DOM.navIco.classList.toggle("active");
	DOM.header.classList.toggle("opened");

	handlers.call("active", [isActive], DOM.nav);
	!isActive && viewport.isMobile() && requestEstimatePopup.isShow() && requestEstimatePopup.hide();
	// if (!isActive && !requestEstimatePopup.isShow()) {
	// 	scrollBlocker.scrollOn();
	// } else {
	// 	scrollBlocker.scrollOff();
	// }
}

function iosBodyScrolling(bool) {
	window.removeEventListener("touchmove", prevent);
	[].forEach.call(DOM.scrollable, function (item) {
		item.removeEventListener("touchstart", elPos);
		item.removeEventListener("touchmove", stopProp);
	});

	if (bool) {
		window.addEventListener("touchmove", prevent);
		[].forEach.call(DOM.scrollable, function (item) {
			item.addEventListener("touchstart", elPos);
			item.addEventListener("touchmove", stopProp);
		});
	}
}

function prevent(e) {
	e.preventDefault();
}

function elPos(e) {
	if (e.currentTarget.scrollTop === 0) {
		e.currentTarget.scrollTop = 1;
	} else if (e.currentTarget.scrollHeight === e.currentTarget.scrollTop + e.currentTarget.offsetHeight) {
		e.currentTarget.scrollTop -= 1;
	}
}

function stopProp(e) {
	e.stopPropagation();
}

function initToggleTransparentLayout() {
	var isTransparentSupport = DOM.header.classList.contains("js-toggle-transparent");

	if (viewport.isMobile() || !isTransparentSupport) return;

	toggleTransparentLayout();

	window.addEventListener("scroll", throttle(function () {
		toggleTransparentLayout();
	}, 300));
}

function toggleTransparentLayout() {
	var isScrolled = window.pageYOffset > 0;

	DOM.header.classList.toggle("l-header--transparent", !isScrolled);
}

/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(35);
var core = __webpack_require__(9);
var ctx = __webpack_require__(88);
var hide = __webpack_require__(90);
var has = __webpack_require__(40);
var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
          }return new C(a, b, c);
        }return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
      // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(91);
var IE8_DOM_DEFINE = __webpack_require__(37);
var toPrimitive = __webpack_require__(38);
var dP = Object.defineProperty;

exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ 37:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = !__webpack_require__(6) && !__webpack_require__(18)(function () {
  return Object.defineProperty(__webpack_require__(92)('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ 38:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(17);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ 39:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = __webpack_require__(136);

var Methods = {
  addClass: _dom.addClass,
  removeClass: _dom.removeClass,
  hasClass: _dom.hasClass,
  toggleClass: _dom.toggleClass,
  attr: _dom.attr,
  removeAttr: _dom.removeAttr,
  transform: _dom.transform,
  transition: _dom.transition,
  on: _dom.on,
  off: _dom.off,
  trigger: _dom.trigger,
  transitionEnd: _dom.transitionEnd,
  outerWidth: _dom.outerWidth,
  outerHeight: _dom.outerHeight,
  styles: _dom.styles,
  offset: _dom.offset,
  css: _dom.css,
  each: _dom.each,
  html: _dom.html,
  text: _dom.text,
  is: _dom.is,
  index: _dom.index,
  eq: _dom.eq,
  append: _dom.append,
  prepend: _dom.prepend,
  next: _dom.next,
  nextAll: _dom.nextAll,
  prev: _dom.prev,
  prevAll: _dom.prevAll,
  parent: _dom.parent,
  parents: _dom.parents,
  closest: _dom.closest,
  find: _dom.find,
  children: _dom.children,
  filter: _dom.filter,
  remove: _dom.remove
};
Object.keys(Methods).forEach(function (methodName) {
  Object.defineProperty(_dom.$.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
exports.default = _dom.$;

/***/ }),

/***/ 40:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ 41:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(96);
var defined = __webpack_require__(98);
module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ 42:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  assign: function assign(target, firstSource) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert first argument to object');
    }

    var to = Object(target);
    for (var i = 1; i < arguments.length; i++) {
      var nextSource = arguments[i];
      if (nextSource === undefined || nextSource === null) {
        continue;
      }

      var keysArray = Object.keys(Object(nextSource));
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
    return to;
  }
};

/***/ }),

/***/ 43:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var Promise = __webpack_require__(104);
var googleAnalytics = __webpack_require__(3);
var axios = __webpack_require__(49);

if (!window.Promise) {
  window.Promise = Promise;
}

module.exports = {
  cache: {},

  sendRequest: function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var formData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var formType = arguments[1];
      var formIdRequest = arguments[2];

      var _ref2, _ref2$data, sent, data;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              formData.page = document.location.pathname;
              formData.pageType = this._getPageType();

              this.cache[formIdRequest] = {};

              _context.next = 5;
              return axios.post(undefined ? "http://localhost:5001/api/core/requestEstimate" : "/api/core/requestEstimate", _extends({}, this.cache[formIdRequest], formData));

            case 5:
              _ref2 = _context.sent;
              _ref2$data = _ref2.data;
              sent = _ref2$data.sent;
              data = _objectWithoutProperties(_ref2$data, ["sent"]);


              this.cache[formIdRequest] = _extends({}, data, formData);

              _context.prev = 10;

              this._sendAnalytics(formIdRequest, formType);
              _context.next = 17;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](10);

              console.error("Analytics request failed", _context.t0);

            case 17:
              _context.prev = 17;
              return _context.abrupt("return", this.cache[formIdRequest]);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[10, 14, 17, 20]]);
    }));

    function sendRequest() {
      return _ref.apply(this, arguments);
    }

    return sendRequest;
  }(),

  _sendAnalytics: function _sendAnalytics(formIdRequest, formType) {
    if (!window.google_trackConversion) return;

    switch (formIdRequest) {
      case "request-estimate-step1":
        window.google_trackConversion({
          google_conversion_id: 950055030,
          google_conversion_language: "en",
          google_conversion_format: "3",
          google_conversion_color: "ffffff",
          google_conversion_label: "KAoeCP7g6VwQ9uCCxQM",
          google_remarketing_only: false
        });

        window.google_trackConversion({
          google_conversion_id: 875350916,
          google_conversion_language: "en",
          google_conversion_format: "3",
          google_conversion_color: "ffffff",
          google_conversion_label: "qFB6CIqku28QhJezoQM",
          google_remarketing_only: false
        });

        if (typeof conversionGoal !== "undefined") window.optimizely.push(["trackEvent", conversionGoal]);

        _gaq.push(["_trackEvent", "formStepFirst", true]);
        yaCounter38650490.reachGoal("SUBMIT");

        if (formType === "footer") {
          var virtualPage = "/feedback_footer_wwd";

          switch (document.location.pathname) {
            case "/what-we-do/ble":
              virtualPage = "/ble_feedback_footer";
              break;
            case "/what-we-do/indoor":
              virtualPage = "/ibeacon_feedback_footer";
              break;
            case "/what-we-do/applewatch":
              virtualPage = "/watch_feedback_footer";
              break;
            case "/what-we-do/appletv":
              virtualPage = "/appletv_feedback_footer";
              break;
            default:
              break;
          }

          if (virtualPage) googleAnalytics.virtualPage({ page: virtualPage });
        }
        googleAnalytics.virtualPage({ page: "/thankyou_1_step" });
        break;
      case "request-estimate-step2":
        googleAnalytics.virtualPage({ page: "/thankyou_2_step" });
        break;
    }
  },

  _getPageType: function _getPageType() {
    var page = window.location.pathname;

    switch (page) {
      case "/what-we-do/mobile":
      case "/what-we-do/ios":
      case "/what-we-do/android":
        return "Mobile Development Enquiry";
      case "/what-we-do/desktop":
      case "/what-we-do/mac":
      case "/what-we-do/windows":
        return "Desktop Development Enquiry";

      case "/what-we-do/web":
        return "Web Development Enquiry";

      case "/what-we-do/ble":
        return "BLE Development Enquiry";

      case "/what-we-do/applewatch":
      case "/what-we-do/smartwatch":
      case "/what-we-do/androidwatch":
        return "Smart Watch Development Enquiry";

      case "/what-we-do/ellpa":
      case "/what-we-do/appletv":
      case "/what-we-do/smarttv":
        return "Multimedia App Development Enquiry";

      default:
        return "App Development Enquiry";
    }
  }
};

/***/ }),

/***/ 44:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Support = __webpack_require__(14);
var formActions = __webpack_require__(43);

__webpack_require__(107);
__webpack_require__(108);

/**
 * @public
 * @constructor
 */
var requestEstimateForm = function requestEstimateForm() {
	if (!(this instanceof requestEstimateForm)) {
		new requestEstimateForm();
	}

	/**
  * @public
  * @type {Object}
  */
	this.DOM = {};
	this.data = {};
	this.formStep = 1;
	this.isSend = false;
};

/**
 * @public
 */
requestEstimateForm.prototype.init = function (container) {
	if (!container) return false;

	this.setDOM(container);
	this.initHandlers();
};

/**
 * @public
 */
requestEstimateForm.prototype.setDOM = function (container) {
	this.DOM.container = container;

	this.DOM.content = this.DOM.container.querySelector(".js-request_content");
	this.DOM.title = this.DOM.container.querySelector(".js-request_title span");
	this.DOM.success = this.DOM.container.querySelector(".js-request_success");
	this.DOM.fail = this.DOM.container.querySelector(".js-request_fail");

	this.DOM.form = this.DOM.container.querySelector(".js-request_form");
	this.DOM.formSteps = {
		wrap: this.DOM.form.querySelector(".js-request_steps"),
		step: this.DOM.form.querySelectorAll(".js-request_step")
	};
	this.DOM.footer = this.DOM.form.querySelector(".b-request_footer");
	this.DOM.formReload = Array.from(this.DOM.container.querySelectorAll(".js-request_reload")), this.DOM.formSubmit = this.DOM.footer.querySelector(".js-request_submit");
	this.DOM.budget = this.DOM.form.querySelector(".js-request_budget");
	this.DOM.adviser = this.DOM.form.querySelector(".js-request_adviser");
	this.DOM.fields = {
		text: Array.apply(null, this.DOM.form.querySelectorAll(".js-request_field")),
		radio: {
			budget: Array.apply(null, this.DOM.form.querySelectorAll("[name='budget']")),
			adviser: Array.apply(null, this.DOM.form.querySelectorAll("[name='adviser']"))
		},
		required: []
	};
};

/**
 * @public
 * @param text {String}
 */
requestEstimateForm.prototype.setTitle = function (text) {
	if (this.DOM.title) this.DOM.title.innerHTML = text;
};

/**
 * @public
 * @return {String}
 */
requestEstimateForm.prototype.getTitle = function () {
	return this.DOM.title.innerHTML;
};

/**
 * @public
 */
requestEstimateForm.prototype.initHandlers = function () {
	var self = this;

	this.DOM.form.onsubmit = function () {
		self.checkFormStep() && self.sendRequest();
		return false;
	};

	this.DOM.fields.text.map(function (field) {
		field.addEventListener("keyup", function () {
			if (this.value) {
				this.classList.add("full");
			} else {
				this.classList.remove("full");
			}

			self.data[this.name] = this.value;
		});

		field.addEventListener("blur", function () {
			self.data[this.name] = this.value;
		});

		if (field.classList.contains("required")) {
			self.DOM.fields.required.push(field);

			field.addEventListener("focus", function () {
				this.parentNode.classList.remove("error");
			});
		}

		if (field.classList.contains("radio")) {
			field.addEventListener("focus", function () {
				var id = this.parentNode.parentNode.getAttribute("for");

				var radio = document.getElementById(id);

				radio.checked = true;
				self.data[radio.name] = radio.value;
			});
		}

		return field;
	});

	var _DOM$fields$radio = this.DOM.fields.radio,
	    budget = _DOM$fields$radio.budget,
	    adviser = _DOM$fields$radio.adviser;


	[].concat(_toConsumableArray(budget), _toConsumableArray(adviser)).map(function (field) {
		field.onchange = function () {
			self.data[this.name] = this.value;
			this.checked && self.DOM.budget.classList.remove("error");
			this.checked && self.DOM.adviser.classList.remove("error");
		};
		return field;
	});

	this.DOM.formReload.map(function (button) {
		button.addEventListener("click", function () {
			return self.clearForm();
		});
	});
};

/**
 * @public
 */
requestEstimateForm.prototype.onShow = function () {
	!Support.isSafari() && this.autofocus(0);
};

/**
 * @public
 */
requestEstimateForm.prototype.onHide = function () {
	this.DOM.container.classList.remove("finished");
	this.DOM.content.classList.remove("g-hide");
	this.DOM.fail.classList.add("g-hide");
	this.DOM.success.classList.add("g-hide");
};

/**
 * @public
 */
requestEstimateForm.prototype.nextFormStep = function () {
	this.formStep++;

	if (this.formStep === 2) {
		this.DOM.formSteps.wrap.classList.remove("fst");
		this.DOM.formSteps.wrap.classList.add("sec");
	} else if (this.formStep === 3) {
		this.DOM.formSteps.wrap.classList.remove("sec");
		this.DOM.formSteps.wrap.classList.add("third");

		this.setTitle("Thank you!");
	}

	setTimeout(function () {
		this.autofocus(1);
	}.bind(this), 1000);

	/* if (this.formStep !== 1) {
 	_gaq.push(['_trackEvent', 'formSubmit', true]);
 	yaCounter38650490.reachGoal('SUBMIT');
 } */
};

/**
 * @public
 * @param i {Number}
 */
requestEstimateForm.prototype.autofocus = function (i) {
	this.DOM.formSteps.step[i].querySelector(".autofocus").focus();
};

/**
 * @public
 */
requestEstimateForm.prototype.prevFormStep = function () {
	this.formStep -= 2;
	this.DOM.formSteps.wrap.classList.remove("third");
	this.DOM.formSteps.wrap.classList.add("fst");
};

/**
 * @public
 * @returns {Boolean}
 */
requestEstimateForm.prototype.checkFormStep = function () {
	return this.isFormStepFirst() ? this.checkFormStepFirst() : this.isFormStepLast() ? this.checkFormStepThird() : this.checkFormStepSecond();
};

/**
 * @public
 * @returns {Boolean}
 */
requestEstimateForm.prototype.checkFormStepFirst = function () {
	var result = true;

	this.DOM.fields.required.map(function (field) {
		var value = field.value.trim();

		if (!value) {
			field.parentNode.classList.add("error");
			field.value = "";
			result = false;
		} else if (field.name === "mail") {
			var isValid = false;

			/*
    *  RegEx has ben taken from https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email
    *  Browsers that implement the specification should be using an algorithm equivalent to the following regular expression:
    *
    *  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    */

			var isEmailValid = value.match(/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]{1,63}@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/);
			var isPhoneValid = value.replace(/\s/g, "").match(/^(\+?([0-9][\-.]?){3,4}|(\+?[0-9][\-.]?)?\([0-9]{3}\)[\-.]?)([0-9][\-.]?){2}[0-9][^@]*$/i);

			if (isEmailValid || isPhoneValid) {
				isValid = true;
			}

			if (!isValid) {
				field.parentNode.classList.add("error");
				result = false;
			}
		}

		return field;
	});

	return result;
};

/**
 * @public
 * @returns {Boolean}
 */
requestEstimateForm.prototype.checkFormStepSecond = function () {
	var result = false;

	this.DOM.fields.radio.budget.map(function (field) {
		field.checked && (result = true);

		return field;
	});

	!result && this.DOM.budget.classList.add("error");

	return result;
};

/**
 * @public
 * @returns {Boolean}
 */
requestEstimateForm.prototype.checkFormStepThird = function () {
	var result = this.DOM.fields.radio.adviser.some(function (field) {
		return field.checked;
	});

	!result && this.DOM.adviser.classList.add("error");

	return result;
};

/**
 * @public
 * @returns {Boolean}
 */
requestEstimateForm.prototype.isFormStepFirst = function () {
	return this.formStep < 2;
};

requestEstimateForm.prototype.isFormStepLast = function () {
	return this.formStep > 2;
};

requestEstimateForm.prototype.setSending = function (status) {
	this.isSending = status;
	this.DOM.form.classList.toggle("js-is-sending", status);
};

/**
 * @public
 * @param isError {Boolean}
 */
requestEstimateForm.prototype.showResult = function () {
	this.DOM.container.classList.add("finished");
	this.DOM.formSteps.wrap.classList.add("g-hide");

	if (this.DOM.title) this.DOM.title.classList.add("g-hide");

	this.DOM.footer.classList.add("g-hide");
	this.DOM.success.classList.remove("g-hide");
	this.prevFormStep();
};

requestEstimateForm.prototype.showError = function () {
	this.DOM.formSteps.wrap.classList.add("g-hide");

	if (this.DOM.title) this.DOM.title.classList.add("g-hide");

	this.DOM.footer.classList.add("g-hide");
	this.DOM.fail.classList.remove("g-hide");
};

requestEstimateForm.prototype.hideResult = function () {
	this.DOM.formSteps.wrap.classList.remove("g-hide");

	if (this.DOM.title) this.DOM.title.classList.remove("g-hide");

	this.DOM.footer.classList.remove("g-hide");
	this.DOM.fail.classList.add("g-hide");
	this.DOM.success.classList.add("g-hide");
};

/**
 * @public
 * @returns {Boolean}
 */
requestEstimateForm.prototype.clearForm = function () {
	this.setTitle("Request a Project Estimation");
	this.hideResult();

	this.DOM.fields.text.map(function (field) {
		field.parentNode.classList.remove("error");
		field.classList.remove("full");
		field.value = "";

		return field;
	});

	var _DOM$fields$radio2 = this.DOM.fields.radio,
	    budget = _DOM$fields$radio2.budget,
	    adviser = _DOM$fields$radio2.adviser;


	[].concat(_toConsumableArray(budget), _toConsumableArray(adviser)).map(function (field) {
		field.checked = false;
		return field;
	});

	this.data = {};
};

/**
 * @public
 * @param formType {String}
 * @returns {Boolean}
 */
requestEstimateForm.prototype.sendRequest = function () {
	var self = this;

	if (this.isSending) return;
	this.setSending(true);

	this.data.step = this.formStep - 1;
	var formData = this.data;

	var formIdRequest = self.isFormStepFirst() ? 'request-estimate-step1' : 'request-estimate-step2';
	var formType = self.DOM.form.getAttribute("data-type");

	formActions.sendRequest(formData, formType, formIdRequest).then(function (data) {
		self.data = data;
		self.setSending(false);

		if (!self.isFormStepLast()) {
			self.nextFormStep();
		} else {
			self.showResult();
		}
	}).catch(function (error) {
		console.error(error);
		self.setSending(false);
		self.showError();
	});
};

/**
 * @public
 * @type {Handlers}
 */
module.exports = requestEstimateForm;

/***/ }),

/***/ 45:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var Support = __webpack_require__(14);
var googleAnalytics = __webpack_require__(3);
var formActions = __webpack_require__(43);
var Handlers = __webpack_require__(7);
var assign = __webpack_require__(42);

/**
 * @public
 * @constructor
 */
var requestAdviserForm = function requestAdviserForm() {
    if (!(this instanceof requestAdviserForm)) {
        new requestAdviserForm();
    }

    /**
     * @public
     * @type {Object}
     */
    this.DOM = {};
    this.data = {};
    this.isSend = false;
    this.handlers = new Handlers();

    this.on = this.handlers.add.bind(this.handlers);
    this.off = this.handlers.remove.bind(this.handlers);
};

requestAdviserForm.prototype.setAdviser = function (radioButtons) {
    var referrer = this.getReferrerUrlFromCookies();

    for (var i = 0; i < radioButtons.length; i++) {
        var value = radioButtons[i].value.toLowerCase().trim();

        // https://www.appfutura.com/
        // https://clutch.co/
        // https://www.goodfirms.co/

        var canCheck = value === "appfutura" && referrer.match(/https:\/\/(www\.)?appfutura\.com[^a-z]/i) || value === "clutch" && referrer.match(/https:\/\/(www\.)?clutch\.co[^a-z]?/i) || value === "google" && referrer.match(/https:\/\/(www\.)?google\./i) || value === "goodfirms" && referrer.match(/https:\/\/(www\.)?goodfirms\.co[^a-z]?/i);

        if (canCheck) {
            var radioButton = radioButtons[i];

            radioButton.checked = true;
            this.data[radioButton.name] = radioButton.value;

            break;
        }
    }
};

requestAdviserForm.prototype.getReferrerUrlFromCookies = function () {
    return document.cookie.replace(/(?:(?:^|.*;\s*)referrerUrl\s*\=\s*([^;]*).*$)|^.*$/, "$1");
};

requestAdviserForm.prototype.setReferrerUrlIntoCookies = function () {
    var referrer = null;
    var search = document.location.search;

    if (search.match(/[^a-z]?utm_source=appfutura[^a-z]?/i)) {
        referrer = "https://www.appfutura.com/";
    } else if (search.match(/[^a-z]?utm_source=clutch[^a-z]?/i)) {
        referrer = "https://clutch.co/";
    } else if (search.match(/[^a-z]?utm_source=goodfirms[^a-z]?/i)) {
        referrer = "https://www.goodfirms.co/";
    } else if (search.match(/[^a-z]?gclid=/i)) {
        referrer = "https://www.google.com/";
    } else {
        referrer = document.referrer;
    }

    if (!referrer) {
        document.cookie = "referrerUrl=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    } else {
        var cookieReferrer = this.getReferrerUrlFromCookies();

        if (cookieReferrer !== referrer && !referrer.match(/https:\/\/([a-z]{3}\.)?(mercdev|mercurydevelopment)\.com/i)) {
            document.cookie = "referrerUrl=" + referrer + "; path=/;";
        }
    }
};

/**
 * @public
 */
requestAdviserForm.prototype.init = function (container) {
    if (!container) return false;

    this.setReferrerUrlIntoCookies();
    this.setDOM(container);
    this.initHandlers();
};

/**
 * @public
 */
requestAdviserForm.prototype.setDOM = function (container) {
    this.DOM.container = container;

    this.DOM.form = this.DOM.container.querySelector(".js-request_form");
    this.DOM.formSubmit = this.DOM.form.querySelector(".js-request_submit");
    this.DOM.adviser = this.DOM.form.querySelector(".js-request_adviser");
    this.DOM.fields = {
        text: Array.apply(null, this.DOM.form.querySelectorAll(".js-request_field")),
        radio: Array.apply(null, this.DOM.form.querySelectorAll("[name='adviser']")),
        required: []
    };

    this.setAdviser(this.DOM.fields.radio);
};

/**
 * @public
 */
requestAdviserForm.prototype.initHandlers = function () {
    var self = this;

    this.DOM.form.onsubmit = function () {

        self.checkForm() && self.sendRequest();
        return false;
    };

    this.DOM.fields.text.map(function (field) {
        field.addEventListener("keyup", function () {
            if (this.value) {
                this.classList.add("full");
            } else {
                this.classList.remove("full");
            }
        });

        field.addEventListener("blur", function () {
            self.data[this.name] = this.value;
        });

        if (field.classList.contains("required")) {
            self.DOM.fields.required.push(field);

            field.addEventListener("focus", function () {
                this.parentNode.classList.remove("error");
            });
        }

        if (field.classList.contains("radio")) {
            field.addEventListener("focus", function () {
                var id = this.parentNode.parentNode.getAttribute("for");

                var radio = document.getElementById(id);

                radio.checked = true;
                self.data[radio.name] = radio.value;
            });
        }

        return field;
    });

    this.DOM.fields.radio.map(function (field) {
        field.onchange = function () {
            self.data[this.name] = this.value;
            this.checked && self.DOM.adviser.classList.remove("error");
        };
        return field;
    });
};

/**
 * @public
 * @returns {Boolean}
 */
requestAdviserForm.prototype.checkForm = function () {
    /*var result = false;
     this.DOM.fields.radio.map(function(field) {
        field.checked && (result = true);
         return field;
    });
     !result && this.DOM.adviser.classList.add("error");
     return result;*/

    return true;
};

requestAdviserForm.prototype.setSending = function (status) {
    this.isSending = status;
    this.DOM.form.classList.toggle("js-is-sending", status);
};

requestAdviserForm.prototype.showError = function () {
    this.DOM.fail.classList.remove("g-hide");
};

/**
 * @public
 * @returns {Boolean}
 */
requestAdviserForm.prototype.clearForm = function () {
    this.DOM.fields.text.map(function (field) {
        field.parentNode.classList.remove("error");
        field.classList.remove("full");
        field.value = "";

        return field;
    });

    this.DOM.adviser.classList.remove("error");

    this.DOM.fields.radio.map(function (field) {
        field.checked = false;
        return field;
    });

    this.data = {};

    this.setAdviser(this.DOM.fields.radio);
};

/**
 * @public
 * @param formType {String}
 * @returns {Boolean}
 */
requestAdviserForm.prototype.sendRequest = function () {
    var self = this;
    var formData = this.data;

    if (this.isSending) return;
    this.setSending(true);

    var formIdRequest = 'request-estimate-adviser';
    var formType = self.DOM.form.getAttribute("data-type");

    if (formActions.cache['request-estimate-step2']) {
        formData = assign.assign({}, formActions.cache['request-estimate-step2'], formData);
    }

    formActions.sendRequest(formData, formType, formIdRequest).then(function (data) {
        self.data = data;

        self.setSending(false);
        self.handlers.call('done');
        self.clearForm();
    }).catch(function (error) {
        console.error(error);
        self.setSending(false);
        self.showError();
        self.clearForm();
    });
};

/**
 * @public
 * @type {Handlers}
 */
module.exports = requestAdviserForm;

/***/ }),

/***/ 46:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ 47:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(32),
    getRawTag = __webpack_require__(80),
    objectToString = __webpack_require__(81);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ 48:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var googleAnalytics = __webpack_require__(3);
var requestEstimatePopup = __webpack_require__(16);

/**
 * @public
 * @type {Object}
 */
module.exports = {
	init: function init(className, isHeaderLink) {
		if (typeof isHeaderLink === "undefined") isHeaderLink = false;

		var links = document.querySelectorAll(className || ".js-request_estimate_link");
		var self = this;

		for (var i = 0; i < links.length; i++) {
			var link = links[i];

			if (link) {
				requestEstimatePopup.init();

				link.addEventListener('click', function () {
					if (isHeaderLink) {
						googleAnalytics.virtualPage({ page: '/feedback_head' });
					} else {
						self.getGoogleVirtualPageAddress();
					}
					this.classList.add("active");
					requestEstimatePopup.show();

					_gaq.push(['_trackEvent', 'popupLink', 'click&show']);
				});

				requestEstimatePopup.on("hide", function () {
					link.classList.remove("active");
				});
			}
		}
	},
	getGoogleVirtualPageAddress: function getGoogleVirtualPageAddress() {
		var virtualPage = "";
		switch (document.location.pathname) {
			case "/what-we-do/ble":
				virtualPage = "/ble_feedback";
				break;
			case "/what-we-do/indoor":
				virtualPage = "/ibeacon_feedback";
				break;
			case "/what-we-do/applewatch":
				virtualPage = "/watch_feedback";
				break;
			case "/what-we-do/appletv":
				virtualPage = "/appletv_feedback";
				break;
			default:
				break;
		}

		if (virtualPage) googleAnalytics.virtualPage({ page: virtualPage });
	}
};

/***/ }),

/***/ 49:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(51);

/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * SSR Window 3.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: November 9, 2020
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend(target, src) {
    if (target === void 0) {
        target = {};
    }
    if (src === void 0) {
        src = {};
    }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

var ssrDocument = {
    body: {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    activeElement: {
        blur: function blur() {},
        nodeName: ''
    },
    querySelector: function querySelector() {
        return null;
    },
    querySelectorAll: function querySelectorAll() {
        return [];
    },
    getElementById: function getElementById() {
        return null;
    },
    createEvent: function createEvent() {
        return {
            initEvent: function initEvent() {}
        };
    },
    createElement: function createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function setAttribute() {},
            getElementsByTagName: function getElementsByTagName() {
                return [];
            }
        };
    },
    createElementNS: function createElementNS() {
        return {};
    },
    importNode: function importNode() {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
    }
};
function getDocument() {
    var doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
}

var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ''
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: ''
    },
    history: {
        replaceState: function replaceState() {},
        pushState: function pushState() {},
        go: function go() {},
        back: function back() {}
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    getComputedStyle: function getComputedStyle() {
        return {
            getPropertyValue: function getPropertyValue() {
                return '';
            }
        };
    },
    Image: function Image() {},
    Date: function Date() {},
    screen: {},
    setTimeout: function setTimeout() {},
    clearTimeout: function clearTimeout() {},
    matchMedia: function matchMedia() {
        return {};
    },
    requestAnimationFrame: function requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame: function cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    }
};
function getWindow() {
    var win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
}

exports.extend = extend;
exports.getDocument = getDocument;
exports.getWindow = getWindow;
exports.ssrDocument = ssrDocument;
exports.ssrWindow = ssrWindow;

/***/ }),

/***/ 50:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),

/***/ 51:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var bind = __webpack_require__(22);
var Axios = __webpack_require__(52);
var mergeConfig = __webpack_require__(29);
var defaults = __webpack_require__(15);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = __webpack_require__(8);
axios.CancelToken = __webpack_require__(70);
axios.isCancel = __webpack_require__(28);
axios.VERSION = __webpack_require__(30).version;
axios.toFormData = __webpack_require__(25);

// Expose AxiosError class
axios.AxiosError = __webpack_require__(2);

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(71);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(72);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),

/***/ 52:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var buildURL = __webpack_require__(23);
var InterceptorManager = __webpack_require__(53);
var dispatchRequest = __webpack_require__(54);
var mergeConfig = __webpack_require__(29);
var buildFullPath = __webpack_require__(27);
var validator = __webpack_require__(69);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }

  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;

/***/ }),

/***/ 53:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ 54:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var transformData = __webpack_require__(55);
var isCancel = __webpack_require__(28);
var defaults = __webpack_require__(15);
var CanceledError = __webpack_require__(8);

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(config, config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ 55:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var defaults = __webpack_require__(15);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

/***/ }),

/***/ 56:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ 57:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(58);
var ieee754 = __webpack_require__(59);
var isArray = __webpack_require__(60);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),

/***/ 58:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ 59:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(18)(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ 60:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AxiosError = __webpack_require__(2);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
};

/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ 63:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)
  );
};

/***/ }),

/***/ 64:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ 65:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

/***/ }),

/***/ 66:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ 67:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// eslint-disable-next-line strict
module.exports = null;

/***/ }),

/***/ 69:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var VERSION = __webpack_require__(30).version;
var AxiosError = __webpack_require__(2);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
  validators[type] = function validator(thing) {
    return (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function (value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

/***/ }),

/***/ 7:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @public
 * @constructor
 */

var Handlers = function Handlers() {
  if (!(this instanceof Handlers)) {
    new Handlers();
  }

  /**
   * @public
   * @type {Object}
   */
  this.list = {};
};

/**
 * @public
 * @param event {String}
 * @param callback {Function}
 * @returns {Number}
 */
Handlers.prototype.add = function (event, callback) {
  if (!this.list.hasOwnProperty(event)) {
    this.list[event] = [];
  }

  this.list[event].push(callback);

  return this.list[event].length - 1;
};

/**
 * @public
 * @param event {String}
 * @param fn {Function}
 * @returns {Handlers}
 */
Handlers.prototype.remove = function (event, fn) {
  if (this.hasHandlers(event)) {
    this.list[event] = this.list[event].filter(function (handler) {
      return handler !== fn;
    });
  }

  return this;
};

/**
 * @public
 * @param event {String}
 * @returns {Boolean}
 */
Handlers.prototype.hasHandlers = function (event) {
  return this.list.hasOwnProperty(event) && this.list[event].length ? true : false;
};

/**
 * @public
 * @param event {String}
 * @param args {Array}
 * @param context {*}
 * @returns {Handlers}
 */
Handlers.prototype.call = function (event, args, context) {
  if (this.hasHandlers(event)) {
    this.list[event].map(function (handler) {
      handler && handler.apply(context || null, args);
    });
  }

  return this;
};

/**
 * @public
 * @type {Handlers}
 */
module.exports = Handlers;

/***/ }),

/***/ 70:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CanceledError = __webpack_require__(8);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function (cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function (onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function (resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ 71:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ 72:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
};

/***/ }),

/***/ 73:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 * @private
 */

var googleAnalytics = __webpack_require__(3);
var nav = __webpack_require__(33);
var requestEstimateLink = __webpack_require__(48);

/**
 * @public
 * @type {Object}
 */
module.exports = {
	init: function init() {
		nav.on("collapse", onNavCollapse);
		nav.init();

		requestEstimateLink.init(".js-request_estimate_link", true);
		initHandlers();
	}
};

/**
 * @private
 */
function initHandlers() {
	var emailLink = document.querySelector(".l-header .l-mail-link.b-nav_footer_email");

	emailLink.addEventListener('click', sendGoogleAnalyticsEvent);
}

/**
 * @private
 */
function sendGoogleAnalyticsEvent() {
	googleAnalytics.sendEvent({
		eventCategory: 'request',
		eventAction: 'email',
		eventLabel: 'tab'
	});
}

/**
 * @private
 * @param isCollapse {Boolean}
 */
function onNavCollapse(isCollapse) {
	var siteNavClassList = document.querySelector(".js-site-navigation").classList;

	if (isCollapse) siteNavClassList.add("collapse");else siteNavClassList.remove("collapse");
}

/***/ }),

/***/ 74:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var debounce = __webpack_require__(31),
    isObject = __webpack_require__(11);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

/***/ }),

/***/ 75:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(21);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),

/***/ 76:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTrim = __webpack_require__(77),
    isObject = __webpack_require__(11),
    isSymbol = __webpack_require__(79);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),

/***/ 77:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var trimmedEndIndex = __webpack_require__(78);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

module.exports = baseTrim;

/***/ }),

/***/ 78:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;

/***/ }),

/***/ 79:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(47),
    isObjectLike = __webpack_require__(46);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AxiosError = __webpack_require__(2);
var utils = __webpack_require__(0);

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;

/***/ }),

/***/ 80:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(32);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ 81:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ 82:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function (global, factory) {

	if (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : undefined, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var _slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var version = "2.2.4",


	// Define a local copy of jQuery
	jQuery = function jQuery(selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function fcamelCase(all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function toArray() {
			return _slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function get(num) {
			return num != null ?

			// Return just the one element from the set
			num < 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			_slice.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function pushStack(elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function each(callback) {
			return jQuery.each(this, callback);
		},

		map: function map(callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function slice() {
			return this.pushStack(_slice.apply(this, arguments));
		},

		first: function first() {
			return this.eq(0);
		},

		last: function last() {
			return this.eq(-1);
		},

		eq: function eq(i) {
			var len = this.length,
			    j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},

		end: function end() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];
						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function error(msg) {
			throw new Error(msg);
		},

		noop: function noop() {},

		isFunction: function isFunction(obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function isWindow(obj) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function isNumeric(obj) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj && obj.toString();
			return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
		},

		isPlainObject: function isPlainObject(obj) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for (key in obj) {}

			return key === undefined || hasOwn.call(obj, key);
		},

		isEmptyObject: function isEmptyObject(obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function type(obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
		},

		// Evaluates a script in a global context
		globalEval: function globalEval(code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function camelCase(string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function nodeName(elem, name) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function each(obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i < length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function trim(text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function makeArray(arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function inArray(elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function merge(first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j < len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function grep(elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i < length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function map(elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i < length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function proxy(fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = _slice.call(arguments, 2);
			proxy = function proxy() {
				return fn.apply(context || this, args.concat(_slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function sortOrder(a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function indexOf(list, elem) {
			var i = 0,
			    len = list.length;
			for (; i < len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function funescape(_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high < 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function unloadHandler() {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE<9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    nidselect,
			    match,
			    groups,
			    newSelector,
			    newContext = context && context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rescape, "\\$&");
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
							while (i--) {
								groups[i] = nidselect + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b && a,
			    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ((parent = document.defaultView) && parent.top !== parent) {
				// Support: IE 11
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (parent.attachEvent) {
					parent.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(document.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" && documentIsHTML) {
						var m = context.getElementById(id);
						return m ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b && b.parentNode;
				return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare & 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function ATTR(match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function CHILD(match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function PSEUDO(match) {
					var excess,
					    unquoted = !match[6] && match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted && rpseudo.test(unquoted) && (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) && (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function TAG(nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function CLASS(className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
					});
				},

				"ATTR": function ATTR(name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function CHILD(type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType && elem.nodeName.toLowerCase(),
						    useCache = !xml && !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward && useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = nodeIndex && cache[2];
								node = nodeIndex && parent.childNodes[nodeIndex];

								while (node = ++nodeIndex && node && node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 && ++diff && node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns && cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 && diff / first >= 0;
						}
					};
				},

				"PSEUDO": function PSEUDO(pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) && elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function target(elem) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice(1) === elem.id;
				},

				"root": function root(elem) {
					return elem === docElem;
				},

				"focus": function focus(elem) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function enabled(elem) {
					return elem.disabled === false;
				},

				"disabled": function disabled(elem) {
					return elem.disabled === true;
				},

				"checked": function checked(elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
				},

				"selected": function selected(elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function empty(elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType < 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function parent(elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function header(elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function input(elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function button(elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function text(elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument < 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i < length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument < 0 ? argument + length : argument;
					for (; ++i < length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i < len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base && dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i < len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i < len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter && !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder && !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i < len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j < len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function superMatcher(seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed && [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for (; i !== len && (elem = elems[i]) != null; i++) {
					if (byElement && elem) {
						j = 0;
						if (!context && elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher && elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet && i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" && selector,
			    match = !seed && tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length && toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "<a href='#'></a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "<input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML && elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var dir = function dir(elem, _dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[_dir]) && elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate && jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var _siblings = function _siblings(n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 && n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function find(selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i < len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i < len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function filter(selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function not(selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function is(selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if (elem && elem.parentNode) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function has(target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i < l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function closest(selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i < l; i++) {
				for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

					// Always skip document fragments
					if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function index(elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function add(selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function addBack(selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) && cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function parent(elem) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function parents(elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function parentsUntil(elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function next(elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function prev(elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function nextAll(elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function prevAll(elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function nextUntil(elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function prevUntil(elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function siblings(elem) {
			return _siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function children(elem) {
			return _siblings(elem.firstChild);
		},
		contents: function contents(elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector && typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		_fired,


		// Flag to prevent firing
		_locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function fire() {

			// Enforce single-firing
			_locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			_fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex < list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (_locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function add() {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory && !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg && arg.length && jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory && !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function remove() {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function has(fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function empty() {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function disable() {
				_locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function disabled() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function lock() {
				_locked = queue = [];
				if (!memory) {
					list = memory = "";
				}
				return this;
			},
			locked: function locked() {
				return !!_locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function fireWith(context, args) {
				if (!_locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function fire() {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function fired() {
				return !!_fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function Deferred(func) {
			var tuples = [

			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    _state = "pending",
			    _promise = {
				state: function state() {
					return _state;
				},
				always: function always() {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function then() /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) && fns[i];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn && fn.apply(this, arguments);
								if (returned && jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function promise(obj) {
					return obj != null ? jQuery.extend(obj, _promise) : _promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			_promise.pipe = _promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				_promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = [ resolved | rejected ]
						_state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? _promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			_promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function when(subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = _slice.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function updateFunc(i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? _slice.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i < length; i++) {
					if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {

		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function holdReady(hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function ready(wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true && --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function fn(elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i < len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function acceptData(owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function register(owner, initial) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if (owner.nodeType) {
				owner[this.expando] = value;

				// Otherwise secure it in a non-enumerable, non-writable property
				// configurability must be true to allow the property to be
				// deleted with the delete operator
			} else {
				Object.defineProperty(owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				});
			}
			return owner[this.expando];
		},
		cache: function cache(owner) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if (!acceptData(owner)) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function set(owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[prop] = data[prop];
				}
			}
			return cache;
		},
		get: function get(owner, key) {
			return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
		},
		access: function access(owner, key, value) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key && typeof key === "string" && value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function remove(owner, key) {
			var i,
			    name,
			    camel,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key === undefined) {
				this.register(owner);
			} else {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);

					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;

				while (i--) {
					delete cache[name[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome <= 35-45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function hasData(owner) {
			var cache = owner[this.expando];
			return cache !== undefined && !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined && elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function hasData(elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function data(elem, name, _data) {
			return dataUser.access(elem, name, _data);
		},

		removeData: function removeData(elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function _data(elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function _removeData(elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function data(key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem && elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem && value === undefined) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get(elem, key) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

					if (data !== undefined) {
						return data;
					}

					camelKey = jQuery.camelCase(key);

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase(key);
				this.each(function () {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") > -1 && data !== undefined) {
						dataUser.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function removeData(key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function queue(elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function dequeue(elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function next() {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength && hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function _queueHooks(elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function queue(type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length < setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" && queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function dequeue(type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function clearQueue(type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function promise(type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function resolve() {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp && tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function isHidden(elem, el) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit && initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /<([\w:-]+)/;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [1, "<select multiple='multiple'>", "</select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i < l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android<4.1, PhantomJS<2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection && jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0-4.3, Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function _on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				_on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null && fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function fn(event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function add(elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function remove(elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount && !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function dispatch(event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = _slice.call(arguments),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch && special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function handlers(event, _handlers) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = _handlers.delegateCount,
			    cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			//
			// Support: Firefox<=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
						matches = [];
						for (i = 0; i < delegateCount; i++) {
							handleObj = _handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount < _handlers.length) {
				handlerQueue.push({ elem: this, handlers: _handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function filter(event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
			filter: function filter(event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null && original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
					event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which && button !== undefined) {
					event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function fix(event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function trigger() {
					if (this !== safeActiveElement() && this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function trigger() {
					if (this === safeActiveElement() && this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function trigger() {
					if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function _default(event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function postDispatch(event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined && event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src && src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&

			// Support: Android<4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function preventDefault() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e && !this.isSimulated) {
				e.preventDefault();
			}
		},
		stopPropagation: function stopPropagation() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function stopImmediatePropagation() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e && !this.isSimulated) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function handle(event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target && !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({
		on: function on(types, selector, data, fn) {
			return _on(this, types, selector, data, fn);
		},
		one: function one(types, selector, data, fn) {
			return _on(this, types, selector, data, fn, 1);
		},
		off: function off(types, selector, fn) {
			var handleObj, type;
			if (types && types.preventDefault && types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,


	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i < l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" && rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i < l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android<4.1, PhantomJS<2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i < hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function _remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData && node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData && jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function htmlPrefilter(html) {
			return html.replace(rxhtmlTag, "<$1></$2>");
		},

		clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i < l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i < l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage && getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function cleanData(elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome <= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function detach(selector) {
			return _remove(this, selector, true);
		},

		remove: function remove(selector) {
			return _remove(this, selector);
		},

		text: function text(value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function append() {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function prepend() {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function before() {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function after() {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function empty() {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function clone(dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function html(value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined && elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i < l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function replaceWith() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) < 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i <= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */

	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
		    display = jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function getStyles(elem) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	var swap = function swap(elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var documentElement = document.documentElement;

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);
		}

		jQuery.extend(support, {
			pixelPosition: function pixelPosition() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function boxSizingReliable() {
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function pixelMarginRight() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function reliableMarginLeft() {

				// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function reliableMarginRight() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
				    marginDiv = div.appendChild(document.createElement("div"));

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild(container);

				ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

				documentElement.removeChild(container);
				div.removeChild(marginDiv);

				return ret;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);
		ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
			ret = jQuery.style(elem, name);
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function get() {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i < 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val <= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val < 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = dataPriv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] && display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" && isHidden(elem)) {
					values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index < length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function get(elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function style(elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value === "undefined" ? "undefined" : _typeof(value);

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function css(elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks && "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" && name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function get(elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function set(elem, value, extra) {
				var matches,
				    styles = extra && getStyles(elem),
				    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function expand(value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i < 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function css(name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i < len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function show() {
			return showHide(this, true);
		},
		hide: function hide() {
			return showHide(this);
		},
		toggle: function toggle(state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function init(elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function cur() {
			var hooks = Tween.propHooks[this.prop];

			return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function run(percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks && hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function get(tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function set(tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function set(tween) {
			if (tween.elem.nodeType && tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function linear(p) {
			return p;
		},
		swing: function swing(p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i < 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index < length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType && isHidden(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" && dataShow && dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				dataPriv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
			style.display = display;
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks && "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function tick() {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index < length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent < 1 && length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function createTween(prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function stop(gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index < length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index < length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function tweener(props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnotwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index < length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function prefilter(callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function fadeTo(speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function animate(prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function doAnimation() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function stop(type, clearQueue, gotoEnd) {
			var stopQueue = function stopQueue(hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue && type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null && type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] && data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] && data[index].stop && rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function finish(type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks && hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this && timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index < length; index++) {
					if (queue[index] && queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i < timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() && timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		window.clearInterval(timerId);

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function attr(name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function removeAttr(name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function attr(elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function set(elem, value) {
					if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function removeAttr(elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value && value.match(rnotwhite);

			if (attrNames && elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {

						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function set(elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function prop(name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function removeProp(name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function prop(elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function get(elem) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function get(elem) {
				var parent = elem.parentNode;
				if (parent && parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function set(elem) {
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	function getClass(elem) {
		return elem.getAttribute && elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function addClass(value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") < 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function removeClass(value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" && value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function toggleClass(value, stateVal) {
			var type = typeof value === "undefined" ? "undefined" : _typeof(value);

			if (typeof stateVal === "boolean" && type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function hasClass(selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g,
	    rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend({
		val: function val(value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace(rreturn, "") :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function get(elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
				}
			},
			select: {
				get: function get(elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index < 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index < 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i < max; i++) {
						option = options[i];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) && (

						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function set(elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function set(elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function trigger(event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype && cur[ontype];
				if (handle && handle.apply && acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers && !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function simulate(type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true
			});

			jQuery.event.trigger(e, null, elem);
		}

	});

	jQuery.fn.extend({

		trigger: function trigger(type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function triggerHandler(type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function hover(fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function handler(event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function setup() {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function teardown() {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&])_=[^&]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] && contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev && isSuccess && s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" && prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv && s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function ajaxSetup(target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function ajax(url, options) {

			// If url is an object, simulate pre-1.5 signature
			if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			_statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// The jqXHR state
			state = 0,


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function getResponseHeader(key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function getAllResponseHeaders() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function setRequestHeader(name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function overrideMimeType(type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function statusCode(map) {
					var code;
					if (map) {
						if (state < 2) {
							for (code in map) {

								// Lazy-add the new callback in a way that preserves old ones
								_statusCode[code] = [_statusCode[code], map[code]];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function abort(statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data && s.processData && typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if (fireGlobals && jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (state === 2) {
					return jqXHR;
				}

				// Timeout
				if (s.async && s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Propagate exception as error if not done
					if (state < 2) {
						done(-1, e);

						// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status < 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(_statusCode);
				_statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function getJSON(url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function getScript(url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) && url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function wrapAll(html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function wrapInner(html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function wrap(html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function unwrap() {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		return !jQuery.expr.filters.visible(elem);
	};
	jQuery.expr.filters.visible = function (elem) {

		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional && jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function add(key, value) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function serialize() {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function serializeArray() {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var _callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported && !options.crossDomain) {
			return {
				send: function send(headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType && xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain && !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					_callback = function callback(type) {
						return function () {
							if (_callback) {
								_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = _callback();
					errorCallback = xhr.onerror = _callback("error");

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (_callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					_callback = _callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent && options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (_callback) {
							throw e;
						}
					}
				},

				abort: function abort() {
					if (_callback) {
						_callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function textScript(text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, _callback2;
			return {
				send: function send(_, complete) {
					script = jQuery("<script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", _callback2 = function callback(evt) {
						script.remove();
						_callback2 = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function abort() {
					if (_callback2) {
						_callback2();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function jsonpCallback() {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer && jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts && [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts && scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" && _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback && function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function setOffset(elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function offset(options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem && elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function position() {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function offsetParent() {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari<7-8+, Chrome<37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	jQuery.fn.extend({

		bind: function bind(types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function unbind(types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function delegate(selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function undelegate(selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		},
		size: function size() {
			return this.length;
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return jQuery;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(112)(module)))

/***/ }),

/***/ 83:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies (polyfills).
 * @private
 */

__webpack_require__(84);
__webpack_require__(102);

/**
 * Module dependencies (components).
 * @private
 */
var header = __webpack_require__(73);
var requestEstimatePopup = __webpack_require__(16);
var nav = __webpack_require__(33);

/**
 * Module dependencies (utils).
 * @private
 */
var support = __webpack_require__(14);
var scrollBlocker = __webpack_require__(10);
__webpack_require__(109);

__webpack_require__(110);
__webpack_require__(111);

/**
 * @private
 */
var DOM = {};

/**
 * @private
 */
function setDOMiOS() {
    DOM.body = document.body;
    DOM.popupWrapper = DOM.body.querySelector(".js-popup-wrapper");
    DOM.bodyWrapper = DOM.body.querySelector(".js-body-wrapper");
}

module.exports = {
    init: function init() {
        header.init();

        requestEstimatePopup.init();
        requestEstimatePopup.on("beforeShow", function () {
            support.isiOS() && setDOMiOS();
            if (support.isiOS()) {
                DOM.windowPosition = document.documentElement.scrollTop || document.body.scrollTop;
            }
        });

        requestEstimatePopup.on("beforeHide", function () {
            // Если у нас в мобильной версии включена менюшка, то noscroll убирать не нужно, т.к в коде для нав бара используется toggle "noscroll"
            if (!nav.isOpen()) {
                scrollBlocker.scrollOn();
            }
            if (support.isiOS()) {
                window.scroll(0, DOM.windowPosition);
            }
        });
    }
};

/***/ }),

/***/ 84:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty = __webpack_require__(85);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(93);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-env browser */

//
// element-dataset 2.2.6
//
// element-dataset is released under the terms of the BSD-3-Clause license.
// (c) 2015 - 2017 Mark Milstein <mark@epiloque.com> 
//
// For all details and documentation: https://github.com/epiloque/element-dataset
//

function elementDatasetPolyfill() {
  if (!document.documentElement.dataset && (!(0, _getOwnPropertyDescriptor2.default)(HTMLElement.prototype, 'dataset') || !(0, _getOwnPropertyDescriptor2.default)(HTMLElement.prototype, 'dataset').get)) {
    var descriptor = {};

    descriptor.enumerable = true;

    descriptor.get = function get() {
      var element = this;
      var map = {};
      var attributes = this.attributes;

      function toUpperCase(n0) {
        return n0.charAt(1).toUpperCase();
      }

      function getter() {
        return this.value;
      }

      function setter(name, value) {
        if (typeof value !== 'undefined') {
          this.setAttribute(name, value);
        } else {
          this.removeAttribute(name);
        }
      }

      for (var i = 0; i < attributes.length; i += 1) {
        var attribute = attributes[i];

        // This test really should allow any XML Name without
        // colons (and non-uppercase for XHTML)

        if (attribute && attribute.name && /^data-\w[\w-]*$/.test(attribute.name)) {
          var name = attribute.name;
          var value = attribute.value;

          // Change to CamelCase

          var propName = name.substr(5).replace(/-./g, toUpperCase);

          (0, _defineProperty2.default)(map, propName, {
            enumerable: descriptor.enumerable,
            get: getter.bind({ value: value || '' }),
            set: setter.bind(element, name)
          });
        }
      }
      return map;
    };

    Object.defineProperty(HTMLElement.prototype, 'dataset', descriptor);
  }
}

exports.default = elementDatasetPolyfill;

/***/ }),

/***/ 85:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(86), __esModule: true };

/***/ }),

/***/ 86:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(87);
var $Object = __webpack_require__(9).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

/***/ }),

/***/ 87:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(34);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperty: __webpack_require__(36).f });

/***/ }),

/***/ 88:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// optional / simple context binding
var aFunction = __webpack_require__(89);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ 89:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ 90:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(36);
var createDesc = __webpack_require__(39);
module.exports = __webpack_require__(6) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ 91:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(17);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ 92:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(17);
var document = __webpack_require__(35).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ 93:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(94), __esModule: true };

/***/ }),

/***/ 94:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(95);
var $Object = __webpack_require__(9).Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

/***/ }),

/***/ 95:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(41);
var $getOwnPropertyDescriptor = __webpack_require__(99).f;

__webpack_require__(101)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ 96:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(97);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ 97:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ 98:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ 99:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var pIE = __webpack_require__(100);
var createDesc = __webpack_require__(39);
var toIObject = __webpack_require__(41);
var toPrimitive = __webpack_require__(38);
var has = __webpack_require__(40);
var IE8_DOM_DEFINE = __webpack_require__(37);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ })

},[1699]);